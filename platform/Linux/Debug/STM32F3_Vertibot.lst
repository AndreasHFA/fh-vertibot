
STM32F3_Vertibot.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000188  08000000  08000000  00008000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000a014  08000188  08000188  00008188  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .data         0000047c  20000000  0800a19c  00018000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          00002f60  2000047c  2000047c  0001847c  2**2
                  ALLOC
  4 ._user_heap_stack 00000200  200033dc  200033dc  0001847c  2**0
                  ALLOC
  5 .ARM.attributes 00000037  00000000  00000000  0001847c  2**0
                  CONTENTS, READONLY
  6 .debug_info   00016f06  00000000  00000000  000184b3  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000042c8  00000000  00000000  0002f3b9  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_aranges 000004a8  00000000  00000000  00033688  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_macro  00013b84  00000000  00000000  00033b30  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   0000c105  00000000  00000000  000476b4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0005dea1  00000000  00000000  000537b9  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .comment      00000070  00000000  00000000  000b165a  2**0
                  CONTENTS, READONLY
 13 .debug_loc    0000b280  00000000  00000000  000b16ca  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00003368  00000000  00000000  000bc94c  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 00000110  00000000  00000000  000bfcb8  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08000188 <IMU_init>:
void IMU_init(struct IMU_values *IMU, float dt)
{
	IMU->dt = dt;	

	IMU->dcm_xe_line[0] = 1;
	IMU->dcm_xe_line[1] = 0;
 8000188:	2300      	movs	r3, #0
//! Initialization of the main dcm-variables used for the Gyro input
void IMU_init(struct IMU_values *IMU, float dt)
{
	IMU->dt = dt;	

	IMU->dcm_xe_line[0] = 1;
 800018a:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000


//! Initialization of the main dcm-variables used for the Gyro input
void IMU_init(struct IMU_values *IMU, float dt)
{
	IMU->dt = dt;	
 800018e:	ed80 0a00 	vstr	s0, [r0]

	IMU->dcm_xe_line[0] = 1;
 8000192:	6042      	str	r2, [r0, #4]
	IMU->dcm_xe_line[1] = 0;
 8000194:	6083      	str	r3, [r0, #8]
	IMU->dcm_xe_line[2] = 0;
 8000196:	60c3      	str	r3, [r0, #12]

	IMU->dcm_ye_line[0] = 0;
 8000198:	6103      	str	r3, [r0, #16]
	IMU->dcm_ye_line[1] = 1;
 800019a:	6142      	str	r2, [r0, #20]
	IMU->dcm_ye_line[2] = 0;
 800019c:	6183      	str	r3, [r0, #24]

	IMU->dcm_ze_line[0] = 0;
 800019e:	61c3      	str	r3, [r0, #28]
	IMU->dcm_ze_line[1] = 0;
 80001a0:	6203      	str	r3, [r0, #32]
	IMU->dcm_ze_line[2] = 1;			
 80001a2:	6242      	str	r2, [r0, #36]	; 0x24

	IMU->velocity_vector[0] = 0;
 80001a4:	6283      	str	r3, [r0, #40]	; 0x28
	IMU->velocity_vector[1] = 0;
 80001a6:	62c3      	str	r3, [r0, #44]	; 0x2c
	IMU->velocity_vector[2] = 0;
 80001a8:	6303      	str	r3, [r0, #48]	; 0x30
 80001aa:	4770      	bx	lr

080001ac <IMU_init_drift_correction>:
//! Initialization of the drift-correction variables - this is mainly solved with a PI-Controller
void IMU_init_drift_correction(struct IMU_values *IMU, float kp)
{
	IMU->kp = kp;

	IMU->accel_vector[0] = 0;
 80001ac:	2300      	movs	r3, #0


//! Initialization of the drift-correction variables - this is mainly solved with a PI-Controller
void IMU_init_drift_correction(struct IMU_values *IMU, float kp)
{
	IMU->kp = kp;
 80001ae:	ed80 0a13 	vstr	s0, [r0, #76]	; 0x4c

	IMU->accel_vector[0] = 0;
 80001b2:	6343      	str	r3, [r0, #52]	; 0x34
	IMU->accel_vector[1] = 0;
 80001b4:	6383      	str	r3, [r0, #56]	; 0x38
	IMU->accel_vector[2] = 0;
 80001b6:	63c3      	str	r3, [r0, #60]	; 0x3c

	IMU->mag_vector[0] = 0;
 80001b8:	6403      	str	r3, [r0, #64]	; 0x40
	IMU->mag_vector[1] = 0;
 80001ba:	6443      	str	r3, [r0, #68]	; 0x44
	IMU->mag_vector[2] = 0;
 80001bc:	6483      	str	r3, [r0, #72]	; 0x48

	IMU->kp_vector_ACC[0] = 0;
 80001be:	6603      	str	r3, [r0, #96]	; 0x60
	IMU->kp_vector_ACC[1] = 0;
 80001c0:	6643      	str	r3, [r0, #100]	; 0x64
	IMU->kp_vector_ACC[2] = 0;
 80001c2:	6683      	str	r3, [r0, #104]	; 0x68

	IMU->kp_vector_MAG[0] = 0;
 80001c4:	66c3      	str	r3, [r0, #108]	; 0x6c
	IMU->kp_vector_MAG[1] = 0;
 80001c6:	6703      	str	r3, [r0, #112]	; 0x70
	IMU->kp_vector_MAG[2] = 0;
 80001c8:	6743      	str	r3, [r0, #116]	; 0x74

	IMU->error_rollpitch[0] = 0;
 80001ca:	6503      	str	r3, [r0, #80]	; 0x50
	IMU->error_rollpitch[1] = 0;
 80001cc:	6543      	str	r3, [r0, #84]	; 0x54
	IMU->error_rollpitch[2] = 0;
 80001ce:	6583      	str	r3, [r0, #88]	; 0x58

	IMU->error_yaw = 0;
 80001d0:	65c3      	str	r3, [r0, #92]	; 0x5c
 80001d2:	4770      	bx	lr

080001d4 <IMU_update>:
void IMU_update(struct IMU_values *IMU)
{
	float result[3];

	/*dt-factor + addition of omega_vector, which holds the PI-Values*/
	IMU->velocity_vector[0] = (IMU->velocity_vector[0]*IMU->dt) - (IMU->kp_vector_ACC[0]) - (IMU->kp_vector_MAG[0]);
 80001d4:	ed90 7a00 	vldr	s14, [r0]
 80001d8:	edd0 6a0a 	vldr	s13, [r0, #40]	; 0x28
 80001dc:	edd0 7a18 	vldr	s15, [r0, #96]	; 0x60
 80001e0:	eed6 7a87 	vfnms.f32	s15, s13, s14
}


//! Update of the dcm-matrix
void IMU_update(struct IMU_values *IMU)
{
 80001e4:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	float result[3];

	/*dt-factor + addition of omega_vector, which holds the PI-Values*/
	IMU->velocity_vector[0] = (IMU->velocity_vector[0]*IMU->dt) - (IMU->kp_vector_ACC[0]) - (IMU->kp_vector_MAG[0]);
 80001e6:	edd0 6a1b 	vldr	s13, [r0, #108]	; 0x6c
 80001ea:	ee77 7ae6 	vsub.f32	s15, s15, s13
	IMU->velocity_vector[1] = (IMU->velocity_vector[1]*IMU->dt) - (IMU->kp_vector_ACC[1]) - (IMU->kp_vector_MAG[1]);
 80001ee:	edd0 6a0b 	vldr	s13, [r0, #44]	; 0x2c
void IMU_update(struct IMU_values *IMU)
{
	float result[3];

	/*dt-factor + addition of omega_vector, which holds the PI-Values*/
	IMU->velocity_vector[0] = (IMU->velocity_vector[0]*IMU->dt) - (IMU->kp_vector_ACC[0]) - (IMU->kp_vector_MAG[0]);
 80001f2:	edc0 7a0a 	vstr	s15, [r0, #40]	; 0x28
 80001f6:	edd0 7a19 	vldr	s15, [r0, #100]	; 0x64
	IMU->velocity_vector[1] = (IMU->velocity_vector[1]*IMU->dt) - (IMU->kp_vector_ACC[1]) - (IMU->kp_vector_MAG[1]);
 80001fa:	eed6 7a87 	vfnms.f32	s15, s13, s14
	IMU->velocity_vector[2] = (IMU->velocity_vector[2]*IMU->dt) - (IMU->kp_vector_ACC[2]) - (IMU->kp_vector_MAG[2]);

	/*Update of the first dcm-line (xe)*/
	VectorCrossProduct(result, IMU->dcm_xe_line, IMU->velocity_vector);
 80001fe:	1d06      	adds	r6, r0, #4
 8000200:	f100 0528 	add.w	r5, r0, #40	; 0x28
{
	float result[3];

	/*dt-factor + addition of omega_vector, which holds the PI-Values*/
	IMU->velocity_vector[0] = (IMU->velocity_vector[0]*IMU->dt) - (IMU->kp_vector_ACC[0]) - (IMU->kp_vector_MAG[0]);
	IMU->velocity_vector[1] = (IMU->velocity_vector[1]*IMU->dt) - (IMU->kp_vector_ACC[1]) - (IMU->kp_vector_MAG[1]);
 8000204:	edd0 6a1c 	vldr	s13, [r0, #112]	; 0x70
 8000208:	ee77 7ae6 	vsub.f32	s15, s15, s13
	IMU->velocity_vector[2] = (IMU->velocity_vector[2]*IMU->dt) - (IMU->kp_vector_ACC[2]) - (IMU->kp_vector_MAG[2]);
 800020c:	edd0 6a0c 	vldr	s13, [r0, #48]	; 0x30
{
	float result[3];

	/*dt-factor + addition of omega_vector, which holds the PI-Values*/
	IMU->velocity_vector[0] = (IMU->velocity_vector[0]*IMU->dt) - (IMU->kp_vector_ACC[0]) - (IMU->kp_vector_MAG[0]);
	IMU->velocity_vector[1] = (IMU->velocity_vector[1]*IMU->dt) - (IMU->kp_vector_ACC[1]) - (IMU->kp_vector_MAG[1]);
 8000210:	edc0 7a0b 	vstr	s15, [r0, #44]	; 0x2c
 8000214:	edd0 7a1a 	vldr	s15, [r0, #104]	; 0x68
	IMU->velocity_vector[2] = (IMU->velocity_vector[2]*IMU->dt) - (IMU->kp_vector_ACC[2]) - (IMU->kp_vector_MAG[2]);
 8000218:	eed6 7a87 	vfnms.f32	s15, s13, s14
}


//! Update of the dcm-matrix
void IMU_update(struct IMU_values *IMU)
{
 800021c:	4604      	mov	r4, r0
	IMU->velocity_vector[0] = (IMU->velocity_vector[0]*IMU->dt) - (IMU->kp_vector_ACC[0]) - (IMU->kp_vector_MAG[0]);
	IMU->velocity_vector[1] = (IMU->velocity_vector[1]*IMU->dt) - (IMU->kp_vector_ACC[1]) - (IMU->kp_vector_MAG[1]);
	IMU->velocity_vector[2] = (IMU->velocity_vector[2]*IMU->dt) - (IMU->kp_vector_ACC[2]) - (IMU->kp_vector_MAG[2]);

	/*Update of the first dcm-line (xe)*/
	VectorCrossProduct(result, IMU->dcm_xe_line, IMU->velocity_vector);
 800021e:	4631      	mov	r1, r6
	float result[3];

	/*dt-factor + addition of omega_vector, which holds the PI-Values*/
	IMU->velocity_vector[0] = (IMU->velocity_vector[0]*IMU->dt) - (IMU->kp_vector_ACC[0]) - (IMU->kp_vector_MAG[0]);
	IMU->velocity_vector[1] = (IMU->velocity_vector[1]*IMU->dt) - (IMU->kp_vector_ACC[1]) - (IMU->kp_vector_MAG[1]);
	IMU->velocity_vector[2] = (IMU->velocity_vector[2]*IMU->dt) - (IMU->kp_vector_ACC[2]) - (IMU->kp_vector_MAG[2]);
 8000220:	ed90 7a1d 	vldr	s14, [r0, #116]	; 0x74
 8000224:	ee77 7ac7 	vsub.f32	s15, s15, s14

	/*Update of the first dcm-line (xe)*/
	VectorCrossProduct(result, IMU->dcm_xe_line, IMU->velocity_vector);
 8000228:	462a      	mov	r2, r5
	float result[3];

	/*dt-factor + addition of omega_vector, which holds the PI-Values*/
	IMU->velocity_vector[0] = (IMU->velocity_vector[0]*IMU->dt) - (IMU->kp_vector_ACC[0]) - (IMU->kp_vector_MAG[0]);
	IMU->velocity_vector[1] = (IMU->velocity_vector[1]*IMU->dt) - (IMU->kp_vector_ACC[1]) - (IMU->kp_vector_MAG[1]);
	IMU->velocity_vector[2] = (IMU->velocity_vector[2]*IMU->dt) - (IMU->kp_vector_ACC[2]) - (IMU->kp_vector_MAG[2]);
 800022a:	edc0 7a0c 	vstr	s15, [r0, #48]	; 0x30

	/*Update of the first dcm-line (xe)*/
	VectorCrossProduct(result, IMU->dcm_xe_line, IMU->velocity_vector);
 800022e:	a801      	add	r0, sp, #4
 8000230:	f001 fbc4 	bl	80019bc <VectorCrossProduct>
	VectorAdd(IMU->dcm_xe_line, IMU->dcm_xe_line, result);
 8000234:	4630      	mov	r0, r6
 8000236:	4631      	mov	r1, r6
 8000238:	aa01      	add	r2, sp, #4

	/*Update of the second dcm-line(ye)*/
	VectorCrossProduct(result, IMU->dcm_ye_line, IMU->velocity_vector);
 800023a:	f104 0610 	add.w	r6, r4, #16
	IMU->velocity_vector[1] = (IMU->velocity_vector[1]*IMU->dt) - (IMU->kp_vector_ACC[1]) - (IMU->kp_vector_MAG[1]);
	IMU->velocity_vector[2] = (IMU->velocity_vector[2]*IMU->dt) - (IMU->kp_vector_ACC[2]) - (IMU->kp_vector_MAG[2]);

	/*Update of the first dcm-line (xe)*/
	VectorCrossProduct(result, IMU->dcm_xe_line, IMU->velocity_vector);
	VectorAdd(IMU->dcm_xe_line, IMU->dcm_xe_line, result);
 800023e:	f001 fbf6 	bl	8001a2e <VectorAdd>

	/*Update of the second dcm-line(ye)*/
	VectorCrossProduct(result, IMU->dcm_ye_line, IMU->velocity_vector);
 8000242:	a801      	add	r0, sp, #4
 8000244:	4631      	mov	r1, r6
 8000246:	462a      	mov	r2, r5
 8000248:	f001 fbb8 	bl	80019bc <VectorCrossProduct>
	VectorAdd(IMU->dcm_ye_line, IMU->dcm_ye_line, result);

	/*Update of the second dcm-line(ze)*/
	VectorCrossProduct(result, IMU->dcm_ze_line, IMU->velocity_vector);
 800024c:	341c      	adds	r4, #28
	VectorCrossProduct(result, IMU->dcm_xe_line, IMU->velocity_vector);
	VectorAdd(IMU->dcm_xe_line, IMU->dcm_xe_line, result);

	/*Update of the second dcm-line(ye)*/
	VectorCrossProduct(result, IMU->dcm_ye_line, IMU->velocity_vector);
	VectorAdd(IMU->dcm_ye_line, IMU->dcm_ye_line, result);
 800024e:	4630      	mov	r0, r6
 8000250:	4631      	mov	r1, r6
 8000252:	aa01      	add	r2, sp, #4
 8000254:	f001 fbeb 	bl	8001a2e <VectorAdd>

	/*Update of the second dcm-line(ze)*/
	VectorCrossProduct(result, IMU->dcm_ze_line, IMU->velocity_vector);
 8000258:	a801      	add	r0, sp, #4
 800025a:	4621      	mov	r1, r4
 800025c:	462a      	mov	r2, r5
 800025e:	f001 fbad 	bl	80019bc <VectorCrossProduct>
	VectorAdd(IMU->dcm_ze_line, IMU->dcm_ze_line, result);
 8000262:	4620      	mov	r0, r4
 8000264:	4621      	mov	r1, r4
 8000266:	aa01      	add	r2, sp, #4
 8000268:	f001 fbe1 	bl	8001a2e <VectorAdd>
}
 800026c:	b004      	add	sp, #16
 800026e:	bd70      	pop	{r4, r5, r6, pc}

08000270 <IMU_normalize>:

//! Normalization of the vectors
void IMU_normalize(struct IMU_values *IMU)
{
	float normfactor;
	normfactor = sqrtf(IMU->dcm_xe_line[0]*IMU->dcm_xe_line[0] + IMU->dcm_xe_line[1]*IMU->dcm_xe_line[1] + IMU->dcm_xe_line[2]*IMU->dcm_xe_line[2]);
 8000270:	ed90 0a02 	vldr	s0, [r0, #8]
 8000274:	ed90 7a01 	vldr	s14, [r0, #4]
 8000278:	edd0 7a03 	vldr	s15, [r0, #12]
 800027c:	ee20 0a00 	vmul.f32	s0, s0, s0
}


//! Normalization of the vectors
void IMU_normalize(struct IMU_values *IMU)
{
 8000280:	b510      	push	{r4, lr}
	float normfactor;
	normfactor = sqrtf(IMU->dcm_xe_line[0]*IMU->dcm_xe_line[0] + IMU->dcm_xe_line[1]*IMU->dcm_xe_line[1] + IMU->dcm_xe_line[2]*IMU->dcm_xe_line[2]);
 8000282:	eea7 0a07 	vfma.f32	s0, s14, s14
}


//! Normalization of the vectors
void IMU_normalize(struct IMU_values *IMU)
{
 8000286:	4604      	mov	r4, r0
	float normfactor;
	normfactor = sqrtf(IMU->dcm_xe_line[0]*IMU->dcm_xe_line[0] + IMU->dcm_xe_line[1]*IMU->dcm_xe_line[1] + IMU->dcm_xe_line[2]*IMU->dcm_xe_line[2]);
 8000288:	eea7 0aa7 	vfma.f32	s0, s15, s15
 800028c:	f008 f852 	bl	8008334 <sqrtf>
	IMU->dcm_xe_line[0] = IMU->dcm_xe_line[0]/normfactor;	
 8000290:	edd4 7a01 	vldr	s15, [r4, #4]
	IMU->dcm_xe_line[1] = IMU->dcm_xe_line[1]/normfactor;	
	IMU->dcm_xe_line[2] = IMU->dcm_xe_line[2]/normfactor;	

	normfactor = sqrtf(IMU->dcm_ye_line[0]*IMU->dcm_ye_line[0] + IMU->dcm_ye_line[1]*IMU->dcm_ye_line[1] + IMU->dcm_ye_line[2]*IMU->dcm_ye_line[2]);
 8000294:	ed94 7a04 	vldr	s14, [r4, #16]
//! Normalization of the vectors
void IMU_normalize(struct IMU_values *IMU)
{
	float normfactor;
	normfactor = sqrtf(IMU->dcm_xe_line[0]*IMU->dcm_xe_line[0] + IMU->dcm_xe_line[1]*IMU->dcm_xe_line[1] + IMU->dcm_xe_line[2]*IMU->dcm_xe_line[2]);
	IMU->dcm_xe_line[0] = IMU->dcm_xe_line[0]/normfactor;	
 8000298:	eec7 7a80 	vdiv.f32	s15, s15, s0
 800029c:	edc4 7a01 	vstr	s15, [r4, #4]
	IMU->dcm_xe_line[1] = IMU->dcm_xe_line[1]/normfactor;	
 80002a0:	edd4 7a02 	vldr	s15, [r4, #8]
 80002a4:	eec7 7a80 	vdiv.f32	s15, s15, s0
 80002a8:	edc4 7a02 	vstr	s15, [r4, #8]
	IMU->dcm_xe_line[2] = IMU->dcm_xe_line[2]/normfactor;	
 80002ac:	edd4 7a03 	vldr	s15, [r4, #12]
 80002b0:	ee87 0a80 	vdiv.f32	s0, s15, s0

	normfactor = sqrtf(IMU->dcm_ye_line[0]*IMU->dcm_ye_line[0] + IMU->dcm_ye_line[1]*IMU->dcm_ye_line[1] + IMU->dcm_ye_line[2]*IMU->dcm_ye_line[2]);
 80002b4:	edd4 7a06 	vldr	s15, [r4, #24]
{
	float normfactor;
	normfactor = sqrtf(IMU->dcm_xe_line[0]*IMU->dcm_xe_line[0] + IMU->dcm_xe_line[1]*IMU->dcm_xe_line[1] + IMU->dcm_xe_line[2]*IMU->dcm_xe_line[2]);
	IMU->dcm_xe_line[0] = IMU->dcm_xe_line[0]/normfactor;	
	IMU->dcm_xe_line[1] = IMU->dcm_xe_line[1]/normfactor;	
	IMU->dcm_xe_line[2] = IMU->dcm_xe_line[2]/normfactor;	
 80002b8:	ed84 0a03 	vstr	s0, [r4, #12]

	normfactor = sqrtf(IMU->dcm_ye_line[0]*IMU->dcm_ye_line[0] + IMU->dcm_ye_line[1]*IMU->dcm_ye_line[1] + IMU->dcm_ye_line[2]*IMU->dcm_ye_line[2]);
 80002bc:	ed94 0a05 	vldr	s0, [r4, #20]
 80002c0:	ee20 0a00 	vmul.f32	s0, s0, s0
 80002c4:	eea7 0a07 	vfma.f32	s0, s14, s14
 80002c8:	eea7 0aa7 	vfma.f32	s0, s15, s15
 80002cc:	f008 f832 	bl	8008334 <sqrtf>
	IMU->dcm_ye_line[0] = IMU->dcm_ye_line[0]/normfactor;	
 80002d0:	edd4 7a04 	vldr	s15, [r4, #16]
	IMU->dcm_ye_line[1] = IMU->dcm_ye_line[1]/normfactor;	
	IMU->dcm_ye_line[2] = IMU->dcm_ye_line[2]/normfactor;	

	normfactor = sqrtf(IMU->dcm_ze_line[0]*IMU->dcm_ze_line[0] + IMU->dcm_ze_line[1]*IMU->dcm_ze_line[1] + IMU->dcm_ze_line[2]*IMU->dcm_ze_line[2]);
 80002d4:	ed94 7a07 	vldr	s14, [r4, #28]
	IMU->dcm_xe_line[0] = IMU->dcm_xe_line[0]/normfactor;	
	IMU->dcm_xe_line[1] = IMU->dcm_xe_line[1]/normfactor;	
	IMU->dcm_xe_line[2] = IMU->dcm_xe_line[2]/normfactor;	

	normfactor = sqrtf(IMU->dcm_ye_line[0]*IMU->dcm_ye_line[0] + IMU->dcm_ye_line[1]*IMU->dcm_ye_line[1] + IMU->dcm_ye_line[2]*IMU->dcm_ye_line[2]);
	IMU->dcm_ye_line[0] = IMU->dcm_ye_line[0]/normfactor;	
 80002d8:	eec7 7a80 	vdiv.f32	s15, s15, s0
 80002dc:	edc4 7a04 	vstr	s15, [r4, #16]
	IMU->dcm_ye_line[1] = IMU->dcm_ye_line[1]/normfactor;	
 80002e0:	edd4 7a05 	vldr	s15, [r4, #20]
 80002e4:	eec7 7a80 	vdiv.f32	s15, s15, s0
 80002e8:	edc4 7a05 	vstr	s15, [r4, #20]
	IMU->dcm_ye_line[2] = IMU->dcm_ye_line[2]/normfactor;	
 80002ec:	edd4 7a06 	vldr	s15, [r4, #24]
 80002f0:	ee87 0a80 	vdiv.f32	s0, s15, s0

	normfactor = sqrtf(IMU->dcm_ze_line[0]*IMU->dcm_ze_line[0] + IMU->dcm_ze_line[1]*IMU->dcm_ze_line[1] + IMU->dcm_ze_line[2]*IMU->dcm_ze_line[2]);
 80002f4:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
	IMU->dcm_xe_line[2] = IMU->dcm_xe_line[2]/normfactor;	

	normfactor = sqrtf(IMU->dcm_ye_line[0]*IMU->dcm_ye_line[0] + IMU->dcm_ye_line[1]*IMU->dcm_ye_line[1] + IMU->dcm_ye_line[2]*IMU->dcm_ye_line[2]);
	IMU->dcm_ye_line[0] = IMU->dcm_ye_line[0]/normfactor;	
	IMU->dcm_ye_line[1] = IMU->dcm_ye_line[1]/normfactor;	
	IMU->dcm_ye_line[2] = IMU->dcm_ye_line[2]/normfactor;	
 80002f8:	ed84 0a06 	vstr	s0, [r4, #24]

	normfactor = sqrtf(IMU->dcm_ze_line[0]*IMU->dcm_ze_line[0] + IMU->dcm_ze_line[1]*IMU->dcm_ze_line[1] + IMU->dcm_ze_line[2]*IMU->dcm_ze_line[2]);
 80002fc:	ed94 0a08 	vldr	s0, [r4, #32]
 8000300:	ee20 0a00 	vmul.f32	s0, s0, s0
 8000304:	eea7 0a07 	vfma.f32	s0, s14, s14
 8000308:	eea7 0aa7 	vfma.f32	s0, s15, s15
 800030c:	f008 f812 	bl	8008334 <sqrtf>
	IMU->dcm_ze_line[0] = IMU->dcm_ze_line[0]/normfactor;	
 8000310:	edd4 7a07 	vldr	s15, [r4, #28]
 8000314:	eec7 7a80 	vdiv.f32	s15, s15, s0
 8000318:	edc4 7a07 	vstr	s15, [r4, #28]
	IMU->dcm_ze_line[1] = IMU->dcm_ze_line[1]/normfactor;	
 800031c:	edd4 7a08 	vldr	s15, [r4, #32]
 8000320:	eec7 7a80 	vdiv.f32	s15, s15, s0
 8000324:	edc4 7a08 	vstr	s15, [r4, #32]
	IMU->dcm_ze_line[2] = IMU->dcm_ze_line[2]/normfactor;		
 8000328:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
 800032c:	ee87 0a80 	vdiv.f32	s0, s15, s0
 8000330:	ed84 0a09 	vstr	s0, [r4, #36]	; 0x24
 8000334:	bd10      	pop	{r4, pc}

08000336 <IMU_ortho_adjust>:
}

//! Keep the orthogonality
void IMU_ortho_adjust(struct IMU_values *IMU)
{
 8000336:	b570      	push	{r4, r5, r6, lr}
 8000338:	ed2d 8b02 	vpush	{d8}

	float result_x[3];
	float result_y[3];

	/*calc the orthogonality error*/	
	ortho_error = -VectorDotProduct(&IMU->dcm_xe_line[0], &IMU->dcm_ye_line[0])*0.5f;
 800033c:	f100 0410 	add.w	r4, r0, #16
 8000340:	1d05      	adds	r5, r0, #4
	IMU->dcm_ze_line[2] = IMU->dcm_ze_line[2]/normfactor;		
}

//! Keep the orthogonality
void IMU_ortho_adjust(struct IMU_values *IMU)
{
 8000342:	b086      	sub	sp, #24
 8000344:	4606      	mov	r6, r0

	float result_x[3];
	float result_y[3];

	/*calc the orthogonality error*/	
	ortho_error = -VectorDotProduct(&IMU->dcm_xe_line[0], &IMU->dcm_ye_line[0])*0.5f;
 8000346:	4621      	mov	r1, r4
 8000348:	4628      	mov	r0, r5
 800034a:	f001 fb25 	bl	8001998 <VectorDotProduct>
 800034e:	eeb6 8a00 	vmov.f32	s16, #96	; 0x60
 8000352:	ee20 8a48 	vnmul.f32	s16, s0, s16
	
	/*add the half of the error to xe and ye*/
	VectorScale(&result_y[0],&IMU->dcm_ye_line[0],ortho_error);
 8000356:	a803      	add	r0, sp, #12
 8000358:	4621      	mov	r1, r4
 800035a:	eeb0 0a48 	vmov.f32	s0, s16
 800035e:	f001 fb58 	bl	8001a12 <VectorScale>
	VectorScale(&result_x[0],&IMU->dcm_xe_line[0],ortho_error);
 8000362:	eeb0 0a48 	vmov.f32	s0, s16
 8000366:	4668      	mov	r0, sp
 8000368:	4629      	mov	r1, r5
 800036a:	f001 fb52 	bl	8001a12 <VectorScale>

	VectorAdd(&IMU->dcm_xe_line[0], &IMU->dcm_xe_line[0], &result_y[0]);
 800036e:	4628      	mov	r0, r5
 8000370:	4629      	mov	r1, r5
 8000372:	aa03      	add	r2, sp, #12
 8000374:	f001 fb5b 	bl	8001a2e <VectorAdd>
	VectorAdd(&IMU->dcm_ye_line[0], &IMU->dcm_ye_line[0], &result_x[0]);
 8000378:	4620      	mov	r0, r4
 800037a:	4621      	mov	r1, r4
 800037c:	466a      	mov	r2, sp
 800037e:	f001 fb56 	bl	8001a2e <VectorAdd>
	
	/*the ze-line will be recalculated with the crossproduct*/	
	VectorCrossProduct(&IMU->dcm_ze_line[0],&IMU->dcm_xe_line[0],&IMU->dcm_ye_line[0]);   
 8000382:	f106 001c 	add.w	r0, r6, #28
 8000386:	4629      	mov	r1, r5
 8000388:	4622      	mov	r2, r4
 800038a:	f001 fb17 	bl	80019bc <VectorCrossProduct>
}
 800038e:	b006      	add	sp, #24
 8000390:	ecbd 8b02 	vpop	{d8}
 8000394:	bd70      	pop	{r4, r5, r6, pc}

08000396 <IMU_drift_correction_ACC>:
void IMU_drift_correction_ACC(struct IMU_values *IMU)
{
	float normfactor;
	float error_absolute;

	normfactor = sqrtf((IMU->accel_vector[0]*IMU->accel_vector[0]) + (IMU->accel_vector[1]*IMU->accel_vector[1]) + (IMU->accel_vector[2]*IMU->accel_vector[2]));
 8000396:	ed90 0a0e 	vldr	s0, [r0, #56]	; 0x38
 800039a:	ed90 7a0d 	vldr	s14, [r0, #52]	; 0x34
 800039e:	edd0 7a0f 	vldr	s15, [r0, #60]	; 0x3c
 80003a2:	ee20 0a00 	vmul.f32	s0, s0, s0
}


//! Roll-pitch Drift-Correction with Accelerometer
void IMU_drift_correction_ACC(struct IMU_values *IMU)
{
 80003a6:	b538      	push	{r3, r4, r5, lr}
	float normfactor;
	float error_absolute;

	normfactor = sqrtf((IMU->accel_vector[0]*IMU->accel_vector[0]) + (IMU->accel_vector[1]*IMU->accel_vector[1]) + (IMU->accel_vector[2]*IMU->accel_vector[2]));
 80003a8:	eea7 0a07 	vfma.f32	s0, s14, s14
}


//! Roll-pitch Drift-Correction with Accelerometer
void IMU_drift_correction_ACC(struct IMU_values *IMU)
{
 80003ac:	4604      	mov	r4, r0
	float normfactor;
	float error_absolute;

	normfactor = sqrtf((IMU->accel_vector[0]*IMU->accel_vector[0]) + (IMU->accel_vector[1]*IMU->accel_vector[1]) + (IMU->accel_vector[2]*IMU->accel_vector[2]));
 80003ae:	eea7 0aa7 	vfma.f32	s0, s15, s15
 80003b2:	f007 ffbf 	bl	8008334 <sqrtf>

	if(normfactor != 0)
 80003b6:	eeb5 0a40 	vcmp.f32	s0, #0.0
 80003ba:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80003be:	d011      	beq.n	80003e4 <IMU_drift_correction_ACC+0x4e>
	{
		IMU->accel_vector[0] = IMU->accel_vector[0]/normfactor;
 80003c0:	edd4 7a0d 	vldr	s15, [r4, #52]	; 0x34
 80003c4:	eec7 7a80 	vdiv.f32	s15, s15, s0
 80003c8:	edc4 7a0d 	vstr	s15, [r4, #52]	; 0x34
		IMU->accel_vector[1] = IMU->accel_vector[1]/normfactor;
 80003cc:	edd4 7a0e 	vldr	s15, [r4, #56]	; 0x38
 80003d0:	eec7 7a80 	vdiv.f32	s15, s15, s0
 80003d4:	edc4 7a0e 	vstr	s15, [r4, #56]	; 0x38
		IMU->accel_vector[2] = IMU->accel_vector[2]/normfactor;
 80003d8:	edd4 7a0f 	vldr	s15, [r4, #60]	; 0x3c
 80003dc:	ee87 0a80 	vdiv.f32	s0, s15, s0
 80003e0:	ed84 0a0f 	vstr	s0, [r4, #60]	; 0x3c
	}
	
	/*Calc the error between the gyrobased calculations and the vector of the accelerometer, 
	this will be done with the crossproduct of the two vectors*/
	VectorCrossProduct(&IMU->error_rollpitch[0], &IMU->dcm_ze_line[0], &IMU->accel_vector[0]);
 80003e4:	f104 0550 	add.w	r5, r4, #80	; 0x50
 80003e8:	4628      	mov	r0, r5
 80003ea:	f104 011c 	add.w	r1, r4, #28
 80003ee:	f104 0234 	add.w	r2, r4, #52	; 0x34
 80003f2:	f001 fae3 	bl	80019bc <VectorCrossProduct>
	//VectorCrossProduct(&IMU->error_rollpitch[0], &IMU->dcm_ze_line[0], &test[0]);
	
	error_absolute = sqrtf((IMU->error_rollpitch[0]*IMU->error_rollpitch[0]) + (IMU->error_rollpitch[1]*IMU->error_rollpitch[1]) + (IMU->error_rollpitch[2]*IMU->error_rollpitch[2]));
 80003f6:	ed94 0a15 	vldr	s0, [r4, #84]	; 0x54
 80003fa:	ed94 7a14 	vldr	s14, [r4, #80]	; 0x50
 80003fe:	edd4 7a16 	vldr	s15, [r4, #88]	; 0x58
 8000402:	ee20 0a00 	vmul.f32	s0, s0, s0
 8000406:	eea7 0a07 	vfma.f32	s0, s14, s14
 800040a:	eea7 0aa7 	vfma.f32	s0, s15, s15
 800040e:	f007 ff91 	bl	8008334 <sqrtf>
	else
	{
		VectorScale(&IMU->kp_vector[0], &IMU->error_rollpitch[0], IMU->kp);
	}
	*/
	VectorScale(&IMU->kp_vector_ACC[0], &IMU->error_rollpitch[0], (IMU->kp+(IMU->kp*error_absolute)));
 8000412:	edd4 7a13 	vldr	s15, [r4, #76]	; 0x4c
 8000416:	eee7 7a80 	vfma.f32	s15, s15, s0
 800041a:	f104 0060 	add.w	r0, r4, #96	; 0x60
 800041e:	4629      	mov	r1, r5
	//printf("%f\n", (IMU->kp+(IMU->kp*error_absolute)));
}
 8000420:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	else
	{
		VectorScale(&IMU->kp_vector[0], &IMU->error_rollpitch[0], IMU->kp);
	}
	*/
	VectorScale(&IMU->kp_vector_ACC[0], &IMU->error_rollpitch[0], (IMU->kp+(IMU->kp*error_absolute)));
 8000424:	eeb0 0a67 	vmov.f32	s0, s15
 8000428:	f001 baf3 	b.w	8001a12 <VectorScale>

0800042c <IMU_drift_correction_MAG>:
void IMU_drift_correction_MAG(struct IMU_values *IMU)
{
	float normfactor;
	//float error_absolute;

	normfactor = sqrtf((IMU->mag_vector[0]*IMU->mag_vector[0]) + (IMU->mag_vector[1]*IMU->mag_vector[1]) + (IMU->mag_vector[2]*IMU->mag_vector[2]));
 800042c:	ed90 0a11 	vldr	s0, [r0, #68]	; 0x44
 8000430:	ed90 7a10 	vldr	s14, [r0, #64]	; 0x40
 8000434:	edd0 7a12 	vldr	s15, [r0, #72]	; 0x48
 8000438:	ee20 0a00 	vmul.f32	s0, s0, s0
}


//! yaw Drift-Correction with Magnetometer
void IMU_drift_correction_MAG(struct IMU_values *IMU)
{
 800043c:	b510      	push	{r4, lr}
	float normfactor;
	//float error_absolute;

	normfactor = sqrtf((IMU->mag_vector[0]*IMU->mag_vector[0]) + (IMU->mag_vector[1]*IMU->mag_vector[1]) + (IMU->mag_vector[2]*IMU->mag_vector[2]));
 800043e:	eea7 0a07 	vfma.f32	s0, s14, s14
}


//! yaw Drift-Correction with Magnetometer
void IMU_drift_correction_MAG(struct IMU_values *IMU)
{
 8000442:	4604      	mov	r4, r0
	float normfactor;
	//float error_absolute;

	normfactor = sqrtf((IMU->mag_vector[0]*IMU->mag_vector[0]) + (IMU->mag_vector[1]*IMU->mag_vector[1]) + (IMU->mag_vector[2]*IMU->mag_vector[2]));
 8000444:	eea7 0aa7 	vfma.f32	s0, s15, s15
 8000448:	f007 ff74 	bl	8008334 <sqrtf>

	if(normfactor != 0)
 800044c:	eeb5 0a40 	vcmp.f32	s0, #0.0
 8000450:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8000454:	d011      	beq.n	800047a <IMU_drift_correction_MAG+0x4e>
	{
		IMU->mag_vector[0] = IMU->mag_vector[0]/normfactor;
 8000456:	edd4 7a10 	vldr	s15, [r4, #64]	; 0x40
 800045a:	eec7 7a80 	vdiv.f32	s15, s15, s0
 800045e:	edc4 7a10 	vstr	s15, [r4, #64]	; 0x40
		IMU->mag_vector[1] = IMU->mag_vector[1]/normfactor;
 8000462:	edd4 7a11 	vldr	s15, [r4, #68]	; 0x44
 8000466:	eec7 7a80 	vdiv.f32	s15, s15, s0
 800046a:	edc4 7a11 	vstr	s15, [r4, #68]	; 0x44
		IMU->mag_vector[2] = IMU->mag_vector[2]/normfactor;
 800046e:	edd4 7a12 	vldr	s15, [r4, #72]	; 0x48
 8000472:	ee87 0a80 	vdiv.f32	s0, s15, s0
 8000476:	ed84 0a12 	vstr	s0, [r4, #72]	; 0x48

	/*Calc the error between the gyrobased calculations and the vector of the accelerometer,
	this will be done with the crossproduct of the two vectors*/
	//VectorCrossProduct(&IMU->error_yaw[0], &IMU->dcm_xe_line[0], &IMU->mag_vector[0]);

	IMU->error_yaw = (IMU->dcm_xe_line[0]*IMU->mag_vector[1]) - (IMU->dcm_ye_line[0]*IMU->mag_vector[0]);
 800047a:	ed94 7a10 	vldr	s14, [r4, #64]	; 0x40
 800047e:	edd4 7a04 	vldr	s15, [r4, #16]
 8000482:	edd4 6a01 	vldr	s13, [r4, #4]
	VectorScale(&IMU->kp_vector_MAG[0], &IMU->dcm_ze_line[0], (IMU->kp*IMU->error_yaw));
 8000486:	ed94 0a13 	vldr	s0, [r4, #76]	; 0x4c
 800048a:	ee67 7a67 	vnmul.f32	s15, s14, s15

	/*Calc the error between the gyrobased calculations and the vector of the accelerometer,
	this will be done with the crossproduct of the two vectors*/
	//VectorCrossProduct(&IMU->error_yaw[0], &IMU->dcm_xe_line[0], &IMU->mag_vector[0]);

	IMU->error_yaw = (IMU->dcm_xe_line[0]*IMU->mag_vector[1]) - (IMU->dcm_ye_line[0]*IMU->mag_vector[0]);
 800048e:	ed94 7a11 	vldr	s14, [r4, #68]	; 0x44
 8000492:	eee6 7a87 	vfma.f32	s15, s13, s14
	VectorScale(&IMU->kp_vector_MAG[0], &IMU->dcm_ze_line[0], (IMU->kp*IMU->error_yaw));
 8000496:	f104 006c 	add.w	r0, r4, #108	; 0x6c
 800049a:	f104 011c 	add.w	r1, r4, #28

	/*Calc the error between the gyrobased calculations and the vector of the accelerometer,
	this will be done with the crossproduct of the two vectors*/
	//VectorCrossProduct(&IMU->error_yaw[0], &IMU->dcm_xe_line[0], &IMU->mag_vector[0]);

	IMU->error_yaw = (IMU->dcm_xe_line[0]*IMU->mag_vector[1]) - (IMU->dcm_ye_line[0]*IMU->mag_vector[0]);
 800049e:	edc4 7a17 	vstr	s15, [r4, #92]	; 0x5c
	VectorScale(&IMU->kp_vector_MAG[0], &IMU->dcm_ze_line[0], (IMU->kp*IMU->error_yaw));
 80004a2:	ee27 0a80 	vmul.f32	s0, s15, s0
	//VectorScale(&IMU->kp_vector_MAG[0], &IMU->error_yaw[0], IMU->kp);
	//printf("%f\n", (IMU->kp+(IMU->kp*error_absolute)));
}
 80004a6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	/*Calc the error between the gyrobased calculations and the vector of the accelerometer,
	this will be done with the crossproduct of the two vectors*/
	//VectorCrossProduct(&IMU->error_yaw[0], &IMU->dcm_xe_line[0], &IMU->mag_vector[0]);

	IMU->error_yaw = (IMU->dcm_xe_line[0]*IMU->mag_vector[1]) - (IMU->dcm_ye_line[0]*IMU->mag_vector[0]);
	VectorScale(&IMU->kp_vector_MAG[0], &IMU->dcm_ze_line[0], (IMU->kp*IMU->error_yaw));
 80004aa:	f001 bab2 	b.w	8001a12 <VectorScale>

080004ae <IMU_DCM_to_Euler_deg>:
}


//! DCM to EULER Angles
void IMU_DCM_to_Euler_deg(struct IMU_values* IMU, struct EULER_angles *euler)
{
 80004ae:	b538      	push	{r3, r4, r5, lr}
	euler->pitch = (asinf(-IMU->dcm_ze_line[0]))*(180/M_PI);
 80004b0:	ed90 0a07 	vldr	s0, [r0, #28]
}


//! DCM to EULER Angles
void IMU_DCM_to_Euler_deg(struct IMU_values* IMU, struct EULER_angles *euler)
{
 80004b4:	ed2d 8b02 	vpush	{d8}
	euler->pitch = (asinf(-IMU->dcm_ze_line[0]))*(180/M_PI);
 80004b8:	eeb1 0a40 	vneg.f32	s0, s0
}


//! DCM to EULER Angles
void IMU_DCM_to_Euler_deg(struct IMU_values* IMU, struct EULER_angles *euler)
{
 80004bc:	4604      	mov	r4, r0
 80004be:	460d      	mov	r5, r1
	euler->pitch = (asinf(-IMU->dcm_ze_line[0]))*(180/M_PI);
 80004c0:	f007 fed8 	bl	8008274 <asinf>
 80004c4:	ed9f 8a0e 	vldr	s16, [pc, #56]	; 8000500 <IMU_DCM_to_Euler_deg+0x52>
	euler->roll = (atan2f(IMU->dcm_ze_line[1],IMU->dcm_ze_line[2]))*(180/M_PI);
 80004c8:	edd4 0a09 	vldr	s1, [r4, #36]	; 0x24


//! DCM to EULER Angles
void IMU_DCM_to_Euler_deg(struct IMU_values* IMU, struct EULER_angles *euler)
{
	euler->pitch = (asinf(-IMU->dcm_ze_line[0]))*(180/M_PI);
 80004cc:	ee20 0a08 	vmul.f32	s0, s0, s16
 80004d0:	ed85 0a01 	vstr	s0, [r5, #4]
	euler->roll = (atan2f(IMU->dcm_ze_line[1],IMU->dcm_ze_line[2]))*(180/M_PI);
 80004d4:	ed94 0a08 	vldr	s0, [r4, #32]
 80004d8:	f007 ff2a 	bl	8008330 <atan2f>
 80004dc:	ee20 0a08 	vmul.f32	s0, s0, s16
	euler->yaw = (atan2f(IMU->dcm_ye_line[0],IMU->dcm_xe_line[0]))*(180/M_PI);
 80004e0:	edd4 0a01 	vldr	s1, [r4, #4]

//! DCM to EULER Angles
void IMU_DCM_to_Euler_deg(struct IMU_values* IMU, struct EULER_angles *euler)
{
	euler->pitch = (asinf(-IMU->dcm_ze_line[0]))*(180/M_PI);
	euler->roll = (atan2f(IMU->dcm_ze_line[1],IMU->dcm_ze_line[2]))*(180/M_PI);
 80004e4:	ed85 0a00 	vstr	s0, [r5]
	euler->yaw = (atan2f(IMU->dcm_ye_line[0],IMU->dcm_xe_line[0]))*(180/M_PI);
 80004e8:	ed94 0a04 	vldr	s0, [r4, #16]
 80004ec:	f007 ff20 	bl	8008330 <atan2f>
 80004f0:	ee20 0a08 	vmul.f32	s0, s0, s16
	//printf("%3.1f  %3.1f  %3.1f\n", roll*(180/M_PI), pitch*(180/M_PI), yaw*(180/M_PI));
}
 80004f4:	ecbd 8b02 	vpop	{d8}
//! DCM to EULER Angles
void IMU_DCM_to_Euler_deg(struct IMU_values* IMU, struct EULER_angles *euler)
{
	euler->pitch = (asinf(-IMU->dcm_ze_line[0]))*(180/M_PI);
	euler->roll = (atan2f(IMU->dcm_ze_line[1],IMU->dcm_ze_line[2]))*(180/M_PI);
	euler->yaw = (atan2f(IMU->dcm_ye_line[0],IMU->dcm_xe_line[0]))*(180/M_PI);
 80004f8:	ed85 0a02 	vstr	s0, [r5, #8]
	//printf("%3.1f  %3.1f  %3.1f\n", roll*(180/M_PI), pitch*(180/M_PI), yaw*(180/M_PI));
}
 80004fc:	bd38      	pop	{r3, r4, r5, pc}
 80004fe:	bf00      	nop
 8000500:	42652ee0 	.word	0x42652ee0

08000504 <IMU_Euler_to_DCM>:

//! EULER Angles to DCM
void IMU_Euler_to_DCM(struct IMU_values* IMU, struct EULER_angles *euler)
{
 8000504:	b538      	push	{r3, r4, r5, lr}
 8000506:	ed2d 8b08 	vpush	{d8-d11}
	/*First line DCM Matrix*/
	IMU->dcm_xe_line[0] = cosf(euler->pitch)*cosf(euler->yaw);
 800050a:	ed91 aa01 	vldr	s20, [r1, #4]
 800050e:	eeb0 0a4a 	vmov.f32	s0, s20
	//printf("%3.1f  %3.1f  %3.1f\n", roll*(180/M_PI), pitch*(180/M_PI), yaw*(180/M_PI));
}

//! EULER Angles to DCM
void IMU_Euler_to_DCM(struct IMU_values* IMU, struct EULER_angles *euler)
{
 8000512:	4604      	mov	r4, r0
 8000514:	460d      	mov	r5, r1
	/*First line DCM Matrix*/
	IMU->dcm_xe_line[0] = cosf(euler->pitch)*cosf(euler->yaw);
 8000516:	f007 fdd3 	bl	80080c0 <cosf>
 800051a:	ed95 9a02 	vldr	s18, [r5, #8]
 800051e:	eef0 8a40 	vmov.f32	s17, s0
 8000522:	eeb0 0a49 	vmov.f32	s0, s18
 8000526:	f007 fdcb 	bl	80080c0 <cosf>
 800052a:	ee68 7a80 	vmul.f32	s15, s17, s0
 800052e:	eeb0 8a40 	vmov.f32	s16, s0
 8000532:	edc4 7a01 	vstr	s15, [r4, #4]
	IMU->dcm_xe_line[1] = (cosf(euler->pitch)*sinf(euler->yaw))+(sinf(euler->roll)*sinf(euler->pitch)*cosf(euler->yaw));
 8000536:	eeb0 0a49 	vmov.f32	s0, s18
 800053a:	f007 fdfd 	bl	8008138 <sinf>
 800053e:	edd5 ba00 	vldr	s23, [r5]
 8000542:	eef0 9a40 	vmov.f32	s19, s0
 8000546:	ee28 ba80 	vmul.f32	s22, s17, s0
 800054a:	eeb0 0a6b 	vmov.f32	s0, s23
 800054e:	f007 fdf3 	bl	8008138 <sinf>
 8000552:	eeb0 9a40 	vmov.f32	s18, s0
 8000556:	eeb0 0a4a 	vmov.f32	s0, s20
 800055a:	f007 fded 	bl	8008138 <sinf>
 800055e:	ee69 aa00 	vmul.f32	s21, s18, s0
 8000562:	eef0 7a4b 	vmov.f32	s15, s22
 8000566:	eeea 7a88 	vfma.f32	s15, s21, s16
 800056a:	eeb0 aa40 	vmov.f32	s20, s0
 800056e:	edc4 7a02 	vstr	s15, [r4, #8]
	IMU->dcm_xe_line[2] = (sinf(euler->roll)*sinf(euler->yaw))-(cosf(euler->roll)*sinf(euler->pitch)*cosf(euler->yaw));
 8000572:	eeb0 0a6b 	vmov.f32	s0, s23
 8000576:	f007 fda3 	bl	80080c0 <cosf>
 800057a:	ee60 6a0a 	vmul.f32	s13, s0, s20
 800057e:	ee69 7aea 	vnmul.f32	s15, s19, s21
 8000582:	ee28 7a66 	vnmul.f32	s14, s16, s13

	/*Second line DCM Matrix*/
	IMU->dcm_ye_line[0] = -(cosf(euler->pitch)*sinf(euler->yaw));
 8000586:	eeb1 ba4b 	vneg.f32	s22, s22
void IMU_Euler_to_DCM(struct IMU_values* IMU, struct EULER_angles *euler)
{
	/*First line DCM Matrix*/
	IMU->dcm_xe_line[0] = cosf(euler->pitch)*cosf(euler->yaw);
	IMU->dcm_xe_line[1] = (cosf(euler->pitch)*sinf(euler->yaw))+(sinf(euler->roll)*sinf(euler->pitch)*cosf(euler->yaw));
	IMU->dcm_xe_line[2] = (sinf(euler->roll)*sinf(euler->yaw))-(cosf(euler->roll)*sinf(euler->pitch)*cosf(euler->yaw));
 800058a:	eea9 7a29 	vfma.f32	s14, s18, s19

	/*Second line DCM Matrix*/
	IMU->dcm_ye_line[0] = -(cosf(euler->pitch)*sinf(euler->yaw));
	IMU->dcm_ye_line[1] = (cosf(euler->roll)*cosf(euler->yaw))-(sinf(euler->roll)*sinf(euler->pitch)*sinf(euler->yaw));
	IMU->dcm_ye_line[2] = (sinf(euler->roll)*cosf(euler->yaw)) + (cosf(euler->roll)*sinf(euler->pitch)*sinf(euler->yaw));
 800058e:	ee66 9aa9 	vmul.f32	s19, s13, s19
	IMU->dcm_xe_line[1] = (cosf(euler->pitch)*sinf(euler->yaw))+(sinf(euler->roll)*sinf(euler->pitch)*cosf(euler->yaw));
	IMU->dcm_xe_line[2] = (sinf(euler->roll)*sinf(euler->yaw))-(cosf(euler->roll)*sinf(euler->pitch)*cosf(euler->yaw));

	/*Second line DCM Matrix*/
	IMU->dcm_ye_line[0] = -(cosf(euler->pitch)*sinf(euler->yaw));
	IMU->dcm_ye_line[1] = (cosf(euler->roll)*cosf(euler->yaw))-(sinf(euler->roll)*sinf(euler->pitch)*sinf(euler->yaw));
 8000592:	eee0 7a08 	vfma.f32	s15, s0, s16
	IMU->dcm_ye_line[2] = (sinf(euler->roll)*cosf(euler->yaw)) + (cosf(euler->roll)*sinf(euler->pitch)*sinf(euler->yaw));
 8000596:	eee9 9a08 	vfma.f32	s19, s18, s16

	/*Third line DCM Matrix*/
	IMU->dcm_ze_line[0] = sinf(euler->pitch);
	IMU->dcm_ze_line[1] = -sinf(euler->roll)*cosf(euler->pitch);
 800059a:	ee29 9a68 	vnmul.f32	s18, s18, s17
	IMU->dcm_ze_line[2] = cosf(euler->roll)*cosf(euler->pitch);
 800059e:	ee60 8a28 	vmul.f32	s17, s0, s17
	IMU->dcm_xe_line[0] = cosf(euler->pitch)*cosf(euler->yaw);
	IMU->dcm_xe_line[1] = (cosf(euler->pitch)*sinf(euler->yaw))+(sinf(euler->roll)*sinf(euler->pitch)*cosf(euler->yaw));
	IMU->dcm_xe_line[2] = (sinf(euler->roll)*sinf(euler->yaw))-(cosf(euler->roll)*sinf(euler->pitch)*cosf(euler->yaw));

	/*Second line DCM Matrix*/
	IMU->dcm_ye_line[0] = -(cosf(euler->pitch)*sinf(euler->yaw));
 80005a2:	ed84 ba04 	vstr	s22, [r4, #16]
	IMU->dcm_ye_line[1] = (cosf(euler->roll)*cosf(euler->yaw))-(sinf(euler->roll)*sinf(euler->pitch)*sinf(euler->yaw));
	IMU->dcm_ye_line[2] = (sinf(euler->roll)*cosf(euler->yaw)) + (cosf(euler->roll)*sinf(euler->pitch)*sinf(euler->yaw));
 80005a6:	edc4 9a06 	vstr	s19, [r4, #24]

	/*Third line DCM Matrix*/
	IMU->dcm_ze_line[0] = sinf(euler->pitch);
 80005aa:	ed84 aa07 	vstr	s20, [r4, #28]
	IMU->dcm_ze_line[1] = -sinf(euler->roll)*cosf(euler->pitch);
 80005ae:	ed84 9a08 	vstr	s18, [r4, #32]
	IMU->dcm_ze_line[2] = cosf(euler->roll)*cosf(euler->pitch);
 80005b2:	edc4 8a09 	vstr	s17, [r4, #36]	; 0x24
}
 80005b6:	ecbd 8b08 	vpop	{d8-d11}
void IMU_Euler_to_DCM(struct IMU_values* IMU, struct EULER_angles *euler)
{
	/*First line DCM Matrix*/
	IMU->dcm_xe_line[0] = cosf(euler->pitch)*cosf(euler->yaw);
	IMU->dcm_xe_line[1] = (cosf(euler->pitch)*sinf(euler->yaw))+(sinf(euler->roll)*sinf(euler->pitch)*cosf(euler->yaw));
	IMU->dcm_xe_line[2] = (sinf(euler->roll)*sinf(euler->yaw))-(cosf(euler->roll)*sinf(euler->pitch)*cosf(euler->yaw));
 80005ba:	ed84 7a03 	vstr	s14, [r4, #12]

	/*Second line DCM Matrix*/
	IMU->dcm_ye_line[0] = -(cosf(euler->pitch)*sinf(euler->yaw));
	IMU->dcm_ye_line[1] = (cosf(euler->roll)*cosf(euler->yaw))-(sinf(euler->roll)*sinf(euler->pitch)*sinf(euler->yaw));
 80005be:	edc4 7a05 	vstr	s15, [r4, #20]

	/*Third line DCM Matrix*/
	IMU->dcm_ze_line[0] = sinf(euler->pitch);
	IMU->dcm_ze_line[1] = -sinf(euler->roll)*cosf(euler->pitch);
	IMU->dcm_ze_line[2] = cosf(euler->roll)*cosf(euler->pitch);
}
 80005c2:	bd38      	pop	{r3, r4, r5, pc}

080005c4 <IMU_DCM_to_XYZ>:

//! DCM to kartesic coordinates
void IMU_DCM_to_XYZ(struct IMU_values* IMU, struct XYZ_angles *XYZ)
{
 80005c4:	b538      	push	{r3, r4, r5, lr}
	XYZ->x = asinf(-IMU->dcm_ze_line[0])*(180/M_PI);
 80005c6:	ed90 0a07 	vldr	s0, [r0, #28]
	IMU->dcm_ze_line[2] = cosf(euler->roll)*cosf(euler->pitch);
}

//! DCM to kartesic coordinates
void IMU_DCM_to_XYZ(struct IMU_values* IMU, struct XYZ_angles *XYZ)
{
 80005ca:	ed2d 8b02 	vpush	{d8}
	XYZ->x = asinf(-IMU->dcm_ze_line[0])*(180/M_PI);
 80005ce:	eeb1 0a40 	vneg.f32	s0, s0
	IMU->dcm_ze_line[2] = cosf(euler->roll)*cosf(euler->pitch);
}

//! DCM to kartesic coordinates
void IMU_DCM_to_XYZ(struct IMU_values* IMU, struct XYZ_angles *XYZ)
{
 80005d2:	4604      	mov	r4, r0
 80005d4:	460d      	mov	r5, r1
	XYZ->x = asinf(-IMU->dcm_ze_line[0])*(180/M_PI);
 80005d6:	f007 fe4d 	bl	8008274 <asinf>
 80005da:	ed9f 8a0d 	vldr	s16, [pc, #52]	; 8000610 <IMU_DCM_to_XYZ+0x4c>
 80005de:	ee20 0a08 	vmul.f32	s0, s0, s16
 80005e2:	ed85 0a00 	vstr	s0, [r5]
	XYZ->y = asinf(IMU->dcm_ze_line[1])*(180/M_PI);
 80005e6:	ed94 0a08 	vldr	s0, [r4, #32]
 80005ea:	f007 fe43 	bl	8008274 <asinf>
 80005ee:	ee20 0a08 	vmul.f32	s0, s0, s16
	XYZ->z = (atan2f(IMU->dcm_ye_line[0],IMU->dcm_xe_line[0]))*(180/M_PI);
 80005f2:	edd4 0a01 	vldr	s1, [r4, #4]

//! DCM to kartesic coordinates
void IMU_DCM_to_XYZ(struct IMU_values* IMU, struct XYZ_angles *XYZ)
{
	XYZ->x = asinf(-IMU->dcm_ze_line[0])*(180/M_PI);
	XYZ->y = asinf(IMU->dcm_ze_line[1])*(180/M_PI);
 80005f6:	ed85 0a01 	vstr	s0, [r5, #4]
	XYZ->z = (atan2f(IMU->dcm_ye_line[0],IMU->dcm_xe_line[0]))*(180/M_PI);
 80005fa:	ed94 0a04 	vldr	s0, [r4, #16]
 80005fe:	f007 fe97 	bl	8008330 <atan2f>
 8000602:	ee20 0a08 	vmul.f32	s0, s0, s16
}
 8000606:	ecbd 8b02 	vpop	{d8}
//! DCM to kartesic coordinates
void IMU_DCM_to_XYZ(struct IMU_values* IMU, struct XYZ_angles *XYZ)
{
	XYZ->x = asinf(-IMU->dcm_ze_line[0])*(180/M_PI);
	XYZ->y = asinf(IMU->dcm_ze_line[1])*(180/M_PI);
	XYZ->z = (atan2f(IMU->dcm_ye_line[0],IMU->dcm_xe_line[0]))*(180/M_PI);
 800060a:	ed85 0a02 	vstr	s0, [r5, #8]
}
 800060e:	bd38      	pop	{r3, r4, r5, pc}
 8000610:	42652ee0 	.word	0x42652ee0

08000614 <L3GD20_SendByte>:
 */

#include <L3GD20_Lib_SPI.h>

static uint8_t L3GD20_SendByte(uint8_t byte)
{
 8000614:	b510      	push	{r4, lr}
 8000616:	4604      	mov	r4, r0
  /* Loop while DR register in not empty */
  while (SPI_I2S_GetFlagStatus(L3GD20_SPI, SPI_I2S_FLAG_TXE) == RESET)
 8000618:	480a      	ldr	r0, [pc, #40]	; (8000644 <L3GD20_SendByte+0x30>)
 800061a:	2102      	movs	r1, #2
 800061c:	f004 f8b8 	bl	8004790 <SPI_I2S_GetFlagStatus>
 8000620:	2800      	cmp	r0, #0
 8000622:	d0f9      	beq.n	8000618 <L3GD20_SendByte+0x4>
  {
  }

  /* Send a Byte through the SPI peripheral */
  SPI_SendData8(L3GD20_SPI, byte);
 8000624:	4807      	ldr	r0, [pc, #28]	; (8000644 <L3GD20_SendByte+0x30>)
 8000626:	4621      	mov	r1, r4
 8000628:	f004 f858 	bl	80046dc <SPI_SendData8>

  /* Wait to receive a Byte */
  while (SPI_I2S_GetFlagStatus(L3GD20_SPI, SPI_I2S_FLAG_RXNE) == RESET)
 800062c:	4805      	ldr	r0, [pc, #20]	; (8000644 <L3GD20_SendByte+0x30>)
 800062e:	2101      	movs	r1, #1
 8000630:	f004 f8ae 	bl	8004790 <SPI_I2S_GetFlagStatus>
 8000634:	2800      	cmp	r0, #0
 8000636:	d0f9      	beq.n	800062c <L3GD20_SendByte+0x18>
  {
  }

  /* Return the Byte read from the SPI bus */
  return (uint8_t)SPI_ReceiveData8(L3GD20_SPI);
 8000638:	4802      	ldr	r0, [pc, #8]	; (8000644 <L3GD20_SendByte+0x30>)
}
 800063a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  while (SPI_I2S_GetFlagStatus(L3GD20_SPI, SPI_I2S_FLAG_RXNE) == RESET)
  {
  }

  /* Return the Byte read from the SPI bus */
  return (uint8_t)SPI_ReceiveData8(L3GD20_SPI);
 800063e:	f004 b851 	b.w	80046e4 <SPI_ReceiveData8>
 8000642:	bf00      	nop
 8000644:	40013000 	.word	0x40013000

08000648 <L3GD20_Init>:
}



void L3GD20_Init(void)
{
 8000648:	b510      	push	{r4, lr}

  ctrl5 = (uint8_t) (0x13); /* CTRL_REG5   low pass filter enable, high pass filter enabled */


  /* Write value to MEMS CTRL_REG1 regsister */
  L3GD20_CS_LOW();
 800064a:	4c1d      	ldr	r4, [pc, #116]	; (80006c0 <L3GD20_Init+0x78>)
 800064c:	2108      	movs	r1, #8
 800064e:	4620      	mov	r0, r4
 8000650:	f003 f9ac 	bl	80039ac <GPIO_ResetBits>
  L3GD20_SendByte(L3GD20_CTRL_REG1_ADDR);
 8000654:	2020      	movs	r0, #32
 8000656:	f7ff ffdd 	bl	8000614 <L3GD20_SendByte>
  L3GD20_SendByte(ctrl1);
 800065a:	20ff      	movs	r0, #255	; 0xff
 800065c:	f7ff ffda 	bl	8000614 <L3GD20_SendByte>
  L3GD20_CS_HIGH();
 8000660:	4620      	mov	r0, r4
 8000662:	2108      	movs	r1, #8
 8000664:	f003 f9a0 	bl	80039a8 <GPIO_SetBits>

  /* Write value to MEMS CTRL_REG2 regsister */
  L3GD20_CS_LOW();
 8000668:	2108      	movs	r1, #8
 800066a:	4620      	mov	r0, r4
 800066c:	f003 f99e 	bl	80039ac <GPIO_ResetBits>
  L3GD20_SendByte(L3GD20_CTRL_REG2_ADDR);
 8000670:	2021      	movs	r0, #33	; 0x21
 8000672:	f7ff ffcf 	bl	8000614 <L3GD20_SendByte>
  L3GD20_SendByte(ctrl2);
 8000676:	2034      	movs	r0, #52	; 0x34
 8000678:	f7ff ffcc 	bl	8000614 <L3GD20_SendByte>
  L3GD20_CS_HIGH();
 800067c:	4620      	mov	r0, r4
 800067e:	2108      	movs	r1, #8
 8000680:	f003 f992 	bl	80039a8 <GPIO_SetBits>

  /* Write value to MEMS CTRL_REG4 regsister */
  L3GD20_CS_LOW();
 8000684:	2108      	movs	r1, #8
 8000686:	4620      	mov	r0, r4
 8000688:	f003 f990 	bl	80039ac <GPIO_ResetBits>
  L3GD20_SendByte(L3GD20_CTRL_REG4_ADDR);
 800068c:	2023      	movs	r0, #35	; 0x23
 800068e:	f7ff ffc1 	bl	8000614 <L3GD20_SendByte>
  L3GD20_SendByte(ctrl4);
 8000692:	20a0      	movs	r0, #160	; 0xa0
 8000694:	f7ff ffbe 	bl	8000614 <L3GD20_SendByte>
  L3GD20_CS_HIGH();
 8000698:	4620      	mov	r0, r4
 800069a:	2108      	movs	r1, #8
 800069c:	f003 f984 	bl	80039a8 <GPIO_SetBits>

  /* Write value to MEMS CTRL_REG2 regsister */
  L3GD20_CS_LOW();
 80006a0:	2108      	movs	r1, #8
 80006a2:	4620      	mov	r0, r4
 80006a4:	f003 f982 	bl	80039ac <GPIO_ResetBits>
  L3GD20_SendByte(L3GD20_CTRL_REG5_ADDR);
 80006a8:	2024      	movs	r0, #36	; 0x24
 80006aa:	f7ff ffb3 	bl	8000614 <L3GD20_SendByte>
  L3GD20_SendByte(ctrl5);
 80006ae:	2013      	movs	r0, #19
 80006b0:	f7ff ffb0 	bl	8000614 <L3GD20_SendByte>
  L3GD20_CS_HIGH();
 80006b4:	4620      	mov	r0, r4
 80006b6:	2108      	movs	r1, #8
}
 80006b8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  /* Write value to MEMS CTRL_REG2 regsister */
  L3GD20_CS_LOW();
  L3GD20_SendByte(L3GD20_CTRL_REG5_ADDR);
  L3GD20_SendByte(ctrl5);
  L3GD20_CS_HIGH();
 80006bc:	f003 b974 	b.w	80039a8 <GPIO_SetBits>
 80006c0:	48001000 	.word	0x48001000

080006c4 <L3GD20_Read>:
}


void L3GD20_Read(uint8_t* pBuffer, uint8_t ReadAddr, uint16_t NumByteToRead)
{
  if(NumByteToRead > 0x01)
 80006c4:	2a01      	cmp	r2, #1
  L3GD20_CS_HIGH();
}


void L3GD20_Read(uint8_t* pBuffer, uint8_t ReadAddr, uint16_t NumByteToRead)
{
 80006c6:	b570      	push	{r4, r5, r6, lr}
  if(NumByteToRead > 0x01)
  {
    ReadAddr |= (uint8_t)(READWRITE_CMD | MULTIPLEBYTE_CMD);
 80006c8:	bf8c      	ite	hi
 80006ca:	f041 04c0 	orrhi.w	r4, r1, #192	; 0xc0
  }
  else
  {
    ReadAddr |= (uint8_t)READWRITE_CMD;
 80006ce:	f041 0480 	orrls.w	r4, r1, #128	; 0x80
  L3GD20_CS_HIGH();
}


void L3GD20_Read(uint8_t* pBuffer, uint8_t ReadAddr, uint16_t NumByteToRead)
{
 80006d2:	4606      	mov	r6, r0
  else
  {
    ReadAddr |= (uint8_t)READWRITE_CMD;
  }
  /* Set chip select Low at the start of the transmission */
  L3GD20_CS_LOW();
 80006d4:	2108      	movs	r1, #8
 80006d6:	480b      	ldr	r0, [pc, #44]	; (8000704 <L3GD20_Read+0x40>)
  L3GD20_CS_HIGH();
}


void L3GD20_Read(uint8_t* pBuffer, uint8_t ReadAddr, uint16_t NumByteToRead)
{
 80006d8:	4615      	mov	r5, r2
  else
  {
    ReadAddr |= (uint8_t)READWRITE_CMD;
  }
  /* Set chip select Low at the start of the transmission */
  L3GD20_CS_LOW();
 80006da:	f003 f967 	bl	80039ac <GPIO_ResetBits>

  /* Send the Address of the indexed register */
  L3GD20_SendByte(ReadAddr);
 80006de:	4620      	mov	r0, r4
 80006e0:	f7ff ff98 	bl	8000614 <L3GD20_SendByte>

  /* Receive the data that will be read from the device (MSB First) */
  while(NumByteToRead > 0x00)
 80006e4:	2400      	movs	r4, #0
 80006e6:	b2a3      	uxth	r3, r4
 80006e8:	429d      	cmp	r5, r3
 80006ea:	d005      	beq.n	80006f8 <L3GD20_Read+0x34>
  {
    /* Send dummy byte (0x00) to generate the SPI clock to L3GD20 (Slave device) */
    *pBuffer = L3GD20_SendByte(DUMMY_BYTE);
 80006ec:	2000      	movs	r0, #0
 80006ee:	f7ff ff91 	bl	8000614 <L3GD20_SendByte>
 80006f2:	5530      	strb	r0, [r6, r4]
 80006f4:	3401      	adds	r4, #1
 80006f6:	e7f6      	b.n	80006e6 <L3GD20_Read+0x22>
    NumByteToRead--;
    pBuffer++;
  }

  /* Set chip select High at the end of the transmission */
  L3GD20_CS_HIGH();
 80006f8:	4802      	ldr	r0, [pc, #8]	; (8000704 <L3GD20_Read+0x40>)
 80006fa:	2108      	movs	r1, #8
}
 80006fc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    NumByteToRead--;
    pBuffer++;
  }

  /* Set chip select High at the end of the transmission */
  L3GD20_CS_HIGH();
 8000700:	f003 b952 	b.w	80039a8 <GPIO_SetBits>
 8000704:	48001000 	.word	0x48001000

08000708 <Gyro_convert>:
}


void Gyro_convert(uint8_t Buffer[6], struct gyroValues *gyro, uint8_t bigEndian)
{
 8000708:	b510      	push	{r4, lr}
 800070a:	7843      	ldrb	r3, [r0, #1]
 800070c:	7804      	ldrb	r4, [r0, #0]
	if(bigEndian)
 800070e:	b152      	cbz	r2, 8000726 <Gyro_convert+0x1e>
	{
		gyro->gyroValueX = (Buffer[1] << 8) | (Buffer[0]);
 8000710:	ea44 2303 	orr.w	r3, r4, r3, lsl #8
 8000714:	800b      	strh	r3, [r1, #0]
		gyro->gyroValueY = (Buffer[3] << 8) | (Buffer[2]);
 8000716:	78c2      	ldrb	r2, [r0, #3]
 8000718:	7883      	ldrb	r3, [r0, #2]
 800071a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 800071e:	804b      	strh	r3, [r1, #2]
		gyro->gyroValueZ = (Buffer[5] << 8) | (Buffer[4]);
 8000720:	7942      	ldrb	r2, [r0, #5]
 8000722:	7903      	ldrb	r3, [r0, #4]
 8000724:	e009      	b.n	800073a <Gyro_convert+0x32>
	}
	else
	{
		gyro->gyroValueX = (Buffer[0] << 8) | (Buffer[1]);
 8000726:	ea43 2304 	orr.w	r3, r3, r4, lsl #8
 800072a:	800b      	strh	r3, [r1, #0]
		gyro->gyroValueY = (Buffer[2] << 8) | (Buffer[3]);
 800072c:	7882      	ldrb	r2, [r0, #2]
 800072e:	78c3      	ldrb	r3, [r0, #3]
 8000730:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8000734:	804b      	strh	r3, [r1, #2]
		gyro->gyroValueZ = (Buffer[4] << 8) | (Buffer[5]);
 8000736:	7902      	ldrb	r2, [r0, #4]
 8000738:	7943      	ldrb	r3, [r0, #5]
 800073a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 800073e:	808b      	strh	r3, [r1, #4]
 8000740:	bd10      	pop	{r4, pc}

08000742 <Gyro_readValues>:
	}
}


void Gyro_readValues (struct gyroValues *gyro)
{
 8000742:	b530      	push	{r4, r5, lr}
 8000744:	b085      	sub	sp, #20
 8000746:	4605      	mov	r5, r0
  uint8_t tmpbuffer[6] ={0};
  uint8_t tmpreg = 0;
 8000748:	a804      	add	r0, sp, #16
}


void Gyro_readValues (struct gyroValues *gyro)
{
  uint8_t tmpbuffer[6] ={0};
 800074a:	2400      	movs	r4, #0
  uint8_t tmpreg = 0;
 800074c:	f800 4d09 	strb.w	r4, [r0, #-9]!

  L3GD20_Read(&tmpreg,L3GD20_CTRL_REG4_ADDR,1);
 8000750:	2123      	movs	r1, #35	; 0x23
 8000752:	2201      	movs	r2, #1
}


void Gyro_readValues (struct gyroValues *gyro)
{
  uint8_t tmpbuffer[6] ={0};
 8000754:	9402      	str	r4, [sp, #8]
 8000756:	f8ad 400c 	strh.w	r4, [sp, #12]
  uint8_t tmpreg = 0;

  L3GD20_Read(&tmpreg,L3GD20_CTRL_REG4_ADDR,1);
 800075a:	f7ff ffb3 	bl	80006c4 <L3GD20_Read>
  L3GD20_Read(tmpbuffer,L3GD20_OUT_X_L_ADDR,6);
 800075e:	a802      	add	r0, sp, #8
 8000760:	2128      	movs	r1, #40	; 0x28
 8000762:	2206      	movs	r2, #6
 8000764:	f7ff ffae 	bl	80006c4 <L3GD20_Read>

  /* check in the control register 4 the data alignment (Big Endian or Little Endian)*/
  if(!(tmpreg & 0x40))
 8000768:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800076c:	065b      	lsls	r3, r3, #25
 800076e:	d415      	bmi.n	800079c <Gyro_readValues+0x5a>

void Gyro_convert(uint8_t Buffer[6], struct gyroValues *gyro, uint8_t bigEndian)
{
	if(bigEndian)
	{
		gyro->gyroValueX = (Buffer[1] << 8) | (Buffer[0]);
 8000770:	f89d 2009 	ldrb.w	r2, [sp, #9]
 8000774:	f89d 3008 	ldrb.w	r3, [sp, #8]
 8000778:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 800077c:	802b      	strh	r3, [r5, #0]
		gyro->gyroValueY = (Buffer[3] << 8) | (Buffer[2]);
 800077e:	f89d 200b 	ldrb.w	r2, [sp, #11]
 8000782:	f89d 300a 	ldrb.w	r3, [sp, #10]
 8000786:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 800078a:	806b      	strh	r3, [r5, #2]
		gyro->gyroValueZ = (Buffer[5] << 8) | (Buffer[4]);
 800078c:	f89d 200d 	ldrb.w	r2, [sp, #13]
 8000790:	f89d 300c 	ldrb.w	r3, [sp, #12]
 8000794:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8000798:	80ab      	strh	r3, [r5, #4]
 800079a:	e004      	b.n	80007a6 <Gyro_readValues+0x64>
  {
	Gyro_convert(&tmpbuffer[0], gyro, 1);
  }
  else
  {
   	Gyro_convert(&tmpbuffer[0], gyro, 0);
 800079c:	a802      	add	r0, sp, #8
 800079e:	4629      	mov	r1, r5
 80007a0:	4622      	mov	r2, r4
 80007a2:	f7ff ffb1 	bl	8000708 <Gyro_convert>
  }
}
 80007a6:	b005      	add	sp, #20
 80007a8:	bd30      	pop	{r4, r5, pc}

080007aa <Gyro_calibrate>:



//ACC und GYRO kalibrieren:
void Gyro_calibrate(struct gyroValues *gyroOffset)
{
 80007aa:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80007ae:	4604      	mov	r4, r0
int i = 0;
int32_t tmpX = 0;
int32_t tmpY = 0;
int32_t tmpZ = 0;

L3GD20_Init();
 80007b0:	f7ff ff4a 	bl	8000648 <L3GD20_Init>
 80007b4:	2564      	movs	r5, #100	; 0x64

//discard the first 100 values
for(i=0;i<100;i++)
{
	Gyro_readValues(gyroOffset);
 80007b6:	4620      	mov	r0, r4
 80007b8:	f7ff ffc3 	bl	8000742 <Gyro_readValues>
int32_t tmpZ = 0;

L3GD20_Init();

//discard the first 100 values
for(i=0;i<100;i++)
 80007bc:	3d01      	subs	r5, #1
 80007be:	d1fa      	bne.n	80007b6 <Gyro_calibrate+0xc>
{
	Gyro_readValues(gyroOffset);
}

gyroOffset->gyroValueX = 0;
 80007c0:	8025      	strh	r5, [r4, #0]
gyroOffset->gyroValueY = 0;
 80007c2:	8065      	strh	r5, [r4, #2]
gyroOffset->gyroValueZ = 0;
 80007c4:	80a5      	strh	r5, [r4, #4]
 80007c6:	f44f 7896 	mov.w	r8, #300	; 0x12c
//ACC und GYRO kalibrieren:
void Gyro_calibrate(struct gyroValues *gyroOffset)
{
int i = 0;
int32_t tmpX = 0;
int32_t tmpY = 0;
 80007ca:	462e      	mov	r6, r5

//ACC und GYRO kalibrieren:
void Gyro_calibrate(struct gyroValues *gyroOffset)
{
int i = 0;
int32_t tmpX = 0;
 80007cc:	462f      	mov	r7, r5

/***************Calibrate the Gyro***************/
for(i=0;i<average_loop_value;i++)
{

	Gyro_readValues(gyroOffset);
 80007ce:	4620      	mov	r0, r4
 80007d0:	f7ff ffb7 	bl	8000742 <Gyro_readValues>
	tmpX += gyroOffset->gyroValueX;
 80007d4:	f9b4 3000 	ldrsh.w	r3, [r4]
 80007d8:	441f      	add	r7, r3
	tmpY += gyroOffset->gyroValueY;
 80007da:	f9b4 3002 	ldrsh.w	r3, [r4, #2]
 80007de:	441e      	add	r6, r3
	tmpZ += gyroOffset->gyroValueZ;
 80007e0:	f9b4 3004 	ldrsh.w	r3, [r4, #4]
gyroOffset->gyroValueX = 0;
gyroOffset->gyroValueY = 0;
gyroOffset->gyroValueZ = 0;

/***************Calibrate the Gyro***************/
for(i=0;i<average_loop_value;i++)
 80007e4:	f1b8 0801 	subs.w	r8, r8, #1
{

	Gyro_readValues(gyroOffset);
	tmpX += gyroOffset->gyroValueX;
	tmpY += gyroOffset->gyroValueY;
	tmpZ += gyroOffset->gyroValueZ;
 80007e8:	441d      	add	r5, r3
gyroOffset->gyroValueX = 0;
gyroOffset->gyroValueY = 0;
gyroOffset->gyroValueZ = 0;

/***************Calibrate the Gyro***************/
for(i=0;i<average_loop_value;i++)
 80007ea:	d1f0      	bne.n	80007ce <Gyro_calibrate+0x24>
	tmpX += gyroOffset->gyroValueX;
	tmpY += gyroOffset->gyroValueY;
	tmpZ += gyroOffset->gyroValueZ;
}

gyroOffset->gyroValueX = tmpX/average_loop_value;
 80007ec:	f44f 7396 	mov.w	r3, #300	; 0x12c
 80007f0:	fb97 f7f3 	sdiv	r7, r7, r3
gyroOffset->gyroValueY = tmpY/average_loop_value;
 80007f4:	fb96 f6f3 	sdiv	r6, r6, r3
gyroOffset->gyroValueZ = tmpZ/average_loop_value;
 80007f8:	fb95 f5f3 	sdiv	r5, r5, r3
	tmpX += gyroOffset->gyroValueX;
	tmpY += gyroOffset->gyroValueY;
	tmpZ += gyroOffset->gyroValueZ;
}

gyroOffset->gyroValueX = tmpX/average_loop_value;
 80007fc:	8027      	strh	r7, [r4, #0]
gyroOffset->gyroValueY = tmpY/average_loop_value;
 80007fe:	8066      	strh	r6, [r4, #2]
gyroOffset->gyroValueZ = tmpZ/average_loop_value;
 8000800:	80a5      	strh	r5, [r4, #4]
 8000802:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000806:	bf00      	nop

08000808 <LSM303DLHC_Write>:
#include <LSM303DLHC_Lib_I2C.h>


void LSM303DLHC_Write(uint8_t DeviceAddr, uint8_t RegAddr, uint8_t* pBuffer)
{
 8000808:	b573      	push	{r0, r1, r4, r5, r6, lr}
 800080a:	4604      	mov	r4, r0
 800080c:	460e      	mov	r6, r1
 800080e:	4615      	mov	r5, r2
  /* Test on BUSY Flag */
  while(I2C_GetFlagStatus(LSM303DLHC_I2C, I2C_ISR_BUSY) != RESET)
 8000810:	4820      	ldr	r0, [pc, #128]	; (8000894 <LSM303DLHC_Write+0x8c>)
 8000812:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8000816:	f003 fa74 	bl	8003d02 <I2C_GetFlagStatus>
 800081a:	2800      	cmp	r0, #0
 800081c:	d1f8      	bne.n	8000810 <LSM303DLHC_Write+0x8>
  {
  }

  /* Configure slave address, nbytes, reload, end mode and start or stop generation */
  I2C_TransferHandling(LSM303DLHC_I2C, DeviceAddr, 1, I2C_Reload_Mode, I2C_Generate_Start_Write);
 800081e:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8000822:	9300      	str	r3, [sp, #0]
 8000824:	481b      	ldr	r0, [pc, #108]	; (8000894 <LSM303DLHC_Write+0x8c>)
 8000826:	4621      	mov	r1, r4
 8000828:	2201      	movs	r2, #1
 800082a:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 800082e:	f003 f9ea 	bl	8003c06 <I2C_TransferHandling>

  /* Wait until TXIS flag is set */
  while(I2C_GetFlagStatus(LSM303DLHC_I2C, I2C_ISR_TXIS) == RESET)
 8000832:	4818      	ldr	r0, [pc, #96]	; (8000894 <LSM303DLHC_Write+0x8c>)
 8000834:	2102      	movs	r1, #2
 8000836:	f003 fa64 	bl	8003d02 <I2C_GetFlagStatus>
 800083a:	2800      	cmp	r0, #0
 800083c:	d0f9      	beq.n	8000832 <LSM303DLHC_Write+0x2a>
  {
  }

  /* Send Register address */
  I2C_SendData(LSM303DLHC_I2C, (uint8_t) RegAddr);
 800083e:	4815      	ldr	r0, [pc, #84]	; (8000894 <LSM303DLHC_Write+0x8c>)
 8000840:	4631      	mov	r1, r6
 8000842:	f003 fa51 	bl	8003ce8 <I2C_SendData>

  /* Wait until TCR flag is set */
  while(I2C_GetFlagStatus(LSM303DLHC_I2C, I2C_ISR_TCR) == RESET)
 8000846:	4813      	ldr	r0, [pc, #76]	; (8000894 <LSM303DLHC_Write+0x8c>)
 8000848:	2180      	movs	r1, #128	; 0x80
 800084a:	f003 fa5a 	bl	8003d02 <I2C_GetFlagStatus>
 800084e:	2800      	cmp	r0, #0
 8000850:	d0f9      	beq.n	8000846 <LSM303DLHC_Write+0x3e>
  {
  }

  /* Configure slave address, nbytes, reload, end mode and start or stop generation */
  I2C_TransferHandling(LSM303DLHC_I2C, DeviceAddr, 1, I2C_AutoEnd_Mode, I2C_No_StartStop);
 8000852:	2300      	movs	r3, #0
 8000854:	9300      	str	r3, [sp, #0]
 8000856:	480f      	ldr	r0, [pc, #60]	; (8000894 <LSM303DLHC_Write+0x8c>)
 8000858:	4621      	mov	r1, r4
 800085a:	2201      	movs	r2, #1
 800085c:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8000860:	f003 f9d1 	bl	8003c06 <I2C_TransferHandling>

  /* Wait until TXIS flag is set */
  while(I2C_GetFlagStatus(LSM303DLHC_I2C, I2C_ISR_TXIS) == RESET)
 8000864:	480b      	ldr	r0, [pc, #44]	; (8000894 <LSM303DLHC_Write+0x8c>)
 8000866:	2102      	movs	r1, #2
 8000868:	f003 fa4b 	bl	8003d02 <I2C_GetFlagStatus>
 800086c:	2800      	cmp	r0, #0
 800086e:	d0f9      	beq.n	8000864 <LSM303DLHC_Write+0x5c>
  {
  }

  /* Write data to TXDR */
  I2C_SendData(LSM303DLHC_I2C, *pBuffer);
 8000870:	4808      	ldr	r0, [pc, #32]	; (8000894 <LSM303DLHC_Write+0x8c>)
 8000872:	7829      	ldrb	r1, [r5, #0]
 8000874:	f003 fa38 	bl	8003ce8 <I2C_SendData>

  /* Wait until STOPF flag is set */
  while(I2C_GetFlagStatus(LSM303DLHC_I2C, I2C_ISR_STOPF) == RESET)
 8000878:	4806      	ldr	r0, [pc, #24]	; (8000894 <LSM303DLHC_Write+0x8c>)
 800087a:	2120      	movs	r1, #32
 800087c:	f003 fa41 	bl	8003d02 <I2C_GetFlagStatus>
 8000880:	2800      	cmp	r0, #0
 8000882:	d0f9      	beq.n	8000878 <LSM303DLHC_Write+0x70>
  {
  }

  /* Clear STOPF flag */
  I2C_ClearFlag(LSM303DLHC_I2C, I2C_ICR_STOPCF);
 8000884:	4803      	ldr	r0, [pc, #12]	; (8000894 <LSM303DLHC_Write+0x8c>)
 8000886:	2120      	movs	r1, #32
}
 8000888:	b002      	add	sp, #8
 800088a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  while(I2C_GetFlagStatus(LSM303DLHC_I2C, I2C_ISR_STOPF) == RESET)
  {
  }

  /* Clear STOPF flag */
  I2C_ClearFlag(LSM303DLHC_I2C, I2C_ICR_STOPCF);
 800088e:	f003 ba3e 	b.w	8003d0e <I2C_ClearFlag>
 8000892:	bf00      	nop
 8000894:	40005400 	.word	0x40005400

08000898 <LSM303DLHC_Read>:
}


void LSM303DLHC_Read(uint8_t DeviceAddr, uint8_t RegAddr, uint8_t* pBuffer, uint16_t NumByteToRead)
{
 8000898:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800089a:	4606      	mov	r6, r0
 800089c:	460c      	mov	r4, r1
 800089e:	4617      	mov	r7, r2
 80008a0:	461d      	mov	r5, r3
  /* Test on BUSY Flag */
  while(I2C_GetFlagStatus(LSM303DLHC_I2C, I2C_ISR_BUSY) != RESET)
 80008a2:	4825      	ldr	r0, [pc, #148]	; (8000938 <LSM303DLHC_Read+0xa0>)
 80008a4:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 80008a8:	f003 fa2b 	bl	8003d02 <I2C_GetFlagStatus>
 80008ac:	4603      	mov	r3, r0
 80008ae:	2800      	cmp	r0, #0
 80008b0:	d1f7      	bne.n	80008a2 <LSM303DLHC_Read+0xa>
  {
  }

  /* Configure slave address, nbytes, reload, end mode and start or stop generation */
  I2C_TransferHandling(LSM303DLHC_I2C, DeviceAddr, 1, I2C_SoftEnd_Mode, I2C_Generate_Start_Write);
 80008b2:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 80008b6:	9200      	str	r2, [sp, #0]
 80008b8:	481f      	ldr	r0, [pc, #124]	; (8000938 <LSM303DLHC_Read+0xa0>)
 80008ba:	4631      	mov	r1, r6
 80008bc:	2201      	movs	r2, #1
 80008be:	f003 f9a2 	bl	8003c06 <I2C_TransferHandling>

  /* Wait until TXIS flag is set */
  while(I2C_GetFlagStatus(LSM303DLHC_I2C, I2C_ISR_TXIS) == RESET)
 80008c2:	481d      	ldr	r0, [pc, #116]	; (8000938 <LSM303DLHC_Read+0xa0>)
 80008c4:	2102      	movs	r1, #2
 80008c6:	f003 fa1c 	bl	8003d02 <I2C_GetFlagStatus>
 80008ca:	2800      	cmp	r0, #0
 80008cc:	d0f9      	beq.n	80008c2 <LSM303DLHC_Read+0x2a>
  {
  }

  if(NumByteToRead>1)
 80008ce:	2d01      	cmp	r5, #1
      RegAddr |= 0x80;
 80008d0:	bf88      	it	hi
 80008d2:	f044 0480 	orrhi.w	r4, r4, #128	; 0x80


  /* Send Register address */
  I2C_SendData(LSM303DLHC_I2C, (uint8_t)RegAddr);
 80008d6:	4818      	ldr	r0, [pc, #96]	; (8000938 <LSM303DLHC_Read+0xa0>)
 80008d8:	4621      	mov	r1, r4
 80008da:	f003 fa05 	bl	8003ce8 <I2C_SendData>

  /* Wait until TC flag is set */
  while(I2C_GetFlagStatus(LSM303DLHC_I2C, I2C_ISR_TC) == RESET)
 80008de:	4816      	ldr	r0, [pc, #88]	; (8000938 <LSM303DLHC_Read+0xa0>)
 80008e0:	2140      	movs	r1, #64	; 0x40
 80008e2:	f003 fa0e 	bl	8003d02 <I2C_GetFlagStatus>
 80008e6:	2800      	cmp	r0, #0
 80008e8:	d0f9      	beq.n	80008de <LSM303DLHC_Read+0x46>
  {
  }

  /* Configure slave address, nbytes, reload, end mode and start or stop generation */
  I2C_TransferHandling(LSM303DLHC_I2C, DeviceAddr, NumByteToRead, I2C_AutoEnd_Mode, I2C_Generate_Start_Read);
 80008ea:	f44f 5310 	mov.w	r3, #9216	; 0x2400
 80008ee:	9300      	str	r3, [sp, #0]
 80008f0:	4811      	ldr	r0, [pc, #68]	; (8000938 <LSM303DLHC_Read+0xa0>)
 80008f2:	4631      	mov	r1, r6
 80008f4:	b2ea      	uxtb	r2, r5
 80008f6:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 80008fa:	f003 f984 	bl	8003c06 <I2C_TransferHandling>

  /* Wait until all data are received */
  while (NumByteToRead)
 80008fe:	2400      	movs	r4, #0
 8000900:	b2a3      	uxth	r3, r4
 8000902:	429d      	cmp	r5, r3
 8000904:	d00b      	beq.n	800091e <LSM303DLHC_Read+0x86>
  {
    /* Wait until RXNE flag is set */
    while(I2C_GetFlagStatus(LSM303DLHC_I2C, I2C_ISR_RXNE) == RESET)
 8000906:	480c      	ldr	r0, [pc, #48]	; (8000938 <LSM303DLHC_Read+0xa0>)
 8000908:	2104      	movs	r1, #4
 800090a:	f003 f9fa 	bl	8003d02 <I2C_GetFlagStatus>
 800090e:	2800      	cmp	r0, #0
 8000910:	d0f9      	beq.n	8000906 <LSM303DLHC_Read+0x6e>
    {
    }

    /* Read data from RXDR */
    *pBuffer = I2C_ReceiveData(LSM303DLHC_I2C);
 8000912:	4809      	ldr	r0, [pc, #36]	; (8000938 <LSM303DLHC_Read+0xa0>)
 8000914:	f003 f9ea 	bl	8003cec <I2C_ReceiveData>
 8000918:	5538      	strb	r0, [r7, r4]
 800091a:	3401      	adds	r4, #1
 800091c:	e7f0      	b.n	8000900 <LSM303DLHC_Read+0x68>
    /* Decrement the read bytes counter */
    NumByteToRead--;
  }

  /* Wait until STOPF flag is set */
  while(I2C_GetFlagStatus(LSM303DLHC_I2C, I2C_ISR_STOPF) == RESET)
 800091e:	4806      	ldr	r0, [pc, #24]	; (8000938 <LSM303DLHC_Read+0xa0>)
 8000920:	2120      	movs	r1, #32
 8000922:	f003 f9ee 	bl	8003d02 <I2C_GetFlagStatus>
 8000926:	2800      	cmp	r0, #0
 8000928:	d0f9      	beq.n	800091e <LSM303DLHC_Read+0x86>
  {
  }

  /* Clear STOPF flag */
  I2C_ClearFlag(LSM303DLHC_I2C, I2C_ICR_STOPCF);
 800092a:	4803      	ldr	r0, [pc, #12]	; (8000938 <LSM303DLHC_Read+0xa0>)
 800092c:	2120      	movs	r1, #32
}
 800092e:	b003      	add	sp, #12
 8000930:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  while(I2C_GetFlagStatus(LSM303DLHC_I2C, I2C_ISR_STOPF) == RESET)
  {
  }

  /* Clear STOPF flag */
  I2C_ClearFlag(LSM303DLHC_I2C, I2C_ICR_STOPCF);
 8000934:	f003 b9eb 	b.w	8003d0e <I2C_ClearFlag>
 8000938:	40005400 	.word	0x40005400

0800093c <LSM303DLHC_ReadDMA>:
}

void LSM303DLHC_ReadDMA(uint8_t DeviceAddr, uint8_t RegAddr, uint8_t* pBuffer, uint16_t NumByteToRead)
{
 800093c:	b573      	push	{r0, r1, r4, r5, r6, lr}
 800093e:	4606      	mov	r6, r0
 8000940:	460c      	mov	r4, r1
 8000942:	461d      	mov	r5, r3
//	  return;
//  }

  //DMA_Configuration(pBuffer);
  /* Test on BUSY Flag */
  while(I2C_GetFlagStatus(LSM303DLHC_I2C, I2C_ISR_BUSY) != RESET)
 8000944:	482c      	ldr	r0, [pc, #176]	; (80009f8 <LSM303DLHC_ReadDMA+0xbc>)
 8000946:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 800094a:	f003 f9da 	bl	8003d02 <I2C_GetFlagStatus>
 800094e:	4603      	mov	r3, r0
 8000950:	2800      	cmp	r0, #0
 8000952:	d1f7      	bne.n	8000944 <LSM303DLHC_ReadDMA+0x8>
  {
  }


  /* Configure slave address, nbytes, reload, end mode and start or stop generation */
  I2C_TransferHandling(LSM303DLHC_I2C, DeviceAddr, 1, I2C_SoftEnd_Mode, I2C_Generate_Start_Write);
 8000954:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8000958:	9200      	str	r2, [sp, #0]
 800095a:	4827      	ldr	r0, [pc, #156]	; (80009f8 <LSM303DLHC_ReadDMA+0xbc>)
 800095c:	4631      	mov	r1, r6
 800095e:	2201      	movs	r2, #1
 8000960:	f003 f951 	bl	8003c06 <I2C_TransferHandling>

  /* Wait until TXIS flag is set */
  while(I2C_GetFlagStatus(LSM303DLHC_I2C, I2C_ISR_TXIS) == RESET)
 8000964:	4824      	ldr	r0, [pc, #144]	; (80009f8 <LSM303DLHC_ReadDMA+0xbc>)
 8000966:	2102      	movs	r1, #2
 8000968:	f003 f9cb 	bl	8003d02 <I2C_GetFlagStatus>
 800096c:	2800      	cmp	r0, #0
 800096e:	d0f9      	beq.n	8000964 <LSM303DLHC_ReadDMA+0x28>
  {
  }

  if(NumByteToRead>1)
 8000970:	2d01      	cmp	r5, #1
      RegAddr |= 0x80;
 8000972:	bf88      	it	hi
 8000974:	f044 0480 	orrhi.w	r4, r4, #128	; 0x80

  //printf("M2%d ", 0);

  /* Send Register address */
  I2C_SendData(LSM303DLHC_I2C, (uint8_t)RegAddr);
 8000978:	481f      	ldr	r0, [pc, #124]	; (80009f8 <LSM303DLHC_ReadDMA+0xbc>)
 800097a:	4621      	mov	r1, r4
 800097c:	f003 f9b4 	bl	8003ce8 <I2C_SendData>

  /* Wait until TXIS flag is set */
  while(I2C_GetFlagStatus(LSM303DLHC_I2C, I2C_ISR_TC) == RESET)
 8000980:	481d      	ldr	r0, [pc, #116]	; (80009f8 <LSM303DLHC_ReadDMA+0xbc>)
 8000982:	2140      	movs	r1, #64	; 0x40
 8000984:	f003 f9bd 	bl	8003d02 <I2C_GetFlagStatus>
 8000988:	2800      	cmp	r0, #0
 800098a:	d0f9      	beq.n	8000980 <LSM303DLHC_ReadDMA+0x44>
//  I2C_MasterRequestConfig(LSM303DLHC_I2C, I2C_Direction_Receiver);
//  I2C_GenerateSTART(LSM303DLHC_I2C, ENABLE);
//  I2C_SlaveAddressConfig(LSM303DLHC_I2C, DeviceAddr);
  //I2C_MasterRequestConfig(LSM303DLHC_I2C, I2C_Direction_Receiver);
  /* Configure slave address, nbytes, reload, end mode and start or stop generation */
  I2C_TransferHandling(LSM303DLHC_I2C, DeviceAddr, NumByteToRead, I2C_AutoEnd_Mode, I2C_Generate_Start_Read);
 800098c:	f44f 5310 	mov.w	r3, #9216	; 0x2400
 8000990:	9300      	str	r3, [sp, #0]
 8000992:	4819      	ldr	r0, [pc, #100]	; (80009f8 <LSM303DLHC_ReadDMA+0xbc>)
 8000994:	4631      	mov	r1, r6
 8000996:	b2ea      	uxtb	r2, r5
 8000998:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800099c:	f003 f933 	bl	8003c06 <I2C_TransferHandling>

  /* Enable DMA1 Channel5 */
  I2C_DMACmd(LSM303DLHC_I2C, I2C_DMAReq_Rx, ENABLE);
 80009a0:	4815      	ldr	r0, [pc, #84]	; (80009f8 <LSM303DLHC_ReadDMA+0xbc>)
 80009a2:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 80009a6:	2201      	movs	r2, #1
 80009a8:	f003 f9a3 	bl	8003cf2 <I2C_DMACmd>
DMA_Cmd(DMA1_Channel7, ENABLE);
 80009ac:	4813      	ldr	r0, [pc, #76]	; (80009fc <LSM303DLHC_ReadDMA+0xc0>)
 80009ae:	2101      	movs	r1, #1
 80009b0:	f002 fe0d 	bl	80035ce <DMA_Cmd>
//  }

//printf("M4%d ", 0);

  /* DMA1 Channel1 transfer complete test */
  while(!DMA_GetFlagStatus(DMA1_FLAG_TC7));
 80009b4:	f04f 7000 	mov.w	r0, #33554432	; 0x2000000
 80009b8:	f002 fe21 	bl	80035fe <DMA_GetFlagStatus>
 80009bc:	2800      	cmp	r0, #0
 80009be:	d0f9      	beq.n	80009b4 <LSM303DLHC_ReadDMA+0x78>

  //printf("M5%d ", 0);

  DMA_ClearFlag(DMA1_FLAG_GL7);
 80009c0:	f04f 7080 	mov.w	r0, #16777216	; 0x1000000
 80009c4:	f002 fe2a 	bl	800361c <DMA_ClearFlag>

  I2C_DMACmd(LSM303DLHC_I2C, I2C_DMAReq_Rx, DISABLE);
 80009c8:	480b      	ldr	r0, [pc, #44]	; (80009f8 <LSM303DLHC_ReadDMA+0xbc>)
 80009ca:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 80009ce:	2200      	movs	r2, #0
 80009d0:	f003 f98f 	bl	8003cf2 <I2C_DMACmd>
  DMA_Cmd(DMA1_Channel7, DISABLE);
 80009d4:	4809      	ldr	r0, [pc, #36]	; (80009fc <LSM303DLHC_ReadDMA+0xc0>)
 80009d6:	2100      	movs	r1, #0
 80009d8:	f002 fdf9 	bl	80035ce <DMA_Cmd>
  //GPIO_SetBits(GPIOE,GPIO_Pin_9);

  //I2C_GenerateSTOP(LSM303DLHC_I2C, ENABLE);

  /* Wait until STOPF flag is set */
  while(I2C_GetFlagStatus(LSM303DLHC_I2C, I2C_ISR_STOPF) == RESET)
 80009dc:	4806      	ldr	r0, [pc, #24]	; (80009f8 <LSM303DLHC_ReadDMA+0xbc>)
 80009de:	2120      	movs	r1, #32
 80009e0:	f003 f98f 	bl	8003d02 <I2C_GetFlagStatus>
 80009e4:	2800      	cmp	r0, #0
 80009e6:	d0f9      	beq.n	80009dc <LSM303DLHC_ReadDMA+0xa0>
  {
  }

  /* Clear STOPF flag */
  I2C_ClearFlag(LSM303DLHC_I2C, I2C_ICR_STOPCF);
 80009e8:	4803      	ldr	r0, [pc, #12]	; (80009f8 <LSM303DLHC_ReadDMA+0xbc>)
 80009ea:	2120      	movs	r1, #32
}
 80009ec:	b002      	add	sp, #8
 80009ee:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  while(I2C_GetFlagStatus(LSM303DLHC_I2C, I2C_ISR_STOPF) == RESET)
  {
  }

  /* Clear STOPF flag */
  I2C_ClearFlag(LSM303DLHC_I2C, I2C_ICR_STOPCF);
 80009f2:	f003 b98c 	b.w	8003d0e <I2C_ClearFlag>
 80009f6:	bf00      	nop
 80009f8:	40005400 	.word	0x40005400
 80009fc:	40020080 	.word	0x40020080

08000a00 <LSM303DLHC_AccInit>:
}


#ifdef LSM303_ACC
void LSM303DLHC_AccInit(void)
{
 8000a00:	b507      	push	{r0, r1, r2, lr}
  uint8_t ctrl1 = 0x00, ctrl2 = 0x00, ctrl4 = 0x00;
 8000a02:	2300      	movs	r3, #0
 8000a04:	f88d 3006 	strb.w	r3, [sp, #6]

  /* Configure MEMS: data rate, power mode, full scale and axes */
//  ctrl1 |= (uint8_t) (LSM303DLHC_NORMAL_MODE | LSM303DLHC_ODR_200_HZ |
//		  	  	  	  LSM303DLHC_AXES_ENABLE);

    ctrl1 |= (uint8_t) (LSM303DLHC_NORMAL_MODE | LSM303DLHC_ODR_1344_HZ |
 8000a08:	2397      	movs	r3, #151	; 0x97
 8000a0a:	f88d 3005 	strb.w	r3, [sp, #5]
  		  	  	  	  LSM303DLHC_FULLSCALE_16G | LSM303DLHC_HR_ENABLE);

  //ctrl4 = 0x30;

  /* Write value to ACC MEMS CTRL_REG1 regsister */
  LSM303DLHC_Write(ACC_I2C_ADDRESS, LSM303DLHC_CTRL_REG1_A, &ctrl1);
 8000a0e:	f10d 0205 	add.w	r2, sp, #5


//  ctrl4 |= (uint8_t) (LSM303DLHC_BlockUpdate_Continous | LSM303DLHC_BLE_LSB |
//		  	  	  	  LSM303DLHC_FULLSCALE_16G | LSM303DLHC_HR_ENABLE);

  ctrl4 |= (uint8_t) (LSM303DLHC_BlockUpdate_Continous | LSM303DLHC_BLE_LSB |
 8000a12:	2338      	movs	r3, #56	; 0x38
  		  	  	  	  LSM303DLHC_FULLSCALE_16G | LSM303DLHC_HR_ENABLE);

  //ctrl4 = 0x30;

  /* Write value to ACC MEMS CTRL_REG1 regsister */
  LSM303DLHC_Write(ACC_I2C_ADDRESS, LSM303DLHC_CTRL_REG1_A, &ctrl1);
 8000a14:	2032      	movs	r0, #50	; 0x32
 8000a16:	2120      	movs	r1, #32


//  ctrl4 |= (uint8_t) (LSM303DLHC_BlockUpdate_Continous | LSM303DLHC_BLE_LSB |
//		  	  	  	  LSM303DLHC_FULLSCALE_16G | LSM303DLHC_HR_ENABLE);

  ctrl4 |= (uint8_t) (LSM303DLHC_BlockUpdate_Continous | LSM303DLHC_BLE_LSB |
 8000a18:	f88d 3007 	strb.w	r3, [sp, #7]
  		  	  	  	  LSM303DLHC_FULLSCALE_16G | LSM303DLHC_HR_ENABLE);

  //ctrl4 = 0x30;

  /* Write value to ACC MEMS CTRL_REG1 regsister */
  LSM303DLHC_Write(ACC_I2C_ADDRESS, LSM303DLHC_CTRL_REG1_A, &ctrl1);
 8000a1c:	f7ff fef4 	bl	8000808 <LSM303DLHC_Write>

  /* Write value to ACC MEMS CTRL_REG2 regsister */
  LSM303DLHC_Write(ACC_I2C_ADDRESS, LSM303DLHC_CTRL_REG2_A, &ctrl2);
 8000a20:	f10d 0206 	add.w	r2, sp, #6
 8000a24:	2032      	movs	r0, #50	; 0x32
 8000a26:	2121      	movs	r1, #33	; 0x21
 8000a28:	f7ff feee 	bl	8000808 <LSM303DLHC_Write>

  /* Write value to ACC MEMS CTRL_REG4 regsister */
  LSM303DLHC_Write(ACC_I2C_ADDRESS, LSM303DLHC_CTRL_REG4_A, &ctrl4);
 8000a2c:	2032      	movs	r0, #50	; 0x32
 8000a2e:	2123      	movs	r1, #35	; 0x23
 8000a30:	f10d 0207 	add.w	r2, sp, #7
 8000a34:	f7ff fee8 	bl	8000808 <LSM303DLHC_Write>
}
 8000a38:	b003      	add	sp, #12
 8000a3a:	f85d fb04 	ldr.w	pc, [sp], #4

08000a3e <LSM303DLHC_ACC_readValues>:
	Acc_values->accGValue = Acc_values->accGValue*maxGOverflow;
}


void LSM303DLHC_ACC_readValues(struct accValues *accXYZ)
{
 8000a3e:	b513      	push	{r0, r1, r4, lr}
	uint8_t buffer[6], cDivider;

	LSM303DLHC_Read(ACC_I2C_ADDRESS, LSM303DLHC_OUT_X_L_A, buffer, 6);
 8000a40:	2306      	movs	r3, #6
	Acc_values->accGValue = Acc_values->accGValue*maxGOverflow;
}


void LSM303DLHC_ACC_readValues(struct accValues *accXYZ)
{
 8000a42:	4604      	mov	r4, r0
	uint8_t buffer[6], cDivider;

	LSM303DLHC_Read(ACC_I2C_ADDRESS, LSM303DLHC_OUT_X_L_A, buffer, 6);
 8000a44:	466a      	mov	r2, sp
 8000a46:	2032      	movs	r0, #50	; 0x32
 8000a48:	2128      	movs	r1, #40	; 0x28
 8000a4a:	f7ff ff25 	bl	8000898 <LSM303DLHC_Read>

	cDivider=16;

	/* check in the control register4 the data alignment */
	accXYZ->accValueX = ((int16_t)((uint16_t)buffer[1] << 8) + buffer[0])/cDivider;
 8000a4e:	f89d 3000 	ldrb.w	r3, [sp]
 8000a52:	f99d 2001 	ldrsb.w	r2, [sp, #1]
	accXYZ->accValueY = ((int16_t)((uint16_t)buffer[3] << 8) + buffer[2])/cDivider;
 8000a56:	f99d 1003 	ldrsb.w	r1, [sp, #3]
	LSM303DLHC_Read(ACC_I2C_ADDRESS, LSM303DLHC_OUT_X_L_A, buffer, 6);

	cDivider=16;

	/* check in the control register4 the data alignment */
	accXYZ->accValueX = ((int16_t)((uint16_t)buffer[1] << 8) + buffer[0])/cDivider;
 8000a5a:	eb03 2202 	add.w	r2, r3, r2, lsl #8
 8000a5e:	2310      	movs	r3, #16
 8000a60:	fb92 f2f3 	sdiv	r2, r2, r3
 8000a64:	8022      	strh	r2, [r4, #0]
	accXYZ->accValueY = ((int16_t)((uint16_t)buffer[3] << 8) + buffer[2])/cDivider;
 8000a66:	f89d 2002 	ldrb.w	r2, [sp, #2]
 8000a6a:	eb02 2201 	add.w	r2, r2, r1, lsl #8
 8000a6e:	fb92 f2f3 	sdiv	r2, r2, r3
 8000a72:	8062      	strh	r2, [r4, #2]
	accXYZ->accValueZ = ((int16_t)((uint16_t)buffer[5] << 8) + buffer[4])/cDivider;
 8000a74:	f99d 1005 	ldrsb.w	r1, [sp, #5]
 8000a78:	f89d 2004 	ldrb.w	r2, [sp, #4]
 8000a7c:	eb02 2201 	add.w	r2, r2, r1, lsl #8
 8000a80:	fb92 f3f3 	sdiv	r3, r2, r3
 8000a84:	80a3      	strh	r3, [r4, #4]
}
 8000a86:	b002      	add	sp, #8
 8000a88:	bd10      	pop	{r4, pc}

08000a8a <LSM303DLHC_ACC_calibrate>:
  LSM303DLHC_Write(ACC_I2C_ADDRESS, LSM303DLHC_CTRL_REG4_A, &ctrl4);
}


void LSM303DLHC_ACC_calibrate(float maxGOverflow, struct accValues *Acc_values)
{
 8000a8a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8000a8e:	ed2d 8b02 	vpush	{d8}
 8000a92:	4604      	mov	r4, r0
 8000a94:	eeb0 8a40 	vmov.f32	s16, s0
	u8 i;
	uint32_t tmpX = 0;
	uint32_t tmpY = 0;
	uint32_t tmpZ = 0;

	LSM303DLHC_AccInit();
 8000a98:	f7ff ffb2 	bl	8000a00 <LSM303DLHC_AccInit>
void LSM303DLHC_ACC_calibrate(float maxGOverflow, struct accValues *Acc_values)
{
	u8 i;
	uint32_t tmpX = 0;
	uint32_t tmpY = 0;
	uint32_t tmpZ = 0;
 8000a9c:	2500      	movs	r5, #0

	LSM303DLHC_AccInit();
 8000a9e:	f04f 080a 	mov.w	r8, #10

void LSM303DLHC_ACC_calibrate(float maxGOverflow, struct accValues *Acc_values)
{
	u8 i;
	uint32_t tmpX = 0;
	uint32_t tmpY = 0;
 8000aa2:	462e      	mov	r6, r5


void LSM303DLHC_ACC_calibrate(float maxGOverflow, struct accValues *Acc_values)
{
	u8 i;
	uint32_t tmpX = 0;
 8000aa4:	462f      	mov	r7, r5

	LSM303DLHC_AccInit();

	for(i=0;i<AVG_ROUNDS;i++)
	{
		LSM303DLHC_ACC_readValues(Acc_values);
 8000aa6:	4620      	mov	r0, r4
 8000aa8:	f7ff ffc9 	bl	8000a3e <LSM303DLHC_ACC_readValues>

		tmpX += (Acc_values->accValueX);
 8000aac:	f9b4 3000 	ldrsh.w	r3, [r4]
 8000ab0:	441f      	add	r7, r3
		tmpY += (Acc_values->accValueY);
 8000ab2:	f9b4 3002 	ldrsh.w	r3, [r4, #2]
 8000ab6:	441e      	add	r6, r3
		tmpZ += (Acc_values->accValueZ);
 8000ab8:	f9b4 3004 	ldrsh.w	r3, [r4, #4]

		Delay(INIT_DELAY_TIME/10);
 8000abc:	f643 2098 	movw	r0, #15000	; 0x3a98
 8000ac0:	f108 38ff 	add.w	r8, r8, #4294967295
	{
		LSM303DLHC_ACC_readValues(Acc_values);

		tmpX += (Acc_values->accValueX);
		tmpY += (Acc_values->accValueY);
		tmpZ += (Acc_values->accValueZ);
 8000ac4:	441d      	add	r5, r3

		Delay(INIT_DELAY_TIME/10);
 8000ac6:	f001 f98d 	bl	8001de4 <Delay>
	uint32_t tmpY = 0;
	uint32_t tmpZ = 0;

	LSM303DLHC_AccInit();

	for(i=0;i<AVG_ROUNDS;i++)
 8000aca:	f018 08ff 	ands.w	r8, r8, #255	; 0xff
 8000ace:	d1ea      	bne.n	8000aa6 <LSM303DLHC_ACC_calibrate+0x1c>
		tmpY += (Acc_values->accValueY);
		tmpZ += (Acc_values->accValueZ);

		Delay(INIT_DELAY_TIME/10);
	}
	Acc_values->accValueX = (tmpX/AVG_ROUNDS);
 8000ad0:	230a      	movs	r3, #10
	Acc_values->accValueY = (tmpY/AVG_ROUNDS);
 8000ad2:	fbb6 f6f3 	udiv	r6, r6, r3
		tmpY += (Acc_values->accValueY);
		tmpZ += (Acc_values->accValueZ);

		Delay(INIT_DELAY_TIME/10);
	}
	Acc_values->accValueX = (tmpX/AVG_ROUNDS);
 8000ad6:	fbb7 f7f3 	udiv	r7, r7, r3
	Acc_values->accValueY = (tmpY/AVG_ROUNDS);
 8000ada:	b2b6      	uxth	r6, r6
		tmpY += (Acc_values->accValueY);
		tmpZ += (Acc_values->accValueZ);

		Delay(INIT_DELAY_TIME/10);
	}
	Acc_values->accValueX = (tmpX/AVG_ROUNDS);
 8000adc:	b2bf      	uxth	r7, r7
	Acc_values->accValueY = (tmpY/AVG_ROUNDS);
 8000ade:	8066      	strh	r6, [r4, #2]
	Acc_values->accValueZ = (tmpZ/AVG_ROUNDS);
 8000ae0:	fbb5 f5f3 	udiv	r5, r5, r3

	Acc_values->accGValue = sqrtf((Acc_values->accValueX*Acc_values->accValueX) +
									(Acc_values->accValueY*Acc_values->accValueY) +
 8000ae4:	fb16 f606 	smulbb	r6, r6, r6
		tmpY += (Acc_values->accValueY);
		tmpZ += (Acc_values->accValueZ);

		Delay(INIT_DELAY_TIME/10);
	}
	Acc_values->accValueX = (tmpX/AVG_ROUNDS);
 8000ae8:	8027      	strh	r7, [r4, #0]
	Acc_values->accValueY = (tmpY/AVG_ROUNDS);
	Acc_values->accValueZ = (tmpZ/AVG_ROUNDS);
 8000aea:	b2ad      	uxth	r5, r5

	Acc_values->accGValue = sqrtf((Acc_values->accValueX*Acc_values->accValueX) +
 8000aec:	fb17 6707 	smlabb	r7, r7, r7, r6
									(Acc_values->accValueY*Acc_values->accValueY) +
 8000af0:	fb15 7705 	smlabb	r7, r5, r5, r7
 8000af4:	ee00 7a10 	vmov	s0, r7

		Delay(INIT_DELAY_TIME/10);
	}
	Acc_values->accValueX = (tmpX/AVG_ROUNDS);
	Acc_values->accValueY = (tmpY/AVG_ROUNDS);
	Acc_values->accValueZ = (tmpZ/AVG_ROUNDS);
 8000af8:	80a5      	strh	r5, [r4, #4]

	Acc_values->accGValue = sqrtf((Acc_values->accValueX*Acc_values->accValueX) +
 8000afa:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
 8000afe:	f007 fc19 	bl	8008334 <sqrtf>
									(Acc_values->accValueY*Acc_values->accValueY) +
									(Acc_values->accValueZ*Acc_values->accValueZ));

	/* Allow some kind of overflow */
	Acc_values->accGValue = Acc_values->accGValue*maxGOverflow;
 8000b02:	ee20 0a08 	vmul.f32	s0, s0, s16
}
 8000b06:	ecbd 8b02 	vpop	{d8}
	Acc_values->accGValue = sqrtf((Acc_values->accValueX*Acc_values->accValueX) +
									(Acc_values->accValueY*Acc_values->accValueY) +
									(Acc_values->accValueZ*Acc_values->accValueZ));

	/* Allow some kind of overflow */
	Acc_values->accGValue = Acc_values->accGValue*maxGOverflow;
 8000b0a:	ed84 0a02 	vstr	s0, [r4, #8]
}
 8000b0e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08000b12 <LSM303DLHC_ACC_readValuesDMA>:
	accXYZ->accValueY = ((int16_t)((uint16_t)buffer[3] << 8) + buffer[2])/cDivider;
	accXYZ->accValueZ = ((int16_t)((uint16_t)buffer[5] << 8) + buffer[4])/cDivider;
}

void LSM303DLHC_ACC_readValuesDMA(struct accValues *accXYZ, uint8_t *buffer)
{
 8000b12:	b538      	push	{r3, r4, r5, lr}
 8000b14:	460c      	mov	r4, r1
 8000b16:	4605      	mov	r5, r0
	uint8_t cDivider;

	/* Read the register content */
	LSM303DLHC_ReadDMA(ACC_I2C_ADDRESS, LSM303DLHC_OUT_X_L_A, buffer, 6);
 8000b18:	2128      	movs	r1, #40	; 0x28
 8000b1a:	4622      	mov	r2, r4
 8000b1c:	2306      	movs	r3, #6
 8000b1e:	2032      	movs	r0, #50	; 0x32
 8000b20:	f7ff ff0c 	bl	800093c <LSM303DLHC_ReadDMA>

	cDivider=16;

	// TODO Faster conversation
	// gyro->gyroValueX = (Buffer[1] << 8) | (Buffer[0]);
	accXYZ->accValueX = ((int16_t)((uint16_t)buffer[1] << 8) + buffer[0])/cDivider;
 8000b24:	7823      	ldrb	r3, [r4, #0]
 8000b26:	f994 2001 	ldrsb.w	r2, [r4, #1]
 8000b2a:	eb03 2202 	add.w	r2, r3, r2, lsl #8
 8000b2e:	2310      	movs	r3, #16
 8000b30:	fb92 f2f3 	sdiv	r2, r2, r3
 8000b34:	802a      	strh	r2, [r5, #0]
	accXYZ->accValueY = ((int16_t)((uint16_t)buffer[3] << 8) + buffer[2])/cDivider;
 8000b36:	f994 1003 	ldrsb.w	r1, [r4, #3]
 8000b3a:	78a2      	ldrb	r2, [r4, #2]
 8000b3c:	eb02 2201 	add.w	r2, r2, r1, lsl #8
 8000b40:	fb92 f2f3 	sdiv	r2, r2, r3
 8000b44:	806a      	strh	r2, [r5, #2]
	accXYZ->accValueZ = ((int16_t)((uint16_t)buffer[5] << 8) + buffer[4])/cDivider;
 8000b46:	f994 1005 	ldrsb.w	r1, [r4, #5]
 8000b4a:	7922      	ldrb	r2, [r4, #4]
 8000b4c:	eb02 2201 	add.w	r2, r2, r1, lsl #8
 8000b50:	fb92 f3f3 	sdiv	r3, r2, r3
 8000b54:	80ab      	strh	r3, [r5, #4]
 8000b56:	bd38      	pop	{r3, r4, r5, pc}

08000b58 <Mag_calibrate>:
//}

#endif

void Mag_calibrate(void)
{
 8000b58:	b507      	push	{r0, r1, r2, lr}
	uint8_t cra_regm = 0x00, crb_regm = 0x00, mr_regm = 0x00;

	/* Configure MEMS: temp and Data rate */
	cra_regm |= (uint8_t) (LSM303DLHC_TEMPSENSOR_DISABLE | LSM303DLHC_ODR_30_HZ);
 8000b5a:	2314      	movs	r3, #20

#endif

void Mag_calibrate(void)
{
	uint8_t cra_regm = 0x00, crb_regm = 0x00, mr_regm = 0x00;
 8000b5c:	2100      	movs	r1, #0

	/* Configure MEMS: temp and Data rate */
	cra_regm |= (uint8_t) (LSM303DLHC_TEMPSENSOR_DISABLE | LSM303DLHC_ODR_30_HZ);
 8000b5e:	f88d 3005 	strb.w	r3, [sp, #5]

	/* Configure MEMS: working mode */
	mr_regm |= (uint8_t) (LSM303DLHC_CONTINUOS_CONVERSION);

	/* Write value to Mag MEMS CRA_REG regsister */
	LSM303DLHC_Write(MAG_I2C_ADDRESS, LSM303DLHC_CRA_REG_M, &cra_regm);
 8000b62:	f10d 0205 	add.w	r2, sp, #5

	/* Configure MEMS: temp and Data rate */
	cra_regm |= (uint8_t) (LSM303DLHC_TEMPSENSOR_DISABLE | LSM303DLHC_ODR_30_HZ);

	/* Configure MEMS: full Scale */
	crb_regm |= (uint8_t) (LSM303DLHC_FS_8_1_GA);
 8000b66:	23e0      	movs	r3, #224	; 0xe0

	/* Configure MEMS: working mode */
	mr_regm |= (uint8_t) (LSM303DLHC_CONTINUOS_CONVERSION);

	/* Write value to Mag MEMS CRA_REG regsister */
	LSM303DLHC_Write(MAG_I2C_ADDRESS, LSM303DLHC_CRA_REG_M, &cra_regm);
 8000b68:	203c      	movs	r0, #60	; 0x3c

	/* Configure MEMS: temp and Data rate */
	cra_regm |= (uint8_t) (LSM303DLHC_TEMPSENSOR_DISABLE | LSM303DLHC_ODR_30_HZ);

	/* Configure MEMS: full Scale */
	crb_regm |= (uint8_t) (LSM303DLHC_FS_8_1_GA);
 8000b6a:	f88d 3006 	strb.w	r3, [sp, #6]

#endif

void Mag_calibrate(void)
{
	uint8_t cra_regm = 0x00, crb_regm = 0x00, mr_regm = 0x00;
 8000b6e:	f88d 1007 	strb.w	r1, [sp, #7]

	/* Configure MEMS: working mode */
	mr_regm |= (uint8_t) (LSM303DLHC_CONTINUOS_CONVERSION);

	/* Write value to Mag MEMS CRA_REG regsister */
	LSM303DLHC_Write(MAG_I2C_ADDRESS, LSM303DLHC_CRA_REG_M, &cra_regm);
 8000b72:	f7ff fe49 	bl	8000808 <LSM303DLHC_Write>

	/* Write value to Mag MEMS CRB_REG regsister */
	LSM303DLHC_Write(MAG_I2C_ADDRESS, LSM303DLHC_CRB_REG_M, &crb_regm);
 8000b76:	f10d 0206 	add.w	r2, sp, #6
 8000b7a:	203c      	movs	r0, #60	; 0x3c
 8000b7c:	2101      	movs	r1, #1
 8000b7e:	f7ff fe43 	bl	8000808 <LSM303DLHC_Write>

	/* Write value to Mag MEMS MR_REG regsister */
	LSM303DLHC_Write(MAG_I2C_ADDRESS, LSM303DLHC_MR_REG_M, &mr_regm);
 8000b82:	203c      	movs	r0, #60	; 0x3c
 8000b84:	2102      	movs	r1, #2
 8000b86:	f10d 0207 	add.w	r2, sp, #7
 8000b8a:	f7ff fe3d 	bl	8000808 <LSM303DLHC_Write>
}
 8000b8e:	b003      	add	sp, #12
 8000b90:	f85d fb04 	ldr.w	pc, [sp], #4

08000b94 <Mag_readValues>:


void Mag_readValues (struct magValues *magXYZ)
{
 8000b94:	b537      	push	{r0, r1, r2, r4, r5, lr}
  static uint8_t buffer[6] = {0};
  uint8_t CTRLB = 0;
 8000b96:	aa02      	add	r2, sp, #8
  uint16_t Magn_Sensitivity_XY = 0, Magn_Sensitivity_Z = 0;
  LSM303DLHC_Read(MAG_I2C_ADDRESS, LSM303DLHC_CRB_REG_M, &CTRLB, 1);
 8000b98:	2101      	movs	r1, #1


void Mag_readValues (struct magValues *magXYZ)
{
  static uint8_t buffer[6] = {0};
  uint8_t CTRLB = 0;
 8000b9a:	2300      	movs	r3, #0
 8000b9c:	f802 3d01 	strb.w	r3, [r2, #-1]!
	LSM303DLHC_Write(MAG_I2C_ADDRESS, LSM303DLHC_MR_REG_M, &mr_regm);
}


void Mag_readValues (struct magValues *magXYZ)
{
 8000ba0:	4604      	mov	r4, r0
  static uint8_t buffer[6] = {0};
  uint8_t CTRLB = 0;
  uint16_t Magn_Sensitivity_XY = 0, Magn_Sensitivity_Z = 0;
  LSM303DLHC_Read(MAG_I2C_ADDRESS, LSM303DLHC_CRB_REG_M, &CTRLB, 1);
 8000ba2:	460b      	mov	r3, r1
 8000ba4:	203c      	movs	r0, #60	; 0x3c
 8000ba6:	f7ff fe77 	bl	8000898 <LSM303DLHC_Read>

  LSM303DLHC_Read(MAG_I2C_ADDRESS, LSM303DLHC_OUT_X_H_M, buffer, 6);
 8000baa:	2306      	movs	r3, #6
 8000bac:	203c      	movs	r0, #60	; 0x3c
 8000bae:	2103      	movs	r1, #3
 8000bb0:	4a3e      	ldr	r2, [pc, #248]	; (8000cac <Mag_readValues+0x118>)
 8000bb2:	f7ff fe71 	bl	8000898 <LSM303DLHC_Read>
//  LSM303DLHC_Read(MAG_I2C_ADDRESS, LSM303DLHC_OUT_Y_H_M, buffer+2, 1);
//  LSM303DLHC_Read(MAG_I2C_ADDRESS, LSM303DLHC_OUT_Y_L_M, buffer+3, 1);
//  LSM303DLHC_Read(MAG_I2C_ADDRESS, LSM303DLHC_OUT_Z_H_M, buffer+4, 1);
//  LSM303DLHC_Read(MAG_I2C_ADDRESS, LSM303DLHC_OUT_Z_L_M, buffer+5, 1);
  /* Switch the sensitivity set in the CRTLB*/
  switch(CTRLB & 0xE0)
 8000bb6:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8000bba:	f003 03e0 	and.w	r3, r3, #224	; 0xe0
 8000bbe:	2b80      	cmp	r3, #128	; 0x80
 8000bc0:	d01a      	beq.n	8000bf8 <Mag_readValues+0x64>
 8000bc2:	d806      	bhi.n	8000bd2 <Mag_readValues+0x3e>
 8000bc4:	2b40      	cmp	r3, #64	; 0x40
 8000bc6:	d00d      	beq.n	8000be4 <Mag_readValues+0x50>
 8000bc8:	2b60      	cmp	r3, #96	; 0x60
 8000bca:	d010      	beq.n	8000bee <Mag_readValues+0x5a>
 8000bcc:	2b20      	cmp	r3, #32
 8000bce:	d106      	bne.n	8000bde <Mag_readValues+0x4a>
 8000bd0:	e024      	b.n	8000c1c <Mag_readValues+0x88>
 8000bd2:	2bc0      	cmp	r3, #192	; 0xc0
 8000bd4:	d01a      	beq.n	8000c0c <Mag_readValues+0x78>
 8000bd6:	2be0      	cmp	r3, #224	; 0xe0
 8000bd8:	d01d      	beq.n	8000c16 <Mag_readValues+0x82>
 8000bda:	2ba0      	cmp	r3, #160	; 0xa0
 8000bdc:	d011      	beq.n	8000c02 <Mag_readValues+0x6e>

void Mag_readValues (struct magValues *magXYZ)
{
  static uint8_t buffer[6] = {0};
  uint8_t CTRLB = 0;
  uint16_t Magn_Sensitivity_XY = 0, Magn_Sensitivity_Z = 0;
 8000bde:	2300      	movs	r3, #0
 8000be0:	461a      	mov	r2, r3
 8000be2:	e01f      	b.n	8000c24 <Mag_readValues+0x90>
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_1_3Ga;
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_1_3Ga;
    break;
  case LSM303DLHC_FS_1_9_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_1_9Ga;
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_1_9Ga;
 8000be4:	f44f 733e 	mov.w	r3, #760	; 0x2f8
  case LSM303DLHC_FS_1_3_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_1_3Ga;
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_1_3Ga;
    break;
  case LSM303DLHC_FS_1_9_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_1_9Ga;
 8000be8:	f240 3257 	movw	r2, #855	; 0x357
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_1_9Ga;
    break;
 8000bec:	e01a      	b.n	8000c24 <Mag_readValues+0x90>
  case LSM303DLHC_FS_2_5_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_2_5Ga;
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_2_5Ga;
 8000bee:	f44f 7316 	mov.w	r3, #600	; 0x258
  case LSM303DLHC_FS_1_9_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_1_9Ga;
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_1_9Ga;
    break;
  case LSM303DLHC_FS_2_5_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_2_5Ga;
 8000bf2:	f240 229e 	movw	r2, #670	; 0x29e
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_2_5Ga;
    break;
 8000bf6:	e015      	b.n	8000c24 <Mag_readValues+0x90>
  case LSM303DLHC_FS_4_0_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_4Ga;
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_4Ga;
 8000bf8:	f44f 73c8 	mov.w	r3, #400	; 0x190
  case LSM303DLHC_FS_2_5_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_2_5Ga;
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_2_5Ga;
    break;
  case LSM303DLHC_FS_4_0_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_4Ga;
 8000bfc:	f44f 72e1 	mov.w	r2, #450	; 0x1c2
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_4Ga;
    break;
 8000c00:	e010      	b.n	8000c24 <Mag_readValues+0x90>
  case LSM303DLHC_FS_4_7_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_4_7Ga;
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_4_7Ga;
 8000c02:	f240 1363 	movw	r3, #355	; 0x163
  case LSM303DLHC_FS_4_0_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_4Ga;
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_4Ga;
    break;
  case LSM303DLHC_FS_4_7_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_4_7Ga;
 8000c06:	f44f 72c8 	mov.w	r2, #400	; 0x190
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_4_7Ga;
    break;
 8000c0a:	e00b      	b.n	8000c24 <Mag_readValues+0x90>
  case LSM303DLHC_FS_5_6_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_5_6Ga;
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_5_6Ga;
 8000c0c:	f240 1327 	movw	r3, #295	; 0x127
  case LSM303DLHC_FS_4_7_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_4_7Ga;
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_4_7Ga;
    break;
  case LSM303DLHC_FS_5_6_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_5_6Ga;
 8000c10:	f44f 72a5 	mov.w	r2, #330	; 0x14a
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_5_6Ga;
    break;
 8000c14:	e006      	b.n	8000c24 <Mag_readValues+0x90>
  case LSM303DLHC_FS_8_1_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_8_1Ga;
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_8_1Ga;
 8000c16:	23cd      	movs	r3, #205	; 0xcd
  case LSM303DLHC_FS_5_6_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_5_6Ga;
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_5_6Ga;
    break;
  case LSM303DLHC_FS_8_1_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_8_1Ga;
 8000c18:	22e6      	movs	r2, #230	; 0xe6
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_8_1Ga;
    break;
 8000c1a:	e003      	b.n	8000c24 <Mag_readValues+0x90>
  /* Switch the sensitivity set in the CRTLB*/
  switch(CTRLB & 0xE0)
  {
  case LSM303DLHC_FS_1_3_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_1_3Ga;
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_1_3Ga;
 8000c1c:	f44f 7375 	mov.w	r3, #980	; 0x3d4
//  LSM303DLHC_Read(MAG_I2C_ADDRESS, LSM303DLHC_OUT_Z_L_M, buffer+5, 1);
  /* Switch the sensitivity set in the CRTLB*/
  switch(CTRLB & 0xE0)
  {
  case LSM303DLHC_FS_1_3_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_1_3Ga;
 8000c20:	f240 424c 	movw	r2, #1100	; 0x44c
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_8_1Ga;
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_8_1Ga;
    break;
  }

  magXYZ->magValueX = (float)((int16_t)(((uint16_t)buffer[0] << 8) + buffer[1])*1000)/Magn_Sensitivity_XY;
 8000c24:	4921      	ldr	r1, [pc, #132]	; (8000cac <Mag_readValues+0x118>)
 8000c26:	780d      	ldrb	r5, [r1, #0]
 8000c28:	7848      	ldrb	r0, [r1, #1]
 8000c2a:	eb00 2005 	add.w	r0, r0, r5, lsl #8
 8000c2e:	ee06 2a90 	vmov	s13, r2
 8000c32:	b280      	uxth	r0, r0
 8000c34:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8000c38:	fb10 f002 	smulbb	r0, r0, r2
 8000c3c:	ee07 0a10 	vmov	s14, r0
 8000c40:	eef8 7ae6 	vcvt.f32.s32	s15, s13
 8000c44:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8000c48:	ee87 7a27 	vdiv.f32	s14, s14, s15
 8000c4c:	eebd 7ac7 	vcvt.s32.f32	s14, s14
 8000c50:	ee17 0a10 	vmov	r0, s14
 8000c54:	8020      	strh	r0, [r4, #0]
  magXYZ->magValueZ = (float)((int16_t)(((uint16_t)buffer[2] << 8) + buffer[3])*1000)/Magn_Sensitivity_XY;
 8000c56:	788d      	ldrb	r5, [r1, #2]
 8000c58:	78c8      	ldrb	r0, [r1, #3]
 8000c5a:	eb00 2005 	add.w	r0, r0, r5, lsl #8
 8000c5e:	b280      	uxth	r0, r0
 8000c60:	fb10 f002 	smulbb	r0, r0, r2
 8000c64:	ee06 0a90 	vmov	s13, r0
 8000c68:	eeb8 7ae6 	vcvt.f32.s32	s14, s13
  magXYZ->magValueY = (float)((int16_t)(((uint16_t)buffer[4] << 8) + buffer[5])*1000)/Magn_Sensitivity_Z;
 8000c6c:	ee06 3a90 	vmov	s13, r3
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_8_1Ga;
    break;
  }

  magXYZ->magValueX = (float)((int16_t)(((uint16_t)buffer[0] << 8) + buffer[1])*1000)/Magn_Sensitivity_XY;
  magXYZ->magValueZ = (float)((int16_t)(((uint16_t)buffer[2] << 8) + buffer[3])*1000)/Magn_Sensitivity_XY;
 8000c70:	eec7 7a27 	vdiv.f32	s15, s14, s15
  magXYZ->magValueY = (float)((int16_t)(((uint16_t)buffer[4] << 8) + buffer[5])*1000)/Magn_Sensitivity_Z;
 8000c74:	eeb8 7ae6 	vcvt.f32.s32	s14, s13
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_8_1Ga;
    break;
  }

  magXYZ->magValueX = (float)((int16_t)(((uint16_t)buffer[0] << 8) + buffer[1])*1000)/Magn_Sensitivity_XY;
  magXYZ->magValueZ = (float)((int16_t)(((uint16_t)buffer[2] << 8) + buffer[3])*1000)/Magn_Sensitivity_XY;
 8000c78:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8000c7c:	ee17 0a90 	vmov	r0, s15
 8000c80:	80a0      	strh	r0, [r4, #4]
  magXYZ->magValueY = (float)((int16_t)(((uint16_t)buffer[4] << 8) + buffer[5])*1000)/Magn_Sensitivity_Z;
 8000c82:	7908      	ldrb	r0, [r1, #4]
 8000c84:	7949      	ldrb	r1, [r1, #5]
 8000c86:	eb01 2100 	add.w	r1, r1, r0, lsl #8
 8000c8a:	b289      	uxth	r1, r1
 8000c8c:	fb11 f202 	smulbb	r2, r1, r2
 8000c90:	ee07 2a90 	vmov	s15, r2
 8000c94:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8000c98:	eec7 7a87 	vdiv.f32	s15, s15, s14
 8000c9c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8000ca0:	ee17 3a90 	vmov	r3, s15
 8000ca4:	8063      	strh	r3, [r4, #2]
}
 8000ca6:	b003      	add	sp, #12
 8000ca8:	bd30      	pop	{r4, r5, pc}
 8000caa:	bf00      	nop
 8000cac:	2000047c 	.word	0x2000047c

08000cb0 <PWM_Motor>:



void PWM_Motor(uint8_t Motor, uint16_t value)
{
	switch (Motor)
 8000cb0:	2805      	cmp	r0, #5
 8000cb2:	d816      	bhi.n	8000ce2 <PWM_Motor+0x32>
 8000cb4:	e8df f000 	tbb	[pc, r0]
 8000cb8:	0a070503 	.word	0x0a070503
 8000cbc:	110d      	.short	0x110d
	{
	case 0:
		TIM_SetCompare1(TIM3, value);
 8000cbe:	4809      	ldr	r0, [pc, #36]	; (8000ce4 <PWM_Motor+0x34>)
 8000cc0:	e009      	b.n	8000cd6 <PWM_Motor+0x26>
		break;
	case 1:
		TIM_SetCompare2(TIM3, value);
 8000cc2:	4808      	ldr	r0, [pc, #32]	; (8000ce4 <PWM_Motor+0x34>)
 8000cc4:	e00b      	b.n	8000cde <PWM_Motor+0x2e>
		break;
	case 2:
		TIM_SetCompare3(TIM3, value);
 8000cc6:	4807      	ldr	r0, [pc, #28]	; (8000ce4 <PWM_Motor+0x34>)
 8000cc8:	f004 b84f 	b.w	8004d6a <TIM_SetCompare3>
		break;
	case 3:
		TIM_SetCompare4(TIM3, value);
 8000ccc:	4805      	ldr	r0, [pc, #20]	; (8000ce4 <PWM_Motor+0x34>)
 8000cce:	f004 b84e 	b.w	8004d6e <TIM_SetCompare4>
		break;
	case 4:
		TIM_SetCompare1(TIM2, value);
 8000cd2:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8000cd6:	f004 b844 	b.w	8004d62 <TIM_SetCompare1>
		break;
	case 5:
		TIM_SetCompare2(TIM2, value);
 8000cda:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8000cde:	f004 b842 	b.w	8004d66 <TIM_SetCompare2>
 8000ce2:	4770      	bx	lr
 8000ce4:	40000400 	.word	0x40000400

08000ce8 <Enable_Motor>:
		break;
	}
}

void Enable_Motor(){
 8000ce8:	b510      	push	{r4, lr}
	//GPIO_WriteBit(GPIOB, GPIO_Pin_0 | GPIO_Pin_1 , Bit_SET);
	GPIO_WriteBit(GPIOB, GPIO_Pin_0 , Bit_RESET);
 8000cea:	4c06      	ldr	r4, [pc, #24]	; (8000d04 <Enable_Motor+0x1c>)
 8000cec:	2101      	movs	r1, #1
 8000cee:	4620      	mov	r0, r4
 8000cf0:	2200      	movs	r2, #0
 8000cf2:	f002 fe5d 	bl	80039b0 <GPIO_WriteBit>
	GPIO_WriteBit(GPIOB, GPIO_Pin_1 , Bit_RESET);
 8000cf6:	4620      	mov	r0, r4
 8000cf8:	2102      	movs	r1, #2
 8000cfa:	2200      	movs	r2, #0
}
 8000cfc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
}

void Enable_Motor(){
	//GPIO_WriteBit(GPIOB, GPIO_Pin_0 | GPIO_Pin_1 , Bit_SET);
	GPIO_WriteBit(GPIOB, GPIO_Pin_0 , Bit_RESET);
	GPIO_WriteBit(GPIOB, GPIO_Pin_1 , Bit_RESET);
 8000d00:	f002 be56 	b.w	80039b0 <GPIO_WriteBit>
 8000d04:	48000400 	.word	0x48000400

08000d08 <Disable_Motor>:
}

void Disable_Motor(){
	//GPIO_WriteBit(GPIOB, GPIO_Pin_0 | GPIO_Pin_1 , Bit_RESET);
	GPIO_WriteBit(GPIOB, GPIO_Pin_0 | GPIO_Pin_1 , Bit_SET);
 8000d08:	4802      	ldr	r0, [pc, #8]	; (8000d14 <Disable_Motor+0xc>)
 8000d0a:	2103      	movs	r1, #3
 8000d0c:	2201      	movs	r2, #1
 8000d0e:	f002 be4f 	b.w	80039b0 <GPIO_WriteBit>
 8000d12:	bf00      	nop
 8000d14:	48000400 	.word	0x48000400

08000d18 <init_PID>:
//float CalcDelay(SmitPredictor_Control *value, float Input);


void init_PID(float sample_rate, float kp, float ki, float kd, float kn, PID_Control *values)
{
	values->sampling_rate = sample_rate;
 8000d18:	ed80 0a00 	vstr	s0, [r0]
	values->kp = kp;
 8000d1c:	edc0 0a02 	vstr	s1, [r0, #8]
	values->ki = ki;
 8000d20:	ed80 1a03 	vstr	s2, [r0, #12]
	values->kd = kd;
 8000d24:	edc0 1a04 	vstr	s3, [r0, #16]
	values->kn = kn;
 8000d28:	ed80 2a05 	vstr	s4, [r0, #20]
 8000d2c:	4770      	bx	lr

08000d2e <init_SmithPredictor>:
}

void init_SmithPredictor(float a1, float a2, float b1, float b2, float b3, float gain, SmitPredictor_Control *values)
{
	values->a1 = a1;
 8000d2e:	ed80 0a0b 	vstr	s0, [r0, #44]	; 0x2c
	values->a2 = a2;
 8000d32:	edc0 0a0c 	vstr	s1, [r0, #48]	; 0x30
	values->b1 = b1;
 8000d36:	ed80 1a0d 	vstr	s2, [r0, #52]	; 0x34
	values->b2 = b2;
 8000d3a:	edc0 1a0e 	vstr	s3, [r0, #56]	; 0x38
	values->b3 = b3;
 8000d3e:	ed80 2a0f 	vstr	s4, [r0, #60]	; 0x3c
	values->gain = gain;
 8000d42:	edc0 2a10 	vstr	s5, [r0, #64]	; 0x40
 8000d46:	4770      	bx	lr

08000d48 <resetIntegralValues_PID>:
}

void resetIntegralValues_PID(PID_Control *values)
{
	values->ealt = 0;
 8000d48:	2300      	movs	r3, #0
 8000d4a:	6243      	str	r3, [r0, #36]	; 0x24
	values->Isum = 0;
 8000d4c:	61c3      	str	r3, [r0, #28]
	values->Dsum = 0;
 8000d4e:	6203      	str	r3, [r0, #32]
	values->y = 0;
 8000d50:	6043      	str	r3, [r0, #4]
 8000d52:	4770      	bx	lr

08000d54 <calc_PID>:
	float P ,I ,D;

#define Isum_max 50.0f

	/* */
	PID_Values->e = sollwert - istwert;
 8000d54:	ee70 0ac0 	vsub.f32	s1, s1, s0
	/* Nichtlinearität hinzufügen (x^3) */
	//PID_Values->e = PID_Values->e * PID_Values->e * PID_Values->e;


	// I-Anteil aufsummieren:
	PID_Values->Isum += (PID_Values->e*PID_Values->ki) * PID_Values->sampling_rate;
 8000d58:	ed90 7a03 	vldr	s14, [r0, #12]
 8000d5c:	edd0 7a07 	vldr	s15, [r0, #28]
 8000d60:	ed90 6a00 	vldr	s12, [r0]
	if (PID_Values->Isum < -Isum_max) PID_Values->Isum = -Isum_max;

	P = (PID_Values->kp * PID_Values->e);
	//I = (PID_Values->Isum * PID_Values->ki);
	I = PID_Values->Isum;
	D = (PID_Values->kd * PID_Values->e - PID_Values->Dsum ) * PID_Values->kn;
 8000d64:	edd0 6a08 	vldr	s13, [r0, #32]

	// Anti-Windup
	if (PID_Values->Isum > Isum_max) PID_Values->Isum = Isum_max;
	if (PID_Values->Isum < -Isum_max) PID_Values->Isum = -Isum_max;

	P = (PID_Values->kp * PID_Values->e);
 8000d68:	edd0 5a02 	vldr	s11, [r0, #8]
	float P ,I ,D;

#define Isum_max 50.0f

	/* */
	PID_Values->e = sollwert - istwert;
 8000d6c:	edc0 0a06 	vstr	s1, [r0, #24]
	/* Nichtlinearität hinzufügen (x^3) */
	//PID_Values->e = PID_Values->e * PID_Values->e * PID_Values->e;


	// I-Anteil aufsummieren:
	PID_Values->Isum += (PID_Values->e*PID_Values->ki) * PID_Values->sampling_rate;
 8000d70:	ee20 7a87 	vmul.f32	s14, s1, s14
	if (PID_Values->Isum < -Isum_max) PID_Values->Isum = -Isum_max;

	P = (PID_Values->kp * PID_Values->e);
	//I = (PID_Values->Isum * PID_Values->ki);
	I = PID_Values->Isum;
	D = (PID_Values->kd * PID_Values->e - PID_Values->Dsum ) * PID_Values->kn;
 8000d74:	eeb0 5a66 	vmov.f32	s10, s13
	/* Nichtlinearität hinzufügen (x^3) */
	//PID_Values->e = PID_Values->e * PID_Values->e * PID_Values->e;


	// I-Anteil aufsummieren:
	PID_Values->Isum += (PID_Values->e*PID_Values->ki) * PID_Values->sampling_rate;
 8000d78:	eee7 7a06 	vfma.f32	s15, s14, s12

	// Anti-Windup
	if (PID_Values->Isum > Isum_max) PID_Values->Isum = Isum_max;
 8000d7c:	ed9f 7a14 	vldr	s14, [pc, #80]	; 8000dd0 <calc_PID+0x7c>
 8000d80:	eef4 7ac7 	vcmpe.f32	s15, s14
 8000d84:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
	/* Nichtlinearität hinzufügen (x^3) */
	//PID_Values->e = PID_Values->e * PID_Values->e * PID_Values->e;


	// I-Anteil aufsummieren:
	PID_Values->Isum += (PID_Values->e*PID_Values->ki) * PID_Values->sampling_rate;
 8000d88:	bfc8      	it	gt
 8000d8a:	eef0 7a47 	vmovgt.f32	s15, s14

	// Anti-Windup
	if (PID_Values->Isum > Isum_max) PID_Values->Isum = Isum_max;
	if (PID_Values->Isum < -Isum_max) PID_Values->Isum = -Isum_max;
 8000d8e:	ed9f 7a11 	vldr	s14, [pc, #68]	; 8000dd4 <calc_PID+0x80>
	/* Nichtlinearität hinzufügen (x^3) */
	//PID_Values->e = PID_Values->e * PID_Values->e * PID_Values->e;


	// I-Anteil aufsummieren:
	PID_Values->Isum += (PID_Values->e*PID_Values->ki) * PID_Values->sampling_rate;
 8000d92:	edc0 7a07 	vstr	s15, [r0, #28]

	// Anti-Windup
	if (PID_Values->Isum > Isum_max) PID_Values->Isum = Isum_max;
	if (PID_Values->Isum < -Isum_max) PID_Values->Isum = -Isum_max;
 8000d96:	eef4 7ac7 	vcmpe.f32	s15, s14
 8000d9a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8000d9e:	bf48      	it	mi
 8000da0:	ed80 7a07 	vstrmi	s14, [r0, #28]

	P = (PID_Values->kp * PID_Values->e);
	//I = (PID_Values->Isum * PID_Values->ki);
	I = PID_Values->Isum;
	D = (PID_Values->kd * PID_Values->e - PID_Values->Dsum ) * PID_Values->kn;
 8000da4:	ed90 7a04 	vldr	s14, [r0, #16]
	if (PID_Values->Isum > Isum_max) PID_Values->Isum = Isum_max;
	if (PID_Values->Isum < -Isum_max) PID_Values->Isum = -Isum_max;

	P = (PID_Values->kp * PID_Values->e);
	//I = (PID_Values->Isum * PID_Values->ki);
	I = PID_Values->Isum;
 8000da8:	edd0 7a07 	vldr	s15, [r0, #28]
	D = (PID_Values->kd * PID_Values->e - PID_Values->Dsum ) * PID_Values->kn;
 8000dac:	ee97 5a20 	vfnms.f32	s10, s14, s1
 8000db0:	ed90 7a05 	vldr	s14, [r0, #20]
	PID_Values->Dsum += D * PID_Values->sampling_rate;

	// PID-Regler
	PID_Values->y = P + I + D;
 8000db4:	eee5 7aa0 	vfma.f32	s15, s11, s1
	if (PID_Values->Isum < -Isum_max) PID_Values->Isum = -Isum_max;

	P = (PID_Values->kp * PID_Values->e);
	//I = (PID_Values->Isum * PID_Values->ki);
	I = PID_Values->Isum;
	D = (PID_Values->kd * PID_Values->e - PID_Values->Dsum ) * PID_Values->kn;
 8000db8:	ee25 7a07 	vmul.f32	s14, s10, s14
	PID_Values->Dsum += D * PID_Values->sampling_rate;
 8000dbc:	eee7 6a06 	vfma.f32	s13, s14, s12

	// PID-Regler
	PID_Values->y = P + I + D;
 8000dc0:	ee77 7a87 	vadd.f32	s15, s15, s14

	P = (PID_Values->kp * PID_Values->e);
	//I = (PID_Values->Isum * PID_Values->ki);
	I = PID_Values->Isum;
	D = (PID_Values->kd * PID_Values->e - PID_Values->Dsum ) * PID_Values->kn;
	PID_Values->Dsum += D * PID_Values->sampling_rate;
 8000dc4:	edc0 6a08 	vstr	s13, [r0, #32]

	// PID-Regler
	PID_Values->y = P + I + D;
 8000dc8:	edc0 7a01 	vstr	s15, [r0, #4]
 8000dcc:	4770      	bx	lr
 8000dce:	bf00      	nop
 8000dd0:	42480000 	.word	0x42480000
 8000dd4:	c2480000 	.word	0xc2480000

08000dd8 <CalcVirtualPlant>:
/* Simulate Virtual Plant */
/* checked */
float CalcVirtualPlant(SmitPredictor_Control *value, float Input){

	/* Calculate first Section */
	value->vPlantyT1y[0] = value->b1 * value->vPlantyT1y[1] + value->a1 * value->vPlantyT1x[1];
 8000dd8:	ed90 7a0b 	vldr	s14, [r0, #44]	; 0x2c
 8000ddc:	edd0 7a04 	vldr	s15, [r0, #16]
 8000de0:	edd0 6a0d 	vldr	s13, [r0, #52]	; 0x34
	value->vPlantyT1x[1] = Input;
 8000de4:	ed80 0a04 	vstr	s0, [r0, #16]
/* Simulate Virtual Plant */
/* checked */
float CalcVirtualPlant(SmitPredictor_Control *value, float Input){

	/* Calculate first Section */
	value->vPlantyT1y[0] = value->b1 * value->vPlantyT1y[1] + value->a1 * value->vPlantyT1x[1];
 8000de8:	ee67 7a27 	vmul.f32	s15, s14, s15
 8000dec:	ed90 7a06 	vldr	s14, [r0, #24]
	value->vPlantyT1x[1] = Input;
	value->vPlantyT1y[1] = value->vPlantyT1y[0];

	/* Calculate second Section */
	value->vPlantyT2y[0] = value->vPlantyT2y[1] + value->a2 * value->vPlantyT2x[1];
 8000df0:	ed90 0a0a 	vldr	s0, [r0, #40]	; 0x28
/* Simulate Virtual Plant */
/* checked */
float CalcVirtualPlant(SmitPredictor_Control *value, float Input){

	/* Calculate first Section */
	value->vPlantyT1y[0] = value->b1 * value->vPlantyT1y[1] + value->a1 * value->vPlantyT1x[1];
 8000df4:	eee6 7a87 	vfma.f32	s15, s13, s14
	value->vPlantyT1x[1] = Input;
	value->vPlantyT1y[1] = value->vPlantyT1y[0];

	/* Calculate second Section */
	value->vPlantyT2y[0] = value->vPlantyT2y[1] + value->a2 * value->vPlantyT2x[1];
 8000df8:	ed90 7a08 	vldr	s14, [r0, #32]
 8000dfc:	edd0 6a0c 	vldr	s13, [r0, #48]	; 0x30
/* Simulate Virtual Plant */
/* checked */
float CalcVirtualPlant(SmitPredictor_Control *value, float Input){

	/* Calculate first Section */
	value->vPlantyT1y[0] = value->b1 * value->vPlantyT1y[1] + value->a1 * value->vPlantyT1x[1];
 8000e00:	edc0 7a05 	vstr	s15, [r0, #20]
	value->vPlantyT1x[1] = Input;
	value->vPlantyT1y[1] = value->vPlantyT1y[0];

	/* Calculate second Section */
	value->vPlantyT2y[0] = value->vPlantyT2y[1] + value->a2 * value->vPlantyT2x[1];
 8000e04:	eea6 0a87 	vfma.f32	s0, s13, s14
float CalcVirtualPlant(SmitPredictor_Control *value, float Input){

	/* Calculate first Section */
	value->vPlantyT1y[0] = value->b1 * value->vPlantyT1y[1] + value->a1 * value->vPlantyT1x[1];
	value->vPlantyT1x[1] = Input;
	value->vPlantyT1y[1] = value->vPlantyT1y[0];
 8000e08:	edc0 7a06 	vstr	s15, [r0, #24]

	/* Calculate second Section */
	value->vPlantyT2y[0] = value->vPlantyT2y[1] + value->a2 * value->vPlantyT2x[1];
 8000e0c:	ed80 0a09 	vstr	s0, [r0, #36]	; 0x24
	value->vPlantyT2x[1] = value->vPlantyT1y[0];
 8000e10:	edc0 7a08 	vstr	s15, [r0, #32]
	value->vPlantyT2y[1] = value->vPlantyT2y[0];
 8000e14:	ed80 0a0a 	vstr	s0, [r0, #40]	; 0x28

	return value->vPlantyT2y[0];
}
 8000e18:	4770      	bx	lr

08000e1a <CalcVirtualPlant_xxx>:
/* Simulate Virtual Plant */
/* Fehler */
float CalcVirtualPlant_xxx(SmitPredictor_Control *value, float Input){
	/* shift */
	value->w[2] = 	value->w[1];
	value->w[1] =	value->w[0];
 8000e1a:	edd0 6a00 	vldr	s13, [r0]
	value->w[0] = 	(value->gain*Input) + (value->a1*value->w[1]) + (value->a2*value->w[2]);
 8000e1e:	edd0 7a0b 	vldr	s15, [r0, #44]	; 0x2c
 8000e22:	ed90 6a10 	vldr	s12, [r0, #64]	; 0x40

/* Simulate Virtual Plant */
/* Fehler */
float CalcVirtualPlant_xxx(SmitPredictor_Control *value, float Input){
	/* shift */
	value->w[2] = 	value->w[1];
 8000e26:	ed90 7a01 	vldr	s14, [r0, #4]
	value->w[1] =	value->w[0];
 8000e2a:	edc0 6a01 	vstr	s13, [r0, #4]
	value->w[0] = 	(value->gain*Input) + (value->a1*value->w[1]) + (value->a2*value->w[2]);
 8000e2e:	ee66 7aa7 	vmul.f32	s15, s13, s15

/* Simulate Virtual Plant */
/* Fehler */
float CalcVirtualPlant_xxx(SmitPredictor_Control *value, float Input){
	/* shift */
	value->w[2] = 	value->w[1];
 8000e32:	ed80 7a02 	vstr	s14, [r0, #8]
	value->w[1] =	value->w[0];
	value->w[0] = 	(value->gain*Input) + (value->a1*value->w[1]) + (value->a2*value->w[2]);
 8000e36:	eee6 7a00 	vfma.f32	s15, s12, s0
 8000e3a:	ed90 6a0c 	vldr	s12, [r0, #48]	; 0x30
	return 		(value->b1*value->w[0]) + (value->b2*value->w[1]) + (value->b3*value->w[2]);
 8000e3e:	ed90 0a0e 	vldr	s0, [r0, #56]	; 0x38
/* Fehler */
float CalcVirtualPlant_xxx(SmitPredictor_Control *value, float Input){
	/* shift */
	value->w[2] = 	value->w[1];
	value->w[1] =	value->w[0];
	value->w[0] = 	(value->gain*Input) + (value->a1*value->w[1]) + (value->a2*value->w[2]);
 8000e42:	eee6 7a07 	vfma.f32	s15, s12, s14
	return 		(value->b1*value->w[0]) + (value->b2*value->w[1]) + (value->b3*value->w[2]);
 8000e46:	ee26 0a80 	vmul.f32	s0, s13, s0
 8000e4a:	edd0 6a0d 	vldr	s13, [r0, #52]	; 0x34
/* Fehler */
float CalcVirtualPlant_xxx(SmitPredictor_Control *value, float Input){
	/* shift */
	value->w[2] = 	value->w[1];
	value->w[1] =	value->w[0];
	value->w[0] = 	(value->gain*Input) + (value->a1*value->w[1]) + (value->a2*value->w[2]);
 8000e4e:	edc0 7a00 	vstr	s15, [r0]
	return 		(value->b1*value->w[0]) + (value->b2*value->w[1]) + (value->b3*value->w[2]);
 8000e52:	eea6 0aa7 	vfma.f32	s0, s13, s15
 8000e56:	edd0 7a0f 	vldr	s15, [r0, #60]	; 0x3c
}
 8000e5a:	eea7 0a87 	vfma.f32	s0, s15, s14
 8000e5e:	4770      	bx	lr

08000e60 <CalcDirektForm2>:
float CalcDirektForm2(float istwert, float sollwert, SmitPredictor_Control *value){
	/* shift */
	float E = sollwert - istwert;

	value->w[2] = 	value->w[1];
	value->w[1] =	value->w[0];
 8000e60:	edd0 6a00 	vldr	s13, [r0]
	value->w[0] = 	(value->gain*E) + (-value->a1*value->w[1]) + (-value->a2*value->w[2]);
 8000e64:	edd0 7a0b 	vldr	s15, [r0, #44]	; 0x2c
 8000e68:	edd0 5a10 	vldr	s11, [r0, #64]	; 0x40
/* Fehler */
float CalcDirektForm2(float istwert, float sollwert, SmitPredictor_Control *value){
	/* shift */
	float E = sollwert - istwert;

	value->w[2] = 	value->w[1];
 8000e6c:	ed90 7a01 	vldr	s14, [r0, #4]
	value->w[1] =	value->w[0];
	value->w[0] = 	(value->gain*E) + (-value->a1*value->w[1]) + (-value->a2*value->w[2]);
 8000e70:	ed90 6a0c 	vldr	s12, [r0, #48]	; 0x30
float CalcDirektForm2(float istwert, float sollwert, SmitPredictor_Control *value){
	/* shift */
	float E = sollwert - istwert;

	value->w[2] = 	value->w[1];
	value->w[1] =	value->w[0];
 8000e74:	edc0 6a01 	vstr	s13, [r0, #4]
}

/* Fehler */
float CalcDirektForm2(float istwert, float sollwert, SmitPredictor_Control *value){
	/* shift */
	float E = sollwert - istwert;
 8000e78:	ee70 0ac0 	vsub.f32	s1, s1, s0

	value->w[2] = 	value->w[1];
	value->w[1] =	value->w[0];
	value->w[0] = 	(value->gain*E) + (-value->a1*value->w[1]) + (-value->a2*value->w[2]);
 8000e7c:	ee67 7ae6 	vnmul.f32	s15, s15, s13
	return 		(value->b1*value->w[0]) + (value->b2*value->w[1]) + (value->b3*value->w[2]);
 8000e80:	ed90 0a0e 	vldr	s0, [r0, #56]	; 0x38
/* Fehler */
float CalcDirektForm2(float istwert, float sollwert, SmitPredictor_Control *value){
	/* shift */
	float E = sollwert - istwert;

	value->w[2] = 	value->w[1];
 8000e84:	ed80 7a02 	vstr	s14, [r0, #8]
	value->w[1] =	value->w[0];
	value->w[0] = 	(value->gain*E) + (-value->a1*value->w[1]) + (-value->a2*value->w[2]);
 8000e88:	eee5 7aa0 	vfma.f32	s15, s11, s1
	return 		(value->b1*value->w[0]) + (value->b2*value->w[1]) + (value->b3*value->w[2]);
 8000e8c:	ee26 0a80 	vmul.f32	s0, s13, s0
	/* shift */
	float E = sollwert - istwert;

	value->w[2] = 	value->w[1];
	value->w[1] =	value->w[0];
	value->w[0] = 	(value->gain*E) + (-value->a1*value->w[1]) + (-value->a2*value->w[2]);
 8000e90:	eee6 7a47 	vfms.f32	s15, s12, s14
	return 		(value->b1*value->w[0]) + (value->b2*value->w[1]) + (value->b3*value->w[2]);
 8000e94:	edd0 6a0d 	vldr	s13, [r0, #52]	; 0x34
	/* shift */
	float E = sollwert - istwert;

	value->w[2] = 	value->w[1];
	value->w[1] =	value->w[0];
	value->w[0] = 	(value->gain*E) + (-value->a1*value->w[1]) + (-value->a2*value->w[2]);
 8000e98:	edc0 7a00 	vstr	s15, [r0]
	return 		(value->b1*value->w[0]) + (value->b2*value->w[1]) + (value->b3*value->w[2]);
 8000e9c:	eea6 0aa7 	vfma.f32	s0, s13, s15
 8000ea0:	edd0 7a0f 	vldr	s15, [r0, #60]	; 0x3c
}
 8000ea4:	eea7 0a87 	vfma.f32	s0, s15, s14
 8000ea8:	4770      	bx	lr

08000eaa <CalcDelay>:
/* Checked */
float CalcDelay(SmitPredictor_Control *value, float Input){

	static unsigned char dlyindex = 0;

	dlyindex++;
 8000eaa:	4b0a      	ldr	r3, [pc, #40]	; (8000ed4 <CalcDelay+0x2a>)
 8000eac:	781a      	ldrb	r2, [r3, #0]
 8000eae:	3201      	adds	r2, #1
 8000eb0:	b2d2      	uxtb	r2, r2
	if ( dlyindex >= (sizeof(value->fifo)/sizeof(float))) dlyindex = 0;
 8000eb2:	2a07      	cmp	r2, #7
 8000eb4:	bf88      	it	hi
 8000eb6:	2200      	movhi	r2, #0
 8000eb8:	701a      	strb	r2, [r3, #0]
	value->fifo[dlyindex] = Input;
 8000eba:	781b      	ldrb	r3, [r3, #0]
 8000ebc:	eb00 0283 	add.w	r2, r0, r3, lsl #2
	if ( dlyindex < ( sizeof(value->fifo)/sizeof(float)-1 ) )
 8000ec0:	2b06      	cmp	r3, #6

	static unsigned char dlyindex = 0;

	dlyindex++;
	if ( dlyindex >= (sizeof(value->fifo)/sizeof(float))) dlyindex = 0;
	value->fifo[dlyindex] = Input;
 8000ec2:	ed82 0a11 	vstr	s0, [r2, #68]	; 0x44
	if ( dlyindex < ( sizeof(value->fifo)/sizeof(float)-1 ) )
 8000ec6:	d802      	bhi.n	8000ece <CalcDelay+0x24>
		return value->fifo[(dlyindex + 1)];
 8000ec8:	ed92 0a12 	vldr	s0, [r2, #72]	; 0x48
 8000ecc:	4770      	bx	lr
	else
		return value->fifo[0];
 8000ece:	ed90 0a11 	vldr	s0, [r0, #68]	; 0x44
}
 8000ed2:	4770      	bx	lr
 8000ed4:	20000484 	.word	0x20000484

08000ed8 <calc_PID_SmithPredictor>:
	float P ,I ,D;

#define Isum_max 50.0f

	/* SmithPrädiktor */
	PID_Values->e = sollwert - ( S - E + istwert);
 8000ed8:	4a29      	ldr	r2, [pc, #164]	; (8000f80 <calc_PID_SmithPredictor+0xa8>)

	// I-Anteil aufsummieren:
	PID_Values->Isum += (PID_Values->e*PID_Values->ki) * PID_Values->sampling_rate;
 8000eda:	edd0 6a00 	vldr	s13, [r0]
	float P ,I ,D;

#define Isum_max 50.0f

	/* SmithPrädiktor */
	PID_Values->e = sollwert - ( S - E + istwert);
 8000ede:	ed92 7a01 	vldr	s14, [r2, #4]
 8000ee2:	edd2 7a02 	vldr	s15, [r2, #8]
	if (PID_Values->Isum < -Isum_max) PID_Values->Isum = -Isum_max;

	P = (PID_Values->kp * PID_Values->e);
	//I = (PID_Values->Isum * PID_Values->ki);
	I = PID_Values->Isum;
	D = (PID_Values->kd * PID_Values->e - PID_Values->Dsum ) * PID_Values->kn;
 8000ee6:	edd0 5a04 	vldr	s11, [r0, #16]

	// Anti-Windup
	if (PID_Values->Isum > Isum_max) PID_Values->Isum = Isum_max;
	if (PID_Values->Isum < -Isum_max) PID_Values->Isum = -Isum_max;

	P = (PID_Values->kp * PID_Values->e);
 8000eea:	ed90 6a02 	vldr	s12, [r0, #8]
	float P ,I ,D;

#define Isum_max 50.0f

	/* SmithPrädiktor */
	PID_Values->e = sollwert - ( S - E + istwert);
 8000eee:	ee77 7a67 	vsub.f32	s15, s14, s15

	// I-Anteil aufsummieren:
	PID_Values->Isum += (PID_Values->e*PID_Values->ki) * PID_Values->sampling_rate;
 8000ef2:	ed90 7a03 	vldr	s14, [r0, #12]
	float P ,I ,D;

#define Isum_max 50.0f

	/* SmithPrädiktor */
	PID_Values->e = sollwert - ( S - E + istwert);
 8000ef6:	ee37 0a80 	vadd.f32	s0, s15, s0

	// I-Anteil aufsummieren:
	PID_Values->Isum += (PID_Values->e*PID_Values->ki) * PID_Values->sampling_rate;
 8000efa:	edd0 7a07 	vldr	s15, [r0, #28]
	float P ,I ,D;

#define Isum_max 50.0f

	/* SmithPrädiktor */
	PID_Values->e = sollwert - ( S - E + istwert);
 8000efe:	ee70 0ac0 	vsub.f32	s1, s1, s0
	PID_Values->y = P + I + D;
	
}

void calc_PID_SmithPredictor(float istwert, float sollwert, PID_Control *PID_Values, SmitPredictor_Control *Plant_Values)
{
 8000f02:	b538      	push	{r3, r4, r5, lr}

	/* SmithPrädiktor */
	PID_Values->e = sollwert - ( S - E + istwert);

	// I-Anteil aufsummieren:
	PID_Values->Isum += (PID_Values->e*PID_Values->ki) * PID_Values->sampling_rate;
 8000f04:	ee20 7a87 	vmul.f32	s14, s1, s14
	float P ,I ,D;

#define Isum_max 50.0f

	/* SmithPrädiktor */
	PID_Values->e = sollwert - ( S - E + istwert);
 8000f08:	edc0 0a06 	vstr	s1, [r0, #24]

	// I-Anteil aufsummieren:
	PID_Values->Isum += (PID_Values->e*PID_Values->ki) * PID_Values->sampling_rate;
 8000f0c:	eee7 7a26 	vfma.f32	s15, s14, s13
 8000f10:	4614      	mov	r4, r2
	PID_Values->y = P + I + D;
	
}

void calc_PID_SmithPredictor(float istwert, float sollwert, PID_Control *PID_Values, SmitPredictor_Control *Plant_Values)
{
 8000f12:	460d      	mov	r5, r1

	// I-Anteil aufsummieren:
	PID_Values->Isum += (PID_Values->e*PID_Values->ki) * PID_Values->sampling_rate;

	// Anti-Windup
	if (PID_Values->Isum > Isum_max) PID_Values->Isum = Isum_max;
 8000f14:	ed9f 7a1b 	vldr	s14, [pc, #108]	; 8000f84 <calc_PID_SmithPredictor+0xac>

	/* SmithPrädiktor */
	PID_Values->e = sollwert - ( S - E + istwert);

	// I-Anteil aufsummieren:
	PID_Values->Isum += (PID_Values->e*PID_Values->ki) * PID_Values->sampling_rate;
 8000f18:	eef4 7ac7 	vcmpe.f32	s15, s14
 8000f1c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8000f20:	bfc8      	it	gt
 8000f22:	eef0 7a47 	vmovgt.f32	s15, s14

	// Anti-Windup
	if (PID_Values->Isum > Isum_max) PID_Values->Isum = Isum_max;
	if (PID_Values->Isum < -Isum_max) PID_Values->Isum = -Isum_max;
 8000f26:	ed9f 7a18 	vldr	s14, [pc, #96]	; 8000f88 <calc_PID_SmithPredictor+0xb0>

	/* SmithPrädiktor */
	PID_Values->e = sollwert - ( S - E + istwert);

	// I-Anteil aufsummieren:
	PID_Values->Isum += (PID_Values->e*PID_Values->ki) * PID_Values->sampling_rate;
 8000f2a:	edc0 7a07 	vstr	s15, [r0, #28]

	// Anti-Windup
	if (PID_Values->Isum > Isum_max) PID_Values->Isum = Isum_max;
	if (PID_Values->Isum < -Isum_max) PID_Values->Isum = -Isum_max;
 8000f2e:	eef4 7ac7 	vcmpe.f32	s15, s14
 8000f32:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8000f36:	bf48      	it	mi
 8000f38:	ed80 7a07 	vstrmi	s14, [r0, #28]

	P = (PID_Values->kp * PID_Values->e);
	//I = (PID_Values->Isum * PID_Values->ki);
	I = PID_Values->Isum;
	D = (PID_Values->kd * PID_Values->e - PID_Values->Dsum ) * PID_Values->kn;
 8000f3c:	ed90 7a08 	vldr	s14, [r0, #32]
	if (PID_Values->Isum > Isum_max) PID_Values->Isum = Isum_max;
	if (PID_Values->Isum < -Isum_max) PID_Values->Isum = -Isum_max;

	P = (PID_Values->kp * PID_Values->e);
	//I = (PID_Values->Isum * PID_Values->ki);
	I = PID_Values->Isum;
 8000f40:	edd0 7a07 	vldr	s15, [r0, #28]
	D = (PID_Values->kd * PID_Values->e - PID_Values->Dsum ) * PID_Values->kn;
 8000f44:	eeb0 0a47 	vmov.f32	s0, s14
 8000f48:	ee95 0aa0 	vfnms.f32	s0, s11, s1
 8000f4c:	edd0 5a05 	vldr	s11, [r0, #20]
	PID_Values->Dsum += D * PID_Values->sampling_rate;

	// PID-Regler
	PID_Values->y = P + I + D;
 8000f50:	eee6 7a20 	vfma.f32	s15, s12, s1
	if (PID_Values->Isum < -Isum_max) PID_Values->Isum = -Isum_max;

	P = (PID_Values->kp * PID_Values->e);
	//I = (PID_Values->Isum * PID_Values->ki);
	I = PID_Values->Isum;
	D = (PID_Values->kd * PID_Values->e - PID_Values->Dsum ) * PID_Values->kn;
 8000f54:	ee20 0a25 	vmul.f32	s0, s0, s11
	PID_Values->Dsum += D * PID_Values->sampling_rate;
 8000f58:	eea0 7a26 	vfma.f32	s14, s0, s13

	// PID-Regler
	PID_Values->y = P + I + D;
 8000f5c:	ee37 0a80 	vadd.f32	s0, s15, s0

	P = (PID_Values->kp * PID_Values->e);
	//I = (PID_Values->Isum * PID_Values->ki);
	I = PID_Values->Isum;
	D = (PID_Values->kd * PID_Values->e - PID_Values->Dsum ) * PID_Values->kn;
	PID_Values->Dsum += D * PID_Values->sampling_rate;
 8000f60:	ed80 7a08 	vstr	s14, [r0, #32]

	// PID-Regler
	PID_Values->y = P + I + D;
 8000f64:	ed80 0a01 	vstr	s0, [r0, #4]

	/* Get Virtual Plant */
	S = CalcVirtualPlant(Plant_Values, PID_Values->y);
 8000f68:	4608      	mov	r0, r1
 8000f6a:	f7ff ff35 	bl	8000dd8 <CalcVirtualPlant>

	/* Delay */
	E = CalcDelay(Plant_Values, S);
 8000f6e:	4628      	mov	r0, r5

	// PID-Regler
	PID_Values->y = P + I + D;

	/* Get Virtual Plant */
	S = CalcVirtualPlant(Plant_Values, PID_Values->y);
 8000f70:	ed84 0a01 	vstr	s0, [r4, #4]

	/* Delay */
	E = CalcDelay(Plant_Values, S);
 8000f74:	f7ff ff99 	bl	8000eaa <CalcDelay>
 8000f78:	ed84 0a02 	vstr	s0, [r4, #8]
 8000f7c:	bd38      	pop	{r3, r4, r5, pc}
 8000f7e:	bf00      	nop
 8000f80:	20000484 	.word	0x20000484
 8000f84:	42480000 	.word	0x42480000
 8000f88:	c2480000 	.word	0xc2480000

08000f8c <calc_PID_YAW>:
 * The yaw PID calculation needs a special handling as the input value has
 * an integrating character
 * */
void calc_PID_YAW(float istwert, float sollwert, PID_Control *values)
{
	values->e = sollwert - istwert;
 8000f8c:	ee70 0ac0 	vsub.f32	s1, s1, s0

	if(values->e >= 180) values->e -= 360;
 8000f90:	eddf 7a32 	vldr	s15, [pc, #200]	; 800105c <calc_PID_YAW+0xd0>
 8000f94:	eef4 0ae7 	vcmpe.f32	s1, s15
 8000f98:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8000f9c:	db04      	blt.n	8000fa8 <calc_PID_YAW+0x1c>
 8000f9e:	eddf 7a30 	vldr	s15, [pc, #192]	; 8001060 <calc_PID_YAW+0xd4>
 8000fa2:	ee70 0ae7 	vsub.f32	s1, s1, s15
 8000fa6:	e00a      	b.n	8000fbe <calc_PID_YAW+0x32>
	else if (values->e <= -180) values->e += 360;
 8000fa8:	eddf 7a2e 	vldr	s15, [pc, #184]	; 8001064 <calc_PID_YAW+0xd8>
 8000fac:	eef4 0ae7 	vcmpe.f32	s1, s15
 8000fb0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8000fb4:	bf9c      	itt	ls
 8000fb6:	eddf 7a2a 	vldrls	s15, [pc, #168]	; 8001060 <calc_PID_YAW+0xd4>
 8000fba:	ee70 0aa7 	vaddls.f32	s1, s1, s15
 8000fbe:	edc0 0a06 	vstr	s1, [r0, #24]

	if(values->e > 50) values->e = 50;
 8000fc2:	eddf 6a29 	vldr	s13, [pc, #164]	; 8001068 <calc_PID_YAW+0xdc>
 8000fc6:	edd0 7a06 	vldr	s15, [r0, #24]
	if(values->e < -50) values->e = -50;

	values->Isum = values->Isum + (values->e);

	if(values->Isum < Isum_max) values->Isum = Isum_max;
 8000fca:	ed9f 6a27 	vldr	s12, [pc, #156]	; 8001068 <calc_PID_YAW+0xdc>
	if(values->Isum > Isum_max) values->Isum = Isum_max;

	//PID-Regler
	values->y = (values->kp*values->e) + (values->Isum*values->ki*values->sampling_rate) + (values->kd*(values->e - values->ealt)/values->sampling_rate);
 8000fce:	edd0 5a04 	vldr	s11, [r0, #16]
	values->e = sollwert - istwert;

	if(values->e >= 180) values->e -= 360;
	else if (values->e <= -180) values->e += 360;

	if(values->e > 50) values->e = 50;
 8000fd2:	eef4 7ae6 	vcmpe.f32	s15, s13
 8000fd6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8000fda:	bfc8      	it	gt
 8000fdc:	edc0 6a06 	vstrgt	s13, [r0, #24]
	if(values->e < -50) values->e = -50;
 8000fe0:	eddf 7a22 	vldr	s15, [pc, #136]	; 800106c <calc_PID_YAW+0xe0>
 8000fe4:	ed90 7a06 	vldr	s14, [r0, #24]
 8000fe8:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8000fec:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8000ff0:	bf48      	it	mi
 8000ff2:	edc0 7a06 	vstrmi	s15, [r0, #24]

	values->Isum = values->Isum + (values->e);
 8000ff6:	edd0 7a06 	vldr	s15, [r0, #24]
 8000ffa:	ed90 7a07 	vldr	s14, [r0, #28]
 8000ffe:	ee37 7a87 	vadd.f32	s14, s15, s14
 8001002:	eeb4 7ae6 	vcmpe.f32	s14, s13
 8001006:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800100a:	bf48      	it	mi
 800100c:	eeb0 7a46 	vmovmi.f32	s14, s12

	if(values->Isum < Isum_max) values->Isum = Isum_max;
	if(values->Isum > Isum_max) values->Isum = Isum_max;
 8001010:	eeb4 7a66 	vcmp.f32	s14, s13
 8001014:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001018:	bfc8      	it	gt
 800101a:	eeb0 7a46 	vmovgt.f32	s14, s12

	//PID-Regler
	values->y = (values->kp*values->e) + (values->Isum*values->ki*values->sampling_rate) + (values->kd*(values->e - values->ealt)/values->sampling_rate);
 800101e:	eeb0 6a47 	vmov.f32	s12, s14
	if(values->e < -50) values->e = -50;

	values->Isum = values->Isum + (values->e);

	if(values->Isum < Isum_max) values->Isum = Isum_max;
	if(values->Isum > Isum_max) values->Isum = Isum_max;
 8001022:	ed80 7a07 	vstr	s14, [r0, #28]

	//PID-Regler
	values->y = (values->kp*values->e) + (values->Isum*values->ki*values->sampling_rate) + (values->kd*(values->e - values->ealt)/values->sampling_rate);
 8001026:	ed90 7a03 	vldr	s14, [r0, #12]
 800102a:	edd0 6a00 	vldr	s13, [r0]
 800102e:	ee26 7a07 	vmul.f32	s14, s12, s14
 8001032:	ed90 6a02 	vldr	s12, [r0, #8]
 8001036:	ee27 7a26 	vmul.f32	s14, s14, s13
 800103a:	eea6 7a27 	vfma.f32	s14, s12, s15
 800103e:	ed90 6a09 	vldr	s12, [r0, #36]	; 0x24

	values->ealt = values->e;
 8001042:	edc0 7a09 	vstr	s15, [r0, #36]	; 0x24

	if(values->Isum < Isum_max) values->Isum = Isum_max;
	if(values->Isum > Isum_max) values->Isum = Isum_max;

	//PID-Regler
	values->y = (values->kp*values->e) + (values->Isum*values->ki*values->sampling_rate) + (values->kd*(values->e - values->ealt)/values->sampling_rate);
 8001046:	ee37 6ac6 	vsub.f32	s12, s15, s12
 800104a:	ee26 6a25 	vmul.f32	s12, s12, s11
 800104e:	eec6 6a26 	vdiv.f32	s13, s12, s13
 8001052:	ee37 7a26 	vadd.f32	s14, s14, s13
 8001056:	ed80 7a01 	vstr	s14, [r0, #4]

	values->ealt = values->e;
 800105a:	4770      	bx	lr
 800105c:	43340000 	.word	0x43340000
 8001060:	43b40000 	.word	0x43b40000
 8001064:	c3340000 	.word	0xc3340000
 8001068:	42480000 	.word	0x42480000
 800106c:	c2480000 	.word	0xc2480000

08001070 <Init_PositionController>:
PID_Control PID_Y;
PID_Control PID_Z;
SmitPredictor_Control Smith_Position;


void Init_PositionController(){
 8001070:	b510      	push	{r4, lr}

	init_PID(ContrTaskDT_S, GlobalSettings.PID_rollPitch.PID_kp,
 8001072:	4c1a      	ldr	r4, [pc, #104]	; (80010dc <Init_PositionController+0x6c>)
 8001074:	481a      	ldr	r0, [pc, #104]	; (80010e0 <Init_PositionController+0x70>)
 8001076:	edd4 0a0a 	vldr	s1, [r4, #40]	; 0x28
 800107a:	ed94 1a0b 	vldr	s2, [r4, #44]	; 0x2c
 800107e:	edd4 1a0c 	vldr	s3, [r4, #48]	; 0x30
 8001082:	ed94 2a0d 	vldr	s4, [r4, #52]	; 0x34
PID_Control PID_Y;
PID_Control PID_Z;
SmitPredictor_Control Smith_Position;


void Init_PositionController(){
 8001086:	ed2d 8b02 	vpush	{d8}

	init_PID(ContrTaskDT_S, GlobalSettings.PID_rollPitch.PID_kp,
 800108a:	ed9f 8a16 	vldr	s16, [pc, #88]	; 80010e4 <Init_PositionController+0x74>
 800108e:	eeb0 0a48 	vmov.f32	s0, s16
 8001092:	f7ff fe41 	bl	8000d18 <init_PID>
					GlobalSettings.PID_rollPitch.PID_ki,
					GlobalSettings.PID_rollPitch.PID_kd,
					GlobalSettings.PID_rollPitch.PID_kn, &PID_Y);

	init_PID(ContrTaskDT_S, GlobalSettings.PID_yaw.PID_kp,
 8001096:	eeb0 0a48 	vmov.f32	s0, s16
 800109a:	edd4 0a0e 	vldr	s1, [r4, #56]	; 0x38
 800109e:	ed94 1a0f 	vldr	s2, [r4, #60]	; 0x3c
 80010a2:	edd4 1a10 	vldr	s3, [r4, #64]	; 0x40
 80010a6:	ed94 2a11 	vldr	s4, [r4, #68]	; 0x44
 80010aa:	480f      	ldr	r0, [pc, #60]	; (80010e8 <Init_PositionController+0x78>)
 80010ac:	f7ff fe34 	bl	8000d18 <init_PID>
					GlobalSettings.PID_yaw.PID_ki,
					GlobalSettings.PID_yaw.PID_kd,
					GlobalSettings.PID_yaw.PID_kn, &PID_Z);


	init_SmithPredictor(GlobalSettings.SmithPrediktor_rollPitch.a1, GlobalSettings.SmithPrediktor_rollPitch.a2,
 80010b0:	ed94 0a12 	vldr	s0, [r4, #72]	; 0x48
 80010b4:	edd4 0a13 	vldr	s1, [r4, #76]	; 0x4c
 80010b8:	ed94 1a14 	vldr	s2, [r4, #80]	; 0x50
 80010bc:	edd4 1a15 	vldr	s3, [r4, #84]	; 0x54
 80010c0:	ed94 2a16 	vldr	s4, [r4, #88]	; 0x58
 80010c4:	edd4 2a17 	vldr	s5, [r4, #92]	; 0x5c
 80010c8:	4808      	ldr	r0, [pc, #32]	; (80010ec <Init_PositionController+0x7c>)
 80010ca:	f7ff fe30 	bl	8000d2e <init_SmithPredictor>
						GlobalSettings.SmithPrediktor_rollPitch.b3, GlobalSettings.SmithPrediktor_rollPitch.gain,
						&Smith_Position);

	CtrlStates.pitch = 0.0f;

}
 80010ce:	ecbd 8b02 	vpop	{d8}
	init_SmithPredictor(GlobalSettings.SmithPrediktor_rollPitch.a1, GlobalSettings.SmithPrediktor_rollPitch.a2,
						GlobalSettings.SmithPrediktor_rollPitch.b1, GlobalSettings.SmithPrediktor_rollPitch.b2,
						GlobalSettings.SmithPrediktor_rollPitch.b3, GlobalSettings.SmithPrediktor_rollPitch.gain,
						&Smith_Position);

	CtrlStates.pitch = 0.0f;
 80010d2:	4b07      	ldr	r3, [pc, #28]	; (80010f0 <Init_PositionController+0x80>)
 80010d4:	2200      	movs	r2, #0
 80010d6:	601a      	str	r2, [r3, #0]

}
 80010d8:	bd10      	pop	{r4, pc}
 80010da:	bf00      	nop
 80010dc:	20002f04 	.word	0x20002f04
 80010e0:	20003388 	.word	0x20003388
 80010e4:	3c23d70a 	.word	0x3c23d70a
 80010e8:	200033b4 	.word	0x200033b4
 80010ec:	20003324 	.word	0x20003324
 80010f0:	20002f64 	.word	0x20002f64

080010f4 <Init_IMU>:

void Init_IMU(){
 80010f4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}


	memset(&xGyroFiltered_float, 0, sizeof(xGyroFiltered_float));
 80010f8:	2100      	movs	r1, #0
 80010fa:	222c      	movs	r2, #44	; 0x2c
 80010fc:	489e      	ldr	r0, [pc, #632]	; (8001378 <Init_IMU+0x284>)


	/*Initialize the DCM-variables*/
	IMU_init(&IMU, DT_S);

	if(GlobalSettings.enableDriftCorrection)
 80010fe:	4e9f      	ldr	r6, [pc, #636]	; (800137c <Init_IMU+0x288>)
 8001100:	4d9f      	ldr	r5, [pc, #636]	; (8001380 <Init_IMU+0x28c>)
}

void Init_IMU(){


	memset(&xGyroFiltered_float, 0, sizeof(xGyroFiltered_float));
 8001102:	f006 ff93 	bl	800802c <memset>
	memset(&yGyroFiltered_float, 0, sizeof(yGyroFiltered_float));
 8001106:	2100      	movs	r1, #0
 8001108:	222c      	movs	r2, #44	; 0x2c
 800110a:	489e      	ldr	r0, [pc, #632]	; (8001384 <Init_IMU+0x290>)
 800110c:	f006 ff8e 	bl	800802c <memset>
	memset(&zGyroFiltered_float, 0, sizeof(zGyroFiltered_float));
 8001110:	2100      	movs	r1, #0
 8001112:	222c      	movs	r2, #44	; 0x2c
 8001114:	489c      	ldr	r0, [pc, #624]	; (8001388 <Init_IMU+0x294>)
 8001116:	f006 ff89 	bl	800802c <memset>


	memset(&xAccFiltered_float, 0, sizeof(xAccFiltered_float));
 800111a:	2100      	movs	r1, #0
 800111c:	222c      	movs	r2, #44	; 0x2c
 800111e:	489b      	ldr	r0, [pc, #620]	; (800138c <Init_IMU+0x298>)
 8001120:	f006 ff84 	bl	800802c <memset>
	memset(&yAccFiltered_float, 0, sizeof(yAccFiltered_float));
 8001124:	2100      	movs	r1, #0
 8001126:	222c      	movs	r2, #44	; 0x2c
 8001128:	4899      	ldr	r0, [pc, #612]	; (8001390 <Init_IMU+0x29c>)
 800112a:	f006 ff7f 	bl	800802c <memset>
	memset(&zAccFiltered_float, 0, sizeof(zAccFiltered_float));
 800112e:	2100      	movs	r1, #0
 8001130:	222c      	movs	r2, #44	; 0x2c
 8001132:	4898      	ldr	r0, [pc, #608]	; (8001394 <Init_IMU+0x2a0>)
 8001134:	f006 ff7a 	bl	800802c <memset>


	/*Initialize the DCM-variables*/
	IMU_init(&IMU, DT_S);
 8001138:	4891      	ldr	r0, [pc, #580]	; (8001380 <Init_IMU+0x28c>)
 800113a:	ed9f 0a97 	vldr	s0, [pc, #604]	; 8001398 <Init_IMU+0x2a4>
 800113e:	f7ff f823 	bl	8000188 <IMU_init>

	if(GlobalSettings.enableDriftCorrection)
 8001142:	7ab3      	ldrb	r3, [r6, #10]
 8001144:	b123      	cbz	r3, 8001150 <Init_IMU+0x5c>
	{
		IMU_init_drift_correction(&IMU, 0.00040f);  //0.00020f/*kp-value*/);
 8001146:	4628      	mov	r0, r5
 8001148:	ed9f 0a94 	vldr	s0, [pc, #592]	; 800139c <Init_IMU+0x2a8>
 800114c:	f7ff f82e 	bl	80001ac <IMU_init_drift_correction>
	}

	while(1)
	{
		Gyro_calibrate(&gyroOffset);
 8001150:	4f93      	ldr	r7, [pc, #588]	; (80013a0 <Init_IMU+0x2ac>)
 8001152:	4638      	mov	r0, r7
 8001154:	f7ff fb29 	bl	80007aa <Gyro_calibrate>
		for (i = 0;i<5000;i++)
 8001158:	2300      	movs	r3, #0
 800115a:	80fb      	strh	r3, [r7, #6]
 800115c:	88fa      	ldrh	r2, [r7, #6]
 800115e:	4c90      	ldr	r4, [pc, #576]	; (80013a0 <Init_IMU+0x2ac>)
 8001160:	f241 3387 	movw	r3, #4999	; 0x1387
 8001164:	429a      	cmp	r2, r3
 8001166:	d83d      	bhi.n	80011e4 <Init_IMU+0xf0>
		{
			Gyro_readValues(&gyroXYZ);
 8001168:	f104 0008 	add.w	r0, r4, #8
 800116c:	f7ff fae9 	bl	8000742 <Gyro_readValues>
			gyroXYZ.gyroValueX = ((gyroXYZ.gyroValueX-gyroOffset.gyroValueX));
 8001170:	8922      	ldrh	r2, [r4, #8]
 8001172:	8823      	ldrh	r3, [r4, #0]
			gyroXYZ.gyroValueY = ((gyroXYZ.gyroValueY-gyroOffset.gyroValueY));
 8001174:	8961      	ldrh	r1, [r4, #10]
			gyroXYZ.gyroValueZ = ((gyroXYZ.gyroValueZ-gyroOffset.gyroValueZ));

			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] += ((float)gyroXYZ.gyroValueX*GYROCONVERT)*DT_S;
 8001176:	eddf 7a8b 	vldr	s15, [pc, #556]	; 80013a4 <Init_IMU+0x2b0>
 800117a:	ed9f 7a87 	vldr	s14, [pc, #540]	; 8001398 <Init_IMU+0x2a4>
	{
		Gyro_calibrate(&gyroOffset);
		for (i = 0;i<5000;i++)
		{
			Gyro_readValues(&gyroXYZ);
			gyroXYZ.gyroValueX = ((gyroXYZ.gyroValueX-gyroOffset.gyroValueX));
 800117e:	1ad2      	subs	r2, r2, r3
			gyroXYZ.gyroValueY = ((gyroXYZ.gyroValueY-gyroOffset.gyroValueY));
 8001180:	8863      	ldrh	r3, [r4, #2]
 8001182:	1acb      	subs	r3, r1, r3
 8001184:	8163      	strh	r3, [r4, #10]
			gyroXYZ.gyroValueZ = ((gyroXYZ.gyroValueZ-gyroOffset.gyroValueZ));
 8001186:	89a1      	ldrh	r1, [r4, #12]
 8001188:	88a3      	ldrh	r3, [r4, #4]
	{
		Gyro_calibrate(&gyroOffset);
		for (i = 0;i<5000;i++)
		{
			Gyro_readValues(&gyroXYZ);
			gyroXYZ.gyroValueX = ((gyroXYZ.gyroValueX-gyroOffset.gyroValueX));
 800118a:	b292      	uxth	r2, r2
			gyroXYZ.gyroValueY = ((gyroXYZ.gyroValueY-gyroOffset.gyroValueY));
			gyroXYZ.gyroValueZ = ((gyroXYZ.gyroValueZ-gyroOffset.gyroValueZ));
 800118c:	1acb      	subs	r3, r1, r3
	{
		Gyro_calibrate(&gyroOffset);
		for (i = 0;i<5000;i++)
		{
			Gyro_readValues(&gyroXYZ);
			gyroXYZ.gyroValueX = ((gyroXYZ.gyroValueX-gyroOffset.gyroValueX));
 800118e:	8122      	strh	r2, [r4, #8]
			gyroXYZ.gyroValueY = ((gyroXYZ.gyroValueY-gyroOffset.gyroValueY));
			gyroXYZ.gyroValueZ = ((gyroXYZ.gyroValueZ-gyroOffset.gyroValueZ));

			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] += ((float)gyroXYZ.gyroValueX*GYROCONVERT)*DT_S;
 8001190:	b212      	sxth	r2, r2
		for (i = 0;i<5000;i++)
		{
			Gyro_readValues(&gyroXYZ);
			gyroXYZ.gyroValueX = ((gyroXYZ.gyroValueX-gyroOffset.gyroValueX));
			gyroXYZ.gyroValueY = ((gyroXYZ.gyroValueY-gyroOffset.gyroValueY));
			gyroXYZ.gyroValueZ = ((gyroXYZ.gyroValueZ-gyroOffset.gyroValueZ));
 8001192:	81a3      	strh	r3, [r4, #12]

			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] += ((float)gyroXYZ.gyroValueX*GYROCONVERT)*DT_S;
 8001194:	ee06 2a90 	vmov	s13, r2
 8001198:	7933      	ldrb	r3, [r6, #4]
 800119a:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 800119e:	330a      	adds	r3, #10
 80011a0:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 80011a4:	ee66 6aa7 	vmul.f32	s13, s13, s15
 80011a8:	edd3 7a00 	vldr	s15, [r3]
 80011ac:	eee6 7a87 	vfma.f32	s15, s13, s14
 80011b0:	edc3 7a00 	vstr	s15, [r3]
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] += ((float)gyroXYZ.gyroValueX*GYROCONVERT)*DT_S;
 80011b4:	7973      	ldrb	r3, [r6, #5]
 80011b6:	330a      	adds	r3, #10
 80011b8:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 80011bc:	edd3 7a00 	vldr	s15, [r3]
 80011c0:	eee6 7a87 	vfma.f32	s15, s13, s14
 80011c4:	edc3 7a00 	vstr	s15, [r3]
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] += ((float)gyroXYZ.gyroValueX*GYROCONVERT)*DT_S;
 80011c8:	79b3      	ldrb	r3, [r6, #6]
 80011ca:	330a      	adds	r3, #10
 80011cc:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 80011d0:	edd3 7a00 	vldr	s15, [r3]
 80011d4:	eee6 7a87 	vfma.f32	s15, s13, s14
 80011d8:	edc3 7a00 	vstr	s15, [r3]
	}

	while(1)
	{
		Gyro_calibrate(&gyroOffset);
		for (i = 0;i<5000;i++)
 80011dc:	88e3      	ldrh	r3, [r4, #6]
 80011de:	3301      	adds	r3, #1
 80011e0:	80e3      	strh	r3, [r4, #6]
 80011e2:	e7bb      	b.n	800115c <Init_IMU+0x68>
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] += ((float)gyroXYZ.gyroValueX*GYROCONVERT)*DT_S;
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] += ((float)gyroXYZ.gyroValueX*GYROCONVERT)*DT_S;
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] += ((float)gyroXYZ.gyroValueX*GYROCONVERT)*DT_S;
		}
		//vTaskDelayUntil( &xNextWakeTime, DT );
		GPIOC->ODR ^= GPIO_Pin_11;
 80011e4:	4b70      	ldr	r3, [pc, #448]	; (80013a8 <Init_IMU+0x2b4>)
 80011e6:	8a9a      	ldrh	r2, [r3, #20]
 80011e8:	b292      	uxth	r2, r2
 80011ea:	f482 6200 	eor.w	r2, r2, #2048	; 0x800
 80011ee:	829a      	strh	r2, [r3, #20]
		vTaskDelay( 1000 );
 80011f0:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80011f4:	f005 fce2 	bl	8006bbc <vTaskDelay>

		if((IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] > -MAX_GYRO_ERROR) && (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] < MAX_GYRO_ERROR) &&
 80011f8:	7931      	ldrb	r1, [r6, #4]
 80011fa:	ed9f 7a6c 	vldr	s14, [pc, #432]	; 80013ac <Init_IMU+0x2b8>
 80011fe:	4a5f      	ldr	r2, [pc, #380]	; (800137c <Init_IMU+0x288>)
 8001200:	485f      	ldr	r0, [pc, #380]	; (8001380 <Init_IMU+0x28c>)
 8001202:	310a      	adds	r1, #10
 8001204:	eb05 0881 	add.w	r8, r5, r1, lsl #2
 8001208:	edd8 6a00 	vldr	s13, [r8]
 800120c:	eef4 6ac7 	vcmpe.f32	s13, s14
 8001210:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001214:	f04f 0300 	mov.w	r3, #0
 8001218:	dd38      	ble.n	800128c <Init_IMU+0x198>
 800121a:	eddf 7a65 	vldr	s15, [pc, #404]	; 80013b0 <Init_IMU+0x2bc>
 800121e:	eef4 6ae7 	vcmpe.f32	s13, s15
 8001222:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001226:	d531      	bpl.n	800128c <Init_IMU+0x198>
		   (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] > -MAX_GYRO_ERROR) && (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] < MAX_GYRO_ERROR) &&
 8001228:	f892 c005 	ldrb.w	ip, [r2, #5]
 800122c:	f10c 0c0a 	add.w	ip, ip, #10
 8001230:	eb00 0c8c 	add.w	ip, r0, ip, lsl #2
 8001234:	eddc 6a00 	vldr	s13, [ip]
		}
		//vTaskDelayUntil( &xNextWakeTime, DT );
		GPIOC->ODR ^= GPIO_Pin_11;
		vTaskDelay( 1000 );

		if((IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] > -MAX_GYRO_ERROR) && (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] < MAX_GYRO_ERROR) &&
 8001238:	eef4 6ac7 	vcmpe.f32	s13, s14
 800123c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001240:	dd24      	ble.n	800128c <Init_IMU+0x198>
		   (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] > -MAX_GYRO_ERROR) && (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] < MAX_GYRO_ERROR) &&
 8001242:	eef4 6ae7 	vcmpe.f32	s13, s15
 8001246:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800124a:	d51f      	bpl.n	800128c <Init_IMU+0x198>
		   (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] > -MAX_GYRO_ERROR) && (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] < MAX_GYRO_ERROR))
 800124c:	f892 9006 	ldrb.w	r9, [r2, #6]
 8001250:	f109 090a 	add.w	r9, r9, #10
 8001254:	eb00 0089 	add.w	r0, r0, r9, lsl #2
 8001258:	edd0 6a00 	vldr	s13, [r0]
		//vTaskDelayUntil( &xNextWakeTime, DT );
		GPIOC->ODR ^= GPIO_Pin_11;
		vTaskDelay( 1000 );

		if((IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] > -MAX_GYRO_ERROR) && (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] < MAX_GYRO_ERROR) &&
		   (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] > -MAX_GYRO_ERROR) && (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] < MAX_GYRO_ERROR) &&
 800125c:	eef4 6ac7 	vcmpe.f32	s13, s14
 8001260:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001264:	dd12      	ble.n	800128c <Init_IMU+0x198>
		   (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] > -MAX_GYRO_ERROR) && (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] < MAX_GYRO_ERROR))
 8001266:	eef4 6ae7 	vcmpe.f32	s13, s15
 800126a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800126e:	d50d      	bpl.n	800128c <Init_IMU+0x198>
		{
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] = 0;
 8001270:	f8c8 3000 	str.w	r3, [r8]
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] = 0;
 8001274:	f8cc 3000 	str.w	r3, [ip]
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] = 0;
 8001278:	6003      	str	r3, [r0, #0]
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] = 0;
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] = 0;
		printf("Error Gyro Test!\n\r");
	}

	if(GlobalSettings.enableACC)
 800127a:	7ad3      	ldrb	r3, [r2, #11]
 800127c:	b1ab      	cbz	r3, 80012aa <Init_IMU+0x1b6>
	{
		//ADXL345_calibrate(GlobalSettings.accMaxGOverflow, &accXYZ);
		LSM303DLHC_ACC_calibrate(GlobalSettings.accMaxGOverflow, &accXYZ);
 800127e:	ed92 0a05 	vldr	s0, [r2, #20]
 8001282:	f104 0010 	add.w	r0, r4, #16
 8001286:	f7ff fc00 	bl	8000a8a <LSM303DLHC_ACC_calibrate>
 800128a:	e00e      	b.n	80012aa <Init_IMU+0x1b6>
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] = 0;
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] = 0;
			break;
		}
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] = 0;
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] = 0;
 800128c:	7972      	ldrb	r2, [r6, #5]
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] = 0;
		printf("Error Gyro Test!\n\r");
 800128e:	4849      	ldr	r0, [pc, #292]	; (80013b4 <Init_IMU+0x2c0>)
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] = 0;
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] = 0;
			break;
		}
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] = 0;
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] = 0;
 8001290:	eb05 0282 	add.w	r2, r5, r2, lsl #2
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] = 0;
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] = 0;
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] = 0;
			break;
		}
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] = 0;
 8001294:	eb05 0181 	add.w	r1, r5, r1, lsl #2
 8001298:	600b      	str	r3, [r1, #0]
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] = 0;
 800129a:	6293      	str	r3, [r2, #40]	; 0x28
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] = 0;
 800129c:	79b2      	ldrb	r2, [r6, #6]
 800129e:	eb05 0282 	add.w	r2, r5, r2, lsl #2
 80012a2:	6293      	str	r3, [r2, #40]	; 0x28
		printf("Error Gyro Test!\n\r");
 80012a4:	f000 ffd4 	bl	8002250 <printf>
	}
 80012a8:	e752      	b.n	8001150 <Init_IMU+0x5c>
	{
		//ADXL345_calibrate(GlobalSettings.accMaxGOverflow, &accXYZ);
		LSM303DLHC_ACC_calibrate(GlobalSettings.accMaxGOverflow, &accXYZ);
	}

	if(GlobalSettings.enableMAG)
 80012aa:	7e33      	ldrb	r3, [r6, #24]
 80012ac:	4e42      	ldr	r6, [pc, #264]	; (80013b8 <Init_IMU+0x2c4>)
 80012ae:	2b00      	cmp	r3, #0
 80012b0:	d058      	beq.n	8001364 <Init_IMU+0x270>
	{
		Mag_calibrate();
 80012b2:	f7ff fc51 	bl	8000b58 <Mag_calibrate>
		vTaskDelay( 200 );
 80012b6:	20c8      	movs	r0, #200	; 0xc8
 80012b8:	f005 fc80 	bl	8006bbc <vTaskDelay>
		Mag_readValues(&magXYZ);
 80012bc:	483f      	ldr	r0, [pc, #252]	; (80013bc <Init_IMU+0x2c8>)
 80012be:	f7ff fc69 	bl	8000b94 <Mag_readValues>
		eulerTemp.yaw = atan2((float)(-magXYZ.magValueX),(float)(magXYZ.magValueY))-1.5707;
 80012c2:	f9b7 001c 	ldrsh.w	r0, [r7, #28]
 80012c6:	4240      	negs	r0, r0
 80012c8:	ee07 0a90 	vmov	s15, r0
 80012cc:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80012d0:	ee17 0a90 	vmov	r0, s15
 80012d4:	f006 f9f2 	bl	80076bc <__aeabi_f2d>
 80012d8:	4604      	mov	r4, r0
 80012da:	f9b7 001e 	ldrsh.w	r0, [r7, #30]
 80012de:	ee07 0a90 	vmov	s15, r0
 80012e2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80012e6:	460d      	mov	r5, r1
 80012e8:	ee17 0a90 	vmov	r0, s15
 80012ec:	f006 f9e6 	bl	80076bc <__aeabi_f2d>
 80012f0:	ec45 4b10 	vmov	d0, r4, r5
 80012f4:	ec41 0b11 	vmov	d1, r0, r1
 80012f8:	f006 ff5c 	bl	80081b4 <atan2>
 80012fc:	a31c      	add	r3, pc, #112	; (adr r3, 8001370 <Init_IMU+0x27c>)
 80012fe:	e9d3 2300 	ldrd	r2, r3, [r3]
 8001302:	ec51 0b10 	vmov	r0, r1, d0
 8001306:	f006 f879 	bl	80073fc <__aeabi_dsub>
 800130a:	f006 fa53 	bl	80077b4 <__aeabi_d2f>
		CtrlStates.yaw = -eulerTemp.yaw*(180/M_PI);
 800130e:	ed9f 7a2c 	vldr	s14, [pc, #176]	; 80013c0 <Init_IMU+0x2cc>
	if(GlobalSettings.enableMAG)
	{
		Mag_calibrate();
		vTaskDelay( 200 );
		Mag_readValues(&magXYZ);
		eulerTemp.yaw = atan2((float)(-magXYZ.magValueX),(float)(magXYZ.magValueY))-1.5707;
 8001312:	4b2c      	ldr	r3, [pc, #176]	; (80013c4 <Init_IMU+0x2d0>)
 8001314:	ee07 0a90 	vmov	s15, r0
		CtrlStates.yaw = -eulerTemp.yaw*(180/M_PI);
 8001318:	ee67 7ac7 	vnmul.f32	s15, s15, s14
		/* The yaw value needs a special handling */
		if(CtrlStates.yaw > 180) CtrlStates.yaw -= 360;
 800131c:	ed9f 7a2a 	vldr	s14, [pc, #168]	; 80013c8 <Init_IMU+0x2d4>
	if(GlobalSettings.enableMAG)
	{
		Mag_calibrate();
		vTaskDelay( 200 );
		Mag_readValues(&magXYZ);
		eulerTemp.yaw = atan2((float)(-magXYZ.magValueX),(float)(magXYZ.magValueY))-1.5707;
 8001320:	6098      	str	r0, [r3, #8]
		CtrlStates.yaw = -eulerTemp.yaw*(180/M_PI);
		/* The yaw value needs a special handling */
		if(CtrlStates.yaw > 180) CtrlStates.yaw -= 360;
 8001322:	eef4 7ac7 	vcmpe.f32	s15, s14
 8001326:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
	{
		Mag_calibrate();
		vTaskDelay( 200 );
		Mag_readValues(&magXYZ);
		eulerTemp.yaw = atan2((float)(-magXYZ.magValueX),(float)(magXYZ.magValueY))-1.5707;
		CtrlStates.yaw = -eulerTemp.yaw*(180/M_PI);
 800132a:	edc6 7a01 	vstr	s15, [r6, #4]
		/* The yaw value needs a special handling */
		if(CtrlStates.yaw > 180) CtrlStates.yaw -= 360;
 800132e:	dd05      	ble.n	800133c <Init_IMU+0x248>
 8001330:	ed9f 7a26 	vldr	s14, [pc, #152]	; 80013cc <Init_IMU+0x2d8>
 8001334:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8001338:	edc6 7a01 	vstr	s15, [r6, #4]
		if(CtrlStates.yaw < -180) CtrlStates.yaw += 360;
 800133c:	edd6 7a01 	vldr	s15, [r6, #4]
 8001340:	ed9f 7a23 	vldr	s14, [pc, #140]	; 80013d0 <Init_IMU+0x2dc>
 8001344:	eef4 7ac7 	vcmpe.f32	s15, s14
 8001348:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800134c:	d506      	bpl.n	800135c <Init_IMU+0x268>
 800134e:	ed9f 7a1f 	vldr	s14, [pc, #124]	; 80013cc <Init_IMU+0x2d8>
 8001352:	4b19      	ldr	r3, [pc, #100]	; (80013b8 <Init_IMU+0x2c4>)
 8001354:	ee77 7a87 	vadd.f32	s15, s15, s14
 8001358:	edc3 7a01 	vstr	s15, [r3, #4]
		IMU_Euler_to_DCM(&IMU, &eulerTemp);
 800135c:	4808      	ldr	r0, [pc, #32]	; (8001380 <Init_IMU+0x28c>)
 800135e:	4919      	ldr	r1, [pc, #100]	; (80013c4 <Init_IMU+0x2d0>)
 8001360:	f7ff f8d0 	bl	8000504 <IMU_Euler_to_DCM>
	CtrlStates.copterStatus |= IMU_READY_FLAG;

	//xNextWakeTime = xTaskGetTickCount();

	/* Set the DRIVE Flag! */
	CtrlStates.copterStatus |= ARMED_FLAG;
 8001364:	7a33      	ldrb	r3, [r6, #8]
 8001366:	f043 0303 	orr.w	r3, r3, #3
 800136a:	7233      	strb	r3, [r6, #8]
 800136c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8001370:	60000000 	.word	0x60000000
 8001374:	3ff92196 	.word	0x3ff92196
 8001378:	200032c8 	.word	0x200032c8
 800137c:	20002f04 	.word	0x20002f04
 8001380:	200031f8 	.word	0x200031f8
 8001384:	20002f70 	.word	0x20002f70
 8001388:	20003270 	.word	0x20003270
 800138c:	2000329c 	.word	0x2000329c
 8001390:	200032f8 	.word	0x200032f8
 8001394:	20002fa8 	.word	0x20002fa8
 8001398:	3b03126f 	.word	0x3b03126f
 800139c:	39d1b717 	.word	0x39d1b717
 80013a0:	20000490 	.word	0x20000490
 80013a4:	3d8f5c29 	.word	0x3d8f5c29
 80013a8:	48000800 	.word	0x48000800
 80013ac:	be19999a 	.word	0xbe19999a
 80013b0:	3e19999a 	.word	0x3e19999a
 80013b4:	08009d10 	.word	0x08009d10
 80013b8:	20002f64 	.word	0x20002f64
 80013bc:	200004ac 	.word	0x200004ac
 80013c0:	42652ee0 	.word	0x42652ee0
 80013c4:	20002f9c 	.word	0x20002f9c
 80013c8:	43340000 	.word	0x43340000
 80013cc:	43b40000 	.word	0x43b40000
 80013d0:	c3340000 	.word	0xc3340000

080013d4 <IMU_Calculation>:

}


void IMU_Calculation()
{
 80013d4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	 */

	//GPIOC->ODR |= GPIO_Pin_11;	// Set Debug Pin


		Gyro_readValues(&gyroXYZ);
 80013d8:	4cbb      	ldr	r4, [pc, #748]	; (80016c8 <IMU_Calculation+0x2f4>)
		gyroXYZ.gyroValueX = ((gyroXYZ.gyroValueX-gyroOffset.gyroValueX));
		gyroXYZ.gyroValueY = ((gyroXYZ.gyroValueY-gyroOffset.gyroValueY));
		gyroXYZ.gyroValueZ = ((gyroXYZ.gyroValueZ-gyroOffset.gyroValueZ));

		/* Cut-off the lower values to reduce noise and fail-integration*/
		if(gyroXYZ.gyroValueX > -GlobalSettings.gyroSensTreshold && gyroXYZ.gyroValueX < GlobalSettings.gyroSensTreshold) gyroXYZ.gyroValueX = 0;
 80013da:	4ebc      	ldr	r6, [pc, #752]	; (80016cc <IMU_Calculation+0x2f8>)
	 */

	//GPIOC->ODR |= GPIO_Pin_11;	// Set Debug Pin


		Gyro_readValues(&gyroXYZ);
 80013dc:	f104 0008 	add.w	r0, r4, #8
 80013e0:	f7ff f9af 	bl	8000742 <Gyro_readValues>
		gyroXYZ.gyroValueX = ((gyroXYZ.gyroValueX-gyroOffset.gyroValueX));
 80013e4:	8925      	ldrh	r5, [r4, #8]
 80013e6:	8823      	ldrh	r3, [r4, #0]
		gyroXYZ.gyroValueY = ((gyroXYZ.gyroValueY-gyroOffset.gyroValueY));
 80013e8:	8960      	ldrh	r0, [r4, #10]
		gyroXYZ.gyroValueZ = ((gyroXYZ.gyroValueZ-gyroOffset.gyroValueZ));
 80013ea:	89a1      	ldrh	r1, [r4, #12]

	//GPIOC->ODR |= GPIO_Pin_11;	// Set Debug Pin


		Gyro_readValues(&gyroXYZ);
		gyroXYZ.gyroValueX = ((gyroXYZ.gyroValueX-gyroOffset.gyroValueX));
 80013ec:	1aed      	subs	r5, r5, r3
		gyroXYZ.gyroValueY = ((gyroXYZ.gyroValueY-gyroOffset.gyroValueY));
 80013ee:	8863      	ldrh	r3, [r4, #2]
 80013f0:	1ac0      	subs	r0, r0, r3
		gyroXYZ.gyroValueZ = ((gyroXYZ.gyroValueZ-gyroOffset.gyroValueZ));
 80013f2:	88a3      	ldrh	r3, [r4, #4]
 80013f4:	1ac9      	subs	r1, r1, r3

		/* Cut-off the lower values to reduce noise and fail-integration*/
		if(gyroXYZ.gyroValueX > -GlobalSettings.gyroSensTreshold && gyroXYZ.gyroValueX < GlobalSettings.gyroSensTreshold) gyroXYZ.gyroValueX = 0;
 80013f6:	8833      	ldrh	r3, [r6, #0]

	//GPIOC->ODR |= GPIO_Pin_11;	// Set Debug Pin


		Gyro_readValues(&gyroXYZ);
		gyroXYZ.gyroValueX = ((gyroXYZ.gyroValueX-gyroOffset.gyroValueX));
 80013f8:	b2ad      	uxth	r5, r5
 80013fa:	8125      	strh	r5, [r4, #8]
		gyroXYZ.gyroValueY = ((gyroXYZ.gyroValueY-gyroOffset.gyroValueY));
		gyroXYZ.gyroValueZ = ((gyroXYZ.gyroValueZ-gyroOffset.gyroValueZ));

		/* Cut-off the lower values to reduce noise and fail-integration*/
		if(gyroXYZ.gyroValueX > -GlobalSettings.gyroSensTreshold && gyroXYZ.gyroValueX < GlobalSettings.gyroSensTreshold) gyroXYZ.gyroValueX = 0;
 80013fc:	425a      	negs	r2, r3
 80013fe:	b22d      	sxth	r5, r5
	//GPIOC->ODR |= GPIO_Pin_11;	// Set Debug Pin


		Gyro_readValues(&gyroXYZ);
		gyroXYZ.gyroValueX = ((gyroXYZ.gyroValueX-gyroOffset.gyroValueX));
		gyroXYZ.gyroValueY = ((gyroXYZ.gyroValueY-gyroOffset.gyroValueY));
 8001400:	b280      	uxth	r0, r0
		gyroXYZ.gyroValueZ = ((gyroXYZ.gyroValueZ-gyroOffset.gyroValueZ));
 8001402:	b289      	uxth	r1, r1

		/* Cut-off the lower values to reduce noise and fail-integration*/
		if(gyroXYZ.gyroValueX > -GlobalSettings.gyroSensTreshold && gyroXYZ.gyroValueX < GlobalSettings.gyroSensTreshold) gyroXYZ.gyroValueX = 0;
 8001404:	4295      	cmp	r5, r2
	//GPIOC->ODR |= GPIO_Pin_11;	// Set Debug Pin


		Gyro_readValues(&gyroXYZ);
		gyroXYZ.gyroValueX = ((gyroXYZ.gyroValueX-gyroOffset.gyroValueX));
		gyroXYZ.gyroValueY = ((gyroXYZ.gyroValueY-gyroOffset.gyroValueY));
 8001406:	8160      	strh	r0, [r4, #10]
		gyroXYZ.gyroValueZ = ((gyroXYZ.gyroValueZ-gyroOffset.gyroValueZ));
 8001408:	81a1      	strh	r1, [r4, #12]

		/* Cut-off the lower values to reduce noise and fail-integration*/
		if(gyroXYZ.gyroValueX > -GlobalSettings.gyroSensTreshold && gyroXYZ.gyroValueX < GlobalSettings.gyroSensTreshold) gyroXYZ.gyroValueX = 0;
 800140a:	dd03      	ble.n	8001414 <IMU_Calculation+0x40>
 800140c:	429d      	cmp	r5, r3
 800140e:	bfbc      	itt	lt
 8001410:	2500      	movlt	r5, #0
 8001412:	8125      	strhlt	r5, [r4, #8]
		if(gyroXYZ.gyroValueY > -GlobalSettings.gyroSensTreshold && gyroXYZ.gyroValueY < GlobalSettings.gyroSensTreshold) gyroXYZ.gyroValueY = 0;
 8001414:	b200      	sxth	r0, r0
 8001416:	4290      	cmp	r0, r2
 8001418:	dd03      	ble.n	8001422 <IMU_Calculation+0x4e>
 800141a:	4298      	cmp	r0, r3
 800141c:	bfbc      	itt	lt
 800141e:	2000      	movlt	r0, #0
 8001420:	8160      	strhlt	r0, [r4, #10]
		if(gyroXYZ.gyroValueZ > -GlobalSettings.gyroSensTreshold && gyroXYZ.gyroValueZ < GlobalSettings.gyroSensTreshold) gyroXYZ.gyroValueZ = 0;
 8001422:	b209      	sxth	r1, r1
 8001424:	4291      	cmp	r1, r2
 8001426:	dd03      	ble.n	8001430 <IMU_Calculation+0x5c>
 8001428:	4299      	cmp	r1, r3
 800142a:	bfbc      	itt	lt
 800142c:	2300      	movlt	r3, #0
 800142e:	81a3      	strhlt	r3, [r4, #12]

		floatFilterGyro(&xGyroFiltered_float, gyroXYZ.gyroValueX);
 8001430:	f8df b2bc 	ldr.w	fp, [pc, #700]	; 80016f0 <IMU_Calculation+0x31c>
		floatFilterGyro(&yGyroFiltered_float, gyroXYZ.gyroValueY);
 8001434:	f8df a2bc 	ldr.w	sl, [pc, #700]	; 80016f4 <IMU_Calculation+0x320>
		/* Cut-off the lower values to reduce noise and fail-integration*/
		if(gyroXYZ.gyroValueX > -GlobalSettings.gyroSensTreshold && gyroXYZ.gyroValueX < GlobalSettings.gyroSensTreshold) gyroXYZ.gyroValueX = 0;
		if(gyroXYZ.gyroValueY > -GlobalSettings.gyroSensTreshold && gyroXYZ.gyroValueY < GlobalSettings.gyroSensTreshold) gyroXYZ.gyroValueY = 0;
		if(gyroXYZ.gyroValueZ > -GlobalSettings.gyroSensTreshold && gyroXYZ.gyroValueZ < GlobalSettings.gyroSensTreshold) gyroXYZ.gyroValueZ = 0;

		floatFilterGyro(&xGyroFiltered_float, gyroXYZ.gyroValueX);
 8001438:	f9b4 1008 	ldrsh.w	r1, [r4, #8]
		floatFilterGyro(&yGyroFiltered_float, gyroXYZ.gyroValueY);
		floatFilterGyro(&zGyroFiltered_float, gyroXYZ.gyroValueZ);
 800143c:	f8df 92b8 	ldr.w	r9, [pc, #696]	; 80016f8 <IMU_Calculation+0x324>

		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] = GlobalSettings.gyroDir.sensDirection[sensX]*(xGyroFiltered_float.currentValue*GYROCONVERT)*DEG_TO_RAD;
 8001440:	4da3      	ldr	r5, [pc, #652]	; (80016d0 <IMU_Calculation+0x2fc>)
		/* Cut-off the lower values to reduce noise and fail-integration*/
		if(gyroXYZ.gyroValueX > -GlobalSettings.gyroSensTreshold && gyroXYZ.gyroValueX < GlobalSettings.gyroSensTreshold) gyroXYZ.gyroValueX = 0;
		if(gyroXYZ.gyroValueY > -GlobalSettings.gyroSensTreshold && gyroXYZ.gyroValueY < GlobalSettings.gyroSensTreshold) gyroXYZ.gyroValueY = 0;
		if(gyroXYZ.gyroValueZ > -GlobalSettings.gyroSensTreshold && gyroXYZ.gyroValueZ < GlobalSettings.gyroSensTreshold) gyroXYZ.gyroValueZ = 0;

		floatFilterGyro(&xGyroFiltered_float, gyroXYZ.gyroValueX);
 8001442:	4fa1      	ldr	r7, [pc, #644]	; (80016c8 <IMU_Calculation+0x2f4>)
		floatFilterGyro(&yGyroFiltered_float, gyroXYZ.gyroValueY);
		floatFilterGyro(&zGyroFiltered_float, gyroXYZ.gyroValueZ);

		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] = GlobalSettings.gyroDir.sensDirection[sensX]*(xGyroFiltered_float.currentValue*GYROCONVERT)*DEG_TO_RAD;
 8001444:	f8df 8284 	ldr.w	r8, [pc, #644]	; 80016cc <IMU_Calculation+0x2f8>
		/* Cut-off the lower values to reduce noise and fail-integration*/
		if(gyroXYZ.gyroValueX > -GlobalSettings.gyroSensTreshold && gyroXYZ.gyroValueX < GlobalSettings.gyroSensTreshold) gyroXYZ.gyroValueX = 0;
		if(gyroXYZ.gyroValueY > -GlobalSettings.gyroSensTreshold && gyroXYZ.gyroValueY < GlobalSettings.gyroSensTreshold) gyroXYZ.gyroValueY = 0;
		if(gyroXYZ.gyroValueZ > -GlobalSettings.gyroSensTreshold && gyroXYZ.gyroValueZ < GlobalSettings.gyroSensTreshold) gyroXYZ.gyroValueZ = 0;

		floatFilterGyro(&xGyroFiltered_float, gyroXYZ.gyroValueX);
 8001448:	4658      	mov	r0, fp
 800144a:	f000 fc75 	bl	8001d38 <floatFilterGyro>
		floatFilterGyro(&yGyroFiltered_float, gyroXYZ.gyroValueY);
 800144e:	4650      	mov	r0, sl
 8001450:	f9b4 100a 	ldrsh.w	r1, [r4, #10]
 8001454:	f000 fc70 	bl	8001d38 <floatFilterGyro>
		floatFilterGyro(&zGyroFiltered_float, gyroXYZ.gyroValueZ);
 8001458:	4648      	mov	r0, r9
 800145a:	f9b4 100c 	ldrsh.w	r1, [r4, #12]
 800145e:	f000 fc6b 	bl	8001d38 <floatFilterGyro>

		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] = GlobalSettings.gyroDir.sensDirection[sensX]*(xGyroFiltered_float.currentValue*GYROCONVERT)*DEG_TO_RAD;
 8001462:	f996 2007 	ldrsb.w	r2, [r6, #7]
 8001466:	ed9f 7a9b 	vldr	s14, [pc, #620]	; 80016d4 <IMU_Calculation+0x300>
 800146a:	eddb 7a0a 	vldr	s15, [fp, #40]	; 0x28
 800146e:	7933      	ldrb	r3, [r6, #4]
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] = GlobalSettings.gyroDir.sensDirection[sensY]*(yGyroFiltered_float.currentValue*GYROCONVERT)*DEG_TO_RAD;
 8001470:	f996 e008 	ldrsb.w	lr, [r6, #8]
 8001474:	ed9a 6a0a 	vldr	s12, [sl, #40]	; 0x28

		floatFilterGyro(&xGyroFiltered_float, gyroXYZ.gyroValueX);
		floatFilterGyro(&yGyroFiltered_float, gyroXYZ.gyroValueY);
		floatFilterGyro(&zGyroFiltered_float, gyroXYZ.gyroValueZ);

		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] = GlobalSettings.gyroDir.sensDirection[sensX]*(xGyroFiltered_float.currentValue*GYROCONVERT)*DEG_TO_RAD;
 8001478:	ee06 2a90 	vmov	s13, r2
 800147c:	ee67 7a87 	vmul.f32	s15, s15, s14
 8001480:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 8001484:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 8001488:	ee66 6aa7 	vmul.f32	s13, s13, s15
 800148c:	eddf 7a92 	vldr	s15, [pc, #584]	; 80016d8 <IMU_Calculation+0x304>
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] = GlobalSettings.gyroDir.sensDirection[sensY]*(yGyroFiltered_float.currentValue*GYROCONVERT)*DEG_TO_RAD;
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] = GlobalSettings.gyroDir.sensDirection[sensZ]*(zGyroFiltered_float.currentValue*GYROCONVERT)*DEG_TO_RAD;
 8001490:	f996 2009 	ldrsb.w	r2, [r6, #9]

		floatFilterGyro(&xGyroFiltered_float, gyroXYZ.gyroValueX);
		floatFilterGyro(&yGyroFiltered_float, gyroXYZ.gyroValueY);
		floatFilterGyro(&zGyroFiltered_float, gyroXYZ.gyroValueZ);

		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] = GlobalSettings.gyroDir.sensDirection[sensX]*(xGyroFiltered_float.currentValue*GYROCONVERT)*DEG_TO_RAD;
 8001494:	ee66 6aa7 	vmul.f32	s13, s13, s15
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] = GlobalSettings.gyroDir.sensDirection[sensY]*(yGyroFiltered_float.currentValue*GYROCONVERT)*DEG_TO_RAD;
 8001498:	ee26 6a07 	vmul.f32	s12, s12, s14

		floatFilterGyro(&xGyroFiltered_float, gyroXYZ.gyroValueX);
		floatFilterGyro(&yGyroFiltered_float, gyroXYZ.gyroValueY);
		floatFilterGyro(&zGyroFiltered_float, gyroXYZ.gyroValueZ);

		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] = GlobalSettings.gyroDir.sensDirection[sensX]*(xGyroFiltered_float.currentValue*GYROCONVERT)*DEG_TO_RAD;
 800149c:	edc3 6a0a 	vstr	s13, [r3, #40]	; 0x28
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] = GlobalSettings.gyroDir.sensDirection[sensY]*(yGyroFiltered_float.currentValue*GYROCONVERT)*DEG_TO_RAD;
 80014a0:	ee06 ea90 	vmov	s13, lr
 80014a4:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 80014a8:	7973      	ldrb	r3, [r6, #5]
 80014aa:	ee66 6a86 	vmul.f32	s13, s13, s12
 80014ae:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 80014b2:	ee66 6aa7 	vmul.f32	s13, s13, s15
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] = GlobalSettings.gyroDir.sensDirection[sensZ]*(zGyroFiltered_float.currentValue*GYROCONVERT)*DEG_TO_RAD;
 80014b6:	ed99 6a0a 	vldr	s12, [r9, #40]	; 0x28
		floatFilterGyro(&xGyroFiltered_float, gyroXYZ.gyroValueX);
		floatFilterGyro(&yGyroFiltered_float, gyroXYZ.gyroValueY);
		floatFilterGyro(&zGyroFiltered_float, gyroXYZ.gyroValueZ);

		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] = GlobalSettings.gyroDir.sensDirection[sensX]*(xGyroFiltered_float.currentValue*GYROCONVERT)*DEG_TO_RAD;
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] = GlobalSettings.gyroDir.sensDirection[sensY]*(yGyroFiltered_float.currentValue*GYROCONVERT)*DEG_TO_RAD;
 80014ba:	edc3 6a0a 	vstr	s13, [r3, #40]	; 0x28
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] = GlobalSettings.gyroDir.sensDirection[sensZ]*(zGyroFiltered_float.currentValue*GYROCONVERT)*DEG_TO_RAD;
 80014be:	ee06 2a90 	vmov	s13, r2
 80014c2:	ee26 7a07 	vmul.f32	s14, s12, s14
 80014c6:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 80014ca:	79b3      	ldrb	r3, [r6, #6]
 80014cc:	ee26 7a87 	vmul.f32	s14, s13, s14
 80014d0:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 80014d4:	ee67 7a27 	vmul.f32	s15, s14, s15
 80014d8:	edc3 7a0a 	vstr	s15, [r3, #40]	; 0x28

		/*Here the ACC-Compensation, we do this in every tenth round*/
		if(GlobalSettings.enableACC)
 80014dc:	7af3      	ldrb	r3, [r6, #11]
 80014de:	2b00      	cmp	r3, #0
 80014e0:	f000 809c 	beq.w	800161c <IMU_Calculation+0x248>
		{
			if(accCount >= 5)
 80014e4:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 80014e8:	2b04      	cmp	r3, #4
 80014ea:	f240 8092 	bls.w	8001612 <IMU_Calculation+0x23e>
//
//				accXYZ.accValueX = ADC_GetInjectedConversionValue(ADC2,ADC_InjectedSequence_2)-1700;
//				accXYZ.accValueZ = ADC_GetInjectedConversionValue(ADC2,ADC_InjectedSequence_1)-1700;
//				accXYZ.accValueY = ADC_GetInjectedConversionValue(ADC2,ADC_InjectedSequence_3)-1700;

				floatFilterAcc(&xAccFiltered_float, accXYZ.accValueX);
 80014ee:	f8df b20c 	ldr.w	fp, [pc, #524]	; 80016fc <IMU_Calculation+0x328>
		{
			if(accCount >= 5)
			{
				//ADXL345_readValues(&accXYZ);
				//LSM303DLHC_ACC_readValues(&accXYZ);
				LSM303DLHC_ACC_readValuesDMA(&accXYZ, &accBuffer[0]);
 80014f2:	497a      	ldr	r1, [pc, #488]	; (80016dc <IMU_Calculation+0x308>)
//				accXYZ.accValueX = ADC_GetInjectedConversionValue(ADC2,ADC_InjectedSequence_2)-1700;
//				accXYZ.accValueZ = ADC_GetInjectedConversionValue(ADC2,ADC_InjectedSequence_1)-1700;
//				accXYZ.accValueY = ADC_GetInjectedConversionValue(ADC2,ADC_InjectedSequence_3)-1700;

				floatFilterAcc(&xAccFiltered_float, accXYZ.accValueX);
				floatFilterAcc(&yAccFiltered_float, accXYZ.accValueY);
 80014f4:	f8df a208 	ldr.w	sl, [pc, #520]	; 8001700 <IMU_Calculation+0x32c>
				floatFilterAcc(&zAccFiltered_float, accXYZ.accValueZ);
 80014f8:	f8df 9208 	ldr.w	r9, [pc, #520]	; 8001704 <IMU_Calculation+0x330>
		{
			if(accCount >= 5)
			{
				//ADXL345_readValues(&accXYZ);
				//LSM303DLHC_ACC_readValues(&accXYZ);
				LSM303DLHC_ACC_readValuesDMA(&accXYZ, &accBuffer[0]);
 80014fc:	f107 0010 	add.w	r0, r7, #16
 8001500:	f7ff fb07 	bl	8000b12 <LSM303DLHC_ACC_readValuesDMA>
//
//				accXYZ.accValueX = ADC_GetInjectedConversionValue(ADC2,ADC_InjectedSequence_2)-1700;
//				accXYZ.accValueZ = ADC_GetInjectedConversionValue(ADC2,ADC_InjectedSequence_1)-1700;
//				accXYZ.accValueY = ADC_GetInjectedConversionValue(ADC2,ADC_InjectedSequence_3)-1700;

				floatFilterAcc(&xAccFiltered_float, accXYZ.accValueX);
 8001504:	4658      	mov	r0, fp
 8001506:	f9b7 1010 	ldrsh.w	r1, [r7, #16]
 800150a:	f000 fbd1 	bl	8001cb0 <floatFilterAcc>
				floatFilterAcc(&yAccFiltered_float, accXYZ.accValueY);
 800150e:	4650      	mov	r0, sl
 8001510:	f9b7 1012 	ldrsh.w	r1, [r7, #18]
 8001514:	f000 fbcc 	bl	8001cb0 <floatFilterAcc>
				floatFilterAcc(&zAccFiltered_float, accXYZ.accValueZ);
 8001518:	4648      	mov	r0, r9
 800151a:	f9b7 1014 	ldrsh.w	r1, [r7, #20]
 800151e:	f000 fbc7 	bl	8001cb0 <floatFilterAcc>

				if((xAccFiltered_float.currentValue < accXYZ.accGValue) && (xAccFiltered_float.currentValue > -accXYZ.accGValue) &&
 8001522:	ed9b 6a0a 	vldr	s12, [fp, #40]	; 0x28
 8001526:	edd7 7a06 	vldr	s15, [r7, #24]
 800152a:	486d      	ldr	r0, [pc, #436]	; (80016e0 <IMU_Calculation+0x30c>)
 800152c:	496d      	ldr	r1, [pc, #436]	; (80016e4 <IMU_Calculation+0x310>)
 800152e:	4a6e      	ldr	r2, [pc, #440]	; (80016e8 <IMU_Calculation+0x314>)
 8001530:	eeb4 6ae7 	vcmpe.f32	s12, s15
 8001534:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001538:	d55b      	bpl.n	80015f2 <IMU_Calculation+0x21e>
 800153a:	eef1 5a67 	vneg.f32	s11, s15
 800153e:	eeb4 6ae5 	vcmpe.f32	s12, s11
 8001542:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001546:	dd54      	ble.n	80015f2 <IMU_Calculation+0x21e>
				   (yAccFiltered_float.currentValue < accXYZ.accGValue) && (yAccFiltered_float.currentValue > -accXYZ.accGValue) &&
 8001548:	edda 6a0a 	vldr	s13, [sl, #40]	; 0x28

				floatFilterAcc(&xAccFiltered_float, accXYZ.accValueX);
				floatFilterAcc(&yAccFiltered_float, accXYZ.accValueY);
				floatFilterAcc(&zAccFiltered_float, accXYZ.accValueZ);

				if((xAccFiltered_float.currentValue < accXYZ.accGValue) && (xAccFiltered_float.currentValue > -accXYZ.accGValue) &&
 800154c:	eef4 6ae7 	vcmpe.f32	s13, s15
 8001550:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001554:	d54d      	bpl.n	80015f2 <IMU_Calculation+0x21e>
				   (yAccFiltered_float.currentValue < accXYZ.accGValue) && (yAccFiltered_float.currentValue > -accXYZ.accGValue) &&
 8001556:	eef4 6ae5 	vcmpe.f32	s13, s11
 800155a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800155e:	dd48      	ble.n	80015f2 <IMU_Calculation+0x21e>
				   (zAccFiltered_float.currentValue < accXYZ.accGValue) && (zAccFiltered_float.currentValue > -accXYZ.accGValue))
 8001560:	ed99 7a0a 	vldr	s14, [r9, #40]	; 0x28
				floatFilterAcc(&xAccFiltered_float, accXYZ.accValueX);
				floatFilterAcc(&yAccFiltered_float, accXYZ.accValueY);
				floatFilterAcc(&zAccFiltered_float, accXYZ.accValueZ);

				if((xAccFiltered_float.currentValue < accXYZ.accGValue) && (xAccFiltered_float.currentValue > -accXYZ.accGValue) &&
				   (yAccFiltered_float.currentValue < accXYZ.accGValue) && (yAccFiltered_float.currentValue > -accXYZ.accGValue) &&
 8001564:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8001568:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800156c:	d541      	bpl.n	80015f2 <IMU_Calculation+0x21e>
				   (zAccFiltered_float.currentValue < accXYZ.accGValue) && (zAccFiltered_float.currentValue > -accXYZ.accGValue))
 800156e:	eeb4 7ae5 	vcmpe.f32	s14, s11
 8001572:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001576:	dd3c      	ble.n	80015f2 <IMU_Calculation+0x21e>
				{
					/*Direction setup is the same as above*/
					IMU.accel_vector[GlobalSettings.accDir.sensOrder[sensX]] = GlobalSettings.accDir.sensDirection[sensX]*xAccFiltered_float.currentValue;
 8001578:	f998 300f 	ldrsb.w	r3, [r8, #15]
					IMU.accel_vector[GlobalSettings.accDir.sensOrder[sensY]] = GlobalSettings.accDir.sensDirection[sensY]*yAccFiltered_float.currentValue;
 800157c:	f998 e010 	ldrsb.w	lr, [r8, #16]
				if((xAccFiltered_float.currentValue < accXYZ.accGValue) && (xAccFiltered_float.currentValue > -accXYZ.accGValue) &&
				   (yAccFiltered_float.currentValue < accXYZ.accGValue) && (yAccFiltered_float.currentValue > -accXYZ.accGValue) &&
				   (zAccFiltered_float.currentValue < accXYZ.accGValue) && (zAccFiltered_float.currentValue > -accXYZ.accGValue))
				{
					/*Direction setup is the same as above*/
					IMU.accel_vector[GlobalSettings.accDir.sensOrder[sensX]] = GlobalSettings.accDir.sensDirection[sensX]*xAccFiltered_float.currentValue;
 8001580:	f898 700c 	ldrb.w	r7, [r8, #12]
 8001584:	ee07 3a90 	vmov	s15, r3
 8001588:	eef8 7ae7 	vcvt.f32.s32	s15, s15
					IMU.accel_vector[GlobalSettings.accDir.sensOrder[sensY]] = GlobalSettings.accDir.sensDirection[sensY]*yAccFiltered_float.currentValue;
 800158c:	f898 300d 	ldrb.w	r3, [r8, #13]
				if((xAccFiltered_float.currentValue < accXYZ.accGValue) && (xAccFiltered_float.currentValue > -accXYZ.accGValue) &&
				   (yAccFiltered_float.currentValue < accXYZ.accGValue) && (yAccFiltered_float.currentValue > -accXYZ.accGValue) &&
				   (zAccFiltered_float.currentValue < accXYZ.accGValue) && (zAccFiltered_float.currentValue > -accXYZ.accGValue))
				{
					/*Direction setup is the same as above*/
					IMU.accel_vector[GlobalSettings.accDir.sensOrder[sensX]] = GlobalSettings.accDir.sensDirection[sensX]*xAccFiltered_float.currentValue;
 8001590:	ee27 6a86 	vmul.f32	s12, s15, s12
					IMU.accel_vector[GlobalSettings.accDir.sensOrder[sensY]] = GlobalSettings.accDir.sensDirection[sensY]*yAccFiltered_float.currentValue;
 8001594:	ee07 ea90 	vmov	s15, lr
					IMU.accel_vector[GlobalSettings.accDir.sensOrder[sensZ]] = GlobalSettings.accDir.sensDirection[sensZ]*zAccFiltered_float.currentValue;
 8001598:	f998 e011 	ldrsb.w	lr, [r8, #17]
				   (yAccFiltered_float.currentValue < accXYZ.accGValue) && (yAccFiltered_float.currentValue > -accXYZ.accGValue) &&
				   (zAccFiltered_float.currentValue < accXYZ.accGValue) && (zAccFiltered_float.currentValue > -accXYZ.accGValue))
				{
					/*Direction setup is the same as above*/
					IMU.accel_vector[GlobalSettings.accDir.sensOrder[sensX]] = GlobalSettings.accDir.sensDirection[sensX]*xAccFiltered_float.currentValue;
					IMU.accel_vector[GlobalSettings.accDir.sensOrder[sensY]] = GlobalSettings.accDir.sensDirection[sensY]*yAccFiltered_float.currentValue;
 800159c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
				if((xAccFiltered_float.currentValue < accXYZ.accGValue) && (xAccFiltered_float.currentValue > -accXYZ.accGValue) &&
				   (yAccFiltered_float.currentValue < accXYZ.accGValue) && (yAccFiltered_float.currentValue > -accXYZ.accGValue) &&
				   (zAccFiltered_float.currentValue < accXYZ.accGValue) && (zAccFiltered_float.currentValue > -accXYZ.accGValue))
				{
					/*Direction setup is the same as above*/
					IMU.accel_vector[GlobalSettings.accDir.sensOrder[sensX]] = GlobalSettings.accDir.sensDirection[sensX]*xAccFiltered_float.currentValue;
 80015a0:	370c      	adds	r7, #12
					IMU.accel_vector[GlobalSettings.accDir.sensOrder[sensY]] = GlobalSettings.accDir.sensDirection[sensY]*yAccFiltered_float.currentValue;
 80015a2:	ee67 6aa6 	vmul.f32	s13, s15, s13
					IMU.accel_vector[GlobalSettings.accDir.sensOrder[sensZ]] = GlobalSettings.accDir.sensDirection[sensZ]*zAccFiltered_float.currentValue;
 80015a6:	ee07 ea90 	vmov	s15, lr
 80015aa:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80015ae:	f898 e00e 	ldrb.w	lr, [r8, #14]
 80015b2:	ee27 7a87 	vmul.f32	s14, s15, s14
				   (yAccFiltered_float.currentValue < accXYZ.accGValue) && (yAccFiltered_float.currentValue > -accXYZ.accGValue) &&
				   (zAccFiltered_float.currentValue < accXYZ.accGValue) && (zAccFiltered_float.currentValue > -accXYZ.accGValue))
				{
					/*Direction setup is the same as above*/
					IMU.accel_vector[GlobalSettings.accDir.sensOrder[sensX]] = GlobalSettings.accDir.sensDirection[sensX]*xAccFiltered_float.currentValue;
					IMU.accel_vector[GlobalSettings.accDir.sensOrder[sensY]] = GlobalSettings.accDir.sensDirection[sensY]*yAccFiltered_float.currentValue;
 80015b6:	330c      	adds	r3, #12
				if((xAccFiltered_float.currentValue < accXYZ.accGValue) && (xAccFiltered_float.currentValue > -accXYZ.accGValue) &&
				   (yAccFiltered_float.currentValue < accXYZ.accGValue) && (yAccFiltered_float.currentValue > -accXYZ.accGValue) &&
				   (zAccFiltered_float.currentValue < accXYZ.accGValue) && (zAccFiltered_float.currentValue > -accXYZ.accGValue))
				{
					/*Direction setup is the same as above*/
					IMU.accel_vector[GlobalSettings.accDir.sensOrder[sensX]] = GlobalSettings.accDir.sensDirection[sensX]*xAccFiltered_float.currentValue;
 80015b8:	eb05 0787 	add.w	r7, r5, r7, lsl #2
					IMU.accel_vector[GlobalSettings.accDir.sensOrder[sensY]] = GlobalSettings.accDir.sensDirection[sensY]*yAccFiltered_float.currentValue;
 80015bc:	eb05 0383 	add.w	r3, r5, r3, lsl #2
					IMU.accel_vector[GlobalSettings.accDir.sensOrder[sensZ]] = GlobalSettings.accDir.sensDirection[sensZ]*zAccFiltered_float.currentValue;
 80015c0:	eb05 0e8e 	add.w	lr, r5, lr, lsl #2
				if((xAccFiltered_float.currentValue < accXYZ.accGValue) && (xAccFiltered_float.currentValue > -accXYZ.accGValue) &&
				   (yAccFiltered_float.currentValue < accXYZ.accGValue) && (yAccFiltered_float.currentValue > -accXYZ.accGValue) &&
				   (zAccFiltered_float.currentValue < accXYZ.accGValue) && (zAccFiltered_float.currentValue > -accXYZ.accGValue))
				{
					/*Direction setup is the same as above*/
					IMU.accel_vector[GlobalSettings.accDir.sensOrder[sensX]] = GlobalSettings.accDir.sensDirection[sensX]*xAccFiltered_float.currentValue;
 80015c4:	ed87 6a01 	vstr	s12, [r7, #4]
					IMU.accel_vector[GlobalSettings.accDir.sensOrder[sensY]] = GlobalSettings.accDir.sensDirection[sensY]*yAccFiltered_float.currentValue;
 80015c8:	edc3 6a01 	vstr	s13, [r3, #4]
					IMU.accel_vector[GlobalSettings.accDir.sensOrder[sensZ]] = GlobalSettings.accDir.sensDirection[sensZ]*zAccFiltered_float.currentValue;
 80015cc:	ed8e 7a0d 	vstr	s14, [lr, #52]	; 0x34

					xTemp = (int)IMU.accel_vector[GlobalSettings.accDir.sensOrder[sensX]];
 80015d0:	edd7 7a01 	vldr	s15, [r7, #4]
 80015d4:	eefd 7ae7 	vcvt.s32.f32	s15, s15
					yTemp = (int)IMU.accel_vector[GlobalSettings.accDir.sensOrder[sensY]];
					zTemp = (int)IMU.accel_vector[GlobalSettings.accDir.sensOrder[sensZ]];
 80015d8:	eebd 7ac7 	vcvt.s32.f32	s14, s14
					/*Direction setup is the same as above*/
					IMU.accel_vector[GlobalSettings.accDir.sensOrder[sensX]] = GlobalSettings.accDir.sensDirection[sensX]*xAccFiltered_float.currentValue;
					IMU.accel_vector[GlobalSettings.accDir.sensOrder[sensY]] = GlobalSettings.accDir.sensDirection[sensY]*yAccFiltered_float.currentValue;
					IMU.accel_vector[GlobalSettings.accDir.sensOrder[sensZ]] = GlobalSettings.accDir.sensDirection[sensZ]*zAccFiltered_float.currentValue;

					xTemp = (int)IMU.accel_vector[GlobalSettings.accDir.sensOrder[sensX]];
 80015dc:	edc0 7a00 	vstr	s15, [r0]
					yTemp = (int)IMU.accel_vector[GlobalSettings.accDir.sensOrder[sensY]];
 80015e0:	edd3 7a01 	vldr	s15, [r3, #4]
					zTemp = (int)IMU.accel_vector[GlobalSettings.accDir.sensOrder[sensZ]];
 80015e4:	ed82 7a00 	vstr	s14, [r2]
					IMU.accel_vector[GlobalSettings.accDir.sensOrder[sensX]] = GlobalSettings.accDir.sensDirection[sensX]*xAccFiltered_float.currentValue;
					IMU.accel_vector[GlobalSettings.accDir.sensOrder[sensY]] = GlobalSettings.accDir.sensDirection[sensY]*yAccFiltered_float.currentValue;
					IMU.accel_vector[GlobalSettings.accDir.sensOrder[sensZ]] = GlobalSettings.accDir.sensDirection[sensZ]*zAccFiltered_float.currentValue;

					xTemp = (int)IMU.accel_vector[GlobalSettings.accDir.sensOrder[sensX]];
					yTemp = (int)IMU.accel_vector[GlobalSettings.accDir.sensOrder[sensY]];
 80015e8:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80015ec:	edc1 7a00 	vstr	s15, [r1]
					zTemp = (int)IMU.accel_vector[GlobalSettings.accDir.sensOrder[sensZ]];
 80015f0:	e007      	b.n	8001602 <IMU_Calculation+0x22e>
				}
				else
				{
					IMU.kp_vector_ACC[0] = 0;
 80015f2:	2300      	movs	r3, #0
 80015f4:	662b      	str	r3, [r5, #96]	; 0x60
					IMU.kp_vector_ACC[1] = 0;
 80015f6:	666b      	str	r3, [r5, #100]	; 0x64
					IMU.kp_vector_ACC[2] = 0;
 80015f8:	66ab      	str	r3, [r5, #104]	; 0x68

					xTemp = 0;
 80015fa:	2300      	movs	r3, #0
 80015fc:	6003      	str	r3, [r0, #0]
					yTemp = 0;
 80015fe:	600b      	str	r3, [r1, #0]
					zTemp = 0;
 8001600:	6013      	str	r3, [r2, #0]
				}

				//printf("%d %d %d\n\r", (int)(IMU.accel_vector[0]*30),(int)(IMU.accel_vector[1]*30), (int)(IMU.accel_vector[2]*30));

				if(GlobalSettings.enableDriftCorrection)
 8001602:	7ab3      	ldrb	r3, [r6, #10]
 8001604:	b113      	cbz	r3, 800160c <IMU_Calculation+0x238>
				{
					IMU_drift_correction_ACC(&IMU);
 8001606:	4832      	ldr	r0, [pc, #200]	; (80016d0 <IMU_Calculation+0x2fc>)
 8001608:	f7fe fec5 	bl	8000396 <IMU_drift_correction_ACC>
				}
				accCount = 0;
 800160c:	2300      	movs	r3, #0
 800160e:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
			}
			accCount++;
 8001612:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
 8001616:	3301      	adds	r3, #1
 8001618:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
		}

		/*Here the Mag-Compensation, we do this in every 45 round*/
		if(GlobalSettings.enableMAG)
 800161c:	7e33      	ldrb	r3, [r6, #24]
 800161e:	4f2b      	ldr	r7, [pc, #172]	; (80016cc <IMU_Calculation+0x2f8>)
 8001620:	2b00      	cmp	r3, #0
 8001622:	d042      	beq.n	80016aa <IMU_Calculation+0x2d6>
		{
			if(magCount >= 45)
 8001624:	f894 3023 	ldrb.w	r3, [r4, #35]	; 0x23
 8001628:	4e27      	ldr	r6, [pc, #156]	; (80016c8 <IMU_Calculation+0x2f4>)
 800162a:	2b2c      	cmp	r3, #44	; 0x2c
 800162c:	d938      	bls.n	80016a0 <IMU_Calculation+0x2cc>
			{
				Mag_readValues(&magXYZ);
 800162e:	f106 001c 	add.w	r0, r6, #28
 8001632:	f7ff faaf 	bl	8000b94 <Mag_readValues>
				update_intFilter(&xMagFiltered, GlobalSettings.magLowpassValue, (magXYZ.magValueX));
 8001636:	f106 0024 	add.w	r0, r6, #36	; 0x24
 800163a:	8c39      	ldrh	r1, [r7, #32]
 800163c:	f9b6 201c 	ldrsh.w	r2, [r6, #28]
 8001640:	f000 fa38 	bl	8001ab4 <update_intFilter>
				update_intFilter(&yMagFiltered, GlobalSettings.magLowpassValue, (magXYZ.magValueY));
 8001644:	8c39      	ldrh	r1, [r7, #32]
 8001646:	f9b6 201e 	ldrsh.w	r2, [r6, #30]
 800164a:	f106 002c 	add.w	r0, r6, #44	; 0x2c
 800164e:	f000 fa31 	bl	8001ab4 <update_intFilter>

				/*Direction setup is the same as above*/
				IMU.mag_vector[GlobalSettings.magDir.sensOrder[sensX]] = GlobalSettings.magDir.sensDirection[sensX]*xMagFiltered.filtered;
 8001652:	f997 101c 	ldrsb.w	r1, [r7, #28]
 8001656:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 8001658:	7e7a      	ldrb	r2, [r7, #25]
 800165a:	434b      	muls	r3, r1
 800165c:	ee07 3a10 	vmov	s14, r3
 8001660:	eef8 7ac7 	vcvt.f32.s32	s15, s14
 8001664:	eb05 0282 	add.w	r2, r5, r2, lsl #2
 8001668:	edc2 7a10 	vstr	s15, [r2, #64]	; 0x40
				IMU.mag_vector[GlobalSettings.magDir.sensOrder[sensY]] = GlobalSettings.magDir.sensDirection[sensY]*yMagFiltered.filtered;
 800166c:	6b31      	ldr	r1, [r6, #48]	; 0x30
 800166e:	f997 201d 	ldrsb.w	r2, [r7, #29]
 8001672:	7ebb      	ldrb	r3, [r7, #26]
 8001674:	434a      	muls	r2, r1
 8001676:	ee07 2a10 	vmov	s14, r2
 800167a:	eef8 7ac7 	vcvt.f32.s32	s15, s14
 800167e:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 8001682:	edc3 7a10 	vstr	s15, [r3, #64]	; 0x40
				//IMU.mag_vector[GlobalSettings.magDir.sensOrder[sensZ]] = GlobalSettings.magDir.sensDirection[sensZ]*zMagFiltered;
				IMU.mag_vector[GlobalSettings.magDir.sensOrder[sensZ]] = 0;
 8001686:	7efb      	ldrb	r3, [r7, #27]
 8001688:	eb05 0583 	add.w	r5, r5, r3, lsl #2
 800168c:	2300      	movs	r3, #0
 800168e:	642b      	str	r3, [r5, #64]	; 0x40

				if(GlobalSettings.enableDriftCorrection)
 8001690:	7abb      	ldrb	r3, [r7, #10]
 8001692:	b113      	cbz	r3, 800169a <IMU_Calculation+0x2c6>
				{
					IMU_drift_correction_MAG(&IMU);
 8001694:	480e      	ldr	r0, [pc, #56]	; (80016d0 <IMU_Calculation+0x2fc>)
 8001696:	f7fe fec9 	bl	800042c <IMU_drift_correction_MAG>
				}
				magCount = 0;
 800169a:	2300      	movs	r3, #0
 800169c:	f884 3023 	strb.w	r3, [r4, #35]	; 0x23
				//printf("%d,%d\n\r", (int)xMagFiltered.filtered, (int)yMagFiltered.filtered);
			}
			magCount++;
 80016a0:	f894 3023 	ldrb.w	r3, [r4, #35]	; 0x23
 80016a4:	3301      	adds	r3, #1
 80016a6:	f884 3023 	strb.w	r3, [r4, #35]	; 0x23
		}

		/*This functions here do the DCM-Algorithm stuff*/
		IMU_update(&IMU);
 80016aa:	4809      	ldr	r0, [pc, #36]	; (80016d0 <IMU_Calculation+0x2fc>)
 80016ac:	f7fe fd92 	bl	80001d4 <IMU_update>
		IMU_ortho_adjust(&IMU);
 80016b0:	4807      	ldr	r0, [pc, #28]	; (80016d0 <IMU_Calculation+0x2fc>)
 80016b2:	f7fe fe40 	bl	8000336 <IMU_ortho_adjust>
		IMU_normalize(&IMU);
 80016b6:	4806      	ldr	r0, [pc, #24]	; (80016d0 <IMU_Calculation+0x2fc>)
 80016b8:	f7fe fdda 	bl	8000270 <IMU_normalize>
		//Euler_angles(&DCM);
		//IMU_DCM_to_Euler_deg(&IMU, &euler);
		IMU_DCM_to_XYZ(&IMU, &XYZ);
 80016bc:	4804      	ldr	r0, [pc, #16]	; (80016d0 <IMU_Calculation+0x2fc>)
 80016be:	490b      	ldr	r1, [pc, #44]	; (80016ec <IMU_Calculation+0x318>)

		//GPIOC->ODR &= ~GPIO_Pin_11; // Clear Debug Pin

}
 80016c0:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
		IMU_update(&IMU);
		IMU_ortho_adjust(&IMU);
		IMU_normalize(&IMU);
		//Euler_angles(&DCM);
		//IMU_DCM_to_Euler_deg(&IMU, &euler);
		IMU_DCM_to_XYZ(&IMU, &XYZ);
 80016c4:	f7fe bf7e 	b.w	80005c4 <IMU_DCM_to_XYZ>
 80016c8:	20000490 	.word	0x20000490
 80016cc:	20002f04 	.word	0x20002f04
 80016d0:	200031f8 	.word	0x200031f8
 80016d4:	3d8f5c29 	.word	0x3d8f5c29
 80016d8:	3c8efa35 	.word	0x3c8efa35
 80016dc:	20002fd8 	.word	0x20002fd8
 80016e0:	200031f4 	.word	0x200031f4
 80016e4:	20002fd4 	.word	0x20002fd4
 80016e8:	200033b0 	.word	0x200033b0
 80016ec:	20002ef8 	.word	0x20002ef8
 80016f0:	200032c8 	.word	0x200032c8
 80016f4:	20002f70 	.word	0x20002f70
 80016f8:	20003270 	.word	0x20003270
 80016fc:	2000329c 	.word	0x2000329c
 8001700:	200032f8 	.word	0x200032f8
 8001704:	20002fa8 	.word	0x20002fa8

08001708 <PositionController>:

float Setpoint_Y = 0.0f;
float Setpoint_Z = 0.0f;

void PositionController()
{
 8001708:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	//** PID Calculation Test
	static uint8_t Fault = 1;

	if(CtrlStates.copterStatus & ARMED_FLAG )
 800170c:	4b93      	ldr	r3, [pc, #588]	; (800195c <PositionController+0x254>)
 800170e:	4c94      	ldr	r4, [pc, #592]	; (8001960 <PositionController+0x258>)
 8001710:	7a18      	ldrb	r0, [r3, #8]
 8001712:	4d94      	ldr	r5, [pc, #592]	; (8001964 <PositionController+0x25c>)
 8001714:	4f94      	ldr	r7, [pc, #592]	; (8001968 <PositionController+0x260>)
 8001716:	4e95      	ldr	r6, [pc, #596]	; (800196c <PositionController+0x264>)
 8001718:	f010 0901 	ands.w	r9, r0, #1

float Setpoint_Y = 0.0f;
float Setpoint_Z = 0.0f;

void PositionController()
{
 800171c:	b085      	sub	sp, #20
	//** PID Calculation Test
	static uint8_t Fault = 1;

	if(CtrlStates.copterStatus & ARMED_FLAG )
 800171e:	f000 80f2 	beq.w	8001906 <PositionController+0x1fe>

		float Roll;

		/* !!! TODO: Implement Timeout !!! */
		/* Get Controll Values */
		if(It_Com.rxready == 1)
 8001722:	4a93      	ldr	r2, [pc, #588]	; (8001970 <PositionController+0x268>)
 8001724:	f8d2 1200 	ldr.w	r1, [r2, #512]	; 0x200
 8001728:	2901      	cmp	r1, #1
 800172a:	d106      	bne.n	800173a <PositionController+0x32>
		{
			It_Com.rxready = 0;
 800172c:	2100      	movs	r1, #0
 800172e:	f8c2 1200 	str.w	r1, [r2, #512]	; 0x200
			memcpy(&CtrlStates.pitch, &It_Com.rxbuffer[4], 4);
 8001732:	6851      	ldr	r1, [r2, #4]
			memcpy(&CtrlStates.yaw, &It_Com.rxbuffer[8], 4);
 8001734:	6892      	ldr	r2, [r2, #8]
		/* !!! TODO: Implement Timeout !!! */
		/* Get Controll Values */
		if(It_Com.rxready == 1)
		{
			It_Com.rxready = 0;
			memcpy(&CtrlStates.pitch, &It_Com.rxbuffer[4], 4);
 8001736:	6019      	str	r1, [r3, #0]
			memcpy(&CtrlStates.yaw, &It_Com.rxbuffer[8], 4);
 8001738:	605a      	str	r2, [r3, #4]
			memcpy(&Roll, &It_Com.rxbuffer[12], 4);
		}
		/* Calc Setpoint Z */
		Setpoint_Y = MiddelPos + CtrlStates.pitch/10.0f;
 800173a:	edd3 0a00 	vldr	s1, [r3]
 800173e:	f8df 8240 	ldr.w	r8, [pc, #576]	; 8001980 <PositionController+0x278>
 8001742:	eef2 7a04 	vmov.f32	s15, #36	; 0x24
 8001746:	eec0 0aa7 	vdiv.f32	s1, s1, s15
 800174a:	eef1 7a06 	vmov.f32	s15, #22
 800174e:	ee70 0aa7 	vadd.f32	s1, s1, s15

		/* Integrate YAW Position */
		if(CtrlStates.yaw > 12.0f || CtrlStates.yaw < -12.0f )
 8001752:	edd3 7a01 	vldr	s15, [r3, #4]
			memcpy(&CtrlStates.pitch, &It_Com.rxbuffer[4], 4);
			memcpy(&CtrlStates.yaw, &It_Com.rxbuffer[8], 4);
			memcpy(&Roll, &It_Com.rxbuffer[12], 4);
		}
		/* Calc Setpoint Z */
		Setpoint_Y = MiddelPos + CtrlStates.pitch/10.0f;
 8001756:	edc4 0a0d 	vstr	s1, [r4, #52]	; 0x34

		/* Integrate YAW Position */
		if(CtrlStates.yaw > 12.0f || CtrlStates.yaw < -12.0f )
 800175a:	eeb2 7a08 	vmov.f32	s14, #40	; 0x28
 800175e:	eef4 7ac7 	vcmpe.f32	s15, s14
 8001762:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001766:	dc06      	bgt.n	8001776 <PositionController+0x6e>
 8001768:	eeba 7a08 	vmov.f32	s14, #168	; 0xa8
 800176c:	eef4 7ac7 	vcmpe.f32	s15, s14
 8001770:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001774:	d50b      	bpl.n	800178e <PositionController+0x86>
			Setpoint_Z += CtrlStates.yaw * PID_Z.sampling_rate*0.7f;
 8001776:	edd8 6a00 	vldr	s13, [r8]
 800177a:	ed9f 7a7e 	vldr	s14, [pc, #504]	; 8001974 <PositionController+0x26c>
 800177e:	ee67 6aa6 	vmul.f32	s13, s15, s13
 8001782:	edd4 7a0e 	vldr	s15, [r4, #56]	; 0x38
 8001786:	eee6 7a87 	vfma.f32	s15, s13, s14
 800178a:	edc4 7a0e 	vstr	s15, [r4, #56]	; 0x38

		/* Correct Angular */
		if(Setpoint_Z > 179.9f) Setpoint_Z = -179.9f;
 800178e:	ed94 7a0e 	vldr	s14, [r4, #56]	; 0x38
 8001792:	eddf 7a79 	vldr	s15, [pc, #484]	; 8001978 <PositionController+0x270>
#endif // Fuzzy Controller

#ifdef PIDSmithPredictorController

		//calc_PID_SmithPredictor(XYZ.y, 4.8f, &PID_Position, &Smith_Position);
		calc_PID(XYZ.y, Setpoint_Y, &PID_Y);
 8001796:	f8df 91f4 	ldr.w	r9, [pc, #500]	; 800198c <PositionController+0x284>
 800179a:	ed95 0a01 	vldr	s0, [r5, #4]
		/* Integrate YAW Position */
		if(CtrlStates.yaw > 12.0f || CtrlStates.yaw < -12.0f )
			Setpoint_Z += CtrlStates.yaw * PID_Z.sampling_rate*0.7f;

		/* Correct Angular */
		if(Setpoint_Z > 179.9f) Setpoint_Z = -179.9f;
 800179e:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80017a2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80017a6:	bfc8      	it	gt
 80017a8:	4b6d      	ldrgt	r3, [pc, #436]	; (8001960 <PositionController+0x258>)
 80017aa:	eeb0 7a67 	vmov.f32	s14, s15
 80017ae:	eddf 7a73 	vldr	s15, [pc, #460]	; 800197c <PositionController+0x274>
 80017b2:	bfc8      	it	gt
 80017b4:	edc3 7a0e 	vstrgt	s15, [r3, #56]	; 0x38
		if(Setpoint_Z < -179.9f) Setpoint_Z = 179.9f;
 80017b8:	edd4 6a0e 	vldr	s13, [r4, #56]	; 0x38
 80017bc:	eef4 6ae7 	vcmpe.f32	s13, s15
 80017c0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80017c4:	bf48      	it	mi
 80017c6:	4b66      	ldrmi	r3, [pc, #408]	; (8001960 <PositionController+0x258>)
#endif // Fuzzy Controller

#ifdef PIDSmithPredictorController

		//calc_PID_SmithPredictor(XYZ.y, 4.8f, &PID_Position, &Smith_Position);
		calc_PID(XYZ.y, Setpoint_Y, &PID_Y);
 80017c8:	4648      	mov	r0, r9
		if(CtrlStates.yaw > 12.0f || CtrlStates.yaw < -12.0f )
			Setpoint_Z += CtrlStates.yaw * PID_Z.sampling_rate*0.7f;

		/* Correct Angular */
		if(Setpoint_Z > 179.9f) Setpoint_Z = -179.9f;
		if(Setpoint_Z < -179.9f) Setpoint_Z = 179.9f;
 80017ca:	bf48      	it	mi
 80017cc:	ed83 7a0e 	vstrmi	s14, [r3, #56]	; 0x38
#endif // Fuzzy Controller

#ifdef PIDSmithPredictorController

		//calc_PID_SmithPredictor(XYZ.y, 4.8f, &PID_Position, &Smith_Position);
		calc_PID(XYZ.y, Setpoint_Y, &PID_Y);
 80017d0:	f7ff fac0 	bl	8000d54 <calc_PID>
		calc_PID_YAW(XYZ.z, Setpoint_Z, &PID_Z);
 80017d4:	486a      	ldr	r0, [pc, #424]	; (8001980 <PositionController+0x278>)
 80017d6:	ed95 0a02 	vldr	s0, [r5, #8]
 80017da:	edd4 0a0e 	vldr	s1, [r4, #56]	; 0x38
 80017de:	f7ff fbd5 	bl	8000f8c <calc_PID_YAW>

		/*  */
	//	if(PID_Z.y < 0.0f){
			MOT0 = GlobalSettings.stopSpeed - PID_Y.y + PID_Z.y; 	//+ PID_Z.y;  //- PID_Y.y + PID_Z.y;
 80017e2:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 80017e4:	edd9 7a01 	vldr	s15, [r9, #4]
		//	MOT1 = GlobalSettings.stopSpeed - PID_Y.y + PID_Z.y; 	//- PID_Z.y;  //- PID_Z.y;  //- PID_Y.y - PID_Z.y;
	//	}

		// MOT1 = MOT0 = GlobalSettings.stopSpeed - CtrlStates.yaw;

		if(MOT0 < GlobalSettings.minSpeed) MOT0 = GlobalSettings.minSpeed;
 80017e8:	8cba      	ldrh	r2, [r7, #36]	; 0x24
		calc_PID(XYZ.y, Setpoint_Y, &PID_Y);
		calc_PID_YAW(XYZ.z, Setpoint_Z, &PID_Z);

		/*  */
	//	if(PID_Z.y < 0.0f){
			MOT0 = GlobalSettings.stopSpeed - PID_Y.y + PID_Z.y; 	//+ PID_Z.y;  //- PID_Y.y + PID_Z.y;
 80017ea:	ee07 3a10 	vmov	s14, r3
 80017ee:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 80017f2:	ee37 7a67 	vsub.f32	s14, s14, s15
 80017f6:	edd8 7a01 	vldr	s15, [r8, #4]
 80017fa:	ee77 6a27 	vadd.f32	s13, s14, s15
			MOT1 = GlobalSettings.stopSpeed - PID_Y.y - PID_Z.y;  //- PID_Z.y;  //- PID_Y.y - PID_Z.y;
 80017fe:	ee77 7a67 	vsub.f32	s15, s14, s15
		calc_PID(XYZ.y, Setpoint_Y, &PID_Y);
		calc_PID_YAW(XYZ.z, Setpoint_Z, &PID_Z);

		/*  */
	//	if(PID_Z.y < 0.0f){
			MOT0 = GlobalSettings.stopSpeed - PID_Y.y + PID_Z.y; 	//+ PID_Z.y;  //- PID_Y.y + PID_Z.y;
 8001802:	eefc 6ae6 	vcvt.u32.f32	s13, s13
			MOT1 = GlobalSettings.stopSpeed - PID_Y.y - PID_Z.y;  //- PID_Z.y;  //- PID_Y.y - PID_Z.y;
 8001806:	eefc 7ae7 	vcvt.u32.f32	s15, s15
		calc_PID(XYZ.y, Setpoint_Y, &PID_Y);
		calc_PID_YAW(XYZ.z, Setpoint_Z, &PID_Z);

		/*  */
	//	if(PID_Z.y < 0.0f){
			MOT0 = GlobalSettings.stopSpeed - PID_Y.y + PID_Z.y; 	//+ PID_Z.y;  //- PID_Y.y + PID_Z.y;
 800180a:	ee16 3a90 	vmov	r3, s13
 800180e:	b29b      	uxth	r3, r3
		//	MOT1 = GlobalSettings.stopSpeed - PID_Y.y + PID_Z.y; 	//- PID_Z.y;  //- PID_Z.y;  //- PID_Y.y - PID_Z.y;
	//	}

		// MOT1 = MOT0 = GlobalSettings.stopSpeed - CtrlStates.yaw;

		if(MOT0 < GlobalSettings.minSpeed) MOT0 = GlobalSettings.minSpeed;
 8001810:	4293      	cmp	r3, r2
		calc_PID(XYZ.y, Setpoint_Y, &PID_Y);
		calc_PID_YAW(XYZ.z, Setpoint_Z, &PID_Z);

		/*  */
	//	if(PID_Z.y < 0.0f){
			MOT0 = GlobalSettings.stopSpeed - PID_Y.y + PID_Z.y; 	//+ PID_Z.y;  //- PID_Y.y + PID_Z.y;
 8001812:	87a3      	strh	r3, [r4, #60]	; 0x3c
		//	MOT1 = GlobalSettings.stopSpeed - PID_Y.y + PID_Z.y; 	//- PID_Z.y;  //- PID_Z.y;  //- PID_Y.y - PID_Z.y;
	//	}

		// MOT1 = MOT0 = GlobalSettings.stopSpeed - CtrlStates.yaw;

		if(MOT0 < GlobalSettings.minSpeed) MOT0 = GlobalSettings.minSpeed;
 8001814:	bf38      	it	cc
 8001816:	4b52      	ldrcc	r3, [pc, #328]	; (8001960 <PositionController+0x258>)

		/* Test */
		static uint8_t i = 0;

		/* Out Zone */
		if( (XYZ.y > 40.0f) || (XYZ.y < (-40.0f)) ||
 8001818:	ed9f 7a5a 	vldr	s14, [pc, #360]	; 8001984 <PositionController+0x27c>
		//	MOT1 = GlobalSettings.stopSpeed - PID_Y.y + PID_Z.y; 	//- PID_Z.y;  //- PID_Z.y;  //- PID_Y.y - PID_Z.y;
	//	}

		// MOT1 = MOT0 = GlobalSettings.stopSpeed - CtrlStates.yaw;

		if(MOT0 < GlobalSettings.minSpeed) MOT0 = GlobalSettings.minSpeed;
 800181c:	bf38      	it	cc
 800181e:	879a      	strhcc	r2, [r3, #60]	; 0x3c
		if(MOT0 > GlobalSettings.maxSpeed) MOT0 = GlobalSettings.maxSpeed;
 8001820:	8fa0      	ldrh	r0, [r4, #60]	; 0x3c
 8001822:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
		calc_PID_YAW(XYZ.z, Setpoint_Z, &PID_Z);

		/*  */
	//	if(PID_Z.y < 0.0f){
			MOT0 = GlobalSettings.stopSpeed - PID_Y.y + PID_Z.y; 	//+ PID_Z.y;  //- PID_Y.y + PID_Z.y;
			MOT1 = GlobalSettings.stopSpeed - PID_Y.y - PID_Z.y;  //- PID_Z.y;  //- PID_Y.y - PID_Z.y;
 8001824:	ee17 1a90 	vmov	r1, s15
	//	}

		// MOT1 = MOT0 = GlobalSettings.stopSpeed - CtrlStates.yaw;

		if(MOT0 < GlobalSettings.minSpeed) MOT0 = GlobalSettings.minSpeed;
		if(MOT0 > GlobalSettings.maxSpeed) MOT0 = GlobalSettings.maxSpeed;
 8001828:	4298      	cmp	r0, r3
 800182a:	bf88      	it	hi
 800182c:	484c      	ldrhi	r0, [pc, #304]	; (8001960 <PositionController+0x258>)

		/* Test */
		static uint8_t i = 0;

		/* Out Zone */
		if( (XYZ.y > 40.0f) || (XYZ.y < (-40.0f)) ||
 800182e:	edd5 7a01 	vldr	s15, [r5, #4]
	//	}

		// MOT1 = MOT0 = GlobalSettings.stopSpeed - CtrlStates.yaw;

		if(MOT0 < GlobalSettings.minSpeed) MOT0 = GlobalSettings.minSpeed;
		if(MOT0 > GlobalSettings.maxSpeed) MOT0 = GlobalSettings.maxSpeed;
 8001832:	bf88      	it	hi
 8001834:	8783      	strhhi	r3, [r0, #60]	; 0x3c
		calc_PID_YAW(XYZ.z, Setpoint_Z, &PID_Z);

		/*  */
	//	if(PID_Z.y < 0.0f){
			MOT0 = GlobalSettings.stopSpeed - PID_Y.y + PID_Z.y; 	//+ PID_Z.y;  //- PID_Y.y + PID_Z.y;
			MOT1 = GlobalSettings.stopSpeed - PID_Y.y - PID_Z.y;  //- PID_Z.y;  //- PID_Y.y - PID_Z.y;
 8001836:	b289      	uxth	r1, r1
		// MOT1 = MOT0 = GlobalSettings.stopSpeed - CtrlStates.yaw;

		if(MOT0 < GlobalSettings.minSpeed) MOT0 = GlobalSettings.minSpeed;
		if(MOT0 > GlobalSettings.maxSpeed) MOT0 = GlobalSettings.maxSpeed;

		if(MOT1 < GlobalSettings.minSpeed) MOT1 = GlobalSettings.minSpeed;
 8001838:	4291      	cmp	r1, r2
		calc_PID_YAW(XYZ.z, Setpoint_Z, &PID_Z);

		/*  */
	//	if(PID_Z.y < 0.0f){
			MOT0 = GlobalSettings.stopSpeed - PID_Y.y + PID_Z.y; 	//+ PID_Z.y;  //- PID_Y.y + PID_Z.y;
			MOT1 = GlobalSettings.stopSpeed - PID_Y.y - PID_Z.y;  //- PID_Z.y;  //- PID_Y.y - PID_Z.y;
 800183a:	87e1      	strh	r1, [r4, #62]	; 0x3e
		// MOT1 = MOT0 = GlobalSettings.stopSpeed - CtrlStates.yaw;

		if(MOT0 < GlobalSettings.minSpeed) MOT0 = GlobalSettings.minSpeed;
		if(MOT0 > GlobalSettings.maxSpeed) MOT0 = GlobalSettings.maxSpeed;

		if(MOT1 < GlobalSettings.minSpeed) MOT1 = GlobalSettings.minSpeed;
 800183c:	bf38      	it	cc
 800183e:	87e2      	strhcc	r2, [r4, #62]	; 0x3e
		if(MOT1 > GlobalSettings.maxSpeed) MOT1 = GlobalSettings.maxSpeed;
 8001840:	8fe2      	ldrh	r2, [r4, #62]	; 0x3e
 8001842:	429a      	cmp	r2, r3
 8001844:	bf88      	it	hi
 8001846:	4a46      	ldrhi	r2, [pc, #280]	; (8001960 <PositionController+0x258>)

		/* Test */
		static uint8_t i = 0;

		/* Out Zone */
		if( (XYZ.y > 40.0f) || (XYZ.y < (-40.0f)) ||
 8001848:	eef4 7ac7 	vcmpe.f32	s15, s14

		if(MOT0 < GlobalSettings.minSpeed) MOT0 = GlobalSettings.minSpeed;
		if(MOT0 > GlobalSettings.maxSpeed) MOT0 = GlobalSettings.maxSpeed;

		if(MOT1 < GlobalSettings.minSpeed) MOT1 = GlobalSettings.minSpeed;
		if(MOT1 > GlobalSettings.maxSpeed) MOT1 = GlobalSettings.maxSpeed;
 800184c:	bf88      	it	hi
 800184e:	87d3      	strhhi	r3, [r2, #62]	; 0x3e

		/* Test */
		static uint8_t i = 0;

		/* Out Zone */
		if( (XYZ.y > 40.0f) || (XYZ.y < (-40.0f)) ||
 8001850:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001854:	dc17      	bgt.n	8001886 <PositionController+0x17e>
 8001856:	ed9f 7a4c 	vldr	s14, [pc, #304]	; 8001988 <PositionController+0x280>
 800185a:	eef4 7ac7 	vcmpe.f32	s15, s14
 800185e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001862:	d410      	bmi.n	8001886 <PositionController+0x17e>
			(XYZ.x > 30.0f) || (XYZ.x < (-30.0f))	) Fault = 1;
 8001864:	4b3f      	ldr	r3, [pc, #252]	; (8001964 <PositionController+0x25c>)
 8001866:	ed93 7a00 	vldr	s14, [r3]

		/* Test */
		static uint8_t i = 0;

		/* Out Zone */
		if( (XYZ.y > 40.0f) || (XYZ.y < (-40.0f)) ||
 800186a:	eef3 6a0e 	vmov.f32	s13, #62	; 0x3e
 800186e:	eeb4 7ae6 	vcmpe.f32	s14, s13
 8001872:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001876:	dc06      	bgt.n	8001886 <PositionController+0x17e>
			(XYZ.x > 30.0f) || (XYZ.x < (-30.0f))	) Fault = 1;
 8001878:	eefb 6a0e 	vmov.f32	s13, #190	; 0xbe
 800187c:	eeb4 7ae6 	vcmpe.f32	s14, s13
 8001880:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001884:	d501      	bpl.n	800188a <PositionController+0x182>
 8001886:	2301      	movs	r3, #1
 8001888:	7033      	strb	r3, [r6, #0]


		/* Secure Zone */
		if( (XYZ.y < 20.0f && XYZ.y > (-20.0f) ) && Fault == 1 ){
 800188a:	eeb3 7a04 	vmov.f32	s14, #52	; 0x34
 800188e:	eef4 7ac7 	vcmpe.f32	s15, s14
 8001892:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8001896:	d51e      	bpl.n	80018d6 <PositionController+0x1ce>
 8001898:	eebb 7a04 	vmov.f32	s14, #180	; 0xb4
 800189c:	eef4 7ac7 	vcmpe.f32	s15, s14
 80018a0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80018a4:	dd17      	ble.n	80018d6 <PositionController+0x1ce>
 80018a6:	7833      	ldrb	r3, [r6, #0]
 80018a8:	2b01      	cmp	r3, #1
 80018aa:	d114      	bne.n	80018d6 <PositionController+0x1ce>
			i++;
 80018ac:	f894 3040 	ldrb.w	r3, [r4, #64]	; 0x40
 80018b0:	3301      	adds	r3, #1
 80018b2:	b2db      	uxtb	r3, r3
			if(i > 180) {
 80018b4:	2bb4      	cmp	r3, #180	; 0xb4
			(XYZ.x > 30.0f) || (XYZ.x < (-30.0f))	) Fault = 1;


		/* Secure Zone */
		if( (XYZ.y < 20.0f && XYZ.y > (-20.0f) ) && Fault == 1 ){
			i++;
 80018b6:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
			if(i > 180) {
 80018ba:	d90f      	bls.n	80018dc <PositionController+0x1d4>
				resetIntegralValues_PID(&PID_Y);
 80018bc:	4833      	ldr	r0, [pc, #204]	; (800198c <PositionController+0x284>)
 80018be:	f7ff fa43 	bl	8000d48 <resetIntegralValues_PID>
				resetIntegralValues_PID(&PID_Z);
 80018c2:	482f      	ldr	r0, [pc, #188]	; (8001980 <PositionController+0x278>)
 80018c4:	f7ff fa40 	bl	8000d48 <resetIntegralValues_PID>
				Setpoint_Z = XYZ.z;
 80018c8:	4b25      	ldr	r3, [pc, #148]	; (8001960 <PositionController+0x258>)
 80018ca:	68aa      	ldr	r2, [r5, #8]
 80018cc:	639a      	str	r2, [r3, #56]	; 0x38
				Fault = 0;
 80018ce:	4b27      	ldr	r3, [pc, #156]	; (800196c <PositionController+0x264>)
 80018d0:	2200      	movs	r2, #0
 80018d2:	701a      	strb	r2, [r3, #0]
 80018d4:	e002      	b.n	80018dc <PositionController+0x1d4>
			}
		}else i = 0;
 80018d6:	2300      	movs	r3, #0
 80018d8:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40

		/* Check Fault Status */
		if(Fault == 1) Disable_Motor();
 80018dc:	7833      	ldrb	r3, [r6, #0]
 80018de:	2b01      	cmp	r3, #1
 80018e0:	d102      	bne.n	80018e8 <PositionController+0x1e0>
 80018e2:	f7ff fa11 	bl	8000d08 <Disable_Motor>
 80018e6:	e001      	b.n	80018ec <PositionController+0x1e4>
		else Enable_Motor();
 80018e8:	f7ff f9fe 	bl	8000ce8 <Enable_Motor>

		// Disable Interrupts
		taskENTER_CRITICAL();
 80018ec:	f004 f81e 	bl	800592c <vPortEnterCritical>

		PWM_Motor(0, MOT0);
 80018f0:	8fa1      	ldrh	r1, [r4, #60]	; 0x3c
 80018f2:	2000      	movs	r0, #0
 80018f4:	f7ff f9dc 	bl	8000cb0 <PWM_Motor>
		PWM_Motor(1, MOT1);
 80018f8:	2001      	movs	r0, #1
 80018fa:	8fe1      	ldrh	r1, [r4, #62]	; 0x3e
 80018fc:	f7ff f9d8 	bl	8000cb0 <PWM_Motor>

		taskEXIT_CRITICAL();
 8001900:	f004 f825 	bl	800594e <vPortExitCritical>
 8001904:	e014      	b.n	8001930 <PositionController+0x228>

#endif

	}	else
	{
		resetIntegralValues_PID(&PID_Y);
 8001906:	4821      	ldr	r0, [pc, #132]	; (800198c <PositionController+0x284>)
 8001908:	f7ff fa1e 	bl	8000d48 <resetIntegralValues_PID>
		resetIntegralValues_PID(&PID_Z);
 800190c:	481c      	ldr	r0, [pc, #112]	; (8001980 <PositionController+0x278>)
 800190e:	f7ff fa1b 	bl	8000d48 <resetIntegralValues_PID>
		Fault = 1;
 8001912:	f04f 0801 	mov.w	r8, #1

		Setpoint_Z = XYZ.z;

		MOT0 = (uint16_t)GlobalSettings.stopSpeed;
 8001916:	8c79      	ldrh	r1, [r7, #34]	; 0x22
	{
		resetIntegralValues_PID(&PID_Y);
		resetIntegralValues_PID(&PID_Z);
		Fault = 1;

		Setpoint_Z = XYZ.z;
 8001918:	68ab      	ldr	r3, [r5, #8]

		MOT0 = (uint16_t)GlobalSettings.stopSpeed;
 800191a:	87a1      	strh	r1, [r4, #60]	; 0x3c

		PWM_Motor(0, MOT0);
 800191c:	4648      	mov	r0, r9

	}	else
	{
		resetIntegralValues_PID(&PID_Y);
		resetIntegralValues_PID(&PID_Z);
		Fault = 1;
 800191e:	f886 8000 	strb.w	r8, [r6]

		Setpoint_Z = XYZ.z;
 8001922:	63a3      	str	r3, [r4, #56]	; 0x38

		MOT0 = (uint16_t)GlobalSettings.stopSpeed;

		PWM_Motor(0, MOT0);
 8001924:	f7ff f9c4 	bl	8000cb0 <PWM_Motor>
		PWM_Motor(1, MOT0);
 8001928:	4640      	mov	r0, r8
 800192a:	8fa1      	ldrh	r1, [r4, #60]	; 0x3c
 800192c:	f7ff f9c0 	bl	8000cb0 <PWM_Motor>
	}



	uint32_t Header = 0xFF7F3F1F;
 8001930:	4b17      	ldr	r3, [pc, #92]	; (8001990 <PositionController+0x288>)
 8001932:	9302      	str	r3, [sp, #8]

	static uint16_t foo = 0;
	foo++;
 8001934:	f8b4 3042 	ldrh.w	r3, [r4, #66]	; 0x42

	uint32_t foobar = MOT0;

	// SendBufferedDataFrame(&It_Com ,&Header, &XYZ.y, &PID_Z.Isum, &foobar, 12);
	SendBufferedDataFrame(&It_Com ,&Header, &XYZ.y, &XYZ.x, &foobar, 2);
 8001938:	4a16      	ldr	r2, [pc, #88]	; (8001994 <PositionController+0x28c>)
 800193a:	480d      	ldr	r0, [pc, #52]	; (8001970 <PositionController+0x268>)


	uint32_t Header = 0xFF7F3F1F;

	static uint16_t foo = 0;
	foo++;
 800193c:	3301      	adds	r3, #1
 800193e:	f8a4 3042 	strh.w	r3, [r4, #66]	; 0x42

	uint32_t foobar = MOT0;
 8001942:	8fa3      	ldrh	r3, [r4, #60]	; 0x3c
 8001944:	9303      	str	r3, [sp, #12]

	// SendBufferedDataFrame(&It_Com ,&Header, &XYZ.y, &PID_Z.Isum, &foobar, 12);
	SendBufferedDataFrame(&It_Com ,&Header, &XYZ.y, &XYZ.x, &foobar, 2);
 8001946:	ab03      	add	r3, sp, #12
 8001948:	9300      	str	r3, [sp, #0]
 800194a:	2302      	movs	r3, #2
 800194c:	9301      	str	r3, [sp, #4]
 800194e:	a902      	add	r1, sp, #8
 8001950:	1f13      	subs	r3, r2, #4
 8001952:	f001 f9a5 	bl	8002ca0 <SendBufferedDataFrame>
	//}

	//float delayoutvalue = CalcDelay(&Smith_Position, 1.0f);

	// **** End Test
}
 8001956:	b005      	add	sp, #20
 8001958:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800195c:	20002f64 	.word	0x20002f64
 8001960:	20000490 	.word	0x20000490
 8001964:	20002ef8 	.word	0x20002ef8
 8001968:	20002f04 	.word	0x20002f04
 800196c:	20000000 	.word	0x20000000
 8001970:	20002fe0 	.word	0x20002fe0
 8001974:	3f333333 	.word	0x3f333333
 8001978:	4333e666 	.word	0x4333e666
 800197c:	c333e666 	.word	0xc333e666
 8001980:	200033b4 	.word	0x200033b4
 8001984:	42200000 	.word	0x42200000
 8001988:	c2200000 	.word	0xc2200000
 800198c:	20003388 	.word	0x20003388
 8001990:	ff7f3f1f 	.word	0xff7f3f1f
 8001994:	20002efc 	.word	0x20002efc

08001998 <VectorDotProduct>:
#include <Vector_math.h>


//Computes the dot product of two vectors 
float VectorDotProduct(float vector1[3],float vector2[3]) 
{   
 8001998:	b510      	push	{r4, lr}
	int c = 0;
	float op=0;      
 800199a:	ed9f 0a07 	vldr	s0, [pc, #28]	; 80019b8 <VectorDotProduct+0x20>
#include <Vector_math.h>


//Computes the dot product of two vectors 
float VectorDotProduct(float vector1[3],float vector2[3]) 
{   
 800199e:	2300      	movs	r3, #0
 80019a0:	18c4      	adds	r4, r0, r3
 80019a2:	18ca      	adds	r2, r1, r3
	int c = 0;
	float op=0;      
	for( c = 0 ; c < 3 ; c++ )   
	{   
		op += vector1[c] * vector2[c];   
 80019a4:	ed94 7a00 	vldr	s14, [r4]
 80019a8:	edd2 7a00 	vldr	s15, [r2]
 80019ac:	3304      	adds	r3, #4
//Computes the dot product of two vectors 
float VectorDotProduct(float vector1[3],float vector2[3]) 
{   
	int c = 0;
	float op=0;      
	for( c = 0 ; c < 3 ; c++ )   
 80019ae:	2b0c      	cmp	r3, #12
	{   
		op += vector1[c] * vector2[c];   
 80019b0:	eea7 0a27 	vfma.f32	s0, s14, s15
//Computes the dot product of two vectors 
float VectorDotProduct(float vector1[3],float vector2[3]) 
{   
	int c = 0;
	float op=0;      
	for( c = 0 ; c < 3 ; c++ )   
 80019b4:	d1f4      	bne.n	80019a0 <VectorDotProduct+0x8>
	{   
		op += vector1[c] * vector2[c];   
	}      
	return op;  
}  
 80019b6:	bd10      	pop	{r4, pc}
 80019b8:	00000000 	.word	0x00000000

080019bc <VectorCrossProduct>:

//Computes the cross product of two vectors 
void VectorCrossProduct(float vectorOut[3], float v1[3],float v2[3]) 
{   
	vectorOut[0] = (v1[1]*v2[2]) - (v1[2]*v2[1]);   
 80019bc:	ed92 7a01 	vldr	s14, [r2, #4]
 80019c0:	edd1 7a02 	vldr	s15, [r1, #8]
 80019c4:	edd1 6a01 	vldr	s13, [r1, #4]
 80019c8:	ee67 7a67 	vnmul.f32	s15, s14, s15
 80019cc:	ed92 7a02 	vldr	s14, [r2, #8]
 80019d0:	eee6 7a87 	vfma.f32	s15, s13, s14
 80019d4:	edc0 7a00 	vstr	s15, [r0]
	vectorOut[1] = (v1[2]*v2[0]) - (v1[0]*v2[2]);   
 80019d8:	ed92 7a02 	vldr	s14, [r2, #8]
 80019dc:	edd1 7a00 	vldr	s15, [r1]
 80019e0:	edd1 6a02 	vldr	s13, [r1, #8]
 80019e4:	ee67 7a67 	vnmul.f32	s15, s14, s15
 80019e8:	ed92 7a00 	vldr	s14, [r2]
 80019ec:	eee6 7a87 	vfma.f32	s15, s13, s14
 80019f0:	edc0 7a01 	vstr	s15, [r0, #4]
	vectorOut[2] = (v1[0]*v2[1]) - (v1[1]*v2[0]); 
 80019f4:	ed92 7a00 	vldr	s14, [r2]
 80019f8:	edd1 7a01 	vldr	s15, [r1, #4]
 80019fc:	edd1 6a00 	vldr	s13, [r1]
 8001a00:	ee67 7a67 	vnmul.f32	s15, s14, s15
 8001a04:	ed92 7a01 	vldr	s14, [r2, #4]
 8001a08:	eee6 7a87 	vfma.f32	s15, s13, s14
 8001a0c:	edc0 7a02 	vstr	s15, [r0, #8]
 8001a10:	4770      	bx	lr

08001a12 <VectorScale>:
}  

//Multiply the vector by a scalar.  
void VectorScale(float vectorOut[3],float vectorIn[3], float scale2) 
{   
 8001a12:	b510      	push	{r4, lr}
 8001a14:	2300      	movs	r3, #0
 8001a16:	18cc      	adds	r4, r1, r3
	int c = 0;
	for( c = 0 ; c < 3 ; c++ )   
	{    
		vectorOut[c] = vectorIn[c] * scale2;    
 8001a18:	edd4 7a00 	vldr	s15, [r4]
 8001a1c:	18c2      	adds	r2, r0, r3
 8001a1e:	ee67 7a80 	vmul.f32	s15, s15, s0
 8001a22:	3304      	adds	r3, #4

//Multiply the vector by a scalar.  
void VectorScale(float vectorOut[3],float vectorIn[3], float scale2) 
{   
	int c = 0;
	for( c = 0 ; c < 3 ; c++ )   
 8001a24:	2b0c      	cmp	r3, #12
	{    
		vectorOut[c] = vectorIn[c] * scale2;    
 8001a26:	edc2 7a00 	vstr	s15, [r2]

//Multiply the vector by a scalar.  
void VectorScale(float vectorOut[3],float vectorIn[3], float scale2) 
{   
	int c = 0;
	for( c = 0 ; c < 3 ; c++ )   
 8001a2a:	d1f4      	bne.n	8001a16 <VectorScale+0x4>
	{    
		vectorOut[c] = vectorIn[c] * scale2;    
	} 
}  
 8001a2c:	bd10      	pop	{r4, pc}

08001a2e <VectorAdd>:

void VectorAdd(float vectorOut[3],float vectorIn1[3], float vectorIn2[3]) 
{
 8001a2e:	b570      	push	{r4, r5, r6, lr}
 8001a30:	2300      	movs	r3, #0
 8001a32:	18ce      	adds	r6, r1, r3
 8001a34:	18d5      	adds	r5, r2, r3
	int c = 0;
   
	for(c = 0 ; c < 3 ; c++ )   
	{      
		vectorOut[c] = vectorIn1[c] + vectorIn2[c];   
 8001a36:	ed96 7a00 	vldr	s14, [r6]
 8001a3a:	edd5 7a00 	vldr	s15, [r5]
 8001a3e:	18c4      	adds	r4, r0, r3
 8001a40:	ee77 7a27 	vadd.f32	s15, s14, s15
 8001a44:	3304      	adds	r3, #4

void VectorAdd(float vectorOut[3],float vectorIn1[3], float vectorIn2[3]) 
{
	int c = 0;
   
	for(c = 0 ; c < 3 ; c++ )   
 8001a46:	2b0c      	cmp	r3, #12
	{      
		vectorOut[c] = vectorIn1[c] + vectorIn2[c];   
 8001a48:	edc4 7a00 	vstr	s15, [r4]

void VectorAdd(float vectorOut[3],float vectorIn1[3], float vectorIn2[3]) 
{
	int c = 0;
   
	for(c = 0 ; c < 3 ; c++ )   
 8001a4c:	d1f1      	bne.n	8001a32 <VectorAdd+0x4>
	{      
		vectorOut[c] = vectorIn1[c] + vectorIn2[c];   
	} 
} 
 8001a4e:	bd70      	pop	{r4, r5, r6, pc}

08001a50 <MatrixMultiply>:



//Multiply two 3x3 matrices. 
void MatrixMultiply(float a[3][3], float b[3][3],float mat[3][3]) 
{   
 8001a50:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 8001a54:	2500      	movs	r5, #0
 8001a56:	1947      	adds	r7, r0, r5
 8001a58:	1956      	adds	r6, r2, r5
 8001a5a:	2400      	movs	r4, #0
 8001a5c:	2300      	movs	r3, #0
 8001a5e:	eb03 0a43 	add.w	sl, r3, r3, lsl #1
 8001a62:	eb01 0804 	add.w	r8, r1, r4
 8001a66:	eb07 0903 	add.w	r9, r7, r3
 8001a6a:	44d0      	add	r8, sl
	{     
		for(  y = 0 ; y < 3 ; y++ )     
		{       
			for(  w = 0 ; w < 3 ; w++ )       
			{        
				op[w] = a[x][w]*b[w][y];       
 8001a6c:	ed99 7a00 	vldr	s14, [r9]
 8001a70:	edd8 7a00 	vldr	s15, [r8]
 8001a74:	f10d 0c10 	add.w	ip, sp, #16
 8001a78:	449c      	add	ip, r3
 8001a7a:	ee67 7a27 	vmul.f32	s15, s14, s15
 8001a7e:	3304      	adds	r3, #4
	
	for(  x = 0 ; x < 3 ; x++ )   
	{     
		for(  y = 0 ; y < 3 ; y++ )     
		{       
			for(  w = 0 ; w < 3 ; w++ )       
 8001a80:	2b0c      	cmp	r3, #12
			{        
				op[w] = a[x][w]*b[w][y];       
 8001a82:	ed4c 7a03 	vstr	s15, [ip, #-12]
	
	for(  x = 0 ; x < 3 ; x++ )   
	{     
		for(  y = 0 ; y < 3 ; y++ )     
		{       
			for(  w = 0 ; w < 3 ; w++ )       
 8001a86:	d1ea      	bne.n	8001a5e <MatrixMultiply+0xe>
			{        
				op[w] = a[x][w]*b[w][y];       
			}        
			mat[x][y] = 0;       
			mat[x][y] = op[0] + op[1] + op[2];              
 8001a88:	ed9d 7a01 	vldr	s14, [sp, #4]
 8001a8c:	eddd 7a02 	vldr	s15, [sp, #8]
 8001a90:	ee77 7a27 	vadd.f32	s15, s14, s15
 8001a94:	ed9d 7a03 	vldr	s14, [sp, #12]
 8001a98:	1933      	adds	r3, r6, r4
 8001a9a:	ee77 7a87 	vadd.f32	s15, s15, s14
 8001a9e:	3404      	adds	r4, #4
	int w = 0;
	//float test = 0;
	
	for(  x = 0 ; x < 3 ; x++ )   
	{     
		for(  y = 0 ; y < 3 ; y++ )     
 8001aa0:	2c0c      	cmp	r4, #12
			for(  w = 0 ; w < 3 ; w++ )       
			{        
				op[w] = a[x][w]*b[w][y];       
			}        
			mat[x][y] = 0;       
			mat[x][y] = op[0] + op[1] + op[2];              
 8001aa2:	edc3 7a00 	vstr	s15, [r3]
	int w = 0;
	//float test = 0;
	
	for(  x = 0 ; x < 3 ; x++ )   
	{     
		for(  y = 0 ; y < 3 ; y++ )     
 8001aa6:	d1d9      	bne.n	8001a5c <MatrixMultiply+0xc>
 8001aa8:	350c      	adds	r5, #12
	int x = 0;
	int y = 0;
	int w = 0;
	//float test = 0;
	
	for(  x = 0 ; x < 3 ; x++ )   
 8001aaa:	2d24      	cmp	r5, #36	; 0x24
 8001aac:	d1d3      	bne.n	8001a56 <MatrixMultiply+0x6>
			mat[x][y] = 0;       
			mat[x][y] = op[0] + op[1] + op[2];              
			//test=mat[x][y];     
		}   
	} 
} 
 8001aae:	b004      	add	sp, #16
 8001ab0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

08001ab4 <update_intFilter>:
#include <math.h>


void update_intFilter(intFilter *filter, int lowpassValue, int newMeasurement)
{
	filter->r = newMeasurement + filter->r - filter->filtered;
 8001ab4:	6803      	ldr	r3, [r0, #0]
#include <filter_Lib.h>
#include <math.h>


void update_intFilter(intFilter *filter, int lowpassValue, int newMeasurement)
{
 8001ab6:	b510      	push	{r4, lr}
	filter->r = newMeasurement + filter->r - filter->filtered;
 8001ab8:	6844      	ldr	r4, [r0, #4]
 8001aba:	441a      	add	r2, r3
 8001abc:	1b12      	subs	r2, r2, r4
	filter->filtered = filter->r>>lowpassValue;
 8001abe:	fa42 f101 	asr.w	r1, r2, r1
#include <math.h>


void update_intFilter(intFilter *filter, int lowpassValue, int newMeasurement)
{
	filter->r = newMeasurement + filter->r - filter->filtered;
 8001ac2:	6002      	str	r2, [r0, #0]
	filter->filtered = filter->r>>lowpassValue;
 8001ac4:	6041      	str	r1, [r0, #4]
 8001ac6:	bd10      	pop	{r4, pc}

08001ac8 <initAvgValues>:
}

void initAvgValues(struct movingAverageValues *avg)
{
	int i = 0;
	avg->countValue = 0;
 8001ac8:	2300      	movs	r3, #0
 8001aca:	6143      	str	r3, [r0, #20]
	for(i = 0;i<MA_VALUE;i++)
	{
		avg->avgArray[i] = 0;
 8001acc:	6003      	str	r3, [r0, #0]
 8001ace:	6043      	str	r3, [r0, #4]
 8001ad0:	6083      	str	r3, [r0, #8]
 8001ad2:	60c3      	str	r3, [r0, #12]
 8001ad4:	6103      	str	r3, [r0, #16]
 8001ad6:	4770      	bx	lr

08001ad8 <calcMovingAvg>:
	}
}

int calcMovingAvg(struct movingAverageValues *avg, int newValue)
{
 8001ad8:	b510      	push	{r4, lr}
	int i = 0, result = 0;

	avg->avgArray[avg->countValue] = newValue;
 8001ada:	6944      	ldr	r4, [r0, #20]
 8001adc:	2300      	movs	r3, #0
 8001ade:	f840 1024 	str.w	r1, [r0, r4, lsl #2]
	}
}

int calcMovingAvg(struct movingAverageValues *avg, int newValue)
{
	int i = 0, result = 0;
 8001ae2:	461a      	mov	r2, r3

	avg->avgArray[avg->countValue] = newValue;
	for(i = 0;i<MA_VALUE;i++)
	{
		result += avg->avgArray[i];
 8001ae4:	58c1      	ldr	r1, [r0, r3]
 8001ae6:	3304      	adds	r3, #4
int calcMovingAvg(struct movingAverageValues *avg, int newValue)
{
	int i = 0, result = 0;

	avg->avgArray[avg->countValue] = newValue;
	for(i = 0;i<MA_VALUE;i++)
 8001ae8:	2b14      	cmp	r3, #20
	{
		result += avg->avgArray[i];
 8001aea:	440a      	add	r2, r1
int calcMovingAvg(struct movingAverageValues *avg, int newValue)
{
	int i = 0, result = 0;

	avg->avgArray[avg->countValue] = newValue;
	for(i = 0;i<MA_VALUE;i++)
 8001aec:	d1fa      	bne.n	8001ae4 <calcMovingAvg+0xc>
	{
		result += avg->avgArray[i];
	}
	avg->countValue++;
 8001aee:	3401      	adds	r4, #1
	if (avg->countValue >= MA_VALUE)
 8001af0:	2c04      	cmp	r4, #4
	{
		avg->countValue = 0;
 8001af2:	bfca      	itet	gt
 8001af4:	2300      	movgt	r3, #0
	avg->avgArray[avg->countValue] = newValue;
	for(i = 0;i<MA_VALUE;i++)
	{
		result += avg->avgArray[i];
	}
	avg->countValue++;
 8001af6:	6144      	strle	r4, [r0, #20]
	if (avg->countValue >= MA_VALUE)
	{
		avg->countValue = 0;
 8001af8:	6143      	strgt	r3, [r0, #20]
	}
	return result/MA_VALUE;
}
 8001afa:	2005      	movs	r0, #5
 8001afc:	fb92 f0f0 	sdiv	r0, r2, r0
 8001b00:	bd10      	pop	{r4, pc}

08001b02 <quickSort>:


void quickSort (int a[], int lo, int hi)
{
 8001b02:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8001b06:	4606      	mov	r6, r0
 8001b08:	4617      	mov	r7, r2
//  lo is the lower index, hi is the upper index
//  of the region of array a that is to be sorted
    int i=lo, j=hi, h;
    int x=a[(lo+hi)/2];
 8001b0a:	19ca      	adds	r2, r1, r7
 8001b0c:	2302      	movs	r3, #2
 8001b0e:	fb92 f3f3 	sdiv	r3, r2, r3
 8001b12:	1c4c      	adds	r4, r1, #1
 8001b14:	f856 9023 	ldr.w	r9, [r6, r3, lsl #2]
 8001b18:	eb06 0281 	add.w	r2, r6, r1, lsl #2

void quickSort (int a[], int lo, int hi)
{
//  lo is the lower index, hi is the upper index
//  of the region of array a that is to be sorted
    int i=lo, j=hi, h;
 8001b1c:	463b      	mov	r3, r7
    int x=a[(lo+hi)/2];

    //  partition
    do
    {
        while (a[i]<x) i++;
 8001b1e:	f852 cb04 	ldr.w	ip, [r2], #4
 8001b22:	45cc      	cmp	ip, r9
 8001b24:	f104 35ff 	add.w	r5, r4, #4294967295
 8001b28:	da01      	bge.n	8001b2e <quickSort+0x2c>
 8001b2a:	3401      	adds	r4, #1
 8001b2c:	e7f7      	b.n	8001b1e <quickSort+0x1c>
 8001b2e:	eb06 0083 	add.w	r0, r6, r3, lsl #2
        while (a[j]>x) j--;
 8001b32:	4682      	mov	sl, r0
 8001b34:	f850 8904 	ldr.w	r8, [r0], #-4
 8001b38:	45c8      	cmp	r8, r9
 8001b3a:	dd01      	ble.n	8001b40 <quickSort+0x3e>
 8001b3c:	3b01      	subs	r3, #1
 8001b3e:	e7f8      	b.n	8001b32 <quickSort+0x30>
        if (i<=j)
 8001b40:	429d      	cmp	r5, r3
 8001b42:	dc07      	bgt.n	8001b54 <quickSort+0x52>
        {
            h=a[i]; a[i]=a[j]; a[j]=h;
            i++; j--;
 8001b44:	3b01      	subs	r3, #1
        }
    } while (i<=j);
 8001b46:	429c      	cmp	r4, r3
    {
        while (a[i]<x) i++;
        while (a[j]>x) j--;
        if (i<=j)
        {
            h=a[i]; a[i]=a[j]; a[j]=h;
 8001b48:	f842 8c04 	str.w	r8, [r2, #-4]
            i++; j--;
 8001b4c:	4625      	mov	r5, r4
    {
        while (a[i]<x) i++;
        while (a[j]>x) j--;
        if (i<=j)
        {
            h=a[i]; a[i]=a[j]; a[j]=h;
 8001b4e:	f8ca c000 	str.w	ip, [sl]
            i++; j--;
        }
    } while (i<=j);
 8001b52:	ddea      	ble.n	8001b2a <quickSort+0x28>

    //  recursion
    if (lo<j) quickSort(a, lo, j);
 8001b54:	4299      	cmp	r1, r3
 8001b56:	da03      	bge.n	8001b60 <quickSort+0x5e>
 8001b58:	4630      	mov	r0, r6
 8001b5a:	461a      	mov	r2, r3
 8001b5c:	f7ff ffd1 	bl	8001b02 <quickSort>
    if (i<hi) quickSort(a, i, hi);
 8001b60:	42bd      	cmp	r5, r7
 8001b62:	da01      	bge.n	8001b68 <quickSort+0x66>
 8001b64:	4629      	mov	r1, r5
 8001b66:	e7d0      	b.n	8001b0a <quickSort+0x8>
 8001b68:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

08001b6c <calcStdDev>:

int calcStdDev (int a[], int index, int avgVal)
{
	int sum = 0, i = 0;

	for(i = 0; i<index;i++)
 8001b6c:	2300      	movs	r3, #0
}



int calcStdDev (int a[], int index, int avgVal)
{
 8001b6e:	b510      	push	{r4, lr}
	int sum = 0, i = 0;
 8001b70:	461c      	mov	r4, r3

	for(i = 0; i<index;i++)
 8001b72:	428b      	cmp	r3, r1
 8001b74:	da05      	bge.n	8001b82 <calcStdDev+0x16>
	{
		sum = (a[i]-avgVal)*(a[i]-avgVal);
 8001b76:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
 8001b7a:	1aa4      	subs	r4, r4, r2
 8001b7c:	4364      	muls	r4, r4

int calcStdDev (int a[], int index, int avgVal)
{
	int sum = 0, i = 0;

	for(i = 0; i<index;i++)
 8001b7e:	3301      	adds	r3, #1
 8001b80:	e7f7      	b.n	8001b72 <calcStdDev+0x6>
	{
		sum = (a[i]-avgVal)*(a[i]-avgVal);
	}
	return (sqrt(sum/(index-1)));
 8001b82:	1e48      	subs	r0, r1, #1
 8001b84:	fb94 f0f0 	sdiv	r0, r4, r0
 8001b88:	f005 fd86 	bl	8007698 <__aeabi_i2d>
 8001b8c:	ec41 0b10 	vmov	d0, r0, r1
 8001b90:	f006 fb12 	bl	80081b8 <sqrt>
 8001b94:	ec51 0b10 	vmov	r0, r1, d0
 8001b98:	f005 fde4 	bl	8007764 <__aeabi_d2iz>
}
 8001b9c:	bd10      	pop	{r4, pc}

08001b9e <floatFilterAcc1>:
void floatFilterAcc1(floatFilter *value, int newValue)
{
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];
	xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4];
	xv[4] = (float)newValue / 2.674241096e+06 /*GAIN*/;
 8001b9e:	ee07 1a90 	vmov	s15, r1
 8001ba2:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 8001ba6:	eddf 7a23 	vldr	s15, [pc, #140]	; 8001c34 <floatFilterAcc1+0x96>
 */
void floatFilterAcc1(floatFilter *value, int newValue)
{
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];
	xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4];
 8001baa:	edd0 4a01 	vldr	s9, [r0, #4]
 8001bae:	edd0 3a02 	vldr	s7, [r0, #8]
 8001bb2:	ed90 4a04 	vldr	s8, [r0, #16]
 8001bb6:	ed90 5a03 	vldr	s10, [r0, #12]
 8001bba:	ed80 4a03 	vstr	s8, [r0, #12]
	xv[4] = (float)newValue / 2.674241096e+06 /*GAIN*/;
 8001bbe:	eec7 7a27 	vdiv.f32	s15, s14, s15
	yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3]; yv[3] = yv[4];
	yv[4] =   (xv[0] + xv[4]) + 4 * (xv[1] + xv[3]) + 6 * xv[2]
 8001bc2:	ee33 4a84 	vadd.f32	s8, s7, s8
void floatFilterAcc1(floatFilter *value, int newValue)
{
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];
	xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4];
	xv[4] = (float)newValue / 2.674241096e+06 /*GAIN*/;
 8001bc6:	edc0 7a04 	vstr	s15, [r0, #16]
	yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3]; yv[3] = yv[4];
	yv[4] =   (xv[0] + xv[4]) + 4 * (xv[1] + xv[3]) + 6 * xv[2]
 8001bca:	ee74 7aa7 	vadd.f32	s15, s9, s15
 */
void floatFilterAcc1(floatFilter *value, int newValue)
{
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];
	xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4];
 8001bce:	edc0 4a00 	vstr	s9, [r0]
	xv[4] = (float)newValue / 2.674241096e+06 /*GAIN*/;
	yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3]; yv[3] = yv[4];
	yv[4] =   (xv[0] + xv[4]) + 4 * (xv[1] + xv[3]) + 6 * xv[2]
 8001bd2:	eef1 4a00 	vmov.f32	s9, #16
 8001bd6:	eee4 7a24 	vfma.f32	s15, s8, s9
 8001bda:	eef1 4a08 	vmov.f32	s9, #24
 8001bde:	eee5 7a24 	vfma.f32	s15, s10, s9
{
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];
	xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4];
	xv[4] = (float)newValue / 2.674241096e+06 /*GAIN*/;
	yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3]; yv[3] = yv[4];
 8001be2:	edd0 5a06 	vldr	s11, [r0, #24]
 */
void floatFilterAcc1(floatFilter *value, int newValue)
{
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];
	xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4];
 8001be6:	ed80 5a02 	vstr	s10, [r0, #8]
	xv[4] = (float)newValue / 2.674241096e+06 /*GAIN*/;
	yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3]; yv[3] = yv[4];
	yv[4] =   (xv[0] + xv[4]) + 4 * (xv[1] + xv[3]) + 6 * xv[2]
				 + ( -0.8768965608 * yv[0]) + (  3.6227607596 * yv[1])
 8001bea:	ed9f 5a13 	vldr	s10, [pc, #76]	; 8001c38 <floatFilterAcc1+0x9a>
{
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];
	xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4];
	xv[4] = (float)newValue / 2.674241096e+06 /*GAIN*/;
	yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3]; yv[3] = yv[4];
 8001bee:	ed90 6a07 	vldr	s12, [r0, #28]
 8001bf2:	edc0 5a05 	vstr	s11, [r0, #20]
	yv[4] =   (xv[0] + xv[4]) + 4 * (xv[1] + xv[3]) + 6 * xv[2]
				 + ( -0.8768965608 * yv[0]) + (  3.6227607596 * yv[1])
 8001bf6:	eee5 7a85 	vfma.f32	s15, s11, s10
 8001bfa:	eddf 5a10 	vldr	s11, [pc, #64]	; 8001c3c <floatFilterAcc1+0x9e>
{
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];
	xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4];
	xv[4] = (float)newValue / 2.674241096e+06 /*GAIN*/;
	yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3]; yv[3] = yv[4];
 8001bfe:	edd0 6a08 	vldr	s13, [r0, #32]
 8001c02:	ed80 6a06 	vstr	s12, [r0, #24]
	yv[4] =   (xv[0] + xv[4]) + 4 * (xv[1] + xv[3]) + 6 * xv[2]
				 + ( -0.8768965608 * yv[0]) + (  3.6227607596 * yv[1])
 8001c06:	eee6 7a25 	vfma.f32	s15, s12, s11
				 + ( -5.6145268496 * yv[2]) + (  3.8686566679 * yv[3]);
 8001c0a:	ed9f 6a0d 	vldr	s12, [pc, #52]	; 8001c40 <floatFilterAcc1+0xa2>
{
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];
	xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4];
	xv[4] = (float)newValue / 2.674241096e+06 /*GAIN*/;
	yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3]; yv[3] = yv[4];
 8001c0e:	ed90 7a09 	vldr	s14, [r0, #36]	; 0x24
 8001c12:	edc0 6a07 	vstr	s13, [r0, #28]
	yv[4] =   (xv[0] + xv[4]) + 4 * (xv[1] + xv[3]) + 6 * xv[2]
				 + ( -0.8768965608 * yv[0]) + (  3.6227607596 * yv[1])
				 + ( -5.6145268496 * yv[2]) + (  3.8686566679 * yv[3]);
 8001c16:	eee6 7a86 	vfma.f32	s15, s13, s12
 8001c1a:	eddf 6a0a 	vldr	s13, [pc, #40]	; 8001c44 <floatFilterAcc1+0xa6>
 */
void floatFilterAcc1(floatFilter *value, int newValue)
{
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];
	xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4];
 8001c1e:	edc0 3a01 	vstr	s7, [r0, #4]
	xv[4] = (float)newValue / 2.674241096e+06 /*GAIN*/;
	yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3]; yv[3] = yv[4];
	yv[4] =   (xv[0] + xv[4]) + 4 * (xv[1] + xv[3]) + 6 * xv[2]
				 + ( -0.8768965608 * yv[0]) + (  3.6227607596 * yv[1])
				 + ( -5.6145268496 * yv[2]) + (  3.8686566679 * yv[3]);
 8001c22:	eee7 7a26 	vfma.f32	s15, s14, s13
{
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];
	xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4];
	xv[4] = (float)newValue / 2.674241096e+06 /*GAIN*/;
	yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3]; yv[3] = yv[4];
 8001c26:	ed80 7a08 	vstr	s14, [r0, #32]
	yv[4] =   (xv[0] + xv[4]) + 4 * (xv[1] + xv[3]) + 6 * xv[2]
 8001c2a:	edc0 7a09 	vstr	s15, [r0, #36]	; 0x24
				 + ( -0.8768965608 * yv[0]) + (  3.6227607596 * yv[1])
				 + ( -5.6145268496 * yv[2]) + (  3.8686566679 * yv[3]);
	value->currentValue = yv[4];
 8001c2e:	edc0 7a0a 	vstr	s15, [r0, #40]	; 0x28
 8001c32:	4770      	bx	lr
 8001c34:	4a233904 	.word	0x4a233904
 8001c38:	bf607c4b 	.word	0xbf607c4b
 8001c3c:	4067db50 	.word	0x4067db50
 8001c40:	c0b3aa34 	.word	0xc0b3aa34
 8001c44:	40779812 	.word	0x40779812

08001c48 <floatFilterAcc2>:
void floatFilterAcc2(floatFilter *value, int newValue)
{
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];
	xv[0] = xv[1]; xv[1] = xv[2];
	xv[2] = (float)newValue / 2.555570536e+04 /*GAIN*/;
 8001c48:	ee07 1a90 	vmov	s15, r1
 8001c4c:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 8001c50:	eddf 7a14 	vldr	s15, [pc, #80]	; 8001ca4 <floatFilterAcc2+0x5c>

void floatFilterAcc2(floatFilter *value, int newValue)
{
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];
	xv[0] = xv[1]; xv[1] = xv[2];
 8001c54:	edd0 5a01 	vldr	s11, [r0, #4]
 8001c58:	ed90 6a02 	vldr	s12, [r0, #8]
 8001c5c:	edc0 5a00 	vstr	s11, [r0]
	xv[2] = (float)newValue / 2.555570536e+04 /*GAIN*/;
 8001c60:	eec7 7a27 	vdiv.f32	s15, s14, s15
    yv[0] = yv[1]; yv[1] = yv[2];
 8001c64:	edd0 6a06 	vldr	s13, [r0, #24]
void floatFilterAcc2(floatFilter *value, int newValue)
{
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];
	xv[0] = xv[1]; xv[1] = xv[2];
	xv[2] = (float)newValue / 2.555570536e+04 /*GAIN*/;
 8001c68:	edc0 7a02 	vstr	s15, [r0, #8]
    yv[0] = yv[1]; yv[1] = yv[2];
    yv[2] =   (xv[0] + xv[2]) + 2 * xv[1]
 8001c6c:	ee75 7aa7 	vadd.f32	s15, s11, s15
 8001c70:	eef0 5a00 	vmov.f32	s11, #0
 8001c74:	eee6 7a25 	vfma.f32	s15, s12, s11

void floatFilterAcc2(floatFilter *value, int newValue)
{
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];
	xv[0] = xv[1]; xv[1] = xv[2];
 8001c78:	ed80 6a01 	vstr	s12, [r0, #4]
	xv[2] = (float)newValue / 2.555570536e+04 /*GAIN*/;
    yv[0] = yv[1]; yv[1] = yv[2];
    yv[2] =   (xv[0] + xv[2]) + 2 * xv[1]
                 + ( -0.9823854506 * yv[0]) + (  1.9822289298 * yv[1]);
 8001c7c:	ed9f 6a0a 	vldr	s12, [pc, #40]	; 8001ca8 <floatFilterAcc2+0x60>
{
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];
	xv[0] = xv[1]; xv[1] = xv[2];
	xv[2] = (float)newValue / 2.555570536e+04 /*GAIN*/;
    yv[0] = yv[1]; yv[1] = yv[2];
 8001c80:	ed90 7a07 	vldr	s14, [r0, #28]
 8001c84:	edc0 6a05 	vstr	s13, [r0, #20]
    yv[2] =   (xv[0] + xv[2]) + 2 * xv[1]
                 + ( -0.9823854506 * yv[0]) + (  1.9822289298 * yv[1]);
 8001c88:	eee6 7a86 	vfma.f32	s15, s13, s12
 8001c8c:	eddf 6a07 	vldr	s13, [pc, #28]	; 8001cac <floatFilterAcc2+0x64>
{
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];
	xv[0] = xv[1]; xv[1] = xv[2];
	xv[2] = (float)newValue / 2.555570536e+04 /*GAIN*/;
    yv[0] = yv[1]; yv[1] = yv[2];
 8001c90:	ed80 7a06 	vstr	s14, [r0, #24]
    yv[2] =   (xv[0] + xv[2]) + 2 * xv[1]
                 + ( -0.9823854506 * yv[0]) + (  1.9822289298 * yv[1]);
 8001c94:	eee7 7a26 	vfma.f32	s15, s14, s13
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];
	xv[0] = xv[1]; xv[1] = xv[2];
	xv[2] = (float)newValue / 2.555570536e+04 /*GAIN*/;
    yv[0] = yv[1]; yv[1] = yv[2];
    yv[2] =   (xv[0] + xv[2]) + 2 * xv[1]
 8001c98:	edc0 7a07 	vstr	s15, [r0, #28]
                 + ( -0.9823854506 * yv[0]) + (  1.9822289298 * yv[1]);
    value->currentValue = yv[2];
 8001c9c:	edc0 7a0a 	vstr	s15, [r0, #40]	; 0x28
 8001ca0:	4770      	bx	lr
 8001ca2:	bf00      	nop
 8001ca4:	46c7a769 	.word	0x46c7a769
 8001ca8:	bf7b7d9d 	.word	0xbf7b7d9d
 8001cac:	3ffdb9ad 	.word	0x3ffdb9ad

08001cb0 <floatFilterAcc>:
//	                 + (  0.3617959282 * yv[0]) + ( -1.4470540195 * yv[1])
//	                 + (  2.0037974774 * yv[2]);
//	value->currentValue = yv[3];

    xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3];
    xv[3] = newValue / 1.429899908e+03;
 8001cb0:	ee07 1a90 	vmov	s15, r1
 8001cb4:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 8001cb8:	eddf 7a1b 	vldr	s15, [pc, #108]	; 8001d28 <floatFilterAcc+0x78>
//	yv[3] =   (xv[0] + xv[3]) + 3 * (xv[1] + xv[2])
//	                 + (  0.3617959282 * yv[0]) + ( -1.4470540195 * yv[1])
//	                 + (  2.0037974774 * yv[2]);
//	value->currentValue = yv[3];

    xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3];
 8001cbc:	edd0 5a01 	vldr	s11, [r0, #4]
 8001cc0:	edd0 4a02 	vldr	s9, [r0, #8]
 8001cc4:	ed90 5a03 	vldr	s10, [r0, #12]
 8001cc8:	edc0 5a00 	vstr	s11, [r0]
    xv[3] = newValue / 1.429899908e+03;
 8001ccc:	eec7 7a27 	vdiv.f32	s15, s14, s15
//	yv[3] =   (xv[0] + xv[3]) + 3 * (xv[1] + xv[2])
//	                 + (  0.3617959282 * yv[0]) + ( -1.4470540195 * yv[1])
//	                 + (  2.0037974774 * yv[2]);
//	value->currentValue = yv[3];

    xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3];
 8001cd0:	ed80 5a02 	vstr	s10, [r0, #8]
    xv[3] = newValue / 1.429899908e+03;
 8001cd4:	edc0 7a03 	vstr	s15, [r0, #12]
    yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3];
    yv[3] =   (xv[0] + xv[3]) + 3 * (xv[1] + xv[2])
 8001cd8:	ee34 5a85 	vadd.f32	s10, s9, s10
 8001cdc:	ee75 7aa7 	vadd.f32	s15, s11, s15
 8001ce0:	eef0 5a08 	vmov.f32	s11, #8
 8001ce4:	eee5 7a25 	vfma.f32	s15, s10, s11
//	                 + (  2.0037974774 * yv[2]);
//	value->currentValue = yv[3];

    xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3];
    xv[3] = newValue / 1.429899908e+03;
    yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3];
 8001ce8:	ed90 6a06 	vldr	s12, [r0, #24]
    yv[3] =   (xv[0] + xv[3]) + 3 * (xv[1] + xv[2])
                     + (  0.6855359773 * yv[0]) + ( -2.3146825811 * yv[1])
 8001cec:	eddf 5a0f 	vldr	s11, [pc, #60]	; 8001d2c <floatFilterAcc+0x7c>
//	                 + (  2.0037974774 * yv[2]);
//	value->currentValue = yv[3];

    xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3];
    xv[3] = newValue / 1.429899908e+03;
    yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3];
 8001cf0:	edd0 6a07 	vldr	s13, [r0, #28]
 8001cf4:	ed80 6a05 	vstr	s12, [r0, #20]
    yv[3] =   (xv[0] + xv[3]) + 3 * (xv[1] + xv[2])
                     + (  0.6855359773 * yv[0]) + ( -2.3146825811 * yv[1])
 8001cf8:	eee6 7a25 	vfma.f32	s15, s12, s11
 8001cfc:	ed9f 6a0c 	vldr	s12, [pc, #48]	; 8001d30 <floatFilterAcc+0x80>
//	                 + (  2.0037974774 * yv[2]);
//	value->currentValue = yv[3];

    xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3];
    xv[3] = newValue / 1.429899908e+03;
    yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3];
 8001d00:	ed90 7a08 	vldr	s14, [r0, #32]
 8001d04:	edc0 6a06 	vstr	s13, [r0, #24]
    yv[3] =   (xv[0] + xv[3]) + 3 * (xv[1] + xv[2])
                     + (  0.6855359773 * yv[0]) + ( -2.3146825811 * yv[1])
 8001d08:	eee6 7a86 	vfma.f32	s15, s13, s12
                     + (  2.6235518066 * yv[2]);
 8001d0c:	eddf 6a09 	vldr	s13, [pc, #36]	; 8001d34 <floatFilterAcc+0x84>
//	yv[3] =   (xv[0] + xv[3]) + 3 * (xv[1] + xv[2])
//	                 + (  0.3617959282 * yv[0]) + ( -1.4470540195 * yv[1])
//	                 + (  2.0037974774 * yv[2]);
//	value->currentValue = yv[3];

    xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3];
 8001d10:	edc0 4a01 	vstr	s9, [r0, #4]
    xv[3] = newValue / 1.429899908e+03;
    yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3];
    yv[3] =   (xv[0] + xv[3]) + 3 * (xv[1] + xv[2])
                     + (  0.6855359773 * yv[0]) + ( -2.3146825811 * yv[1])
                     + (  2.6235518066 * yv[2]);
 8001d14:	eee7 7a26 	vfma.f32	s15, s14, s13
//	                 + (  2.0037974774 * yv[2]);
//	value->currentValue = yv[3];

    xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3];
    xv[3] = newValue / 1.429899908e+03;
    yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3];
 8001d18:	ed80 7a07 	vstr	s14, [r0, #28]
    yv[3] =   (xv[0] + xv[3]) + 3 * (xv[1] + xv[2])
 8001d1c:	edc0 7a08 	vstr	s15, [r0, #32]
                     + (  0.6855359773 * yv[0]) + ( -2.3146825811 * yv[1])
                     + (  2.6235518066 * yv[2]);
    value->currentValue = yv[3];
 8001d20:	edc0 7a0a 	vstr	s15, [r0, #40]	; 0x28
 8001d24:	4770      	bx	lr
 8001d26:	bf00      	nop
 8001d28:	44b2bccc 	.word	0x44b2bccc
 8001d2c:	3f2f7f49 	.word	0x3f2f7f49
 8001d30:	c01423c2 	.word	0xc01423c2
 8001d34:	4027e846 	.word	0x4027e846

08001d38 <floatFilterGyro>:
{
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];

	xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4];
	xv[4] = (float)newValue / 2.310287053e+00;
 8001d38:	ee07 1a90 	vmov	s15, r1
 8001d3c:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 8001d40:	eddf 7a23 	vldr	s15, [pc, #140]	; 8001dd0 <floatFilterGyro+0x98>
void floatFilterGyro(floatFilter *value, int newValue)
{
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];

	xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4];
 8001d44:	edd0 4a01 	vldr	s9, [r0, #4]
 8001d48:	edd0 3a02 	vldr	s7, [r0, #8]
 8001d4c:	ed90 4a04 	vldr	s8, [r0, #16]
 8001d50:	ed90 5a03 	vldr	s10, [r0, #12]
 8001d54:	ed80 4a03 	vstr	s8, [r0, #12]
	xv[4] = (float)newValue / 2.310287053e+00;
 8001d58:	eec7 7a27 	vdiv.f32	s15, s14, s15
	yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3]; yv[3] = yv[4];
	yv[4] =   (xv[0] + xv[4]) + 4 * (xv[1] + xv[3]) + 6 * xv[2]
 8001d5c:	ee33 4a84 	vadd.f32	s8, s7, s8
{
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];

	xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4];
	xv[4] = (float)newValue / 2.310287053e+00;
 8001d60:	edc0 7a04 	vstr	s15, [r0, #16]
	yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3]; yv[3] = yv[4];
	yv[4] =   (xv[0] + xv[4]) + 4 * (xv[1] + xv[3]) + 6 * xv[2]
 8001d64:	ee74 7aa7 	vadd.f32	s15, s9, s15
void floatFilterGyro(floatFilter *value, int newValue)
{
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];

	xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4];
 8001d68:	edc0 4a00 	vstr	s9, [r0]
	xv[4] = (float)newValue / 2.310287053e+00;
	yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3]; yv[3] = yv[4];
	yv[4] =   (xv[0] + xv[4]) + 4 * (xv[1] + xv[3]) + 6 * xv[2]
 8001d6c:	eef1 4a00 	vmov.f32	s9, #16
 8001d70:	eee4 7a24 	vfma.f32	s15, s8, s9
 8001d74:	eef1 4a08 	vmov.f32	s9, #24
 8001d78:	eee5 7a24 	vfma.f32	s15, s10, s9
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];

	xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4];
	xv[4] = (float)newValue / 2.310287053e+00;
	yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3]; yv[3] = yv[4];
 8001d7c:	edd0 5a06 	vldr	s11, [r0, #24]
void floatFilterGyro(floatFilter *value, int newValue)
{
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];

	xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4];
 8001d80:	ed80 5a02 	vstr	s10, [r0, #8]
	xv[4] = (float)newValue / 2.310287053e+00;
	yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3]; yv[3] = yv[4];
	yv[4] =   (xv[0] + xv[4]) + 4 * (xv[1] + xv[3]) + 6 * xv[2]
				 + ( -0.1873794924 * yv[0]) + ( -1.0546654059 * yv[1])
 8001d84:	ed9f 5a13 	vldr	s10, [pc, #76]	; 8001dd4 <floatFilterGyro+0x9c>
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];

	xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4];
	xv[4] = (float)newValue / 2.310287053e+00;
	yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3]; yv[3] = yv[4];
 8001d88:	ed90 6a07 	vldr	s12, [r0, #28]
 8001d8c:	edc0 5a05 	vstr	s11, [r0, #20]
	yv[4] =   (xv[0] + xv[4]) + 4 * (xv[1] + xv[3]) + 6 * xv[2]
				 + ( -0.1873794924 * yv[0]) + ( -1.0546654059 * yv[1])
 8001d90:	eee5 7a85 	vfma.f32	s15, s11, s10
 8001d94:	eddf 5a10 	vldr	s11, [pc, #64]	; 8001dd8 <floatFilterGyro+0xa0>
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];

	xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4];
	xv[4] = (float)newValue / 2.310287053e+00;
	yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3]; yv[3] = yv[4];
 8001d98:	edd0 6a08 	vldr	s13, [r0, #32]
 8001d9c:	ed80 6a06 	vstr	s12, [r0, #24]
	yv[4] =   (xv[0] + xv[4]) + 4 * (xv[1] + xv[3]) + 6 * xv[2]
				 + ( -0.1873794924 * yv[0]) + ( -1.0546654059 * yv[1])
 8001da0:	eee6 7a25 	vfma.f32	s15, s12, s11
				 + ( -2.3139884144 * yv[2]) + ( -2.3695130072 * yv[3]);
 8001da4:	ed9f 6a0d 	vldr	s12, [pc, #52]	; 8001ddc <floatFilterGyro+0xa4>
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];

	xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4];
	xv[4] = (float)newValue / 2.310287053e+00;
	yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3]; yv[3] = yv[4];
 8001da8:	ed90 7a09 	vldr	s14, [r0, #36]	; 0x24
 8001dac:	edc0 6a07 	vstr	s13, [r0, #28]
	yv[4] =   (xv[0] + xv[4]) + 4 * (xv[1] + xv[3]) + 6 * xv[2]
				 + ( -0.1873794924 * yv[0]) + ( -1.0546654059 * yv[1])
				 + ( -2.3139884144 * yv[2]) + ( -2.3695130072 * yv[3]);
 8001db0:	eee6 7a86 	vfma.f32	s15, s13, s12
 8001db4:	eddf 6a0a 	vldr	s13, [pc, #40]	; 8001de0 <floatFilterGyro+0xa8>
void floatFilterGyro(floatFilter *value, int newValue)
{
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];

	xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4];
 8001db8:	edc0 3a01 	vstr	s7, [r0, #4]
	xv[4] = (float)newValue / 2.310287053e+00;
	yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3]; yv[3] = yv[4];
	yv[4] =   (xv[0] + xv[4]) + 4 * (xv[1] + xv[3]) + 6 * xv[2]
				 + ( -0.1873794924 * yv[0]) + ( -1.0546654059 * yv[1])
				 + ( -2.3139884144 * yv[2]) + ( -2.3695130072 * yv[3]);
 8001dbc:	eee7 7a26 	vfma.f32	s15, s14, s13
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];

	xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4];
	xv[4] = (float)newValue / 2.310287053e+00;
	yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3]; yv[3] = yv[4];
 8001dc0:	ed80 7a08 	vstr	s14, [r0, #32]
	yv[4] =   (xv[0] + xv[4]) + 4 * (xv[1] + xv[3]) + 6 * xv[2]
 8001dc4:	edc0 7a09 	vstr	s15, [r0, #36]	; 0x24
				 + ( -0.1873794924 * yv[0]) + ( -1.0546654059 * yv[1])
				 + ( -2.3139884144 * yv[2]) + ( -2.3695130072 * yv[3]);
	value->currentValue = yv[4];
 8001dc8:	edc0 7a0a 	vstr	s15, [r0, #40]	; 0x28
 8001dcc:	4770      	bx	lr
 8001dce:	bf00      	nop
 8001dd0:	4013dbbe 	.word	0x4013dbbe
 8001dd4:	be3fe069 	.word	0xbe3fe069
 8001dd8:	bf86ff47 	.word	0xbf86ff47
 8001ddc:	c0141863 	.word	0xc0141863
 8001de0:	c017a61a 	.word	0xc017a61a

08001de4 <Delay>:
#include <helperFunctions.h>


void Delay(volatile uint32_t delayCount)
{
 8001de4:	b082      	sub	sp, #8
 8001de6:	9001      	str	r0, [sp, #4]
	while (delayCount > 0)
 8001de8:	9b01      	ldr	r3, [sp, #4]
 8001dea:	b11b      	cbz	r3, 8001df4 <Delay+0x10>
	{
		delayCount--;
 8001dec:	9b01      	ldr	r3, [sp, #4]
 8001dee:	3b01      	subs	r3, #1
 8001df0:	9301      	str	r3, [sp, #4]
 8001df2:	e7f9      	b.n	8001de8 <Delay+0x4>
	}
}
 8001df4:	b002      	add	sp, #8
 8001df6:	4770      	bx	lr

08001df8 <min>:
//max( a, b ) ( ((a) > (b)) ? (a) : (b) )
float min(float a, float b)
{
	if( a < b ) return a;
 8001df8:	eeb4 0ae0 	vcmpe.f32	s0, s1
 8001dfc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
	else return b;
}
 8001e00:	bf58      	it	pl
 8001e02:	eeb0 0a60 	vmovpl.f32	s0, s1
 8001e06:	4770      	bx	lr

08001e08 <max>:

float max(float a, float b)
{
	if( a > b ) return a;
 8001e08:	eeb4 0ae0 	vcmpe.f32	s0, s1
 8001e0c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
	else return b;
}
 8001e10:	bfd8      	it	le
 8001e12:	eeb0 0a60 	vmovle.f32	s0, s1
 8001e16:	4770      	bx	lr

08001e18 <Control_Task>:

/*********************************
 *		Controller Task
 *********************************/
static void Control_Task( void *pvParameters )
{
 8001e18:	b508      	push	{r3, lr}
	const portTickType xDelay = 10 / portTICK_RATE_MS;

	Init_PositionController();
 8001e1a:	f7ff f929 	bl	8001070 <Init_PositionController>
	while(1)
	{
		//GPIOC->ODR |= GPIO_Pin_10;	// Set Debug Pin

		////Disable_Motor();
		PositionController();
 8001e1e:	f7ff fc73 	bl	8001708 <PositionController>

		//GPIOC->ODR &= ~GPIO_Pin_10; // Clear Debug Pin


		vTaskDelay( xDelay );
 8001e22:	200a      	movs	r0, #10
 8001e24:	f004 feca 	bl	8006bbc <vTaskDelay>
 8001e28:	e7f9      	b.n	8001e1e <Control_Task+0x6>

08001e2a <IMU_Task>:

/*********************************
 *		IMU Task
 *********************************/
static void IMU_Task( void *pvParameters )
{
 8001e2a:	b513      	push	{r0, r1, r4, lr}
	portTickType xNextWakeTime;

	Disable_Motor();
 8001e2c:	f7fe ff6c 	bl	8000d08 <Disable_Motor>
	/*
	 * Wait here 2 Seconds to ensure,
	 * that all capacitors are charged
	 * and VCC is stable
	 * */
	vTaskDelay( 2000 );
 8001e30:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 8001e34:	f004 fec2 	bl	8006bbc <vTaskDelay>

	Init_IMU();
 8001e38:	f7ff f95c 	bl	80010f4 <Init_IMU>

	Enable_Motor();
 8001e3c:	f7fe ff54 	bl	8000ce8 <Enable_Motor>

	xNextWakeTime = xTaskGetTickCount();
 8001e40:	f004 fd8a 	bl	8006958 <xTaskGetTickCount>
 8001e44:	9001      	str	r0, [sp, #4]

	while(1)
	{

		GPIOC->ODR |= GPIO_Pin_11;	// Set Debug Pin
 8001e46:	4c09      	ldr	r4, [pc, #36]	; (8001e6c <IMU_Task+0x42>)
 8001e48:	8aa3      	ldrh	r3, [r4, #20]
 8001e4a:	b29b      	uxth	r3, r3
 8001e4c:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8001e50:	82a3      	strh	r3, [r4, #20]

		IMU_Calculation();
 8001e52:	f7ff fabf 	bl	80013d4 <IMU_Calculation>

		//GPIOC->ODR ^= GPIO_Pin_11; // Toggle Debug Pin

		GPIOC->ODR &= ~GPIO_Pin_11; // Clear Debug Pin
 8001e56:	8aa3      	ldrh	r3, [r4, #20]
 8001e58:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8001e5c:	041b      	lsls	r3, r3, #16
 8001e5e:	0c1b      	lsrs	r3, r3, #16
 8001e60:	82a3      	strh	r3, [r4, #20]

		vTaskDelayUntil( &xNextWakeTime, DT );
 8001e62:	a801      	add	r0, sp, #4
 8001e64:	2102      	movs	r1, #2
 8001e66:	f004 fe75 	bl	8006b54 <vTaskDelayUntil>
 8001e6a:	e7ec      	b.n	8001e46 <IMU_Task+0x1c>
 8001e6c:	48000800 	.word	0x48000800

08001e70 <LED_TOGGLE_NOT_READY>:



void LED_TOGGLE_NOT_READY(void)
{
	GPIOE->ODR ^= GPIO_Pin_8;
 8001e70:	4b0a      	ldr	r3, [pc, #40]	; (8001e9c <LED_TOGGLE_NOT_READY+0x2c>)
 8001e72:	8a9a      	ldrh	r2, [r3, #20]
 8001e74:	b292      	uxth	r2, r2
 8001e76:	f482 7280 	eor.w	r2, r2, #256	; 0x100
 8001e7a:	829a      	strh	r2, [r3, #20]
	GPIOE->ODR ^= GPIO_Pin_10;
 8001e7c:	8a9a      	ldrh	r2, [r3, #20]
 8001e7e:	b292      	uxth	r2, r2
 8001e80:	f482 6280 	eor.w	r2, r2, #1024	; 0x400
 8001e84:	829a      	strh	r2, [r3, #20]
	GPIOE->ODR ^= GPIO_Pin_12;
 8001e86:	8a9a      	ldrh	r2, [r3, #20]
 8001e88:	b292      	uxth	r2, r2
 8001e8a:	f482 5280 	eor.w	r2, r2, #4096	; 0x1000
 8001e8e:	829a      	strh	r2, [r3, #20]
	GPIOE->ODR ^= GPIO_Pin_14;
 8001e90:	8a9a      	ldrh	r2, [r3, #20]
 8001e92:	b292      	uxth	r2, r2
 8001e94:	f482 4280 	eor.w	r2, r2, #16384	; 0x4000
 8001e98:	829a      	strh	r2, [r3, #20]
 8001e9a:	4770      	bx	lr
 8001e9c:	48001000 	.word	0x48001000

08001ea0 <LED_TOGGLE_READY>:
}

void LED_TOGGLE_READY(void)
{
	GPIOE->ODR ^= GPIO_Pin_9;
 8001ea0:	4b0a      	ldr	r3, [pc, #40]	; (8001ecc <LED_TOGGLE_READY+0x2c>)
 8001ea2:	8a9a      	ldrh	r2, [r3, #20]
 8001ea4:	b292      	uxth	r2, r2
 8001ea6:	f482 7200 	eor.w	r2, r2, #512	; 0x200
 8001eaa:	829a      	strh	r2, [r3, #20]
	GPIOE->ODR ^= GPIO_Pin_11;
 8001eac:	8a9a      	ldrh	r2, [r3, #20]
 8001eae:	b292      	uxth	r2, r2
 8001eb0:	f482 6200 	eor.w	r2, r2, #2048	; 0x800
 8001eb4:	829a      	strh	r2, [r3, #20]
	GPIOE->ODR ^= GPIO_Pin_13;
 8001eb6:	8a9a      	ldrh	r2, [r3, #20]
 8001eb8:	b292      	uxth	r2, r2
 8001eba:	f482 5200 	eor.w	r2, r2, #8192	; 0x2000
 8001ebe:	829a      	strh	r2, [r3, #20]
	GPIOE->ODR ^= GPIO_Pin_15;
 8001ec0:	8a9a      	ldrh	r2, [r3, #20]
 8001ec2:	b292      	uxth	r2, r2
 8001ec4:	f482 4200 	eor.w	r2, r2, #32768	; 0x8000
 8001ec8:	829a      	strh	r2, [r3, #20]
 8001eca:	4770      	bx	lr
 8001ecc:	48001000 	.word	0x48001000

08001ed0 <LED_TOGGLE_ALL>:
}

void LED_TOGGLE_ALL(void)
{
	if(GPIOE->ODR & GPIO_Pin_9)
 8001ed0:	4b2e      	ldr	r3, [pc, #184]	; (8001f8c <LED_TOGGLE_ALL+0xbc>)
 8001ed2:	8a9a      	ldrh	r2, [r3, #20]
 8001ed4:	f412 7f00 	tst.w	r2, #512	; 0x200
	{
		GPIOE->ODR &= ~GPIO_Pin_9;
 8001ed8:	8a9a      	ldrh	r2, [r3, #20]
	GPIOE->ODR ^= GPIO_Pin_15;
}

void LED_TOGGLE_ALL(void)
{
	if(GPIOE->ODR & GPIO_Pin_9)
 8001eda:	d028      	beq.n	8001f2e <LED_TOGGLE_ALL+0x5e>
	{
		GPIOE->ODR &= ~GPIO_Pin_9;
 8001edc:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 8001ee0:	0412      	lsls	r2, r2, #16
 8001ee2:	0c12      	lsrs	r2, r2, #16
 8001ee4:	829a      	strh	r2, [r3, #20]
		GPIOE->ODR &= ~GPIO_Pin_11;
 8001ee6:	8a9a      	ldrh	r2, [r3, #20]
 8001ee8:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 8001eec:	0412      	lsls	r2, r2, #16
 8001eee:	0c12      	lsrs	r2, r2, #16
 8001ef0:	829a      	strh	r2, [r3, #20]
		GPIOE->ODR &= ~GPIO_Pin_13;
 8001ef2:	8a9a      	ldrh	r2, [r3, #20]
 8001ef4:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 8001ef8:	0412      	lsls	r2, r2, #16
 8001efa:	0c12      	lsrs	r2, r2, #16
 8001efc:	829a      	strh	r2, [r3, #20]
		GPIOE->ODR &= ~GPIO_Pin_15;
 8001efe:	8a9a      	ldrh	r2, [r3, #20]
 8001f00:	f3c2 020e 	ubfx	r2, r2, #0, #15
 8001f04:	829a      	strh	r2, [r3, #20]
		GPIOE->ODR |= GPIO_Pin_8;
 8001f06:	8a9a      	ldrh	r2, [r3, #20]
 8001f08:	b292      	uxth	r2, r2
 8001f0a:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8001f0e:	829a      	strh	r2, [r3, #20]
		GPIOE->ODR |= GPIO_Pin_10;
 8001f10:	8a9a      	ldrh	r2, [r3, #20]
 8001f12:	b292      	uxth	r2, r2
 8001f14:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8001f18:	829a      	strh	r2, [r3, #20]
		GPIOE->ODR |= GPIO_Pin_12;
 8001f1a:	8a9a      	ldrh	r2, [r3, #20]
 8001f1c:	b292      	uxth	r2, r2
 8001f1e:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8001f22:	829a      	strh	r2, [r3, #20]
		GPIOE->ODR |= GPIO_Pin_14;
 8001f24:	8a9a      	ldrh	r2, [r3, #20]
 8001f26:	b292      	uxth	r2, r2
 8001f28:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8001f2c:	e02b      	b.n	8001f86 <LED_TOGGLE_ALL+0xb6>
	}
	else
	{
		GPIOE->ODR |= GPIO_Pin_9;
 8001f2e:	b292      	uxth	r2, r2
 8001f30:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8001f34:	829a      	strh	r2, [r3, #20]
		GPIOE->ODR |= GPIO_Pin_11;
 8001f36:	8a9a      	ldrh	r2, [r3, #20]
 8001f38:	b292      	uxth	r2, r2
 8001f3a:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 8001f3e:	829a      	strh	r2, [r3, #20]
		GPIOE->ODR |= GPIO_Pin_13;
 8001f40:	8a9a      	ldrh	r2, [r3, #20]
 8001f42:	b292      	uxth	r2, r2
 8001f44:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8001f48:	829a      	strh	r2, [r3, #20]
		GPIOE->ODR |= GPIO_Pin_15;
 8001f4a:	8a9a      	ldrh	r2, [r3, #20]
 8001f4c:	ea6f 4242 	mvn.w	r2, r2, lsl #17
 8001f50:	ea6f 4252 	mvn.w	r2, r2, lsr #17
 8001f54:	b292      	uxth	r2, r2
 8001f56:	829a      	strh	r2, [r3, #20]
		GPIOE->ODR &= ~GPIO_Pin_8;
 8001f58:	8a9a      	ldrh	r2, [r3, #20]
 8001f5a:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8001f5e:	0412      	lsls	r2, r2, #16
 8001f60:	0c12      	lsrs	r2, r2, #16
 8001f62:	829a      	strh	r2, [r3, #20]
		GPIOE->ODR &= ~GPIO_Pin_10;
 8001f64:	8a9a      	ldrh	r2, [r3, #20]
 8001f66:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8001f6a:	0412      	lsls	r2, r2, #16
 8001f6c:	0c12      	lsrs	r2, r2, #16
 8001f6e:	829a      	strh	r2, [r3, #20]
		GPIOE->ODR &= ~GPIO_Pin_12;
 8001f70:	8a9a      	ldrh	r2, [r3, #20]
 8001f72:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 8001f76:	0412      	lsls	r2, r2, #16
 8001f78:	0c12      	lsrs	r2, r2, #16
 8001f7a:	829a      	strh	r2, [r3, #20]
		GPIOE->ODR &= ~GPIO_Pin_14;
 8001f7c:	8a9a      	ldrh	r2, [r3, #20]
 8001f7e:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 8001f82:	0412      	lsls	r2, r2, #16
 8001f84:	0c12      	lsrs	r2, r2, #16
 8001f86:	829a      	strh	r2, [r3, #20]
 8001f88:	4770      	bx	lr
 8001f8a:	bf00      	nop
 8001f8c:	48001000 	.word	0x48001000

08001f90 <vLedCtrlCoRoutine>:

void vLedCtrlCoRoutine( xCoRoutineHandle xHandle,
                         unsigned portBASE_TYPE uxIndex )
{
   // Co-routines must start with a call to crSTART().
   crSTART( xHandle );
 8001f90:	8e83      	ldrh	r3, [r0, #52]	; 0x34
	}
}

void vLedCtrlCoRoutine( xCoRoutineHandle xHandle,
                         unsigned portBASE_TYPE uxIndex )
{
 8001f92:	b510      	push	{r4, lr}
 8001f94:	4604      	mov	r4, r0
   // Co-routines must start with a call to crSTART().
   crSTART( xHandle );
 8001f96:	b14b      	cbz	r3, 8001fac <vLedCtrlCoRoutine+0x1c>
 8001f98:	f5b3 7ffb 	cmp.w	r3, #502	; 0x1f6
 8001f9c:	d000      	beq.n	8001fa0 <vLedCtrlCoRoutine+0x10>
 8001f9e:	bd10      	pop	{r4, pc}
   for( ;; )
   {
	   // Delay for a fixed period.
	   crDELAY( xHandle, 200 );

	   if(CtrlStates.copterStatus == IMU_READY_FLAG)
 8001fa0:	4b0a      	ldr	r3, [pc, #40]	; (8001fcc <vLedCtrlCoRoutine+0x3c>)
 8001fa2:	7a1b      	ldrb	r3, [r3, #8]
 8001fa4:	2b02      	cmp	r3, #2
 8001fa6:	d109      	bne.n	8001fbc <vLedCtrlCoRoutine+0x2c>
	   {
		   LED_TOGGLE_READY();
 8001fa8:	f7ff ff7a 	bl	8001ea0 <LED_TOGGLE_READY>
   crSTART( xHandle );

   for( ;; )
   {
	   // Delay for a fixed period.
	   crDELAY( xHandle, 200 );
 8001fac:	20c8      	movs	r0, #200	; 0xc8
 8001fae:	2100      	movs	r1, #0
 8001fb0:	f003 fdea 	bl	8005b88 <vCoRoutineAddToDelayedList>
 8001fb4:	f44f 73fb 	mov.w	r3, #502	; 0x1f6
 8001fb8:	86a3      	strh	r3, [r4, #52]	; 0x34
 8001fba:	bd10      	pop	{r4, pc}

	   if(CtrlStates.copterStatus == IMU_READY_FLAG)
	   {
		   LED_TOGGLE_READY();
	   }
	   else if (CtrlStates.copterStatus & ARMED_FLAG)
 8001fbc:	07db      	lsls	r3, r3, #31
 8001fbe:	d502      	bpl.n	8001fc6 <vLedCtrlCoRoutine+0x36>
	   {
		   LED_TOGGLE_ALL();
 8001fc0:	f7ff ff86 	bl	8001ed0 <LED_TOGGLE_ALL>
 8001fc4:	e7f2      	b.n	8001fac <vLedCtrlCoRoutine+0x1c>
	   }
	   else
	   {
		   LED_TOGGLE_NOT_READY();
 8001fc6:	f7ff ff53 	bl	8001e70 <LED_TOGGLE_NOT_READY>
 8001fca:	e7ef      	b.n	8001fac <vLedCtrlCoRoutine+0x1c>
 8001fcc:	20002f64 	.word	0x20002f64

08001fd0 <vApplicationMallocFailedHook>:
	internally by FreeRTOS API functions that create tasks, queues, software
	timers, and semaphores.  The size of the FreeRTOS heap is set by the
	configTOTAL_HEAP_SIZE configuration constant in FreeRTOSConfig.h. */
	for( ;; )
	{
		GPIOC->ODR ^= GPIO_Pin_11; // Toggle Debug Pin
 8001fd0:	4b03      	ldr	r3, [pc, #12]	; (8001fe0 <vApplicationMallocFailedHook+0x10>)
 8001fd2:	8a9a      	ldrh	r2, [r3, #20]
 8001fd4:	b292      	uxth	r2, r2
 8001fd6:	f482 6200 	eor.w	r2, r2, #2048	; 0x800
 8001fda:	829a      	strh	r2, [r3, #20]
 8001fdc:	e7f8      	b.n	8001fd0 <vApplicationMallocFailedHook>
 8001fde:	bf00      	nop
 8001fe0:	48000800 	.word	0x48000800

08001fe4 <vApplicationStackOverflowHook>:
	/* Run time stack overflow checking is performed if
	configconfigCHECK_FOR_STACK_OVERFLOW is defined to 1 or 2.  This hook
	function is called if a stack overflow is detected. */
	for( ;; ){

		GPIOC->ODR ^= GPIO_Pin_11; // Toggle Debug Pin
 8001fe4:	4b03      	ldr	r3, [pc, #12]	; (8001ff4 <vApplicationStackOverflowHook+0x10>)
 8001fe6:	8a9a      	ldrh	r2, [r3, #20]
 8001fe8:	b292      	uxth	r2, r2
 8001fea:	f482 6200 	eor.w	r2, r2, #2048	; 0x800
 8001fee:	829a      	strh	r2, [r3, #20]
 8001ff0:	e7f8      	b.n	8001fe4 <vApplicationStackOverflowHook>
 8001ff2:	bf00      	nop
 8001ff4:	48000800 	.word	0x48000800

08001ff8 <vApplicationIdleHook>:
{

	/* This function is called on each cycle of the idle task.  In this case it
	does nothing useful, other than report the amout of FreeRTOS heap that
	remains unallocated. */
	vCoRoutineSchedule();
 8001ff8:	f003 bde4 	b.w	8005bc4 <vCoRoutineSchedule>

08001ffc <vApplicationTickHook>:
}


void vApplicationTickHook( void )
{
 8001ffc:	4770      	bx	lr
 8001ffe:	bf00      	nop

08002000 <printchar>:

static void printchar(char **str, int c)
{
    //extern int putchar(int c);

    if (str) {
 8002000:	b128      	cbz	r0, 800200e <printchar+0xe>
        **str = c;
 8002002:	6803      	ldr	r3, [r0, #0]
 8002004:	7019      	strb	r1, [r3, #0]
        ++(*str);
 8002006:	6803      	ldr	r3, [r0, #0]
 8002008:	3301      	adds	r3, #1
 800200a:	6003      	str	r3, [r0, #0]
 800200c:	4770      	bx	lr
    }
    else (void)putchar(c);
 800200e:	b2c8      	uxtb	r0, r1
 8002010:	f000 be1c 	b.w	8002c4c <Usart2Put>

08002014 <prints>:

#define PAD_RIGHT 1
#define PAD_ZERO 2

static int prints(char **out, const char *string, int width, int pad)
{
 8002014:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    register int pc = 0, padchar = ' ';

    if (width > 0) {
 8002018:	1e14      	subs	r4, r2, #0

#define PAD_RIGHT 1
#define PAD_ZERO 2

static int prints(char **out, const char *string, int width, int pad)
{
 800201a:	4680      	mov	r8, r0
 800201c:	4689      	mov	r9, r1
    register int pc = 0, padchar = ' ';

    if (width > 0) {
 800201e:	dd10      	ble.n	8002042 <prints+0x2e>
 8002020:	2200      	movs	r2, #0
        register int len = 0;
        register const char *ptr;
        for (ptr = string; *ptr; ++ptr) ++len;
 8002022:	f819 1002 	ldrb.w	r1, [r9, r2]
 8002026:	b109      	cbz	r1, 800202c <prints+0x18>
 8002028:	3201      	adds	r2, #1
 800202a:	e7fa      	b.n	8002022 <prints+0xe>
        if (len >= width) width = 0;
 800202c:	42a2      	cmp	r2, r4
        else width -= len;
 800202e:	bfb4      	ite	lt
 8002030:	ebc2 0404 	rsblt	r4, r2, r4

    if (width > 0) {
        register int len = 0;
        register const char *ptr;
        for (ptr = string; *ptr; ++ptr) ++len;
        if (len >= width) width = 0;
 8002034:	460c      	movge	r4, r1
#define PAD_RIGHT 1
#define PAD_ZERO 2

static int prints(char **out, const char *string, int width, int pad)
{
    register int pc = 0, padchar = ' ';
 8002036:	f013 0f02 	tst.w	r3, #2
 800203a:	bf14      	ite	ne
 800203c:	2730      	movne	r7, #48	; 0x30
 800203e:	2720      	moveq	r7, #32
 8002040:	e000      	b.n	8002044 <prints+0x30>
 8002042:	2720      	movs	r7, #32
        for (ptr = string; *ptr; ++ptr) ++len;
        if (len >= width) width = 0;
        else width -= len;
        if (pad & PAD_ZERO) padchar = '0';
    }
    if (!(pad & PAD_RIGHT)) {
 8002044:	07db      	lsls	r3, r3, #31
 8002046:	d40c      	bmi.n	8002062 <prints+0x4e>
 8002048:	4625      	mov	r5, r4
        for ( ; width > 0; --width) {
 800204a:	2d00      	cmp	r5, #0
 800204c:	dd05      	ble.n	800205a <prints+0x46>
            printchar (out, padchar);
 800204e:	4640      	mov	r0, r8
 8002050:	4639      	mov	r1, r7
 8002052:	f7ff ffd5 	bl	8002000 <printchar>
        if (len >= width) width = 0;
        else width -= len;
        if (pad & PAD_ZERO) padchar = '0';
    }
    if (!(pad & PAD_RIGHT)) {
        for ( ; width > 0; --width) {
 8002056:	3d01      	subs	r5, #1
 8002058:	e7f7      	b.n	800204a <prints+0x36>
 800205a:	ea24 76e4 	bic.w	r6, r4, r4, asr #31
 800205e:	1ba4      	subs	r4, r4, r6
 8002060:	e000      	b.n	8002064 <prints+0x50>
#define PAD_RIGHT 1
#define PAD_ZERO 2

static int prints(char **out, const char *string, int width, int pad)
{
    register int pc = 0, padchar = ' ';
 8002062:	2600      	movs	r6, #0
 8002064:	4635      	mov	r5, r6
 8002066:	ebc6 0309 	rsb	r3, r6, r9
        for ( ; width > 0; --width) {
            printchar (out, padchar);
            ++pc;
        }
    }
    for ( ; *string ; ++string) {
 800206a:	5d59      	ldrb	r1, [r3, r5]
 800206c:	b121      	cbz	r1, 8002078 <prints+0x64>
        printchar (out, *string);
 800206e:	4640      	mov	r0, r8
 8002070:	f7ff ffc6 	bl	8002000 <printchar>
        ++pc;
 8002074:	3501      	adds	r5, #1
 8002076:	e7f6      	b.n	8002066 <prints+0x52>
        for ( ; width > 0; --width) {
            printchar (out, padchar);
            ++pc;
        }
    }
    for ( ; *string ; ++string) {
 8002078:	4626      	mov	r6, r4
        printchar (out, *string);
        ++pc;
    }
    for ( ; width > 0; --width) {
 800207a:	2e00      	cmp	r6, #0
 800207c:	dd05      	ble.n	800208a <prints+0x76>
        printchar (out, padchar);
 800207e:	4640      	mov	r0, r8
 8002080:	4639      	mov	r1, r7
 8002082:	f7ff ffbd 	bl	8002000 <printchar>
    }
    for ( ; *string ; ++string) {
        printchar (out, *string);
        ++pc;
    }
    for ( ; width > 0; --width) {
 8002086:	3e01      	subs	r6, #1
 8002088:	e7f7      	b.n	800207a <prints+0x66>
        printchar (out, padchar);
        ++pc;
    }

    return pc;
}
 800208a:	2c00      	cmp	r4, #0
 800208c:	bfac      	ite	ge
 800208e:	1928      	addge	r0, r5, r4
 8002090:	1c28      	addlt	r0, r5, #0
 8002092:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

08002096 <printi>:

/* the following should be enough for 32 bit int */
#define PRINT_BUF_LEN 12

static int printi(char **out, int i, int b, int sg, int width, int pad, int letbase)
{
 8002096:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 800209a:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 800209c:	f8dd 8034 	ldr.w	r8, [sp, #52]	; 0x34
 80020a0:	4681      	mov	r9, r0
    char print_buf[PRINT_BUF_LEN];
    register char *s;
    register int t, neg = 0, pc = 0;
    register unsigned int u = i;
 80020a2:	460c      	mov	r4, r1

    if (i == 0) {
 80020a4:	b951      	cbnz	r1, 80020bc <printi+0x26>
        print_buf[0] = '0';
 80020a6:	2330      	movs	r3, #48	; 0x30
 80020a8:	f88d 3004 	strb.w	r3, [sp, #4]
        print_buf[1] = '\0';
 80020ac:	f88d 1005 	strb.w	r1, [sp, #5]
        return prints (out, print_buf, width, pad);
 80020b0:	4632      	mov	r2, r6
 80020b2:	a901      	add	r1, sp, #4
 80020b4:	4643      	mov	r3, r8
 80020b6:	f7ff ffad 	bl	8002014 <prints>
 80020ba:	e036      	b.n	800212a <printi+0x94>
    }

    if (sg && b == 10 && i < 0) {
 80020bc:	b133      	cbz	r3, 80020cc <printi+0x36>
 80020be:	2a0a      	cmp	r2, #10
 80020c0:	d104      	bne.n	80020cc <printi+0x36>
 80020c2:	2900      	cmp	r1, #0
 80020c4:	da02      	bge.n	80020cc <printi+0x36>
        neg = 1;
        u = -i;
 80020c6:	424c      	negs	r4, r1
        print_buf[1] = '\0';
        return prints (out, print_buf, width, pad);
    }

    if (sg && b == 10 && i < 0) {
        neg = 1;
 80020c8:	2701      	movs	r7, #1
 80020ca:	e000      	b.n	80020ce <printi+0x38>

static int printi(char **out, int i, int b, int sg, int width, int pad, int letbase)
{
    char print_buf[PRINT_BUF_LEN];
    register char *s;
    register int t, neg = 0, pc = 0;
 80020cc:	2700      	movs	r7, #0
        neg = 1;
        u = -i;
    }

    s = print_buf + PRINT_BUF_LEN-1;
    *s = '\0';
 80020ce:	ad04      	add	r5, sp, #16
 80020d0:	2300      	movs	r3, #0
 80020d2:	f805 3d01 	strb.w	r3, [r5, #-1]!
 80020d6:	46aa      	mov	sl, r5

    while (u) {
 80020d8:	b174      	cbz	r4, 80020f8 <printi+0x62>
        t = u % b;
 80020da:	fbb4 f3f2 	udiv	r3, r4, r2
 80020de:	fb02 4413 	mls	r4, r2, r3, r4
        if( t >= 10 )
 80020e2:	2c09      	cmp	r4, #9
 80020e4:	dd03      	ble.n	80020ee <printi+0x58>
            t += letbase - '0' - 10;
 80020e6:	980e      	ldr	r0, [sp, #56]	; 0x38
 80020e8:	f1a0 013a 	sub.w	r1, r0, #58	; 0x3a
 80020ec:	440c      	add	r4, r1
        *--s = t + '0';
 80020ee:	3430      	adds	r4, #48	; 0x30
 80020f0:	f805 4d01 	strb.w	r4, [r5, #-1]!
        u /= b;
 80020f4:	461c      	mov	r4, r3
 80020f6:	e7ee      	b.n	80020d6 <printi+0x40>
    }

    if (neg) {
 80020f8:	b187      	cbz	r7, 800211c <printi+0x86>
        if( width && (pad & PAD_ZERO) ) {
 80020fa:	b14e      	cbz	r6, 8002110 <printi+0x7a>
 80020fc:	f018 0f02 	tst.w	r8, #2
 8002100:	d006      	beq.n	8002110 <printi+0x7a>
            printchar (out, '-');
 8002102:	4648      	mov	r0, r9
 8002104:	212d      	movs	r1, #45	; 0x2d
 8002106:	f7ff ff7b 	bl	8002000 <printchar>
            ++pc;
            --width;
 800210a:	3e01      	subs	r6, #1
    }

    if (neg) {
        if( width && (pad & PAD_ZERO) ) {
            printchar (out, '-');
            ++pc;
 800210c:	2701      	movs	r7, #1
            --width;
 800210e:	e005      	b.n	800211c <printi+0x86>
        }
        else {
            *--s = '-';
 8002110:	232d      	movs	r3, #45	; 0x2d
 8002112:	f105 3aff 	add.w	sl, r5, #4294967295
 8002116:	f805 3c01 	strb.w	r3, [r5, #-1]

static int printi(char **out, int i, int b, int sg, int width, int pad, int letbase)
{
    char print_buf[PRINT_BUF_LEN];
    register char *s;
    register int t, neg = 0, pc = 0;
 800211a:	2700      	movs	r7, #0
        else {
            *--s = '-';
        }
    }

    return pc + prints (out, s, width, pad);
 800211c:	4648      	mov	r0, r9
 800211e:	4651      	mov	r1, sl
 8002120:	4632      	mov	r2, r6
 8002122:	4643      	mov	r3, r8
 8002124:	f7ff ff76 	bl	8002014 <prints>
 8002128:	4438      	add	r0, r7
}
 800212a:	b004      	add	sp, #16
 800212c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

08002130 <print>:

static int print( char **out, const char *format, va_list args )
{
 8002130:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002132:	b089      	sub	sp, #36	; 0x24
 8002134:	4606      	mov	r6, r0
 8002136:	460d      	mov	r5, r1
 8002138:	9205      	str	r2, [sp, #20]
    register int width, pad;
    register int pc = 0;
 800213a:	2400      	movs	r4, #0
    char scr[2];

    for (; *format != 0; ++format) {
 800213c:	782b      	ldrb	r3, [r5, #0]
 800213e:	b123      	cbz	r3, 800214a <print+0x1a>
        if (*format == '%') {
 8002140:	2b25      	cmp	r3, #37	; 0x25
 8002142:	d179      	bne.n	8002238 <print+0x108>
            ++format;
            width = pad = 0;
            if (*format == '\0') break;
 8002144:	786b      	ldrb	r3, [r5, #1]
    register int pc = 0;
    char scr[2];

    for (; *format != 0; ++format) {
        if (*format == '%') {
            ++format;
 8002146:	1c6a      	adds	r2, r5, #1
            width = pad = 0;
            if (*format == '\0') break;
 8002148:	b92b      	cbnz	r3, 8002156 <print+0x26>
        out:
            printchar (out, *format);
            ++pc;
        }
    }
    if (out) **out = '\0';
 800214a:	2e00      	cmp	r6, #0
 800214c:	d07b      	beq.n	8002246 <print+0x116>
 800214e:	6833      	ldr	r3, [r6, #0]
 8002150:	2200      	movs	r2, #0
 8002152:	701a      	strb	r2, [r3, #0]
 8002154:	e077      	b.n	8002246 <print+0x116>
    for (; *format != 0; ++format) {
        if (*format == '%') {
            ++format;
            width = pad = 0;
            if (*format == '\0') break;
            if (*format == '%') goto out;
 8002156:	2b25      	cmp	r3, #37	; 0x25
 8002158:	d06d      	beq.n	8002236 <print+0x106>
            if (*format == '-') {
 800215a:	2b2d      	cmp	r3, #45	; 0x2d
                ++format;
 800215c:	bf06      	itte	eq
 800215e:	1caa      	addeq	r2, r5, #2
                pad = PAD_RIGHT;
 8002160:	2301      	moveq	r3, #1
    char scr[2];

    for (; *format != 0; ++format) {
        if (*format == '%') {
            ++format;
            width = pad = 0;
 8002162:	2300      	movne	r3, #0
 8002164:	4617      	mov	r7, r2
 8002166:	3201      	adds	r2, #1
            if (*format == '%') goto out;
            if (*format == '-') {
                ++format;
                pad = PAD_RIGHT;
            }
            while (*format == '0') {
 8002168:	7839      	ldrb	r1, [r7, #0]
 800216a:	2930      	cmp	r1, #48	; 0x30
 800216c:	d102      	bne.n	8002174 <print+0x44>
                ++format;
                pad |= PAD_ZERO;
 800216e:	f043 0302 	orr.w	r3, r3, #2
 8002172:	e7f7      	b.n	8002164 <print+0x34>
            if (*format == '%') goto out;
            if (*format == '-') {
                ++format;
                pad = PAD_RIGHT;
            }
            while (*format == '0') {
 8002174:	2200      	movs	r2, #0
                ++format;
                pad |= PAD_ZERO;
            }
            for ( ; *format >= '0' && *format <= '9'; ++format) {
 8002176:	7839      	ldrb	r1, [r7, #0]
 8002178:	f1a1 0030 	sub.w	r0, r1, #48	; 0x30
 800217c:	fa5f fc80 	uxtb.w	ip, r0
 8002180:	f1bc 0f09 	cmp.w	ip, #9
 8002184:	463d      	mov	r5, r7
 8002186:	f107 0701 	add.w	r7, r7, #1
 800218a:	d803      	bhi.n	8002194 <print+0x64>
                width *= 10;
                width += *format - '0';
 800218c:	210a      	movs	r1, #10
 800218e:	fb01 0202 	mla	r2, r1, r2, r0
 8002192:	e7f0      	b.n	8002176 <print+0x46>
            }
            if( *format == 's' ) {
 8002194:	2973      	cmp	r1, #115	; 0x73
 8002196:	d109      	bne.n	80021ac <print+0x7c>
                register char *s = (char *)va_arg( args, int );
 8002198:	9905      	ldr	r1, [sp, #20]
                pc += prints (out, s?s:"(null)", width, pad);
 800219a:	4f2c      	ldr	r7, [pc, #176]	; (800224c <print+0x11c>)
            for ( ; *format >= '0' && *format <= '9'; ++format) {
                width *= 10;
                width += *format - '0';
            }
            if( *format == 's' ) {
                register char *s = (char *)va_arg( args, int );
 800219c:	1d08      	adds	r0, r1, #4
 800219e:	6809      	ldr	r1, [r1, #0]
 80021a0:	9005      	str	r0, [sp, #20]
                pc += prints (out, s?s:"(null)", width, pad);
 80021a2:	2900      	cmp	r1, #0
 80021a4:	bf08      	it	eq
 80021a6:	4639      	moveq	r1, r7
 80021a8:	4630      	mov	r0, r6
 80021aa:	e041      	b.n	8002230 <print+0x100>
                continue;
            }
            if( *format == 'd' ) {
 80021ac:	2964      	cmp	r1, #100	; 0x64
 80021ae:	d10e      	bne.n	80021ce <print+0x9e>
                pc += printi (out, va_arg( args, int ), 10, 1, width, pad, 'a');
 80021b0:	e88d 000c 	stmia.w	sp, {r2, r3}
 80021b4:	9905      	ldr	r1, [sp, #20]
 80021b6:	2361      	movs	r3, #97	; 0x61
 80021b8:	9302      	str	r3, [sp, #8]
 80021ba:	1d08      	adds	r0, r1, #4
 80021bc:	6809      	ldr	r1, [r1, #0]
 80021be:	9005      	str	r0, [sp, #20]
 80021c0:	220a      	movs	r2, #10
 80021c2:	4630      	mov	r0, r6
 80021c4:	2301      	movs	r3, #1
 80021c6:	f7ff ff66 	bl	8002096 <printi>
 80021ca:	4404      	add	r4, r0
                continue;
 80021cc:	e039      	b.n	8002242 <print+0x112>
            }
            if( *format == 'x' ) {
 80021ce:	2978      	cmp	r1, #120	; 0x78
 80021d0:	d106      	bne.n	80021e0 <print+0xb0>
                pc += printi (out, va_arg( args, int ), 16, 0, width, pad, 'a');
 80021d2:	9905      	ldr	r1, [sp, #20]
 80021d4:	1d08      	adds	r0, r1, #4
 80021d6:	e88d 000c 	stmia.w	sp, {r2, r3}
 80021da:	9005      	str	r0, [sp, #20]
 80021dc:	2361      	movs	r3, #97	; 0x61
 80021de:	e007      	b.n	80021f0 <print+0xc0>
                continue;
            }
            if( *format == 'X' ) {
 80021e0:	2958      	cmp	r1, #88	; 0x58
 80021e2:	d10a      	bne.n	80021fa <print+0xca>
                pc += printi (out, va_arg( args, int ), 16, 0, width, pad, 'A');
 80021e4:	9905      	ldr	r1, [sp, #20]
 80021e6:	1d08      	adds	r0, r1, #4
 80021e8:	e88d 000c 	stmia.w	sp, {r2, r3}
 80021ec:	9005      	str	r0, [sp, #20]
 80021ee:	2341      	movs	r3, #65	; 0x41
 80021f0:	9302      	str	r3, [sp, #8]
 80021f2:	4630      	mov	r0, r6
 80021f4:	6809      	ldr	r1, [r1, #0]
 80021f6:	2210      	movs	r2, #16
 80021f8:	e00b      	b.n	8002212 <print+0xe2>
                continue;
            }
            if( *format == 'u' ) {
 80021fa:	2975      	cmp	r1, #117	; 0x75
 80021fc:	d10b      	bne.n	8002216 <print+0xe6>
                pc += printi (out, va_arg( args, int ), 10, 0, width, pad, 'a');
 80021fe:	e88d 000c 	stmia.w	sp, {r2, r3}
 8002202:	9905      	ldr	r1, [sp, #20]
 8002204:	2361      	movs	r3, #97	; 0x61
 8002206:	9302      	str	r3, [sp, #8]
 8002208:	1d08      	adds	r0, r1, #4
 800220a:	6809      	ldr	r1, [r1, #0]
 800220c:	9005      	str	r0, [sp, #20]
 800220e:	220a      	movs	r2, #10
 8002210:	4630      	mov	r0, r6
 8002212:	2300      	movs	r3, #0
 8002214:	e7d7      	b.n	80021c6 <print+0x96>
                continue;
            }
            if( *format == 'c' ) {
 8002216:	2963      	cmp	r1, #99	; 0x63
 8002218:	d113      	bne.n	8002242 <print+0x112>
                /* char are converted to int then pushed on the stack */
                scr[0] = (char)va_arg( args, int );
 800221a:	9905      	ldr	r1, [sp, #20]
 800221c:	1d08      	adds	r0, r1, #4
 800221e:	6809      	ldr	r1, [r1, #0]
 8002220:	f88d 101c 	strb.w	r1, [sp, #28]
                scr[1] = '\0';
 8002224:	2100      	movs	r1, #0
                pc += printi (out, va_arg( args, int ), 10, 0, width, pad, 'a');
                continue;
            }
            if( *format == 'c' ) {
                /* char are converted to int then pushed on the stack */
                scr[0] = (char)va_arg( args, int );
 8002226:	9005      	str	r0, [sp, #20]
                scr[1] = '\0';
 8002228:	f88d 101d 	strb.w	r1, [sp, #29]
                pc += prints (out, scr, width, pad);
 800222c:	4630      	mov	r0, r6
 800222e:	a907      	add	r1, sp, #28
 8002230:	f7ff fef0 	bl	8002014 <prints>
 8002234:	e7c9      	b.n	80021ca <print+0x9a>
    register int pc = 0;
    char scr[2];

    for (; *format != 0; ++format) {
        if (*format == '%') {
            ++format;
 8002236:	4615      	mov	r5, r2
                continue;
            }
        }
        else {
        out:
            printchar (out, *format);
 8002238:	4630      	mov	r0, r6
 800223a:	7829      	ldrb	r1, [r5, #0]
 800223c:	f7ff fee0 	bl	8002000 <printchar>
            ++pc;
 8002240:	3401      	adds	r4, #1
{
    register int width, pad;
    register int pc = 0;
    char scr[2];

    for (; *format != 0; ++format) {
 8002242:	3501      	adds	r5, #1
 8002244:	e77a      	b.n	800213c <print+0xc>
        }
    }
    if (out) **out = '\0';
    va_end( args );
    return pc;
}
 8002246:	4620      	mov	r0, r4
 8002248:	b009      	add	sp, #36	; 0x24
 800224a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800224c:	08009d36 	.word	0x08009d36

08002250 <printf>:

int printf(const char *format, ...)
{
 8002250:	b40f      	push	{r0, r1, r2, r3}
 8002252:	b507      	push	{r0, r1, r2, lr}
 8002254:	aa04      	add	r2, sp, #16
        va_list args;

        va_start( args, format );
        return print( 0, format, args );
 8002256:	2000      	movs	r0, #0
    va_end( args );
    return pc;
}

int printf(const char *format, ...)
{
 8002258:	f852 1b04 	ldr.w	r1, [r2], #4
        va_list args;

        va_start( args, format );
 800225c:	9201      	str	r2, [sp, #4]
        return print( 0, format, args );
 800225e:	f7ff ff67 	bl	8002130 <print>
}
 8002262:	b003      	add	sp, #12
 8002264:	f85d eb04 	ldr.w	lr, [sp], #4
 8002268:	b004      	add	sp, #16
 800226a:	4770      	bx	lr

0800226c <sprintf>:

int sprintf(char *out, const char *format, ...)
{
 800226c:	b40e      	push	{r1, r2, r3}
 800226e:	b50f      	push	{r0, r1, r2, r3, lr}
 8002270:	aa05      	add	r2, sp, #20
 8002272:	9001      	str	r0, [sp, #4]
 8002274:	f852 1b04 	ldr.w	r1, [r2], #4
        va_list args;

        va_start( args, format );
 8002278:	9203      	str	r2, [sp, #12]
        return print( &out, format, args );
 800227a:	a801      	add	r0, sp, #4
 800227c:	f7ff ff58 	bl	8002130 <print>
}
 8002280:	b004      	add	sp, #16
 8002282:	f85d eb04 	ldr.w	lr, [sp], #4
 8002286:	b003      	add	sp, #12
 8002288:	4770      	bx	lr

0800228a <snprintf>:


int snprintf( char *buf, unsigned int count, const char *format, ... )
{
 800228a:	b40c      	push	{r2, r3}
 800228c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 800228e:	aa06      	add	r2, sp, #24
 8002290:	9001      	str	r0, [sp, #4]
 8002292:	f852 1b04 	ldr.w	r1, [r2], #4
        va_list args;

        ( void ) count;

        va_start( args, format );
 8002296:	9203      	str	r2, [sp, #12]
        return print( &buf, format, args );
 8002298:	a801      	add	r0, sp, #4
 800229a:	f7ff ff49 	bl	8002130 <print>
}
 800229e:	b005      	add	sp, #20
 80022a0:	f85d eb04 	ldr.w	lr, [sp], #4
 80022a4:	b002      	add	sp, #8
 80022a6:	4770      	bx	lr

080022a8 <CalcRXValues>:
#include <filter_Lib.h>
#include <remote_control.h>
#include <vertibot_settings.h>

void CalcRXValues(unsigned char *msgPointer, int16_t adjValue)
{
 80022a8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	static intFilter pitchFiltered = {0,0};
	static intFilter yawFiltered = {0,0};
	static int16_t currentYaw = 0;

	/*Reset the Watchdog Timer value*/
	CtrlStates.watchDogTimVal = 0;
 80022aa:	4d5a      	ldr	r5, [pc, #360]	; (8002414 <CalcRXValues+0x16c>)

	currentYaw = ((uint8_t)msgPointer[4]-adjValue);
 80022ac:	4c5a      	ldr	r4, [pc, #360]	; (8002418 <CalcRXValues+0x170>)

	update_intFilter(&gasFiltered, 1, (((uint8_t)msgPointer[5]-adjValue)*7.5f)+60);
 80022ae:	eddf 7a5b 	vldr	s15, [pc, #364]	; 800241c <CalcRXValues+0x174>
	static intFilter pitchFiltered = {0,0};
	static intFilter yawFiltered = {0,0};
	static int16_t currentYaw = 0;

	/*Reset the Watchdog Timer value*/
	CtrlStates.watchDogTimVal = 0;
 80022b2:	2300      	movs	r3, #0
 80022b4:	726b      	strb	r3, [r5, #9]

	currentYaw = ((uint8_t)msgPointer[4]-adjValue);
 80022b6:	7903      	ldrb	r3, [r0, #4]
#include <filter_Lib.h>
#include <remote_control.h>
#include <vertibot_settings.h>

void CalcRXValues(unsigned char *msgPointer, int16_t adjValue)
{
 80022b8:	4607      	mov	r7, r0
	static int16_t currentYaw = 0;

	/*Reset the Watchdog Timer value*/
	CtrlStates.watchDogTimVal = 0;

	currentYaw = ((uint8_t)msgPointer[4]-adjValue);
 80022ba:	4620      	mov	r0, r4
 80022bc:	1a5b      	subs	r3, r3, r1
 80022be:	f820 3b04 	strh.w	r3, [r0], #4

	update_intFilter(&gasFiltered, 1, (((uint8_t)msgPointer[5]-adjValue)*7.5f)+60);
 80022c2:	797b      	ldrb	r3, [r7, #5]
 80022c4:	1a5b      	subs	r3, r3, r1
 80022c6:	ee07 3a10 	vmov	s14, r3
 80022ca:	eef8 6ac7 	vcvt.f32.s32	s13, s14
 80022ce:	eeb1 7a0e 	vmov.f32	s14, #30
 80022d2:	eee6 7a87 	vfma.f32	s15, s13, s14
#include <filter_Lib.h>
#include <remote_control.h>
#include <vertibot_settings.h>

void CalcRXValues(unsigned char *msgPointer, int16_t adjValue)
{
 80022d6:	460e      	mov	r6, r1
	/*Reset the Watchdog Timer value*/
	CtrlStates.watchDogTimVal = 0;

	currentYaw = ((uint8_t)msgPointer[4]-adjValue);

	update_intFilter(&gasFiltered, 1, (((uint8_t)msgPointer[5]-adjValue)*7.5f)+60);
 80022d8:	2101      	movs	r1, #1
 80022da:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80022de:	ee17 2a90 	vmov	r2, s15
 80022e2:	f7ff fbe7 	bl	8001ab4 <update_intFilter>
	update_intFilter(&pitchFiltered, 1, ((uint8_t)msgPointer[3]-adjValue)*2.0f);
 80022e6:	78fb      	ldrb	r3, [r7, #3]
 80022e8:	1b9b      	subs	r3, r3, r6
 80022ea:	ee07 3a10 	vmov	s14, r3
 80022ee:	eef8 7ac7 	vcvt.f32.s32	s15, s14
 80022f2:	f104 000c 	add.w	r0, r4, #12
 80022f6:	ee77 7aa7 	vadd.f32	s15, s15, s15
 80022fa:	2101      	movs	r1, #1
 80022fc:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8002300:	ee17 2a90 	vmov	r2, s15
 8002304:	f7ff fbd6 	bl	8001ab4 <update_intFilter>
	update_intFilter(&rollFiltered, 1, ((uint8_t)msgPointer[2]-adjValue)*2.0f);
 8002308:	78bb      	ldrb	r3, [r7, #2]
 800230a:	1b9e      	subs	r6, r3, r6
 800230c:	ee07 6a10 	vmov	s14, r6
 8002310:	eef8 7ac7 	vcvt.f32.s32	s15, s14
 8002314:	f104 0014 	add.w	r0, r4, #20
 8002318:	ee77 7aa7 	vadd.f32	s15, s15, s15
 800231c:	2101      	movs	r1, #1
 800231e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8002322:	ee17 2a90 	vmov	r2, s15
 8002326:	f7ff fbc5 	bl	8001ab4 <update_intFilter>
	update_intFilter(&yawFiltered, 1, currentYaw*0.3f);
 800232a:	4620      	mov	r0, r4
 800232c:	ed9f 7a3c 	vldr	s14, [pc, #240]	; 8002420 <CalcRXValues+0x178>
 8002330:	f930 3b1c 	ldrsh.w	r3, [r0], #28
 8002334:	ee07 3a90 	vmov	s15, r3
 8002338:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800233c:	2101      	movs	r1, #1
 800233e:	ee67 7a87 	vmul.f32	s15, s15, s14
 8002342:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8002346:	ee17 2a90 	vmov	r2, s15
 800234a:	f7ff fbb3 	bl	8001ab4 <update_intFilter>

	//CtrlStates.gas = gasFiltered.filtered;
	//CtrlStates.roll = rollFiltered.filtered;
	CtrlStates.pitch = pitchFiltered.filtered;
 800234e:	ed94 7a04 	vldr	s14, [r4, #16]

	/* integrating the yaw value */
	if(CtrlStates.copterStatus & ARMED_FLAG)
 8002352:	7a2b      	ldrb	r3, [r5, #8]
	update_intFilter(&rollFiltered, 1, ((uint8_t)msgPointer[2]-adjValue)*2.0f);
	update_intFilter(&yawFiltered, 1, currentYaw*0.3f);

	//CtrlStates.gas = gasFiltered.filtered;
	//CtrlStates.roll = rollFiltered.filtered;
	CtrlStates.pitch = pitchFiltered.filtered;
 8002354:	eef8 7ac7 	vcvt.f32.s32	s15, s14

	/* integrating the yaw value */
	if(CtrlStates.copterStatus & ARMED_FLAG)
 8002358:	f013 0f01 	tst.w	r3, #1
	update_intFilter(&rollFiltered, 1, ((uint8_t)msgPointer[2]-adjValue)*2.0f);
	update_intFilter(&yawFiltered, 1, currentYaw*0.3f);

	//CtrlStates.gas = gasFiltered.filtered;
	//CtrlStates.roll = rollFiltered.filtered;
	CtrlStates.pitch = pitchFiltered.filtered;
 800235c:	edc5 7a00 	vstr	s15, [r5]
 8002360:	462b      	mov	r3, r5

	/* integrating the yaw value */
	if(CtrlStates.copterStatus & ARMED_FLAG)
 8002362:	d00a      	beq.n	800237a <CalcRXValues+0xd2>
	{
		CtrlStates.yaw -= yawFiltered.filtered;
 8002364:	ed94 7a08 	vldr	s14, [r4, #32]
 8002368:	edd5 6a01 	vldr	s13, [r5, #4]
 800236c:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8002370:	ee36 7ac7 	vsub.f32	s14, s13, s14
 8002374:	ed85 7a01 	vstr	s14, [r5, #4]
 8002378:	e002      	b.n	8002380 <CalcRXValues+0xd8>
	}
	else
	{
		CtrlStates.yaw = XYZ.z;
 800237a:	4a2a      	ldr	r2, [pc, #168]	; (8002424 <CalcRXValues+0x17c>)
 800237c:	6892      	ldr	r2, [r2, #8]
 800237e:	606a      	str	r2, [r5, #4]
	//if(CtrlStates.roll > -ROLL_PITCH_TRSHLD && CtrlStates.roll < ROLL_PITCH_TRSHLD) CtrlStates.roll = 0;
	//if(CtrlStates.roll > MAX_ROLL) CtrlStates.roll = MAX_ROLL;
	//if(CtrlStates.roll < -MAX_ROLL) CtrlStates.roll = -MAX_ROLL;

    */
	if(CtrlStates.pitch > -ROLL_PITCH_TRSHLD && CtrlStates.pitch < ROLL_PITCH_TRSHLD) CtrlStates.pitch = 0;
 8002380:	eeb8 7a08 	vmov.f32	s14, #136	; 0x88
 8002384:	eef4 7ac7 	vcmpe.f32	s15, s14
 8002388:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800238c:	dd08      	ble.n	80023a0 <CalcRXValues+0xf8>
 800238e:	eeb0 7a08 	vmov.f32	s14, #8
 8002392:	eef4 7ac7 	vcmpe.f32	s15, s14
 8002396:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800239a:	bf44      	itt	mi
 800239c:	2200      	movmi	r2, #0
 800239e:	601a      	strmi	r2, [r3, #0]
	if(CtrlStates.pitch > MAX_PITCH) CtrlStates.pitch = MAX_PITCH;
 80023a0:	ed93 7a00 	vldr	s14, [r3]
 80023a4:	eddf 7a20 	vldr	s15, [pc, #128]	; 8002428 <CalcRXValues+0x180>
 80023a8:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80023ac:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80023b0:	bfc4      	itt	gt
 80023b2:	4a18      	ldrgt	r2, [pc, #96]	; (8002414 <CalcRXValues+0x16c>)
 80023b4:	edc2 7a00 	vstrgt	s15, [r2]
	if(CtrlStates.pitch < -MAX_PITCH) CtrlStates.pitch = -MAX_PITCH;
 80023b8:	ed93 7a00 	vldr	s14, [r3]
 80023bc:	eddf 7a1b 	vldr	s15, [pc, #108]	; 800242c <CalcRXValues+0x184>
 80023c0:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80023c4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80023c8:	bf48      	it	mi
 80023ca:	4a12      	ldrmi	r2, [pc, #72]	; (8002414 <CalcRXValues+0x16c>)

	/* The yaw value needs a special handling */
	if(CtrlStates.yaw > 180) CtrlStates.yaw -= 360;
 80023cc:	ed9f 7a18 	vldr	s14, [pc, #96]	; 8002430 <CalcRXValues+0x188>
	//if(CtrlStates.roll < -MAX_ROLL) CtrlStates.roll = -MAX_ROLL;

    */
	if(CtrlStates.pitch > -ROLL_PITCH_TRSHLD && CtrlStates.pitch < ROLL_PITCH_TRSHLD) CtrlStates.pitch = 0;
	if(CtrlStates.pitch > MAX_PITCH) CtrlStates.pitch = MAX_PITCH;
	if(CtrlStates.pitch < -MAX_PITCH) CtrlStates.pitch = -MAX_PITCH;
 80023d0:	bf48      	it	mi
 80023d2:	edc2 7a00 	vstrmi	s15, [r2]

	/* The yaw value needs a special handling */
	if(CtrlStates.yaw > 180) CtrlStates.yaw -= 360;
 80023d6:	edd3 7a01 	vldr	s15, [r3, #4]
 80023da:	eef4 7ac7 	vcmpe.f32	s15, s14
 80023de:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80023e2:	dd06      	ble.n	80023f2 <CalcRXValues+0x14a>
 80023e4:	ed9f 7a13 	vldr	s14, [pc, #76]	; 8002434 <CalcRXValues+0x18c>
 80023e8:	4a0a      	ldr	r2, [pc, #40]	; (8002414 <CalcRXValues+0x16c>)
 80023ea:	ee77 7ac7 	vsub.f32	s15, s15, s14
 80023ee:	edc2 7a01 	vstr	s15, [r2, #4]
	if(CtrlStates.yaw < -180) CtrlStates.yaw += 360;
 80023f2:	edd3 7a01 	vldr	s15, [r3, #4]
 80023f6:	ed9f 7a10 	vldr	s14, [pc, #64]	; 8002438 <CalcRXValues+0x190>
 80023fa:	eef4 7ac7 	vcmpe.f32	s15, s14
 80023fe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8002402:	d506      	bpl.n	8002412 <CalcRXValues+0x16a>
 8002404:	ed9f 7a0b 	vldr	s14, [pc, #44]	; 8002434 <CalcRXValues+0x18c>
 8002408:	4b02      	ldr	r3, [pc, #8]	; (8002414 <CalcRXValues+0x16c>)
 800240a:	ee77 7a87 	vadd.f32	s15, s15, s14
 800240e:	edc3 7a01 	vstr	s15, [r3, #4]
 8002412:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002414:	20002f64 	.word	0x20002f64
 8002418:	200004d4 	.word	0x200004d4
 800241c:	42700000 	.word	0x42700000
 8002420:	3e99999a 	.word	0x3e99999a
 8002424:	20002ef8 	.word	0x20002ef8
 8002428:	420c0000 	.word	0x420c0000
 800242c:	c20c0000 	.word	0xc20c0000
 8002430:	43340000 	.word	0x43340000
 8002434:	43b40000 	.word	0x43b40000
 8002438:	c3340000 	.word	0xc3340000

0800243c <RCC_Configuration>:

//! Print Debugmessages
#define DEBUG 0

void RCC_Configuration(void)
{
 800243c:	b508      	push	{r3, lr}
	/* Enable I2C1 periph */
	RCC_APB1PeriphClockCmd( RCC_APB1Periph_I2C1 |
 800243e:	4809      	ldr	r0, [pc, #36]	; (8002464 <RCC_Configuration+0x28>)
 8002440:	2101      	movs	r1, #1
 8002442:	f001 ff53 	bl	80042ec <RCC_APB1PeriphClockCmd>
							RCC_APB1Periph_USART3 |
							RCC_APB1Periph_TIM2 |
							RCC_APB1Periph_TIM3 |
							RCC_APB1Periph_TIM4, ENABLE);
	/* Enable the SPI periph */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1 |
 8002446:	f241 0001 	movw	r0, #4097	; 0x1001
 800244a:	2101      	movs	r1, #1
 800244c:	f001 ff42 	bl	80042d4 <RCC_APB2PeriphClockCmd>
						   RCC_APB2Periph_SYSCFG, ENABLE);

	/* Enable Periph clock enable, SPI, GPIOs */
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA |
 8002450:	4805      	ldr	r0, [pc, #20]	; (8002468 <RCC_Configuration+0x2c>)
 8002452:	2101      	movs	r1, #1
 8002454:	f001 ff32 	bl	80042bc <RCC_AHBPeriphClockCmd>
						  RCC_AHBPeriph_GPIOE |
						  RCC_AHBPeriph_ADC12 |
						  RCC_AHBPeriph_DMA1, ENABLE);

	/* Configure the ADC clock */
	RCC_ADCCLKConfig(RCC_ADC12PLLCLK_Div2);
 8002458:	f44f 7088 	mov.w	r0, #272	; 0x110
}
 800245c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
						  RCC_AHBPeriph_GPIOE |
						  RCC_AHBPeriph_ADC12 |
						  RCC_AHBPeriph_DMA1, ENABLE);

	/* Configure the ADC clock */
	RCC_ADCCLKConfig(RCC_ADC12PLLCLK_Div2);
 8002460:	f001 beb8 	b.w	80041d4 <RCC_ADCCLKConfig>
 8002464:	00260007 	.word	0x00260007
 8002468:	103e0001 	.word	0x103e0001

0800246c <NVIC_Configuration>:




void NVIC_Configuration(void)
{
 800246c:	b537      	push	{r0, r1, r2, r4, r5, lr}
	#ifdef  VECT_TAB_RAM
	  /* Set the Vector Table base location at 0x20000000 */
	  NVIC_SetVectorTable(NVIC_VectTab_RAM, 0x0);
	#else  /* VECT_TAB_FLASH  */
	  /* Set the Vector Table base location at 0x08000000 */
	  NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x0);
 800246e:	2100      	movs	r1, #0
 8002470:	f04f 6000 	mov.w	r0, #134217728	; 0x8000000
 8002474:	f001 fca2 	bl	8003dbc <NVIC_SetVectorTable>
	#endif

	NVIC_PriorityGroupConfig( NVIC_PriorityGroup_4 );
 8002478:	f44f 7040 	mov.w	r0, #768	; 0x300
 800247c:	f001 fc60 	bl	8003d40 <NVIC_PriorityGroupConfig>

	/* Enable the USARTx Interrupt */
	NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn;
 8002480:	2326      	movs	r3, #38	; 0x26
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 14;	// Je höher desto niedriger
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;			// FreeRtos desto höher desto höher
 8002482:	2500      	movs	r5, #0
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 8002484:	2401      	movs	r4, #1
	#endif

	NVIC_PriorityGroupConfig( NVIC_PriorityGroup_4 );

	/* Enable the USARTx Interrupt */
	NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn;
 8002486:	f88d 3004 	strb.w	r3, [sp, #4]
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 14;	// Je höher desto niedriger
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;			// FreeRtos desto höher desto höher
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);
 800248a:	a801      	add	r0, sp, #4

	NVIC_PriorityGroupConfig( NVIC_PriorityGroup_4 );

	/* Enable the USARTx Interrupt */
	NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 14;	// Je höher desto niedriger
 800248c:	230e      	movs	r3, #14
 800248e:	f88d 3005 	strb.w	r3, [sp, #5]
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;			// FreeRtos desto höher desto höher
 8002492:	f88d 5006 	strb.w	r5, [sp, #6]
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 8002496:	f88d 4007 	strb.w	r4, [sp, #7]
	NVIC_Init(&NVIC_InitStructure);
 800249a:	f001 fc5b 	bl	8003d54 <NVIC_Init>

	/* Config the USART3 Interrupt*/
	NVIC_InitStructure.NVIC_IRQChannel = USART3_IRQn;
 800249e:	2327      	movs	r3, #39	; 0x27
 80024a0:	f88d 3004 	strb.w	r3, [sp, #4]
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 10;  // wie war das noch mal mit den Interrupt prioritäten??
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);
 80024a4:	a801      	add	r0, sp, #4
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);

	/* Config the USART3 Interrupt*/
	NVIC_InitStructure.NVIC_IRQChannel = USART3_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 10;  // wie war das noch mal mit den Interrupt prioritäten??
 80024a6:	230a      	movs	r3, #10
 80024a8:	f88d 3005 	strb.w	r3, [sp, #5]
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
 80024ac:	f88d 5006 	strb.w	r5, [sp, #6]
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 80024b0:	f88d 4007 	strb.w	r4, [sp, #7]
	NVIC_Init(&NVIC_InitStructure);
 80024b4:	f001 fc4e 	bl	8003d54 <NVIC_Init>

	/* Enable and set EXTI0 Interrupt to the lowest priority */
	NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;
 80024b8:	2328      	movs	r3, #40	; 0x28
 80024ba:	f88d 3004 	strb.w	r3, [sp, #4]
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 13;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);
 80024be:	a801      	add	r0, sp, #4
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);

	/* Enable and set EXTI0 Interrupt to the lowest priority */
	NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 13;
 80024c0:	230d      	movs	r3, #13
 80024c2:	f88d 3005 	strb.w	r3, [sp, #5]
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
 80024c6:	f88d 5006 	strb.w	r5, [sp, #6]
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 80024ca:	f88d 4007 	strb.w	r4, [sp, #7]
	NVIC_Init(&NVIC_InitStructure);
 80024ce:	f001 fc41 	bl	8003d54 <NVIC_Init>
}
 80024d2:	b003      	add	sp, #12
 80024d4:	bd30      	pop	{r4, r5, pc}

080024d6 <GPIO_Configuration>:



void GPIO_Configuration(void)
{
 80024d6:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80024da:	b085      	sub	sp, #20
	/************************GPIO***************************/
	GPIO_InitTypeDef GPIO_InitStructure;
	/* Configure PE14 and PE15 in output pushpull mode */

	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8 | GPIO_Pin_9 |
 80024dc:	f44f 437f 	mov.w	r3, #65280	; 0xff00
 80024e0:	9302      	str	r3, [sp, #8]
								  GPIO_Pin_14 | GPIO_Pin_15;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOE, &GPIO_InitStructure);
 80024e2:	4b7a      	ldr	r3, [pc, #488]	; (80026cc <GPIO_Configuration+0x1f6>)
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOC, &GPIO_InitStructure);
 80024e4:	f8df 91ec 	ldr.w	r9, [pc, #492]	; 80026d4 <GPIO_Configuration+0x1fe>
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 80024e8:	4f79      	ldr	r7, [pc, #484]	; (80026d0 <GPIO_Configuration+0x1fa>)
								  GPIO_Pin_14 | GPIO_Pin_15;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOE, &GPIO_InitStructure);
 80024ea:	9301      	str	r3, [sp, #4]
 80024ec:	4618      	mov	r0, r3
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8 | GPIO_Pin_9 |
								  GPIO_Pin_10 | GPIO_Pin_11 |
								  GPIO_Pin_12 | GPIO_Pin_13 |
								  GPIO_Pin_14 | GPIO_Pin_15;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 80024ee:	2400      	movs	r4, #0
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 80024f0:	2503      	movs	r5, #3

	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8 | GPIO_Pin_9 |
								  GPIO_Pin_10 | GPIO_Pin_11 |
								  GPIO_Pin_12 | GPIO_Pin_13 |
								  GPIO_Pin_14 | GPIO_Pin_15;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 80024f2:	f04f 0801 	mov.w	r8, #1
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOE, &GPIO_InitStructure);
 80024f6:	a902      	add	r1, sp, #8

	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8 | GPIO_Pin_9 |
								  GPIO_Pin_10 | GPIO_Pin_11 |
								  GPIO_Pin_12 | GPIO_Pin_13 |
								  GPIO_Pin_14 | GPIO_Pin_15;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 80024f8:	f88d 800c 	strb.w	r8, [sp, #12]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 80024fc:	f88d 400e 	strb.w	r4, [sp, #14]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8002500:	f88d 500d 	strb.w	r5, [sp, #13]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 8002504:	f88d 400f 	strb.w	r4, [sp, #15]
	GPIO_Init(GPIOE, &GPIO_InitStructure);
 8002508:	f001 f9e8 	bl	80038dc <GPIO_Init>



	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
 800250c:	f44f 6200 	mov.w	r2, #2048	; 0x800
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOC, &GPIO_InitStructure);
 8002510:	4648      	mov	r0, r9
 8002512:	a902      	add	r1, sp, #8
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOE, &GPIO_InitStructure);



	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
 8002514:	9202      	str	r2, [sp, #8]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8002516:	f88d 800c 	strb.w	r8, [sp, #12]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 800251a:	f88d 400e 	strb.w	r4, [sp, #14]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 800251e:	f88d 500d 	strb.w	r5, [sp, #13]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 8002522:	f88d 400f 	strb.w	r4, [sp, #15]
	GPIO_Init(GPIOC, &GPIO_InitStructure);
 8002526:	f001 f9d9 	bl	80038dc <GPIO_Init>
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 800252a:	4638      	mov	r0, r7
 800252c:	a902      	add	r1, sp, #8
	/************************END GPIO***************************/

	/****************************USART****************************/
	/* GPIOA Configuration:  USART2 TX on PA2 */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2 | GPIO_Pin_3;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 800252e:	2602      	movs	r6, #2
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOC, &GPIO_InitStructure);


	/* Enable Motor PWM */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1;
 8002530:	9502      	str	r5, [sp, #8]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8002532:	f88d 800c 	strb.w	r8, [sp, #12]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8002536:	f88d 400e 	strb.w	r4, [sp, #14]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 800253a:	f88d 500d 	strb.w	r5, [sp, #13]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 800253e:	f88d 400f 	strb.w	r4, [sp, #15]
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 8002542:	f001 f9cb 	bl	80038dc <GPIO_Init>

	/************************END GPIO***************************/

	/****************************USART****************************/
	/* GPIOA Configuration:  USART2 TX on PA2 */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2 | GPIO_Pin_3;
 8002546:	220c      	movs	r2, #12
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP ;
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 8002548:	a902      	add	r1, sp, #8
 800254a:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000

	/************************END GPIO***************************/

	/****************************USART****************************/
	/* GPIOA Configuration:  USART2 TX on PA2 */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2 | GPIO_Pin_3;
 800254e:	9202      	str	r2, [sp, #8]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 8002550:	f88d 600c 	strb.w	r6, [sp, #12]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8002554:	f88d 500d 	strb.w	r5, [sp, #13]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8002558:	f88d 400e 	strb.w	r4, [sp, #14]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP ;
 800255c:	f88d 800f 	strb.w	r8, [sp, #15]
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 8002560:	f001 f9bc 	bl	80038dc <GPIO_Init>

	/* Connect USART2 pins to AF2 */
	// TX = PA2
	// RX = PA3
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource2, GPIO_AF_7);
 8002564:	4631      	mov	r1, r6
 8002566:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 800256a:	2207      	movs	r2, #7
 800256c:	f001 fa27 	bl	80039be <GPIO_PinAFConfig>
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource3, GPIO_AF_7);
 8002570:	4629      	mov	r1, r5
 8002572:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8002576:	2207      	movs	r2, #7
 8002578:	f001 fa21 	bl	80039be <GPIO_PinAFConfig>


	/* GPIOB Configuration:  USART3 RX on PB11 and TX on PB10 */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10 | GPIO_Pin_11;
 800257c:	f44f 6240 	mov.w	r2, #3072	; 0xc00
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP ;
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 8002580:	4638      	mov	r0, r7
 8002582:	a902      	add	r1, sp, #8
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource2, GPIO_AF_7);
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource3, GPIO_AF_7);


	/* GPIOB Configuration:  USART3 RX on PB11 and TX on PB10 */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10 | GPIO_Pin_11;
 8002584:	9202      	str	r2, [sp, #8]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 8002586:	f88d 600c 	strb.w	r6, [sp, #12]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 800258a:	f88d 500d 	strb.w	r5, [sp, #13]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 800258e:	f88d 400e 	strb.w	r4, [sp, #14]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP ;
 8002592:	f88d 800f 	strb.w	r8, [sp, #15]
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 8002596:	f001 f9a1 	bl	80038dc <GPIO_Init>

	/* Connect USART3 pins to AF7  */
	GPIO_PinAFConfig(GPIOB, GPIO_PinSource10, GPIO_AF_7);
 800259a:	4638      	mov	r0, r7
 800259c:	210a      	movs	r1, #10
 800259e:	2207      	movs	r2, #7
 80025a0:	f001 fa0d 	bl	80039be <GPIO_PinAFConfig>
	GPIO_PinAFConfig(GPIOB, GPIO_PinSource11, GPIO_AF_7);
 80025a4:	4638      	mov	r0, r7
 80025a6:	210b      	movs	r1, #11
 80025a8:	2207      	movs	r2, #7
 80025aa:	f001 fa08 	bl	80039be <GPIO_PinAFConfig>


	/*************************END USART***************************/

	/******************************* SPI config ********************************/
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource5, GPIO_AF_5);
 80025ae:	2105      	movs	r1, #5
 80025b0:	460a      	mov	r2, r1
 80025b2:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 80025b6:	f001 fa02 	bl	80039be <GPIO_PinAFConfig>
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource6, GPIO_AF_5);
 80025ba:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 80025be:	2106      	movs	r1, #6
 80025c0:	2205      	movs	r2, #5
 80025c2:	f001 f9fc 	bl	80039be <GPIO_PinAFConfig>
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource7, GPIO_AF_5);
 80025c6:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 80025ca:	2107      	movs	r1, #7
 80025cc:	2205      	movs	r2, #5
 80025ce:	f001 f9f6 	bl	80039be <GPIO_PinAFConfig>
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;//GPIO_PuPd_DOWN;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;

	/* SPI SCK pin configuration */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
 80025d2:	2220      	movs	r2, #32
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 80025d4:	a902      	add	r1, sp, #8
 80025d6:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;//GPIO_PuPd_DOWN;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;

	/* SPI SCK pin configuration */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
 80025da:	9202      	str	r2, [sp, #8]
	GPIO_Init(GPIOA, &GPIO_InitStructure);

	/* SPI MISO pin configuration */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
 80025dc:	f04f 0b40 	mov.w	fp, #64	; 0x40
	/******************************* SPI config ********************************/
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource5, GPIO_AF_5);
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource6, GPIO_AF_5);
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource7, GPIO_AF_5);

	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 80025e0:	f88d 600c 	strb.w	r6, [sp, #12]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 80025e4:	f88d 400e 	strb.w	r4, [sp, #14]
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;//GPIO_PuPd_DOWN;
 80025e8:	f88d 400f 	strb.w	r4, [sp, #15]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 80025ec:	f88d 500d 	strb.w	r5, [sp, #13]

	/* SPI SCK pin configuration */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 80025f0:	f001 f974 	bl	80038dc <GPIO_Init>

	/* SPI MISO pin configuration */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 80025f4:	a902      	add	r1, sp, #8
 80025f6:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000

	/* SPI  MOSI pin configuration */
	GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_7;
 80025fa:	f04f 0a80 	mov.w	sl, #128	; 0x80
	/* SPI SCK pin configuration */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
	GPIO_Init(GPIOA, &GPIO_InitStructure);

	/* SPI MISO pin configuration */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
 80025fe:	f8cd b008 	str.w	fp, [sp, #8]
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 8002602:	f001 f96b 	bl	80038dc <GPIO_Init>

	/* SPI  MOSI pin configuration */
	GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_7;
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 8002606:	a902      	add	r1, sp, #8
 8002608:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
	/* SPI MISO pin configuration */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
	GPIO_Init(GPIOA, &GPIO_InitStructure);

	/* SPI  MOSI pin configuration */
	GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_7;
 800260c:	f8cd a008 	str.w	sl, [sp, #8]
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 8002610:	f001 f964 	bl	80038dc <GPIO_Init>
	/* Configure GPIO PIN for Lis Chip select */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3 ;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOE, &GPIO_InitStructure);
 8002614:	9b01      	ldr	r3, [sp, #4]
	GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_7;
	GPIO_Init(GPIOA, &GPIO_InitStructure);

	/* Configure GPIO PIN for Lis Chip select */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3 ;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8002616:	f88d 800c 	strb.w	r8, [sp, #12]
	/* SPI  MOSI pin configuration */
	GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_7;
	GPIO_Init(GPIOA, &GPIO_InitStructure);

	/* Configure GPIO PIN for Lis Chip select */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3 ;
 800261a:	2208      	movs	r2, #8
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOE, &GPIO_InitStructure);
 800261c:	4618      	mov	r0, r3
 800261e:	eb0d 0102 	add.w	r1, sp, r2
	/* SPI  MOSI pin configuration */
	GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_7;
	GPIO_Init(GPIOA, &GPIO_InitStructure);

	/* Configure GPIO PIN for Lis Chip select */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3 ;
 8002622:	9202      	str	r2, [sp, #8]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8002624:	f88d 400e 	strb.w	r4, [sp, #14]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8002628:	f88d 500d 	strb.w	r5, [sp, #13]
	GPIO_Init(GPIOE, &GPIO_InitStructure);
 800262c:	f001 f956 	bl	80038dc <GPIO_Init>
	/******************************* END SPI ********************************/

	/****************************** I2C *************************************/
	GPIO_PinAFConfig(GPIOB, GPIO_PinSource6 , GPIO_AF_4 );
 8002630:	4638      	mov	r0, r7
 8002632:	2106      	movs	r1, #6
 8002634:	2204      	movs	r2, #4
 8002636:	f001 f9c2 	bl	80039be <GPIO_PinAFConfig>
	GPIO_PinAFConfig(GPIOB, GPIO_PinSource7 , GPIO_AF_4 );
 800263a:	2204      	movs	r2, #4
 800263c:	4638      	mov	r0, r7
 800263e:	2107      	movs	r1, #7
 8002640:	f001 f9bd 	bl	80039be <GPIO_PinAFConfig>
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_DOWN;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;

	/* I2C SCK pin configuration */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 8002644:	4638      	mov	r0, r7
 8002646:	a902      	add	r1, sp, #8

	/****************************** I2C *************************************/
	GPIO_PinAFConfig(GPIOB, GPIO_PinSource6 , GPIO_AF_4 );
	GPIO_PinAFConfig(GPIOB, GPIO_PinSource7 , GPIO_AF_4 );

	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 8002648:	f88d 600c 	strb.w	r6, [sp, #12]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 800264c:	f88d 400e 	strb.w	r4, [sp, #14]
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_DOWN;
 8002650:	f88d 600f 	strb.w	r6, [sp, #15]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8002654:	f88d 500d 	strb.w	r5, [sp, #13]

	/* I2C SCK pin configuration */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
 8002658:	f8cd b008 	str.w	fp, [sp, #8]
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 800265c:	f001 f93e 	bl	80038dc <GPIO_Init>

	/* I2C SDA pin configuration */
	GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_7;
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 8002660:	4638      	mov	r0, r7
 8002662:	a902      	add	r1, sp, #8
	/* I2C SCK pin configuration */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
	GPIO_Init(GPIOB, &GPIO_InitStructure);

	/* I2C SDA pin configuration */
	GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_7;
 8002664:	f8cd a008 	str.w	sl, [sp, #8]
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 8002668:	f001 f938 	bl	80038dc <GPIO_Init>
	/****************************** END I2C **********************************/

	/****************************** TIM3 PWM OUT *****************************/
	/* GPIOA Configuration: Channel 1, 2, 3 and 4 as alternate function push-pull */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7; //| GPIO_Pin_8 | GPIO_Pin_9;
 800266c:	23c0      	movs	r3, #192	; 0xc0
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
	GPIO_Init(GPIOC, &GPIO_InitStructure);
 800266e:	4648      	mov	r0, r9
 8002670:	a902      	add	r1, sp, #8
	GPIO_Init(GPIOB, &GPIO_InitStructure);
	/****************************** END I2C **********************************/

	/****************************** TIM3 PWM OUT *****************************/
	/* GPIOA Configuration: Channel 1, 2, 3 and 4 as alternate function push-pull */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7; //| GPIO_Pin_8 | GPIO_Pin_9;
 8002672:	9302      	str	r3, [sp, #8]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 8002674:	f88d 600c 	strb.w	r6, [sp, #12]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8002678:	f88d 500d 	strb.w	r5, [sp, #13]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 800267c:	f88d 400e 	strb.w	r4, [sp, #14]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
 8002680:	f88d 800f 	strb.w	r8, [sp, #15]
	GPIO_Init(GPIOC, &GPIO_InitStructure);
 8002684:	f001 f92a 	bl	80038dc <GPIO_Init>

	GPIO_PinAFConfig(GPIOC, GPIO_PinSource6, GPIO_AF_2);
 8002688:	4648      	mov	r0, r9
 800268a:	4632      	mov	r2, r6
 800268c:	2106      	movs	r1, #6
 800268e:	f001 f996 	bl	80039be <GPIO_PinAFConfig>
	GPIO_PinAFConfig(GPIOC, GPIO_PinSource7, GPIO_AF_2);
 8002692:	4632      	mov	r2, r6
 8002694:	4648      	mov	r0, r9
 8002696:	2107      	movs	r1, #7
 8002698:	f001 f991 	bl	80039be <GPIO_PinAFConfig>
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOD, &GPIO_InitStructure); */

	/* ADC Config */
	/* Configure ADC Channels as analog input */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_5 ;
 800269c:	2330      	movs	r3, #48	; 0x30
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
	GPIO_Init(GPIOC, &GPIO_InitStructure);
 800269e:	4648      	mov	r0, r9
 80026a0:	a902      	add	r1, sp, #8
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOD, &GPIO_InitStructure); */

	/* ADC Config */
	/* Configure ADC Channels as analog input */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_5 ;
 80026a2:	9302      	str	r3, [sp, #8]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
 80026a4:	f88d 500c 	strb.w	r5, [sp, #12]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
 80026a8:	f88d 400f 	strb.w	r4, [sp, #15]
	GPIO_Init(GPIOC, &GPIO_InitStructure);
 80026ac:	f001 f916 	bl	80038dc <GPIO_Init>

	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 ;
 80026b0:	2310      	movs	r3, #16
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 80026b2:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 80026b6:	a902      	add	r1, sp, #8
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_5 ;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
	GPIO_Init(GPIOC, &GPIO_InitStructure);

	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 ;
 80026b8:	9302      	str	r3, [sp, #8]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
 80026ba:	f88d 500c 	strb.w	r5, [sp, #12]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
 80026be:	f88d 400f 	strb.w	r4, [sp, #15]
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 80026c2:	f001 f90b 	bl	80038dc <GPIO_Init>
}
 80026c6:	b005      	add	sp, #20
 80026c8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80026cc:	48001000 	.word	0x48001000
 80026d0:	48000400 	.word	0x48000400
 80026d4:	48000800 	.word	0x48000800

080026d8 <USART_Configuration>:


void USART_Configuration(void)
{
 80026d8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
	USART_InitStructure.USART_StopBits = USART_StopBits_1;
	USART_InitStructure.USART_Parity = USART_Parity_No;
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
	USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;
	USART_Init(USART2, &USART_InitStructure);
 80026dc:	4d1c      	ldr	r5, [pc, #112]	; (8002750 <USART_Configuration+0x78>)

	USART_ITConfig(USART2, USART_IT_RXNE, ENABLE); // enable the USART1 receive interrupt
 80026de:	4e1d      	ldr	r6, [pc, #116]	; (8002754 <USART_Configuration+0x7c>)
	GPIO_Init(GPIOA, &GPIO_InitStructure);
}


void USART_Configuration(void)
{
 80026e0:	b086      	sub	sp, #24
	USART_InitTypeDef USART_InitStructure;

	USART_InitStructure.USART_BaudRate = 115200;
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 80026e2:	2400      	movs	r4, #0

void USART_Configuration(void)
{
	USART_InitTypeDef USART_InitStructure;

	USART_InitStructure.USART_BaudRate = 115200;
 80026e4:	f44f 38e1 	mov.w	r8, #115200	; 0x1c200
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
	USART_InitStructure.USART_StopBits = USART_StopBits_1;
	USART_InitStructure.USART_Parity = USART_Parity_No;
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
	USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;
 80026e8:	270c      	movs	r7, #12
	USART_Init(USART2, &USART_InitStructure);
 80026ea:	4628      	mov	r0, r5
 80026ec:	4669      	mov	r1, sp

void USART_Configuration(void)
{
	USART_InitTypeDef USART_InitStructure;

	USART_InitStructure.USART_BaudRate = 115200;
 80026ee:	f8cd 8000 	str.w	r8, [sp]
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 80026f2:	9401      	str	r4, [sp, #4]
	USART_InitStructure.USART_StopBits = USART_StopBits_1;
 80026f4:	9402      	str	r4, [sp, #8]
	USART_InitStructure.USART_Parity = USART_Parity_No;
 80026f6:	9403      	str	r4, [sp, #12]
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
 80026f8:	9405      	str	r4, [sp, #20]
	USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;
 80026fa:	9704      	str	r7, [sp, #16]
	USART_Init(USART2, &USART_InitStructure);
 80026fc:	f002 fe7c 	bl	80053f8 <USART_Init>

	USART_ITConfig(USART2, USART_IT_RXNE, ENABLE); // enable the USART1 receive interrupt
 8002700:	2201      	movs	r2, #1
 8002702:	4628      	mov	r0, r5
 8002704:	4631      	mov	r1, r6
 8002706:	f003 f829 	bl	800575c <USART_ITConfig>

	USART_Cmd(USART2, ENABLE); // enable USART2
 800270a:	4628      	mov	r0, r5
 800270c:	2101      	movs	r1, #1
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
	USART_InitStructure.USART_StopBits = USART_StopBits_1;
	USART_InitStructure.USART_Parity = USART_Parity_No;
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
	USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;
	USART_Init(USART3, &USART_InitStructure);
 800270e:	f505 6580 	add.w	r5, r5, #1024	; 0x400
	USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;
	USART_Init(USART2, &USART_InitStructure);

	USART_ITConfig(USART2, USART_IT_RXNE, ENABLE); // enable the USART1 receive interrupt

	USART_Cmd(USART2, ENABLE); // enable USART2
 8002712:	f002 feec 	bl	80054ee <USART_Cmd>
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
	USART_InitStructure.USART_StopBits = USART_StopBits_1;
	USART_InitStructure.USART_Parity = USART_Parity_No;
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
	USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;
	USART_Init(USART3, &USART_InitStructure);
 8002716:	4628      	mov	r0, r5
 8002718:	4669      	mov	r1, sp

	/*
	 * Configure USART 3
	 * */
	//USART_InitTypeDef USART_InitStructure;
	USART_InitStructure.USART_BaudRate = 115200;
 800271a:	f8cd 8000 	str.w	r8, [sp]
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 800271e:	9401      	str	r4, [sp, #4]
	USART_InitStructure.USART_StopBits = USART_StopBits_1;
 8002720:	9402      	str	r4, [sp, #8]
	USART_InitStructure.USART_Parity = USART_Parity_No;
 8002722:	9403      	str	r4, [sp, #12]
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
 8002724:	9405      	str	r4, [sp, #20]
	USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;
 8002726:	9704      	str	r7, [sp, #16]
	USART_Init(USART3, &USART_InitStructure);
 8002728:	f002 fe66 	bl	80053f8 <USART_Init>

	USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);
 800272c:	4628      	mov	r0, r5
 800272e:	4631      	mov	r1, r6
 8002730:	2201      	movs	r2, #1
 8002732:	f003 f813 	bl	800575c <USART_ITConfig>
	USART_ITConfig(USART3, USART_IT_TXE, DISABLE);
 8002736:	4628      	mov	r0, r5
 8002738:	4622      	mov	r2, r4
 800273a:	4907      	ldr	r1, [pc, #28]	; (8002758 <USART_Configuration+0x80>)
 800273c:	f003 f80e 	bl	800575c <USART_ITConfig>

	USART_Cmd(USART3, ENABLE); // enable USART3
 8002740:	4628      	mov	r0, r5
 8002742:	2101      	movs	r1, #1
 8002744:	f002 fed3 	bl	80054ee <USART_Cmd>
}
 8002748:	b006      	add	sp, #24
 800274a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800274e:	bf00      	nop
 8002750:	40004400 	.word	0x40004400
 8002754:	00050105 	.word	0x00050105
 8002758:	00070107 	.word	0x00070107

0800275c <SPI_Configuration>:


void SPI_Configuration(void)
{
 800275c:	b510      	push	{r4, lr}
	SPI_InitTypeDef  SPI_InitStructure;
	/* SPI configuration -------------------------------------------------------*/
	SPI_I2S_DeInit(SPI1);
 800275e:	4c17      	ldr	r4, [pc, #92]	; (80027bc <SPI_Configuration+0x60>)
	USART_Cmd(USART3, ENABLE); // enable USART3
}


void SPI_Configuration(void)
{
 8002760:	b086      	sub	sp, #24
	SPI_InitTypeDef  SPI_InitStructure;
	/* SPI configuration -------------------------------------------------------*/
	SPI_I2S_DeInit(SPI1);
 8002762:	4620      	mov	r0, r4
 8002764:	f001 fe44 	bl	80043f0 <SPI_I2S_DeInit>
	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
 8002768:	2300      	movs	r3, #0
	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;
 800276a:	f44f 62e0 	mov.w	r2, #1792	; 0x700
void SPI_Configuration(void)
{
	SPI_InitTypeDef  SPI_InitStructure;
	/* SPI configuration -------------------------------------------------------*/
	SPI_I2S_DeInit(SPI1);
	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
 800276e:	f8ad 3004 	strh.w	r3, [sp, #4]
	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;
 8002772:	f8ad 2008 	strh.w	r2, [sp, #8]
	SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;
 8002776:	f8ad 300a 	strh.w	r3, [sp, #10]
	SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
 800277a:	f8ad 300c 	strh.w	r3, [sp, #12]
	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;
	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_8;
	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
 800277e:	f8ad 3012 	strh.w	r3, [sp, #18]
	SPI_I2S_DeInit(SPI1);
	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;
	SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;
	SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;
 8002782:	f44f 7200 	mov.w	r2, #512	; 0x200
	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_8;
	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
	SPI_InitStructure.SPI_CRCPolynomial = 7;
 8002786:	2307      	movs	r3, #7
	SPI_I2S_DeInit(SPI1);
	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;
	SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;
	SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;
 8002788:	f8ad 200e 	strh.w	r2, [sp, #14]
	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_8;
	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
	SPI_InitStructure.SPI_CRCPolynomial = 7;
 800278c:	f8ad 3014 	strh.w	r3, [sp, #20]
	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;
	SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;
	SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;
	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_8;
 8002790:	2210      	movs	r2, #16
	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
	SPI_InitStructure.SPI_CRCPolynomial = 7;
	SPI_InitStructure.SPI_Mode = SPI_Mode_Master;
 8002792:	f44f 7382 	mov.w	r3, #260	; 0x104
	SPI_Init(SPI1, &SPI_InitStructure);
 8002796:	4620      	mov	r0, r4
 8002798:	a901      	add	r1, sp, #4
	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;
	SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;
	SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;
	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_8;
 800279a:	f8ad 2010 	strh.w	r2, [sp, #16]
	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
	SPI_InitStructure.SPI_CRCPolynomial = 7;
	SPI_InitStructure.SPI_Mode = SPI_Mode_Master;
 800279e:	f8ad 3006 	strh.w	r3, [sp, #6]
	SPI_Init(SPI1, &SPI_InitStructure);
 80027a2:	f001 fe65 	bl	8004470 <SPI_Init>

	/* Configure the RX FIFO Threshold */
	SPI_RxFIFOThresholdConfig(SPI1, SPI_RxFIFOThreshold_QF);
 80027a6:	4620      	mov	r0, r4
 80027a8:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 80027ac:	f001 ff33 	bl	8004616 <SPI_RxFIFOThresholdConfig>
	/* Enable SPI1  */
	SPI_Cmd(SPI1, ENABLE);
 80027b0:	4620      	mov	r0, r4
 80027b2:	2101      	movs	r1, #1
 80027b4:	f001 ff03 	bl	80045be <SPI_Cmd>
}
 80027b8:	b006      	add	sp, #24
 80027ba:	bd10      	pop	{r4, pc}
 80027bc:	40013000 	.word	0x40013000

080027c0 <I2C_Configuration>:


void I2C_Configuration(void)
{
 80027c0:	b510      	push	{r4, lr}
	I2C_InitTypeDef  I2C_InitStructure;

	I2C_DeInit(I2C1);
 80027c2:	4c0c      	ldr	r4, [pc, #48]	; (80027f4 <I2C_Configuration+0x34>)
	SPI_Cmd(SPI1, ENABLE);
}


void I2C_Configuration(void)
{
 80027c4:	b088      	sub	sp, #32
	I2C_InitTypeDef  I2C_InitStructure;

	I2C_DeInit(I2C1);
 80027c6:	4620      	mov	r0, r4
 80027c8:	f001 f90c 	bl	80039e4 <I2C_DeInit>

    /* I2C configuration -------------------------------------------------------*/
    I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
 80027cc:	2300      	movs	r3, #0
    I2C_InitStructure.I2C_AnalogFilter = I2C_AnalogFilter_Enable;
    I2C_InitStructure.I2C_DigitalFilter = 0x00;
    I2C_InitStructure.I2C_OwnAddress1 = 0x00;
    I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
    I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
    I2C_InitStructure.I2C_Timing = 0x00902025;
 80027ce:	a908      	add	r1, sp, #32
	I2C_InitTypeDef  I2C_InitStructure;

	I2C_DeInit(I2C1);

    /* I2C configuration -------------------------------------------------------*/
    I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
 80027d0:	9304      	str	r3, [sp, #16]
    I2C_InitStructure.I2C_AnalogFilter = I2C_AnalogFilter_Enable;
 80027d2:	9302      	str	r3, [sp, #8]
    I2C_InitStructure.I2C_DigitalFilter = 0x00;
 80027d4:	9303      	str	r3, [sp, #12]
    I2C_InitStructure.I2C_OwnAddress1 = 0x00;
 80027d6:	9305      	str	r3, [sp, #20]
    I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
 80027d8:	9306      	str	r3, [sp, #24]
    I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 80027da:	9307      	str	r3, [sp, #28]
    I2C_InitStructure.I2C_Timing = 0x00902025;
 80027dc:	4b06      	ldr	r3, [pc, #24]	; (80027f8 <I2C_Configuration+0x38>)
 80027de:	f841 3d1c 	str.w	r3, [r1, #-28]!

    /* Apply LSM303DLHC_I2C configuration after enabling it */
    I2C_Init(I2C1, &I2C_InitStructure);
 80027e2:	4620      	mov	r0, r4
 80027e4:	f001 f918 	bl	8003a18 <I2C_Init>

    /* LSM303DLHC_I2C Peripheral Enable */
    I2C_Cmd(I2C1, ENABLE);
 80027e8:	4620      	mov	r0, r4
 80027ea:	2101      	movs	r1, #1
 80027ec:	f001 f94f 	bl	8003a8e <I2C_Cmd>
}
 80027f0:	b008      	add	sp, #32
 80027f2:	bd10      	pop	{r4, pc}
 80027f4:	40005400 	.word	0x40005400
 80027f8:	00902025 	.word	0x00902025

080027fc <DMA_Configuration>:


void DMA_Configuration(uint8_t *buffer)
{
 80027fc:	b530      	push	{r4, r5, lr}
	DMA_DeInit(DMA1_Channel7);
 80027fe:	4c0f      	ldr	r4, [pc, #60]	; (800283c <DMA_Configuration+0x40>)
    I2C_Cmd(I2C1, ENABLE);
}


void DMA_Configuration(uint8_t *buffer)
{
 8002800:	b08d      	sub	sp, #52	; 0x34
 8002802:	4605      	mov	r5, r0
	DMA_DeInit(DMA1_Channel7);
 8002804:	4620      	mov	r0, r4
 8002806:	f000 fe3f 	bl	8003488 <DMA_DeInit>
    DMA_InitTypeDef DMA_InitStructure;
    DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&I2C1->RXDR;
 800280a:	4b0d      	ldr	r3, [pc, #52]	; (8002840 <DMA_Configuration+0x44>)
 800280c:	9301      	str	r3, [sp, #4]
    DMA_InitStructure.DMA_MemoryBaseAddr     = (uint32_t)buffer;
    DMA_InitStructure.DMA_BufferSize         = 6;
    DMA_InitStructure.DMA_DIR                = DMA_DIR_PeripheralSRC;
    DMA_InitStructure.DMA_PeripheralInc      = DMA_PeripheralInc_Disable;
    DMA_InitStructure.DMA_MemoryInc          = DMA_MemoryInc_Enable;
 800280e:	2280      	movs	r2, #128	; 0x80
 8002810:	9206      	str	r2, [sp, #24]
{
	DMA_DeInit(DMA1_Channel7);
    DMA_InitTypeDef DMA_InitStructure;
    DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&I2C1->RXDR;
    DMA_InitStructure.DMA_MemoryBaseAddr     = (uint32_t)buffer;
    DMA_InitStructure.DMA_BufferSize         = 6;
 8002812:	2306      	movs	r3, #6
    DMA_InitStructure.DMA_DIR                = DMA_DIR_PeripheralSRC;
    DMA_InitStructure.DMA_PeripheralInc      = DMA_PeripheralInc_Disable;
    DMA_InitStructure.DMA_MemoryInc          = DMA_MemoryInc_Enable;
    DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
    DMA_InitStructure.DMA_MemoryDataSize     = DMA_MemoryDataSize_Byte;
    DMA_InitStructure.DMA_Mode               = DMA_Mode_Circular;
 8002814:	2220      	movs	r2, #32
{
	DMA_DeInit(DMA1_Channel7);
    DMA_InitTypeDef DMA_InitStructure;
    DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&I2C1->RXDR;
    DMA_InitStructure.DMA_MemoryBaseAddr     = (uint32_t)buffer;
    DMA_InitStructure.DMA_BufferSize         = 6;
 8002816:	f8ad 3010 	strh.w	r3, [sp, #16]
    DMA_InitStructure.DMA_DIR                = DMA_DIR_PeripheralSRC;
    DMA_InitStructure.DMA_PeripheralInc      = DMA_PeripheralInc_Disable;
    DMA_InitStructure.DMA_MemoryInc          = DMA_MemoryInc_Enable;
    DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
    DMA_InitStructure.DMA_MemoryDataSize     = DMA_MemoryDataSize_Byte;
    DMA_InitStructure.DMA_Mode               = DMA_Mode_Circular;
 800281a:	9209      	str	r2, [sp, #36]	; 0x24
	DMA_DeInit(DMA1_Channel7);
    DMA_InitTypeDef DMA_InitStructure;
    DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&I2C1->RXDR;
    DMA_InitStructure.DMA_MemoryBaseAddr     = (uint32_t)buffer;
    DMA_InitStructure.DMA_BufferSize         = 6;
    DMA_InitStructure.DMA_DIR                = DMA_DIR_PeripheralSRC;
 800281c:	2300      	movs	r3, #0
    DMA_InitStructure.DMA_PeripheralInc      = DMA_PeripheralInc_Disable;
    DMA_InitStructure.DMA_MemoryInc          = DMA_MemoryInc_Enable;
    DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
    DMA_InitStructure.DMA_MemoryDataSize     = DMA_MemoryDataSize_Byte;
    DMA_InitStructure.DMA_Mode               = DMA_Mode_Circular;
    DMA_InitStructure.DMA_Priority           = DMA_Priority_VeryHigh;
 800281e:	f44f 5240 	mov.w	r2, #12288	; 0x3000
    DMA_InitStructure.DMA_M2M                = DMA_M2M_Disable;
    DMA_Init(DMA1_Channel7, &DMA_InitStructure);
 8002822:	4620      	mov	r0, r4
 8002824:	a901      	add	r1, sp, #4
void DMA_Configuration(uint8_t *buffer)
{
	DMA_DeInit(DMA1_Channel7);
    DMA_InitTypeDef DMA_InitStructure;
    DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&I2C1->RXDR;
    DMA_InitStructure.DMA_MemoryBaseAddr     = (uint32_t)buffer;
 8002826:	9502      	str	r5, [sp, #8]
    DMA_InitStructure.DMA_BufferSize         = 6;
    DMA_InitStructure.DMA_DIR                = DMA_DIR_PeripheralSRC;
 8002828:	9303      	str	r3, [sp, #12]
    DMA_InitStructure.DMA_PeripheralInc      = DMA_PeripheralInc_Disable;
 800282a:	9305      	str	r3, [sp, #20]
    DMA_InitStructure.DMA_MemoryInc          = DMA_MemoryInc_Enable;
    DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
 800282c:	9307      	str	r3, [sp, #28]
    DMA_InitStructure.DMA_MemoryDataSize     = DMA_MemoryDataSize_Byte;
 800282e:	9308      	str	r3, [sp, #32]
    DMA_InitStructure.DMA_Mode               = DMA_Mode_Circular;
    DMA_InitStructure.DMA_Priority           = DMA_Priority_VeryHigh;
 8002830:	920a      	str	r2, [sp, #40]	; 0x28
    DMA_InitStructure.DMA_M2M                = DMA_M2M_Disable;
 8002832:	930b      	str	r3, [sp, #44]	; 0x2c
    DMA_Init(DMA1_Channel7, &DMA_InitStructure);
 8002834:	f000 fea0 	bl	8003578 <DMA_Init>

    //DMA_Cmd(DMA1_Channel1, ENABLE);
}
 8002838:	b00d      	add	sp, #52	; 0x34
 800283a:	bd30      	pop	{r4, r5, pc}
 800283c:	40020080 	.word	0x40020080
 8002840:	40005424 	.word	0x40005424

08002844 <TIM2_PWM_Configuration>:


void TIM2_PWM_Configuration(void)
{
 8002844:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint16_t PrescalerValue = 0;
	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
	static TIM_OCInitTypeDef  TIM_OCInitStructure;

	/* Compute the prescaler value */
	PrescalerValue = (uint16_t) (SystemCoreClock / (50000*PRESCALEVALUE)) - 1;
 8002846:	4b31      	ldr	r3, [pc, #196]	; (800290c <TIM2_PWM_Configuration+0xc8>)
 8002848:	681c      	ldr	r4, [r3, #0]
 800284a:	4b31      	ldr	r3, [pc, #196]	; (8002910 <TIM2_PWM_Configuration+0xcc>)
 800284c:	fbb4 f4f3 	udiv	r4, r4, r3
    //DMA_Cmd(DMA1_Channel1, ENABLE);
}


void TIM2_PWM_Configuration(void)
{
 8002850:	b085      	sub	sp, #20
	uint16_t PrescalerValue = 0;
	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
	static TIM_OCInitTypeDef  TIM_OCInitStructure;

	/* Compute the prescaler value */
	PrescalerValue = (uint16_t) (SystemCoreClock / (50000*PRESCALEVALUE)) - 1;
 8002852:	3c01      	subs	r4, #1

	/* Time base configuration */
	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
 8002854:	a801      	add	r0, sp, #4
	uint16_t PrescalerValue = 0;
	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
	static TIM_OCInitTypeDef  TIM_OCInitStructure;

	/* Compute the prescaler value */
	PrescalerValue = (uint16_t) (SystemCoreClock / (50000*PRESCALEVALUE)) - 1;
 8002856:	b2a4      	uxth	r4, r4

	/* Time base configuration */
	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
 8002858:	f002 f8ae 	bl	80049b8 <TIM_TimeBaseStructInit>
	TIM_TimeBaseStructure.TIM_Period = 1000;
	TIM_TimeBaseStructure.TIM_Prescaler = PrescalerValue;
 800285c:	f8ad 4004 	strh.w	r4, [sp, #4]
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);

	/* PWM1 Mode configuration: Channel1 */
	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
 8002860:	4c2c      	ldr	r4, [pc, #176]	; (8002914 <TIM2_PWM_Configuration+0xd0>)

	/* Time base configuration */
	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
	TIM_TimeBaseStructure.TIM_Period = 1000;
	TIM_TimeBaseStructure.TIM_Prescaler = PrescalerValue;
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
 8002862:	2700      	movs	r7, #0
	/* Compute the prescaler value */
	PrescalerValue = (uint16_t) (SystemCoreClock / (50000*PRESCALEVALUE)) - 1;

	/* Time base configuration */
	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
	TIM_TimeBaseStructure.TIM_Period = 1000;
 8002864:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
	TIM_TimeBaseStructure.TIM_Prescaler = PrescalerValue;
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);
 8002868:	a901      	add	r1, sp, #4
 800286a:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000

	/* PWM1 Mode configuration: Channel1 */
	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
 800286e:	2501      	movs	r5, #1
	TIM_OCInitStructure.TIM_Pulse = 50*PRESCALEVALUE;
 8002870:	f44f 7696 	mov.w	r6, #300	; 0x12c
	/* Compute the prescaler value */
	PrescalerValue = (uint16_t) (SystemCoreClock / (50000*PRESCALEVALUE)) - 1;

	/* Time base configuration */
	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
	TIM_TimeBaseStructure.TIM_Period = 1000;
 8002874:	9302      	str	r3, [sp, #8]
	TIM_TimeBaseStructure.TIM_Prescaler = PrescalerValue;
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
 8002876:	f8ad 700c 	strh.w	r7, [sp, #12]
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
 800287a:	f8ad 7006 	strh.w	r7, [sp, #6]
	TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);
 800287e:	f002 f855 	bl	800492c <TIM_TimeBaseInit>

	/* PWM1 Mode configuration: Channel1 */
	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
 8002882:	2360      	movs	r3, #96	; 0x60
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
	TIM_OCInitStructure.TIM_Pulse = 50*PRESCALEVALUE;
	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
	TIM_OC1Init(TIM2, &TIM_OCInitStructure);
 8002884:	4621      	mov	r1, r4
 8002886:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);

	/* PWM1 Mode configuration: Channel1 */
	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
 800288a:	6023      	str	r3, [r4, #0]
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
 800288c:	80a5      	strh	r5, [r4, #4]
	TIM_OCInitStructure.TIM_Pulse = 50*PRESCALEVALUE;
 800288e:	60a6      	str	r6, [r4, #8]
	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
 8002890:	81a7      	strh	r7, [r4, #12]
	TIM_OC1Init(TIM2, &TIM_OCInitStructure);
 8002892:	f002 f900 	bl	8004a96 <TIM_OC1Init>
	TIM_OC1PreloadConfig(TIM2, TIM_OCPreload_Enable);
 8002896:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 800289a:	2108      	movs	r1, #8
 800289c:	f002 fa98 	bl	8004dd0 <TIM_OC1PreloadConfig>

	/* PWM1 Mode configuration: Channel2 */
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
	TIM_OCInitStructure.TIM_Pulse = 50*PRESCALEVALUE;
	TIM_OC2Init(TIM2, &TIM_OCInitStructure);
 80028a0:	4621      	mov	r1, r4
 80028a2:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
	TIM_OC1Init(TIM2, &TIM_OCInitStructure);
	TIM_OC1PreloadConfig(TIM2, TIM_OCPreload_Enable);

	/* PWM1 Mode configuration: Channel2 */
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
 80028a6:	80a5      	strh	r5, [r4, #4]
	TIM_OCInitStructure.TIM_Pulse = 50*PRESCALEVALUE;
 80028a8:	60a6      	str	r6, [r4, #8]
	TIM_OC2Init(TIM2, &TIM_OCInitStructure);
 80028aa:	f002 f931 	bl	8004b10 <TIM_OC2Init>
	TIM_OC2PreloadConfig(TIM2, TIM_OCPreload_Enable);
 80028ae:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 80028b2:	2108      	movs	r1, #8
 80028b4:	f002 fa92 	bl	8004ddc <TIM_OC2PreloadConfig>

	/* PWM1 Mode configuration: Channel3 */
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
	TIM_OCInitStructure.TIM_Pulse = 50*PRESCALEVALUE;
	TIM_OC3Init(TIM2, &TIM_OCInitStructure);
 80028b8:	4621      	mov	r1, r4
 80028ba:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
	TIM_OCInitStructure.TIM_Pulse = 50*PRESCALEVALUE;
	TIM_OC2Init(TIM2, &TIM_OCInitStructure);
	TIM_OC2PreloadConfig(TIM2, TIM_OCPreload_Enable);

	/* PWM1 Mode configuration: Channel3 */
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
 80028be:	80a5      	strh	r5, [r4, #4]
	TIM_OCInitStructure.TIM_Pulse = 50*PRESCALEVALUE;
 80028c0:	60a6      	str	r6, [r4, #8]
	TIM_OC3Init(TIM2, &TIM_OCInitStructure);
 80028c2:	f002 f95b 	bl	8004b7c <TIM_OC3Init>
	TIM_OC3PreloadConfig(TIM2, TIM_OCPreload_Enable);
 80028c6:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 80028ca:	2108      	movs	r1, #8
 80028cc:	f002 fa8d 	bl	8004dea <TIM_OC3PreloadConfig>

	/* PWM1 Mode configuration: Channel4 */
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
	TIM_OCInitStructure.TIM_Pulse = 50*PRESCALEVALUE;
	TIM_OC4Init(TIM2, &TIM_OCInitStructure);
 80028d0:	4621      	mov	r1, r4
 80028d2:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
	TIM_OCInitStructure.TIM_Pulse = 50*PRESCALEVALUE;
	TIM_OC3Init(TIM2, &TIM_OCInitStructure);
	TIM_OC3PreloadConfig(TIM2, TIM_OCPreload_Enable);

	/* PWM1 Mode configuration: Channel4 */
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
 80028d6:	80a5      	strh	r5, [r4, #4]
	TIM_OCInitStructure.TIM_Pulse = 50*PRESCALEVALUE;
 80028d8:	60a6      	str	r6, [r4, #8]
	TIM_OC4Init(TIM2, &TIM_OCInitStructure);
 80028da:	f002 f983 	bl	8004be4 <TIM_OC4Init>
	TIM_OC4PreloadConfig(TIM2, TIM_OCPreload_Enable);
 80028de:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 80028e2:	2108      	movs	r1, #8
 80028e4:	f002 fa87 	bl	8004df6 <TIM_OC4PreloadConfig>

	TIM_ARRPreloadConfig(TIM2, ENABLE);
 80028e8:	4629      	mov	r1, r5
 80028ea:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 80028ee:	f002 f8a4 	bl	8004a3a <TIM_ARRPreloadConfig>
	TIM_CtrlPWMOutputs(TIM2, ENABLE);
 80028f2:	4629      	mov	r1, r5
 80028f4:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 80028f8:	f002 fc39 	bl	800516e <TIM_CtrlPWMOutputs>

	/* TIM3 enable counter */
	TIM_Cmd(TIM2, ENABLE);
 80028fc:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8002900:	4629      	mov	r1, r5
 8002902:	f002 f8bc 	bl	8004a7e <TIM_Cmd>
}
 8002906:	b005      	add	sp, #20
 8002908:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800290a:	bf00      	nop
 800290c:	20000034 	.word	0x20000034
 8002910:	000493e0 	.word	0x000493e0
 8002914:	200004f8 	.word	0x200004f8

08002918 <TIM3_PWM_Configuration>:


void TIM3_PWM_Configuration(void)
{
 8002918:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	uint16_t PrescalerValue = 0;
	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
	static TIM_OCInitTypeDef  TIM_OCInitStructure;

	/* Compute the prescaler value */
	PrescalerValue = (uint16_t) (SystemCoreClock / (600000*PRESCALEVALUE)) - 1;//(60000*PRESCALEVALUE)) - 1;
 800291c:	4b22      	ldr	r3, [pc, #136]	; (80029a8 <TIM3_PWM_Configuration+0x90>)
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure);

	/* PWM1 Mode configuration: Channel1 */
	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
 800291e:	4d23      	ldr	r5, [pc, #140]	; (80029ac <TIM3_PWM_Configuration+0x94>)
	uint16_t PrescalerValue = 0;
	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
	static TIM_OCInitTypeDef  TIM_OCInitStructure;

	/* Compute the prescaler value */
	PrescalerValue = (uint16_t) (SystemCoreClock / (600000*PRESCALEVALUE)) - 1;//(60000*PRESCALEVALUE)) - 1;
 8002920:	681c      	ldr	r4, [r3, #0]
 8002922:	4b23      	ldr	r3, [pc, #140]	; (80029b0 <TIM3_PWM_Configuration+0x98>)
 8002924:	fbb4 f4f3 	udiv	r4, r4, r3
 8002928:	3c01      	subs	r4, #1

	/* Time base configuration */
	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
 800292a:	a801      	add	r0, sp, #4
	uint16_t PrescalerValue = 0;
	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
	static TIM_OCInitTypeDef  TIM_OCInitStructure;

	/* Compute the prescaler value */
	PrescalerValue = (uint16_t) (SystemCoreClock / (600000*PRESCALEVALUE)) - 1;//(60000*PRESCALEVALUE)) - 1;
 800292c:	b2a4      	uxth	r4, r4

	/* Time base configuration */
	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
 800292e:	f002 f843 	bl	80049b8 <TIM_TimeBaseStructInit>
	TIM_TimeBaseStructure.TIM_Period = 200;
	TIM_TimeBaseStructure.TIM_Prescaler = PrescalerValue;
 8002932:	f8ad 4004 	strh.w	r4, [sp, #4]
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure);
 8002936:	4c1f      	ldr	r4, [pc, #124]	; (80029b4 <TIM3_PWM_Configuration+0x9c>)

	/* Time base configuration */
	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
	TIM_TimeBaseStructure.TIM_Period = 200;
	TIM_TimeBaseStructure.TIM_Prescaler = PrescalerValue;
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
 8002938:	2700      	movs	r7, #0
	/* Compute the prescaler value */
	PrescalerValue = (uint16_t) (SystemCoreClock / (600000*PRESCALEVALUE)) - 1;//(60000*PRESCALEVALUE)) - 1;

	/* Time base configuration */
	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
	TIM_TimeBaseStructure.TIM_Period = 200;
 800293a:	23c8      	movs	r3, #200	; 0xc8
	TIM_TimeBaseStructure.TIM_Prescaler = PrescalerValue;
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure);
 800293c:	4620      	mov	r0, r4
 800293e:	a901      	add	r1, sp, #4
	/* Compute the prescaler value */
	PrescalerValue = (uint16_t) (SystemCoreClock / (600000*PRESCALEVALUE)) - 1;//(60000*PRESCALEVALUE)) - 1;

	/* Time base configuration */
	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
	TIM_TimeBaseStructure.TIM_Period = 200;
 8002940:	9302      	str	r3, [sp, #8]
	TIM_TimeBaseStructure.TIM_Prescaler = PrescalerValue;
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
 8002942:	f8ad 700c 	strh.w	r7, [sp, #12]
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
 8002946:	f8ad 7006 	strh.w	r7, [sp, #6]
	TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure);
 800294a:	f001 ffef 	bl	800492c <TIM_TimeBaseInit>

	/* PWM1 Mode configuration: Channel1 */
	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
	TIM_OCInitStructure.TIM_Pulse = 100;
	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
 800294e:	842f      	strh	r7, [r5, #32]
	TIM_OC1Init(TIM3, &TIM_OCInitStructure);
 8002950:	f105 0714 	add.w	r7, r5, #20
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure);

	/* PWM1 Mode configuration: Channel1 */
	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
 8002954:	2360      	movs	r3, #96	; 0x60
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
 8002956:	2601      	movs	r6, #1
	TIM_OCInitStructure.TIM_Pulse = 100;
 8002958:	f04f 0864 	mov.w	r8, #100	; 0x64
	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
	TIM_OC1Init(TIM3, &TIM_OCInitStructure);
 800295c:	4620      	mov	r0, r4
 800295e:	4639      	mov	r1, r7
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure);

	/* PWM1 Mode configuration: Channel1 */
	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
 8002960:	616b      	str	r3, [r5, #20]
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
 8002962:	832e      	strh	r6, [r5, #24]
	TIM_OCInitStructure.TIM_Pulse = 100;
 8002964:	f8c5 801c 	str.w	r8, [r5, #28]
	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
	TIM_OC1Init(TIM3, &TIM_OCInitStructure);
 8002968:	f002 f895 	bl	8004a96 <TIM_OC1Init>
	TIM_OC1PreloadConfig(TIM3, TIM_OCPreload_Enable);
 800296c:	4620      	mov	r0, r4
 800296e:	2108      	movs	r1, #8
 8002970:	f002 fa2e 	bl	8004dd0 <TIM_OC1PreloadConfig>

	/* PWM1 Mode configuration: Channel2 */
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
	TIM_OCInitStructure.TIM_Pulse = 100;
	TIM_OC2Init(TIM3, &TIM_OCInitStructure);
 8002974:	4620      	mov	r0, r4
 8002976:	4639      	mov	r1, r7
	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
	TIM_OC1Init(TIM3, &TIM_OCInitStructure);
	TIM_OC1PreloadConfig(TIM3, TIM_OCPreload_Enable);

	/* PWM1 Mode configuration: Channel2 */
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
 8002978:	832e      	strh	r6, [r5, #24]
	TIM_OCInitStructure.TIM_Pulse = 100;
 800297a:	f8c5 801c 	str.w	r8, [r5, #28]
	TIM_OC2Init(TIM3, &TIM_OCInitStructure);
 800297e:	f002 f8c7 	bl	8004b10 <TIM_OC2Init>
	TIM_OC2PreloadConfig(TIM3, TIM_OCPreload_Enable);
 8002982:	4620      	mov	r0, r4
 8002984:	2108      	movs	r1, #8
 8002986:	f002 fa29 	bl	8004ddc <TIM_OC2PreloadConfig>
	//TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
	//TIM_OCInitStructure.TIM_Pulse = 50*PRESCALEVALUE;
	//TIM_OC4Init(TIM3, &TIM_OCInitStructure);
	//TIM_OC4PreloadConfig(TIM3, TIM_OCPreload_Enable);

	TIM_ARRPreloadConfig(TIM3, ENABLE);
 800298a:	4620      	mov	r0, r4
 800298c:	4631      	mov	r1, r6
 800298e:	f002 f854 	bl	8004a3a <TIM_ARRPreloadConfig>
	TIM_CtrlPWMOutputs(TIM3, ENABLE);
 8002992:	4620      	mov	r0, r4
 8002994:	4631      	mov	r1, r6
 8002996:	f002 fbea 	bl	800516e <TIM_CtrlPWMOutputs>

	/* TIM3 enable counter */
	TIM_Cmd(TIM3, ENABLE);
 800299a:	4620      	mov	r0, r4
 800299c:	4631      	mov	r1, r6
 800299e:	f002 f86e 	bl	8004a7e <TIM_Cmd>
}
 80029a2:	b004      	add	sp, #16
 80029a4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80029a8:	20000034 	.word	0x20000034
 80029ac:	200004f8 	.word	0x200004f8
 80029b0:	0036ee80 	.word	0x0036ee80
 80029b4:	40000400 	.word	0x40000400

080029b8 <TIM4_Configuration>:


void TIM4_Configuration(void)
{
 80029b8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	uint16_t PrescalerValue = 0;
	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;

	/* Compute the prescaler value */
	PrescalerValue = (uint16_t) (SystemCoreClock / (50000)) - 1;
 80029ba:	4b10      	ldr	r3, [pc, #64]	; (80029fc <TIM4_Configuration+0x44>)
 80029bc:	681c      	ldr	r4, [r3, #0]
 80029be:	f24c 3350 	movw	r3, #50000	; 0xc350
 80029c2:	fbb4 f4f3 	udiv	r4, r4, r3
 80029c6:	3c01      	subs	r4, #1
	/* Time base configuration */
	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
 80029c8:	a801      	add	r0, sp, #4
{
	uint16_t PrescalerValue = 0;
	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;

	/* Compute the prescaler value */
	PrescalerValue = (uint16_t) (SystemCoreClock / (50000)) - 1;
 80029ca:	b2a4      	uxth	r4, r4
	/* Time base configuration */
	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
 80029cc:	f001 fff4 	bl	80049b8 <TIM_TimeBaseStructInit>
	TIM_TimeBaseStructure.TIM_Period = 1000;
	TIM_TimeBaseStructure.TIM_Prescaler = PrescalerValue;
 80029d0:	f8ad 4004 	strh.w	r4, [sp, #4]
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseInit(TIM4, &TIM_TimeBaseStructure);
 80029d4:	4c0a      	ldr	r4, [pc, #40]	; (8002a00 <TIM4_Configuration+0x48>)

	/* Compute the prescaler value */
	PrescalerValue = (uint16_t) (SystemCoreClock / (50000)) - 1;
	/* Time base configuration */
	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
	TIM_TimeBaseStructure.TIM_Period = 1000;
 80029d6:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80029da:	9302      	str	r3, [sp, #8]
	TIM_TimeBaseStructure.TIM_Prescaler = PrescalerValue;
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseInit(TIM4, &TIM_TimeBaseStructure);
 80029dc:	4620      	mov	r0, r4
	PrescalerValue = (uint16_t) (SystemCoreClock / (50000)) - 1;
	/* Time base configuration */
	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
	TIM_TimeBaseStructure.TIM_Period = 1000;
	TIM_TimeBaseStructure.TIM_Prescaler = PrescalerValue;
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
 80029de:	2300      	movs	r3, #0
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseInit(TIM4, &TIM_TimeBaseStructure);
 80029e0:	a901      	add	r1, sp, #4
	PrescalerValue = (uint16_t) (SystemCoreClock / (50000)) - 1;
	/* Time base configuration */
	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
	TIM_TimeBaseStructure.TIM_Period = 1000;
	TIM_TimeBaseStructure.TIM_Prescaler = PrescalerValue;
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
 80029e2:	f8ad 300c 	strh.w	r3, [sp, #12]
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
 80029e6:	f8ad 3006 	strh.w	r3, [sp, #6]
	TIM_TimeBaseInit(TIM4, &TIM_TimeBaseStructure);
 80029ea:	f001 ff9f 	bl	800492c <TIM_TimeBaseInit>

	/* TIM3 enable counter */
	TIM_Cmd(TIM4, ENABLE);
 80029ee:	4620      	mov	r0, r4
 80029f0:	2101      	movs	r1, #1
 80029f2:	f002 f844 	bl	8004a7e <TIM_Cmd>
}
 80029f6:	b004      	add	sp, #16
 80029f8:	bd10      	pop	{r4, pc}
 80029fa:	bf00      	nop
 80029fc:	20000034 	.word	0x20000034
 8002a00:	40000800 	.word	0x40000800

08002a04 <getEXTI_Config>:

EXTI_InitTypeDef *getEXTI_Config(void)
{
	static EXTI_InitTypeDef   EXTI_InitStructure;
	return &EXTI_InitStructure;
}
 8002a04:	4800      	ldr	r0, [pc, #0]	; (8002a08 <getEXTI_Config+0x4>)
 8002a06:	4770      	bx	lr
 8002a08:	20000520 	.word	0x20000520

08002a0c <EXTI_Configuration>:

void EXTI_Configuration(void)
{
 8002a0c:	4770      	bx	lr

08002a0e <ADC_Configuration>:
}



void ADC_Configuration(void)
{
 8002a0e:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002a10:	b095      	sub	sp, #84	; 0x54

	ADC_InitTypeDef       ADC_InitStructure;
	ADC_CommonInitTypeDef ADC_CommonInitStructure;
	ADC_InjectedInitTypeDef ADC_InjInitStructure;

	ADC_StructInit(&ADC_InitStructure);
 8002a12:	a80c      	add	r0, sp, #48	; 0x30
 8002a14:	f000 fa22 	bl	8002e5c <ADC_StructInit>

	/* Calibration procedure */
	ADC_VoltageRegulatorCmd(ADC2, ENABLE);
 8002a18:	2101      	movs	r1, #1
 8002a1a:	482d      	ldr	r0, [pc, #180]	; (8002ad0 <ADC_Configuration+0xc2>)
 8002a1c:	f000 faa5 	bl	8002f6a <ADC_VoltageRegulatorCmd>

	/* Insert delay equal to 10 µs */
	Delay(10);
 8002a20:	200a      	movs	r0, #10
 8002a22:	f7ff f9df 	bl	8001de4 <Delay>

	ADC_SelectCalibrationMode(ADC2, ADC_CalibrationMode_Single);
 8002a26:	482a      	ldr	r0, [pc, #168]	; (8002ad0 <ADC_Configuration+0xc2>)
 8002a28:	2100      	movs	r1, #0
 8002a2a:	f000 fa8a 	bl	8002f42 <ADC_SelectCalibrationMode>
	ADC_StartCalibration(ADC2);
 8002a2e:	4828      	ldr	r0, [pc, #160]	; (8002ad0 <ADC_Configuration+0xc2>)
 8002a30:	f000 fa7c 	bl	8002f2c <ADC_StartCalibration>

	for (; ADC_GetCalibrationStatus(ADC2) != RESET ;);
 8002a34:	4826      	ldr	r0, [pc, #152]	; (8002ad0 <ADC_Configuration+0xc2>)
 8002a36:	f000 fa8c 	bl	8002f52 <ADC_GetCalibrationStatus>
 8002a3a:	4604      	mov	r4, r0
 8002a3c:	2800      	cmp	r0, #0
 8002a3e:	d1f9      	bne.n	8002a34 <ADC_Configuration+0x26>

	#if DEBUG
	calibration_value = ADC_GetCalibrationValue(ADC2);
	#endif

	ADC_CommonInitStructure.ADC_Mode = ADC_Mode_InjSimul;
 8002a40:	2605      	movs	r6, #5
	ADC_CommonInitStructure.ADC_Clock = ADC_Clock_AsynClkMode;
 8002a42:	9001      	str	r0, [sp, #4]
	ADC_CommonInitStructure.ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;
 8002a44:	9002      	str	r0, [sp, #8]
	ADC_CommonInitStructure.ADC_DMAMode = ADC_DMAMode_OneShot;
 8002a46:	9003      	str	r0, [sp, #12]
	ADC_CommonInitStructure.ADC_TwoSamplingDelay = 0;
 8002a48:	f88d 0010 	strb.w	r0, [sp, #16]
	ADC_CommonInit(ADC2, &ADC_CommonInitStructure);
 8002a4c:	4669      	mov	r1, sp
 8002a4e:	4820      	ldr	r0, [pc, #128]	; (8002ad0 <ADC_Configuration+0xc2>)

	#if DEBUG
	calibration_value = ADC_GetCalibrationValue(ADC2);
	#endif

	ADC_CommonInitStructure.ADC_Mode = ADC_Mode_InjSimul;
 8002a50:	9600      	str	r6, [sp, #0]
	ADC_CommonInitStructure.ADC_Clock = ADC_Clock_AsynClkMode;
	ADC_CommonInitStructure.ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;
	ADC_CommonInitStructure.ADC_DMAMode = ADC_DMAMode_OneShot;
	ADC_CommonInitStructure.ADC_TwoSamplingDelay = 0;
	ADC_CommonInit(ADC2, &ADC_CommonInitStructure);
 8002a52:	f000 fa2d 	bl	8002eb0 <ADC_CommonInit>

	ADC_InitStructure.ADC_ContinuousConvMode = ADC_ContinuousConvMode_Enable;
 8002a56:	f44f 5300 	mov.w	r3, #8192	; 0x2000
	ADC_InitStructure.ADC_ExternalTrigConvEvent = ADC_ExternalTrigConvEvent_0;
	ADC_InitStructure.ADC_ExternalTrigEventEdge = ADC_ExternalTrigEventEdge_None;
	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
	ADC_InitStructure.ADC_OverrunMode = ADC_OverrunMode_Disable;
	ADC_InitStructure.ADC_AutoInjMode = ADC_AutoInjec_Enable;
	ADC_InitStructure.ADC_NbrOfRegChannel = 3;
 8002a5a:	2503      	movs	r5, #3
	ADC_CommonInitStructure.ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;
	ADC_CommonInitStructure.ADC_DMAMode = ADC_DMAMode_OneShot;
	ADC_CommonInitStructure.ADC_TwoSamplingDelay = 0;
	ADC_CommonInit(ADC2, &ADC_CommonInitStructure);

	ADC_InitStructure.ADC_ContinuousConvMode = ADC_ContinuousConvMode_Enable;
 8002a5c:	930c      	str	r3, [sp, #48]	; 0x30
	ADC_InitStructure.ADC_ExternalTrigEventEdge = ADC_ExternalTrigEventEdge_None;
	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
	ADC_InitStructure.ADC_OverrunMode = ADC_OverrunMode_Disable;
	ADC_InitStructure.ADC_AutoInjMode = ADC_AutoInjec_Enable;
	ADC_InitStructure.ADC_NbrOfRegChannel = 3;
	ADC_Init(ADC2, &ADC_InitStructure);
 8002a5e:	481c      	ldr	r0, [pc, #112]	; (8002ad0 <ADC_Configuration+0xc2>)
	ADC_CommonInitStructure.ADC_DMAMode = ADC_DMAMode_OneShot;
	ADC_CommonInitStructure.ADC_TwoSamplingDelay = 0;
	ADC_CommonInit(ADC2, &ADC_CommonInitStructure);

	ADC_InitStructure.ADC_ContinuousConvMode = ADC_ContinuousConvMode_Enable;
	ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b;
 8002a60:	940d      	str	r4, [sp, #52]	; 0x34
	ADC_InitStructure.ADC_ExternalTrigConvEvent = ADC_ExternalTrigConvEvent_0;
	ADC_InitStructure.ADC_ExternalTrigEventEdge = ADC_ExternalTrigEventEdge_None;
	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
	ADC_InitStructure.ADC_OverrunMode = ADC_OverrunMode_Disable;
	ADC_InitStructure.ADC_AutoInjMode = ADC_AutoInjec_Enable;
 8002a62:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
	ADC_InitStructure.ADC_NbrOfRegChannel = 3;
	ADC_Init(ADC2, &ADC_InitStructure);
 8002a66:	a90c      	add	r1, sp, #48	; 0x30
	ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b;
	ADC_InitStructure.ADC_ExternalTrigConvEvent = ADC_ExternalTrigConvEvent_0;
	ADC_InitStructure.ADC_ExternalTrigEventEdge = ADC_ExternalTrigEventEdge_None;
	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
	ADC_InitStructure.ADC_OverrunMode = ADC_OverrunMode_Disable;
	ADC_InitStructure.ADC_AutoInjMode = ADC_AutoInjec_Enable;
 8002a68:	9312      	str	r3, [sp, #72]	; 0x48
	ADC_CommonInitStructure.ADC_TwoSamplingDelay = 0;
	ADC_CommonInit(ADC2, &ADC_CommonInitStructure);

	ADC_InitStructure.ADC_ContinuousConvMode = ADC_ContinuousConvMode_Enable;
	ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b;
	ADC_InitStructure.ADC_ExternalTrigConvEvent = ADC_ExternalTrigConvEvent_0;
 8002a6a:	940e      	str	r4, [sp, #56]	; 0x38
	ADC_InitStructure.ADC_ExternalTrigEventEdge = ADC_ExternalTrigEventEdge_None;
 8002a6c:	940f      	str	r4, [sp, #60]	; 0x3c
	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
 8002a6e:	9410      	str	r4, [sp, #64]	; 0x40
	ADC_InitStructure.ADC_OverrunMode = ADC_OverrunMode_Disable;
 8002a70:	9411      	str	r4, [sp, #68]	; 0x44

	ADC_InjInitStructure.ADC_ExternalTrigInjecConvEvent = ADC_ExternalTrigInjecConvEvent_0;
	ADC_InjInitStructure.ADC_ExternalTrigInjecEventEdge = ADC_ExternalTrigInjecEventEdge_None;
	ADC_InjInitStructure.ADC_NbrOfInjecChannel = 3;
	ADC_InjInitStructure.ADC_InjecSequence1 = ADC_Channel_5;
	ADC_InjInitStructure.ADC_InjecSequence2 = ADC_Channel_11;
 8002a72:	270b      	movs	r7, #11
	ADC_InitStructure.ADC_ExternalTrigConvEvent = ADC_ExternalTrigConvEvent_0;
	ADC_InitStructure.ADC_ExternalTrigEventEdge = ADC_ExternalTrigEventEdge_None;
	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
	ADC_InitStructure.ADC_OverrunMode = ADC_OverrunMode_Disable;
	ADC_InitStructure.ADC_AutoInjMode = ADC_AutoInjec_Enable;
	ADC_InitStructure.ADC_NbrOfRegChannel = 3;
 8002a74:	f88d 504c 	strb.w	r5, [sp, #76]	; 0x4c
	ADC_Init(ADC2, &ADC_InitStructure);
 8002a78:	f000 f9d2 	bl	8002e20 <ADC_Init>

	ADC_InjInitStructure.ADC_ExternalTrigInjecConvEvent = ADC_ExternalTrigInjecConvEvent_0;
 8002a7c:	9405      	str	r4, [sp, #20]
	ADC_InjInitStructure.ADC_ExternalTrigInjecEventEdge = ADC_ExternalTrigInjecEventEdge_None;
 8002a7e:	9406      	str	r4, [sp, #24]
	ADC_InjInitStructure.ADC_NbrOfInjecChannel = 3;
	ADC_InjInitStructure.ADC_InjecSequence1 = ADC_Channel_5;
	ADC_InjInitStructure.ADC_InjecSequence2 = ADC_Channel_11;
	ADC_InjInitStructure.ADC_InjecSequence3 = ADC_Channel_12;
	ADC_InjectedInit(ADC2, &ADC_InjInitStructure);
 8002a80:	4813      	ldr	r0, [pc, #76]	; (8002ad0 <ADC_Configuration+0xc2>)
	ADC_InitStructure.ADC_NbrOfRegChannel = 3;
	ADC_Init(ADC2, &ADC_InitStructure);

	ADC_InjInitStructure.ADC_ExternalTrigInjecConvEvent = ADC_ExternalTrigInjecConvEvent_0;
	ADC_InjInitStructure.ADC_ExternalTrigInjecEventEdge = ADC_ExternalTrigInjecEventEdge_None;
	ADC_InjInitStructure.ADC_NbrOfInjecChannel = 3;
 8002a82:	f88d 501c 	strb.w	r5, [sp, #28]
	ADC_InjInitStructure.ADC_InjecSequence1 = ADC_Channel_5;
	ADC_InjInitStructure.ADC_InjecSequence2 = ADC_Channel_11;
	ADC_InjInitStructure.ADC_InjecSequence3 = ADC_Channel_12;
 8002a86:	240c      	movs	r4, #12
	ADC_InjectedInit(ADC2, &ADC_InjInitStructure);
 8002a88:	a905      	add	r1, sp, #20
	ADC_Init(ADC2, &ADC_InitStructure);

	ADC_InjInitStructure.ADC_ExternalTrigInjecConvEvent = ADC_ExternalTrigInjecConvEvent_0;
	ADC_InjInitStructure.ADC_ExternalTrigInjecEventEdge = ADC_ExternalTrigInjecEventEdge_None;
	ADC_InjInitStructure.ADC_NbrOfInjecChannel = 3;
	ADC_InjInitStructure.ADC_InjecSequence1 = ADC_Channel_5;
 8002a8a:	9608      	str	r6, [sp, #32]
	ADC_InjInitStructure.ADC_InjecSequence2 = ADC_Channel_11;
 8002a8c:	9709      	str	r7, [sp, #36]	; 0x24
	ADC_InjInitStructure.ADC_InjecSequence3 = ADC_Channel_12;
 8002a8e:	940a      	str	r4, [sp, #40]	; 0x28
	ADC_InjectedInit(ADC2, &ADC_InjInitStructure);
 8002a90:	f000 f9ef 	bl	8002e72 <ADC_InjectedInit>

	/* ADC1 regular channel7 configuration */
	//ADC_RegularChannelConfig(ADC2, ADC_Channel_5, 1, ADC_SampleTime_7Cycles5);
	ADC_InjectedChannelSampleTimeConfig(ADC2, ADC_Channel_5, ADC_SampleTime_7Cycles5);
 8002a94:	480e      	ldr	r0, [pc, #56]	; (8002ad0 <ADC_Configuration+0xc2>)
 8002a96:	4631      	mov	r1, r6
 8002a98:	462a      	mov	r2, r5
 8002a9a:	f000 fc5c 	bl	8003356 <ADC_InjectedChannelSampleTimeConfig>
	ADC_InjectedChannelSampleTimeConfig(ADC2, ADC_Channel_11,ADC_SampleTime_7Cycles5);
 8002a9e:	480c      	ldr	r0, [pc, #48]	; (8002ad0 <ADC_Configuration+0xc2>)
 8002aa0:	4639      	mov	r1, r7
 8002aa2:	462a      	mov	r2, r5
 8002aa4:	f000 fc57 	bl	8003356 <ADC_InjectedChannelSampleTimeConfig>
	ADC_InjectedChannelSampleTimeConfig(ADC2, ADC_Channel_12,ADC_SampleTime_7Cycles5);
 8002aa8:	4809      	ldr	r0, [pc, #36]	; (8002ad0 <ADC_Configuration+0xc2>)
 8002aaa:	4621      	mov	r1, r4
 8002aac:	462a      	mov	r2, r5
 8002aae:	f000 fc52 	bl	8003356 <ADC_InjectedChannelSampleTimeConfig>

	/* Enable ADC1 */
	ADC_Cmd(ADC2, ENABLE);
 8002ab2:	4807      	ldr	r0, [pc, #28]	; (8002ad0 <ADC_Configuration+0xc2>)
 8002ab4:	2101      	movs	r1, #1
 8002ab6:	f000 fa30 	bl	8002f1a <ADC_Cmd>

	/* wait for ADRDY */
	while(!ADC_GetFlagStatus(ADC2, ADC_FLAG_RDY));
 8002aba:	4805      	ldr	r0, [pc, #20]	; (8002ad0 <ADC_Configuration+0xc2>)
 8002abc:	2101      	movs	r1, #1
 8002abe:	f000 fca2 	bl	8003406 <ADC_GetFlagStatus>
 8002ac2:	2800      	cmp	r0, #0
 8002ac4:	d0f9      	beq.n	8002aba <ADC_Configuration+0xac>

	/* Start ADC1 Software Conversion */
	ADC_StartConversion(ADC2);
 8002ac6:	4802      	ldr	r0, [pc, #8]	; (8002ad0 <ADC_Configuration+0xc2>)
 8002ac8:	f000 fb94 	bl	80031f4 <ADC_StartConversion>

}
 8002acc:	b015      	add	sp, #84	; 0x54
 8002ace:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002ad0:	50000100 	.word	0x50000100

08002ad4 <NMI_Handler>:
  * @brief  This function handles NMI exception.
  * @param  None
  * @retval None
  */
void NMI_Handler(void)
{
 8002ad4:	4770      	bx	lr

08002ad6 <HardFault_Handler>:
  * @brief  This function handles Hard Fault exception.
  * @param  None
  * @retval None
  */
void HardFault_Handler(void)
{
 8002ad6:	e7fe      	b.n	8002ad6 <HardFault_Handler>

08002ad8 <MemManage_Handler>:
  * @brief  This function handles Memory Manage exception.
  * @param  None
  * @retval None
  */
void MemManage_Handler(void)
{
 8002ad8:	e7fe      	b.n	8002ad8 <MemManage_Handler>

08002ada <BusFault_Handler>:
  * @brief  This function handles Bus Fault exception.
  * @param  None
  * @retval None
  */
void BusFault_Handler(void)
{
 8002ada:	e7fe      	b.n	8002ada <BusFault_Handler>

08002adc <UsageFault_Handler>:
  * @brief  This function handles Usage Fault exception.
  * @param  None
  * @retval None
  */
void UsageFault_Handler(void)
{
 8002adc:	e7fe      	b.n	8002adc <UsageFault_Handler>

08002ade <DebugMon_Handler>:
  * @brief  This function handles Debug Monitor exception.
  * @param  None
  * @retval None
  */
void DebugMon_Handler(void)
{
 8002ade:	4770      	bx	lr

08002ae0 <USART3_IRQHandler>:
/*! ***************************************************************************
 *    USART3 Interrupt
 *   Dient zur schnellen Übertragung der aktuellen Telemetriedaten
 *  ************************************************************************ */
void USART3_IRQHandler(void)
{
 8002ae0:	b510      	push	{r4, lr}
	// TODO: Timeout for Receive-Datas
	/* Receive Data register not empty interrupt */
	if(USART_GetITStatus(USART3, USART_IT_RXNE) != RESET)
 8002ae2:	482c      	ldr	r0, [pc, #176]	; (8002b94 <USART3_IRQHandler+0xb4>)
 8002ae4:	492c      	ldr	r1, [pc, #176]	; (8002b98 <USART3_IRQHandler+0xb8>)
 8002ae6:	f002 fe69 	bl	80057bc <USART_GetITStatus>
 8002aea:	b348      	cbz	r0, 8002b40 <USART3_IRQHandler+0x60>
	{
		char Data = USART_ReceiveData(USART3);
 8002aec:	4829      	ldr	r0, [pc, #164]	; (8002b94 <USART3_IRQHandler+0xb4>)
 8002aee:	f002 fd84 	bl	80055fa <USART_ReceiveData>

		if (It_Com.rxready == 0) {
 8002af2:	4b2a      	ldr	r3, [pc, #168]	; (8002b9c <USART3_IRQHandler+0xbc>)
 8002af4:	f8d3 1200 	ldr.w	r1, [r3, #512]	; 0x200
 8002af8:	461c      	mov	r4, r3
 8002afa:	b9e9      	cbnz	r1, 8002b38 <USART3_IRQHandler+0x58>
			It_Com.rxbuffer[It_Com.rxcnt] = Data;
 8002afc:	f8d3 2208 	ldr.w	r2, [r3, #520]	; 0x208
{
	// TODO: Timeout for Receive-Datas
	/* Receive Data register not empty interrupt */
	if(USART_GetITStatus(USART3, USART_IT_RXNE) != RESET)
	{
		char Data = USART_ReceiveData(USART3);
 8002b00:	b2c0      	uxtb	r0, r0

		if (It_Com.rxready == 0) {
			It_Com.rxbuffer[It_Com.rxcnt] = Data;
			switch (It_Com.rxcnt) {
 8002b02:	2a01      	cmp	r2, #1
	if(USART_GetITStatus(USART3, USART_IT_RXNE) != RESET)
	{
		char Data = USART_ReceiveData(USART3);

		if (It_Com.rxready == 0) {
			It_Com.rxbuffer[It_Com.rxcnt] = Data;
 8002b04:	5498      	strb	r0, [r3, r2]
			switch (It_Com.rxcnt) {
 8002b06:	d010      	beq.n	8002b2a <USART3_IRQHandler+0x4a>
 8002b08:	d307      	bcc.n	8002b1a <USART3_IRQHandler+0x3a>
 8002b0a:	2a0f      	cmp	r2, #15
 8002b0c:	d111      	bne.n	8002b32 <USART3_IRQHandler+0x52>
				case 1:
					if (It_Com.rxbuffer[It_Com.rxcnt] == 0x7F) It_Com.rxcnt++;
					else It_Com.rxcnt = 0;
					break;
				case 15:
					It_Com.rxready = 1;
 8002b0e:	2201      	movs	r2, #1
 8002b10:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
					It_Com.rxcnt = 0;
 8002b14:	f8c3 1208 	str.w	r1, [r3, #520]	; 0x208
					break;
 8002b18:	e00e      	b.n	8002b38 <USART3_IRQHandler+0x58>
		if (It_Com.rxready == 0) {
			It_Com.rxbuffer[It_Com.rxcnt] = Data;
			switch (It_Com.rxcnt) {
				/* Header LOW */
				case 0:
					if (It_Com.rxbuffer[It_Com.rxcnt] == 0xff) It_Com.rxcnt++;
 8002b1a:	28ff      	cmp	r0, #255	; 0xff
 8002b1c:	d101      	bne.n	8002b22 <USART3_IRQHandler+0x42>
 8002b1e:	2201      	movs	r2, #1
 8002b20:	e008      	b.n	8002b34 <USART3_IRQHandler+0x54>
					else It_Com.rxcnt = 0;
 8002b22:	2300      	movs	r3, #0
 8002b24:	f8c4 3208 	str.w	r3, [r4, #520]	; 0x208
 8002b28:	e006      	b.n	8002b38 <USART3_IRQHandler+0x58>
					break;
				/* Header High */
				case 1:
					if (It_Com.rxbuffer[It_Com.rxcnt] == 0x7F) It_Com.rxcnt++;
 8002b2a:	287f      	cmp	r0, #127	; 0x7f
 8002b2c:	d1f9      	bne.n	8002b22 <USART3_IRQHandler+0x42>
 8002b2e:	2202      	movs	r2, #2
 8002b30:	e000      	b.n	8002b34 <USART3_IRQHandler+0x54>
				case 15:
					It_Com.rxready = 1;
					It_Com.rxcnt = 0;
					break;
				default:
					It_Com.rxcnt ++;
 8002b32:	3201      	adds	r2, #1
 8002b34:	f8c3 2208 	str.w	r2, [r3, #520]	; 0x208
					break;
			}
		}
	    USART_ClearFlag(USART3, USART_IT_RXNE);
 8002b38:	4816      	ldr	r0, [pc, #88]	; (8002b94 <USART3_IRQHandler+0xb4>)
 8002b3a:	4917      	ldr	r1, [pc, #92]	; (8002b98 <USART3_IRQHandler+0xb8>)
 8002b3c:	f002 fe3c 	bl	80057b8 <USART_ClearFlag>
	}

	// Transmit Data Register empty interrupt
    if(USART_GetITStatus(USART3, USART_IT_TXE) != RESET)
 8002b40:	4814      	ldr	r0, [pc, #80]	; (8002b94 <USART3_IRQHandler+0xb4>)
 8002b42:	4917      	ldr	r1, [pc, #92]	; (8002ba0 <USART3_IRQHandler+0xc0>)
 8002b44:	f002 fe3a 	bl	80057bc <USART_GetITStatus>
 8002b48:	b1f0      	cbz	r0, 8002b88 <USART3_IRQHandler+0xa8>
  	{
  		USART_ClearITPendingBit(USART3, USART_IT_TXE);
 8002b4a:	4915      	ldr	r1, [pc, #84]	; (8002ba0 <USART3_IRQHandler+0xc0>)
 8002b4c:	4811      	ldr	r0, [pc, #68]	; (8002b94 <USART3_IRQHandler+0xb4>)
 8002b4e:	f002 fe52 	bl	80057f6 <USART_ClearITPendingBit>

  		//if(ModbusData.txcnt <= ModbusData.txlen)
  		if(It_Com.txcnt <= (It_Com.txlen-1))
 8002b52:	4b12      	ldr	r3, [pc, #72]	; (8002b9c <USART3_IRQHandler+0xbc>)
 8002b54:	f8d3 1210 	ldr.w	r1, [r3, #528]	; 0x210
 8002b58:	f8d3 220c 	ldr.w	r2, [r3, #524]	; 0x20c
 8002b5c:	3901      	subs	r1, #1
 8002b5e:	428a      	cmp	r2, r1
 8002b60:	d809      	bhi.n	8002b76 <USART3_IRQHandler+0x96>
  		{
            USART_SendData(USART3,It_Com.txbuffer[It_Com.txcnt++]);
 8002b62:	1c51      	adds	r1, r2, #1
 8002b64:	f8c3 120c 	str.w	r1, [r3, #524]	; 0x20c
 8002b68:	4413      	add	r3, r2
 8002b6a:	480a      	ldr	r0, [pc, #40]	; (8002b94 <USART3_IRQHandler+0xb4>)
 8002b6c:	f893 1100 	ldrb.w	r1, [r3, #256]	; 0x100
 8002b70:	f002 fd3f 	bl	80055f2 <USART_SendData>
 8002b74:	e008      	b.n	8002b88 <USART3_IRQHandler+0xa8>
  		}
  		else
  		{
  			It_Com.txcnt = 0;
 8002b76:	2200      	movs	r2, #0
  			It_Com.txready = 0;
  		    //USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);
  		    USART_ITConfig(USART3, USART_IT_TXE, DISABLE);
 8002b78:	4806      	ldr	r0, [pc, #24]	; (8002b94 <USART3_IRQHandler+0xb4>)
 8002b7a:	4909      	ldr	r1, [pc, #36]	; (8002ba0 <USART3_IRQHandler+0xc0>)
  		{
            USART_SendData(USART3,It_Com.txbuffer[It_Com.txcnt++]);
  		}
  		else
  		{
  			It_Com.txcnt = 0;
 8002b7c:	f8c3 220c 	str.w	r2, [r3, #524]	; 0x20c
  			It_Com.txready = 0;
 8002b80:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
  		    //USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);
  		    USART_ITConfig(USART3, USART_IT_TXE, DISABLE);
 8002b84:	f002 fdea 	bl	800575c <USART_ITConfig>
  		}
  	}
	USART_ClearITPendingBit(USART3, USART_IT_RXNE);
 8002b88:	4802      	ldr	r0, [pc, #8]	; (8002b94 <USART3_IRQHandler+0xb4>)
 8002b8a:	4903      	ldr	r1, [pc, #12]	; (8002b98 <USART3_IRQHandler+0xb8>)
}
 8002b8c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  			It_Com.txready = 0;
  		    //USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);
  		    USART_ITConfig(USART3, USART_IT_TXE, DISABLE);
  		}
  	}
	USART_ClearITPendingBit(USART3, USART_IT_RXNE);
 8002b90:	f002 be31 	b.w	80057f6 <USART_ClearITPendingBit>
 8002b94:	40004800 	.word	0x40004800
 8002b98:	00050105 	.word	0x00050105
 8002b9c:	20002fe0 	.word	0x20002fe0
 8002ba0:	00070107 	.word	0x00070107

08002ba4 <USART2_IRQHandler>:
}

/*USART Reception*/
void USART2_IRQHandler(void)
{
 8002ba4:	b538      	push	{r3, r4, r5, lr}
	static unsigned char rxBuffer[5];
	static uint8_t i = 0;

	if(USART_GetITStatus(USART2, USART_IT_RXNE) != RESET)
 8002ba6:	4816      	ldr	r0, [pc, #88]	; (8002c00 <USART2_IRQHandler+0x5c>)
 8002ba8:	4916      	ldr	r1, [pc, #88]	; (8002c04 <USART2_IRQHandler+0x60>)
 8002baa:	f002 fe07 	bl	80057bc <USART_GetITStatus>
 8002bae:	b1e0      	cbz	r0, 8002bea <USART2_IRQHandler+0x46>
	{
		/* Read one byte from the receive data register */
		rxBuffer[i] = USART_ReceiveData(USART2);
 8002bb0:	4c15      	ldr	r4, [pc, #84]	; (8002c08 <USART2_IRQHandler+0x64>)
 8002bb2:	4813      	ldr	r0, [pc, #76]	; (8002c00 <USART2_IRQHandler+0x5c>)
 8002bb4:	7825      	ldrb	r5, [r4, #0]
 8002bb6:	f002 fd20 	bl	80055fa <USART_ReceiveData>
		if(i >= 4)
 8002bba:	7823      	ldrb	r3, [r4, #0]
	static uint8_t i = 0;

	if(USART_GetITStatus(USART2, USART_IT_RXNE) != RESET)
	{
		/* Read one byte from the receive data register */
		rxBuffer[i] = USART_ReceiveData(USART2);
 8002bbc:	4425      	add	r5, r4
		if(i >= 4)
 8002bbe:	2b03      	cmp	r3, #3
	static uint8_t i = 0;

	if(USART_GetITStatus(USART2, USART_IT_RXNE) != RESET)
	{
		/* Read one byte from the receive data register */
		rxBuffer[i] = USART_ReceiveData(USART2);
 8002bc0:	7068      	strb	r0, [r5, #1]
		if(i >= 4)
 8002bc2:	d905      	bls.n	8002bd0 <USART2_IRQHandler+0x2c>
		{
			//xQueueSendFromISR( usartRxQueue, &msgPointer, &xYieldRequired );
			CalcRXValues(&rxBuffer[0], 55);
 8002bc4:	1c60      	adds	r0, r4, #1
 8002bc6:	2137      	movs	r1, #55	; 0x37
 8002bc8:	f7ff fb6e 	bl	80022a8 <CalcRXValues>
			i = 0;
 8002bcc:	2300      	movs	r3, #0
 8002bce:	e003      	b.n	8002bd8 <USART2_IRQHandler+0x34>
		}
		else
		{
			if(rxBuffer[0] == 'A')
 8002bd0:	7862      	ldrb	r2, [r4, #1]
 8002bd2:	2a41      	cmp	r2, #65	; 0x41
 8002bd4:	d102      	bne.n	8002bdc <USART2_IRQHandler+0x38>
			{
				i++;
 8002bd6:	3301      	adds	r3, #1
 8002bd8:	7023      	strb	r3, [r4, #0]
 8002bda:	e006      	b.n	8002bea <USART2_IRQHandler+0x46>
			}
			else
			{
				i = 0;
 8002bdc:	2300      	movs	r3, #0
 8002bde:	7023      	strb	r3, [r4, #0]
				rxBuffer[0] = 0;
 8002be0:	7063      	strb	r3, [r4, #1]
				rxBuffer[1] = 0;
 8002be2:	70a3      	strb	r3, [r4, #2]
				rxBuffer[2] = 0;
 8002be4:	70e3      	strb	r3, [r4, #3]
				rxBuffer[3] = 0;
 8002be6:	7123      	strb	r3, [r4, #4]
				rxBuffer[4] = 0;
 8002be8:	7163      	strb	r3, [r4, #5]
			}
		}
	}
	USART_ClearITPendingBit(USART2, USART_IT_RXNE);
 8002bea:	4805      	ldr	r0, [pc, #20]	; (8002c00 <USART2_IRQHandler+0x5c>)
 8002bec:	4905      	ldr	r1, [pc, #20]	; (8002c04 <USART2_IRQHandler+0x60>)
 8002bee:	f002 fe02 	bl	80057f6 <USART_ClearITPendingBit>
	USART_ClearFlag(USART2, USART_IT_RXNE);
 8002bf2:	4803      	ldr	r0, [pc, #12]	; (8002c00 <USART2_IRQHandler+0x5c>)
 8002bf4:	4903      	ldr	r1, [pc, #12]	; (8002c04 <USART2_IRQHandler+0x60>)
}
 8002bf6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
				rxBuffer[4] = 0;
			}
		}
	}
	USART_ClearITPendingBit(USART2, USART_IT_RXNE);
	USART_ClearFlag(USART2, USART_IT_RXNE);
 8002bfa:	f002 bddd 	b.w	80057b8 <USART_ClearFlag>
 8002bfe:	bf00      	nop
 8002c00:	40004400 	.word	0x40004400
 8002c04:	00050105 	.word	0x00050105
 8002c08:	20000528 	.word	0x20000528

08002c0c <disableEXTI>:
}

void disableEXTI(uint32_t EXTINr)
{
 8002c0c:	b510      	push	{r4, lr}
 8002c0e:	4604      	mov	r4, r0
	getEXTI_Config()->EXTI_Line = EXTINr;
 8002c10:	f7ff fef8 	bl	8002a04 <getEXTI_Config>
 8002c14:	6004      	str	r4, [r0, #0]
	getEXTI_Config()->EXTI_LineCmd = DISABLE;
 8002c16:	f7ff fef5 	bl	8002a04 <getEXTI_Config>
 8002c1a:	2300      	movs	r3, #0
 8002c1c:	7183      	strb	r3, [r0, #6]
	EXTI_Init(getEXTI_Config());
 8002c1e:	f7ff fef1 	bl	8002a04 <getEXTI_Config>
}
 8002c22:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

void disableEXTI(uint32_t EXTINr)
{
	getEXTI_Config()->EXTI_Line = EXTINr;
	getEXTI_Config()->EXTI_LineCmd = DISABLE;
	EXTI_Init(getEXTI_Config());
 8002c26:	f000 bd33 	b.w	8003690 <EXTI_Init>

08002c2a <enableEXTI>:
}

void enableEXTI(uint32_t EXTINr)
{
 8002c2a:	b510      	push	{r4, lr}
 8002c2c:	4604      	mov	r4, r0
	getEXTI_Config()->EXTI_Line = EXTINr;
 8002c2e:	f7ff fee9 	bl	8002a04 <getEXTI_Config>
 8002c32:	6004      	str	r4, [r0, #0]
	getEXTI_Config()->EXTI_LineCmd = ENABLE;
 8002c34:	f7ff fee6 	bl	8002a04 <getEXTI_Config>
 8002c38:	2301      	movs	r3, #1
 8002c3a:	7183      	strb	r3, [r0, #6]
	EXTI_Init(getEXTI_Config());
 8002c3c:	f7ff fee2 	bl	8002a04 <getEXTI_Config>
}
 8002c40:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

void enableEXTI(uint32_t EXTINr)
{
	getEXTI_Config()->EXTI_Line = EXTINr;
	getEXTI_Config()->EXTI_LineCmd = ENABLE;
	EXTI_Init(getEXTI_Config());
 8002c44:	f000 bd24 	b.w	8003690 <EXTI_Init>

08002c48 <EXTI15_10_IRQHandler>:
}

/* Interupt Handlers */
void EXTI15_10_IRQHandler(void)
{
 8002c48:	4770      	bx	lr
 8002c4a:	bf00      	nop

08002c4c <Usart2Put>:
#include <stm32f30x.h>
#include <stm32f30x_conf.h>
#include <usart.h>

void Usart2Put(uint8_t ch)
{
 8002c4c:	4601      	mov	r1, r0
 8002c4e:	b508      	push	{r3, lr}
      USART_SendData(USART2, (uint8_t) ch);
 8002c50:	4804      	ldr	r0, [pc, #16]	; (8002c64 <Usart2Put+0x18>)
 8002c52:	f002 fcce 	bl	80055f2 <USART_SendData>
      //Loop until the end of transmission
      while(USART_GetFlagStatus(USART2, USART_FLAG_TC) == RESET)
 8002c56:	4803      	ldr	r0, [pc, #12]	; (8002c64 <Usart2Put+0x18>)
 8002c58:	2140      	movs	r1, #64	; 0x40
 8002c5a:	f002 fda7 	bl	80057ac <USART_GetFlagStatus>
 8002c5e:	2800      	cmp	r0, #0
 8002c60:	d0f9      	beq.n	8002c56 <Usart2Put+0xa>
      {
      }
}
 8002c62:	bd08      	pop	{r3, pc}
 8002c64:	40004400 	.word	0x40004400

08002c68 <Usart3Put>:
/*
 * USART3 use Interrupt
 * */

void Usart3Put(uint8_t ch)
{
 8002c68:	4601      	mov	r1, r0
 8002c6a:	b508      	push	{r3, lr}
      USART_SendData(USART3, (uint8_t) ch);
 8002c6c:	4804      	ldr	r0, [pc, #16]	; (8002c80 <Usart3Put+0x18>)
 8002c6e:	f002 fcc0 	bl	80055f2 <USART_SendData>
      //Loop until the end of transmission
      while(USART_GetFlagStatus(USART3, USART_FLAG_TC) == RESET)
 8002c72:	4803      	ldr	r0, [pc, #12]	; (8002c80 <Usart3Put+0x18>)
 8002c74:	2140      	movs	r1, #64	; 0x40
 8002c76:	f002 fd99 	bl	80057ac <USART_GetFlagStatus>
 8002c7a:	2800      	cmp	r0, #0
 8002c7c:	d0f9      	beq.n	8002c72 <Usart3Put+0xa>
      {
      }
}
 8002c7e:	bd08      	pop	{r3, pc}
 8002c80:	40004800 	.word	0x40004800

08002c84 <Usart3Get>:

uint8_t Usart3Get(){
 8002c84:	b508      	push	{r3, lr}
	uint8_t ch;
	while(USART_GetFlagStatus(USART3, USART_FLAG_RXNE) == RESET)
 8002c86:	4805      	ldr	r0, [pc, #20]	; (8002c9c <Usart3Get+0x18>)
 8002c88:	2120      	movs	r1, #32
 8002c8a:	f002 fd8f 	bl	80057ac <USART_GetFlagStatus>
 8002c8e:	2800      	cmp	r0, #0
 8002c90:	d0f9      	beq.n	8002c86 <Usart3Get+0x2>
	{
	}
	ch = USART_ReceiveData(USART3);
 8002c92:	4802      	ldr	r0, [pc, #8]	; (8002c9c <Usart3Get+0x18>)
 8002c94:	f002 fcb1 	bl	80055fa <USART_ReceiveData>
	return ch;
}
 8002c98:	b2c0      	uxtb	r0, r0
 8002c9a:	bd08      	pop	{r3, pc}
 8002c9c:	40004800 	.word	0x40004800

08002ca0 <SendBufferedDataFrame>:

void SendBufferedDataFrame(USART_OBJ* It_Data ,void* Header, void* Value1, void* Value2, void* Value3, uint32_t Bufferdeep){
 8002ca0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002ca2:	9c06      	ldr	r4, [sp, #24]

	if (Bufferdeep < 1) {
		Bufferdeep = 1;
	}

	if (loopcnt < (Bufferdeep-1)) {
 8002ca4:	4d1c      	ldr	r5, [pc, #112]	; (8002d18 <SendBufferedDataFrame+0x78>)
	}
	ch = USART_ReceiveData(USART3);
	return ch;
}

void SendBufferedDataFrame(USART_OBJ* It_Data ,void* Header, void* Value1, void* Value2, void* Value3, uint32_t Bufferdeep){
 8002ca6:	9f05      	ldr	r7, [sp, #20]

	if (Bufferdeep < 1) {
		Bufferdeep = 1;
	}

	if (loopcnt < (Bufferdeep-1)) {
 8002ca8:	682e      	ldr	r6, [r5, #0]
 8002caa:	6809      	ldr	r1, [r1, #0]

void SendBufferedDataFrame(USART_OBJ* It_Data ,void* Header, void* Value1, void* Value2, void* Value3, uint32_t Bufferdeep){
	uint32_t offset;
	static uint32_t loopcnt = 0;

	if (Bufferdeep < 1) {
 8002cac:	2c00      	cmp	r4, #0
		Bufferdeep = 1;
 8002cae:	bf08      	it	eq
 8002cb0:	2401      	moveq	r4, #1
	}

	if (loopcnt < (Bufferdeep-1)) {
 8002cb2:	3c01      	subs	r4, #1
 8002cb4:	42a6      	cmp	r6, r4
 8002cb6:	ea4f 1406 	mov.w	r4, r6, lsl #4
 8002cba:	d212      	bcs.n	8002ce2 <SendBufferedDataFrame+0x42>
		offset = loopcnt * 16;
		memcpy(&It_Data->txbuffer[offset + 0], Header, 4); // 0xFF7F3F1F => 4286529311 => [255][127][63][31]Header
 8002cbc:	f504 7c80 	add.w	ip, r4, #256	; 0x100
		memcpy(&It_Data->txbuffer[offset + 4], Value1, 4);
		memcpy(&It_Data->txbuffer[offset + 8], Value2, 4);
		memcpy(&It_Data->txbuffer[offset + 12], Value3, 4);
		loopcnt++;
 8002cc0:	3601      	adds	r6, #1
		Bufferdeep = 1;
	}

	if (loopcnt < (Bufferdeep-1)) {
		offset = loopcnt * 16;
		memcpy(&It_Data->txbuffer[offset + 0], Header, 4); // 0xFF7F3F1F => 4286529311 => [255][127][63][31]Header
 8002cc2:	f840 100c 	str.w	r1, [r0, ip]
		memcpy(&It_Data->txbuffer[offset + 4], Value1, 4);
 8002cc6:	f504 7182 	add.w	r1, r4, #260	; 0x104
 8002cca:	6812      	ldr	r2, [r2, #0]
 8002ccc:	5042      	str	r2, [r0, r1]
		memcpy(&It_Data->txbuffer[offset + 8], Value2, 4);
 8002cce:	f504 7284 	add.w	r2, r4, #264	; 0x108
 8002cd2:	681b      	ldr	r3, [r3, #0]
 8002cd4:	5083      	str	r3, [r0, r2]
		memcpy(&It_Data->txbuffer[offset + 12], Value3, 4);
 8002cd6:	f504 7486 	add.w	r4, r4, #268	; 0x10c
 8002cda:	683b      	ldr	r3, [r7, #0]
 8002cdc:	5103      	str	r3, [r0, r4]
		loopcnt++;
 8002cde:	602e      	str	r6, [r5, #0]
 8002ce0:	bdf0      	pop	{r4, r5, r6, r7, pc}
	} else {
		offset = loopcnt * 16;
		memcpy(&It_Data->txbuffer[offset + 0], Header, 4); // 0xFF7F3F1F => 4286529311 => [255][127][63][31]Header
 8002ce2:	f504 7680 	add.w	r6, r4, #256	; 0x100
 8002ce6:	5181      	str	r1, [r0, r6]
		memcpy(&It_Data->txbuffer[offset + 4], Value1, 4);
 8002ce8:	f504 7182 	add.w	r1, r4, #260	; 0x104
 8002cec:	6812      	ldr	r2, [r2, #0]
 8002cee:	5042      	str	r2, [r0, r1]
		memcpy(&It_Data->txbuffer[offset + 8], Value2, 4);
 8002cf0:	f504 7284 	add.w	r2, r4, #264	; 0x108
 8002cf4:	681b      	ldr	r3, [r3, #0]
 8002cf6:	5083      	str	r3, [r0, r2]
		memcpy(&It_Data->txbuffer[offset + 12], Value3, 4);
 8002cf8:	f504 7386 	add.w	r3, r4, #268	; 0x10c
 8002cfc:	683a      	ldr	r2, [r7, #0]
 8002cfe:	50c2      	str	r2, [r0, r3]
		It_Data->txlen = (loopcnt+1)*16;
 8002d00:	3410      	adds	r4, #16
		loopcnt = 0;
 8002d02:	2300      	movs	r3, #0
		offset = loopcnt * 16;
		memcpy(&It_Data->txbuffer[offset + 0], Header, 4); // 0xFF7F3F1F => 4286529311 => [255][127][63][31]Header
		memcpy(&It_Data->txbuffer[offset + 4], Value1, 4);
		memcpy(&It_Data->txbuffer[offset + 8], Value2, 4);
		memcpy(&It_Data->txbuffer[offset + 12], Value3, 4);
		It_Data->txlen = (loopcnt+1)*16;
 8002d04:	f8c0 4210 	str.w	r4, [r0, #528]	; 0x210
		loopcnt = 0;
 8002d08:	602b      	str	r3, [r5, #0]
		USART_ITConfig(USART3, USART_IT_TXE, ENABLE);
 8002d0a:	4804      	ldr	r0, [pc, #16]	; (8002d1c <SendBufferedDataFrame+0x7c>)
 8002d0c:	4904      	ldr	r1, [pc, #16]	; (8002d20 <SendBufferedDataFrame+0x80>)
 8002d0e:	2201      	movs	r2, #1
	}
}
 8002d10:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		memcpy(&It_Data->txbuffer[offset + 4], Value1, 4);
		memcpy(&It_Data->txbuffer[offset + 8], Value2, 4);
		memcpy(&It_Data->txbuffer[offset + 12], Value3, 4);
		It_Data->txlen = (loopcnt+1)*16;
		loopcnt = 0;
		USART_ITConfig(USART3, USART_IT_TXE, ENABLE);
 8002d14:	f002 bd22 	b.w	800575c <USART_ITConfig>
 8002d18:	20000530 	.word	0x20000530
 8002d1c:	40004800 	.word	0x40004800
 8002d20:	00070107 	.word	0x00070107

08002d24 <SETTINGS_init>:
#include <string.h>


void SETTINGS_init(GlobalSettings_s *settings)
{
	settings->gyroSensTreshold = 20;
 8002d24:	2314      	movs	r3, #20
 8002d26:	8003      	strh	r3, [r0, #0]
	settings->gyroDir.sensDirection[sensX] = -1;
	settings->gyroDir.sensDirection[sensY] = -1;
	settings->gyroDir.sensDirection[sensZ] = 1;
 8002d28:	2301      	movs	r3, #1
 8002d2a:	7243      	strb	r3, [r0, #9]
	settings->gyroDir.sensOrder[sensX] = 0;
	settings->gyroDir.sensOrder[sensY] = 2;
	settings->gyroDir.sensOrder[sensZ] = 1;
 8002d2c:	7183      	strb	r3, [r0, #6]

	settings->enableDriftCorrection = 1;
 8002d2e:	7283      	strb	r3, [r0, #10]

	settings->enableACC = 1;
 8002d30:	72c3      	strb	r3, [r0, #11]
	settings->accDir.sensDirection[sensX] = -1;
	settings->accDir.sensDirection[sensY] = -1;
	settings->accDir.sensDirection[sensZ] = 1;
 8002d32:	7443      	strb	r3, [r0, #17]
	settings->accDir.sensOrder[sensX] = 2;
	settings->accDir.sensOrder[sensY] = 0;
	settings->accDir.sensOrder[sensZ] = 1;
 8002d34:	7383      	strb	r3, [r0, #14]
	settings->accMaxGOverflow = 1.3;

	settings->enableMAG = 0;
	settings->magLowpassValue = 5;//20;
	settings->magDir.sensDirection[sensX] = 1;
 8002d36:	7703      	strb	r3, [r0, #28]
	settings->magDir.sensDirection[sensY] = -1;
	settings->magDir.sensDirection[sensZ] = 1;
 8002d38:	7783      	strb	r3, [r0, #30]
	settings->magDir.sensOrder[sensX] = 0;
	settings->magDir.sensOrder[sensY] = 1;
 8002d3a:	7683      	strb	r3, [r0, #26]
	settings->magDir.sensOrder[sensZ] = 2;

	settings->stopSpeed = 100;	//*PRESCALEVALUE; 	//PRESCALEVALUE=6
 8002d3c:	2364      	movs	r3, #100	; 0x64
{
	settings->gyroSensTreshold = 20;
	settings->gyroDir.sensDirection[sensX] = -1;
	settings->gyroDir.sensDirection[sensY] = -1;
	settings->gyroDir.sensDirection[sensZ] = 1;
	settings->gyroDir.sensOrder[sensX] = 0;
 8002d3e:	2200      	movs	r2, #0
	settings->magDir.sensDirection[sensZ] = 1;
	settings->magDir.sensOrder[sensX] = 0;
	settings->magDir.sensOrder[sensY] = 1;
	settings->magDir.sensOrder[sensZ] = 2;

	settings->stopSpeed = 100;	//*PRESCALEVALUE; 	//PRESCALEVALUE=6
 8002d40:	8443      	strh	r3, [r0, #34]	; 0x22
	settings->minSpeed = 0; 	//*PRESCALEVALUE;
	settings->maxSpeed = 200;	//*PRESCALEVALUE;
 8002d42:	23c8      	movs	r3, #200	; 0xc8
{
	settings->gyroSensTreshold = 20;
	settings->gyroDir.sensDirection[sensX] = -1;
	settings->gyroDir.sensDirection[sensY] = -1;
	settings->gyroDir.sensDirection[sensZ] = 1;
	settings->gyroDir.sensOrder[sensX] = 0;
 8002d44:	7102      	strb	r2, [r0, #4]
	settings->enableACC = 1;
	settings->accDir.sensDirection[sensX] = -1;
	settings->accDir.sensDirection[sensY] = -1;
	settings->accDir.sensDirection[sensZ] = 1;
	settings->accDir.sensOrder[sensX] = 2;
	settings->accDir.sensOrder[sensY] = 0;
 8002d46:	7342      	strb	r2, [r0, #13]
	settings->accDir.sensOrder[sensZ] = 1;
	settings->accMaxGOverflow = 1.3;

	settings->enableMAG = 0;
 8002d48:	7602      	strb	r2, [r0, #24]
	settings->magLowpassValue = 5;//20;
	settings->magDir.sensDirection[sensX] = 1;
	settings->magDir.sensDirection[sensY] = -1;
	settings->magDir.sensDirection[sensZ] = 1;
	settings->magDir.sensOrder[sensX] = 0;
 8002d4a:	7642      	strb	r2, [r0, #25]
	settings->magDir.sensOrder[sensY] = 1;
	settings->magDir.sensOrder[sensZ] = 2;

	settings->stopSpeed = 100;	//*PRESCALEVALUE; 	//PRESCALEVALUE=6
	settings->minSpeed = 0; 	//*PRESCALEVALUE;
 8002d4c:	8482      	strh	r2, [r0, #36]	; 0x24
	settings->maxSpeed = 200;	//*PRESCALEVALUE;
 8002d4e:	84c3      	strh	r3, [r0, #38]	; 0x26


#ifdef PIDSmithPredictorController

	/* PID */
	settings->PID_rollPitch.PID_kp = 18.115707268541f; //14.5478771127435f;    	//22.7f;
 8002d50:	4a14      	ldr	r2, [pc, #80]	; (8002da4 <SETTINGS_init+0x80>)
 8002d52:	6282      	str	r2, [r0, #40]	; 0x28

	settings->stopSpeed = 100;	//*PRESCALEVALUE; 	//PRESCALEVALUE=6
	settings->minSpeed = 0; 	//*PRESCALEVALUE;
	settings->maxSpeed = 200;	//*PRESCALEVALUE;

	settings->PID_yaw.PID_kp = 2.0f;
 8002d54:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
#include <stm32_configuration.h>
#include <string.h>


void SETTINGS_init(GlobalSettings_s *settings)
{
 8002d58:	b530      	push	{r4, r5, lr}

	settings->stopSpeed = 100;	//*PRESCALEVALUE; 	//PRESCALEVALUE=6
	settings->minSpeed = 0; 	//*PRESCALEVALUE;
	settings->maxSpeed = 200;	//*PRESCALEVALUE;

	settings->PID_yaw.PID_kp = 2.0f;
 8002d5a:	6383      	str	r3, [r0, #56]	; 0x38
	settings->accDir.sensDirection[sensY] = -1;
	settings->accDir.sensDirection[sensZ] = 1;
	settings->accDir.sensOrder[sensX] = 2;
	settings->accDir.sensOrder[sensY] = 0;
	settings->accDir.sensOrder[sensZ] = 1;
	settings->accMaxGOverflow = 1.3;
 8002d5c:	4d12      	ldr	r5, [pc, #72]	; (8002da8 <SETTINGS_init+0x84>)

#ifdef PIDSmithPredictorController

	/* PID */
	settings->PID_rollPitch.PID_kp = 18.115707268541f; //14.5478771127435f;    	//22.7f;
	settings->PID_rollPitch.PID_ki = 3.8405091086306f; //28.1211353951591f;  	//0.8f;
 8002d5e:	4a13      	ldr	r2, [pc, #76]	; (8002dac <SETTINGS_init+0x88>)
	settings->accDir.sensDirection[sensY] = -1;
	settings->accDir.sensDirection[sensZ] = 1;
	settings->accDir.sensOrder[sensX] = 2;
	settings->accDir.sensOrder[sensY] = 0;
	settings->accDir.sensOrder[sensZ] = 1;
	settings->accMaxGOverflow = 1.3;
 8002d60:	6145      	str	r5, [r0, #20]
	settings->stopSpeed = 100;	//*PRESCALEVALUE; 	//PRESCALEVALUE=6
	settings->minSpeed = 0; 	//*PRESCALEVALUE;
	settings->maxSpeed = 200;	//*PRESCALEVALUE;

	settings->PID_yaw.PID_kp = 2.0f;
	settings->PID_yaw.PID_ki = 1.0f;
 8002d62:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000


void SETTINGS_init(GlobalSettings_s *settings)
{
	settings->gyroSensTreshold = 20;
	settings->gyroDir.sensDirection[sensX] = -1;
 8002d66:	21ff      	movs	r1, #255	; 0xff
	settings->gyroDir.sensDirection[sensY] = -1;
	settings->gyroDir.sensDirection[sensZ] = 1;
	settings->gyroDir.sensOrder[sensX] = 0;
	settings->gyroDir.sensOrder[sensY] = 2;
 8002d68:	2402      	movs	r4, #2
	settings->stopSpeed = 100;	//*PRESCALEVALUE; 	//PRESCALEVALUE=6
	settings->minSpeed = 0; 	//*PRESCALEVALUE;
	settings->maxSpeed = 200;	//*PRESCALEVALUE;

	settings->PID_yaw.PID_kp = 2.0f;
	settings->PID_yaw.PID_ki = 1.0f;
 8002d6a:	63c3      	str	r3, [r0, #60]	; 0x3c

#ifdef PIDSmithPredictorController

	/* PID */
	settings->PID_rollPitch.PID_kp = 18.115707268541f; //14.5478771127435f;    	//22.7f;
	settings->PID_rollPitch.PID_ki = 3.8405091086306f; //28.1211353951591f;  	//0.8f;
 8002d6c:	62c2      	str	r2, [r0, #44]	; 0x2c
	settings->minSpeed = 0; 	//*PRESCALEVALUE;
	settings->maxSpeed = 200;	//*PRESCALEVALUE;

	settings->PID_yaw.PID_kp = 2.0f;
	settings->PID_yaw.PID_ki = 1.0f;
	settings->PID_yaw.PID_kd = 0.0f;
 8002d6e:	2300      	movs	r3, #0
#ifdef PIDSmithPredictorController

	/* PID */
	settings->PID_rollPitch.PID_kp = 18.115707268541f; //14.5478771127435f;    	//22.7f;
	settings->PID_rollPitch.PID_ki = 3.8405091086306f; //28.1211353951591f;  	//0.8f;
	settings->PID_rollPitch.PID_kd = 0.4392517058174756f; //1.84575662912126f; 	//0.40f;
 8002d70:	4a0f      	ldr	r2, [pc, #60]	; (8002db0 <SETTINGS_init+0x8c>)


void SETTINGS_init(GlobalSettings_s *settings)
{
	settings->gyroSensTreshold = 20;
	settings->gyroDir.sensDirection[sensX] = -1;
 8002d72:	71c1      	strb	r1, [r0, #7]
	settings->accDir.sensOrder[sensY] = 0;
	settings->accDir.sensOrder[sensZ] = 1;
	settings->accMaxGOverflow = 1.3;

	settings->enableMAG = 0;
	settings->magLowpassValue = 5;//20;
 8002d74:	2505      	movs	r5, #5

void SETTINGS_init(GlobalSettings_s *settings)
{
	settings->gyroSensTreshold = 20;
	settings->gyroDir.sensDirection[sensX] = -1;
	settings->gyroDir.sensDirection[sensY] = -1;
 8002d76:	7201      	strb	r1, [r0, #8]
	settings->gyroDir.sensDirection[sensZ] = 1;
	settings->gyroDir.sensOrder[sensX] = 0;
	settings->gyroDir.sensOrder[sensY] = 2;
 8002d78:	7144      	strb	r4, [r0, #5]
	settings->gyroDir.sensOrder[sensZ] = 1;

	settings->enableDriftCorrection = 1;

	settings->enableACC = 1;
	settings->accDir.sensDirection[sensX] = -1;
 8002d7a:	73c1      	strb	r1, [r0, #15]
	settings->accDir.sensDirection[sensY] = -1;
 8002d7c:	7401      	strb	r1, [r0, #16]
	settings->accDir.sensDirection[sensZ] = 1;
	settings->accDir.sensOrder[sensX] = 2;
 8002d7e:	7304      	strb	r4, [r0, #12]
	settings->accDir.sensOrder[sensY] = 0;
	settings->accDir.sensOrder[sensZ] = 1;
	settings->accMaxGOverflow = 1.3;

	settings->enableMAG = 0;
	settings->magLowpassValue = 5;//20;
 8002d80:	8405      	strh	r5, [r0, #32]
	settings->magDir.sensDirection[sensX] = 1;
	settings->magDir.sensDirection[sensY] = -1;
 8002d82:	7741      	strb	r1, [r0, #29]
	settings->magDir.sensDirection[sensZ] = 1;
	settings->magDir.sensOrder[sensX] = 0;
	settings->magDir.sensOrder[sensY] = 1;
	settings->magDir.sensOrder[sensZ] = 2;
 8002d84:	76c4      	strb	r4, [r0, #27]
	settings->minSpeed = 0; 	//*PRESCALEVALUE;
	settings->maxSpeed = 200;	//*PRESCALEVALUE;

	settings->PID_yaw.PID_kp = 2.0f;
	settings->PID_yaw.PID_ki = 1.0f;
	settings->PID_yaw.PID_kd = 0.0f;
 8002d86:	6403      	str	r3, [r0, #64]	; 0x40
#ifdef PIDSmithPredictorController

	/* PID */
	settings->PID_rollPitch.PID_kp = 18.115707268541f; //14.5478771127435f;    	//22.7f;
	settings->PID_rollPitch.PID_ki = 3.8405091086306f; //28.1211353951591f;  	//0.8f;
	settings->PID_rollPitch.PID_kd = 0.4392517058174756f; //1.84575662912126f; 	//0.40f;
 8002d88:	6302      	str	r2, [r0, #48]	; 0x30
	settings->PID_rollPitch.PID_kn = 80.8259704631948f; //683.74924793257f;
 8002d8a:	4a0a      	ldr	r2, [pc, #40]	; (8002db4 <SETTINGS_init+0x90>)
 8002d8c:	6342      	str	r2, [r0, #52]	; 0x34

	/* Smith Predictor */
	settings->SmithPrediktor_rollPitch.b1 = 0.9753f;	// T1b
 8002d8e:	4a0a      	ldr	r2, [pc, #40]	; (8002db8 <SETTINGS_init+0x94>)
 8002d90:	6502      	str	r2, [r0, #80]	; 0x50
    settings->SmithPrediktor_rollPitch.b2 = 0.0f;
	settings->SmithPrediktor_rollPitch.b3 = 0.0f;
	settings->SmithPrediktor_rollPitch.a1 = 0.02469f;	// T1a
 8002d92:	4a0a      	ldr	r2, [pc, #40]	; (8002dbc <SETTINGS_init+0x98>)
 8002d94:	6482      	str	r2, [r0, #72]	; 0x48
	settings->SmithPrediktor_rollPitch.a2 = 0.007f;		// T2a
 8002d96:	4a0a      	ldr	r2, [pc, #40]	; (8002dc0 <SETTINGS_init+0x9c>)
	settings->PID_rollPitch.PID_kd = 0.4392517058174756f; //1.84575662912126f; 	//0.40f;
	settings->PID_rollPitch.PID_kn = 80.8259704631948f; //683.74924793257f;

	/* Smith Predictor */
	settings->SmithPrediktor_rollPitch.b1 = 0.9753f;	// T1b
    settings->SmithPrediktor_rollPitch.b2 = 0.0f;
 8002d98:	6543      	str	r3, [r0, #84]	; 0x54
	settings->SmithPrediktor_rollPitch.b3 = 0.0f;
 8002d9a:	6583      	str	r3, [r0, #88]	; 0x58
	settings->SmithPrediktor_rollPitch.a1 = 0.02469f;	// T1a
	settings->SmithPrediktor_rollPitch.a2 = 0.007f;		// T2a
 8002d9c:	64c2      	str	r2, [r0, #76]	; 0x4c
	settings->SmithPrediktor_rollPitch.gain = 0.0f;
 8002d9e:	65c3      	str	r3, [r0, #92]	; 0x5c
 8002da0:	bd30      	pop	{r4, r5, pc}
 8002da2:	bf00      	nop
 8002da4:	4190ecf8 	.word	0x4190ecf8
 8002da8:	3fa66666 	.word	0x3fa66666
 8002dac:	4075cae7 	.word	0x4075cae7
 8002db0:	3ee0e599 	.word	0x3ee0e599
 8002db4:	42a1a6e6 	.word	0x42a1a6e6
 8002db8:	3f79ad43 	.word	0x3f79ad43
 8002dbc:	3cca42af 	.word	0x3cca42af
 8002dc0:	3be56042 	.word	0x3be56042

08002dc4 <CTRLSTATES_init>:

}

void CTRLSTATES_init(CtrlStates_s *states)
{
	memset(states, 0, sizeof(CtrlStates_s));
 8002dc4:	2100      	movs	r1, #0
 8002dc6:	220c      	movs	r2, #12
 8002dc8:	f005 b930 	b.w	800802c <memset>

08002dcc <setup_xBeeS6>:




	return 0;
}
 8002dcc:	2000      	movs	r0, #0
 8002dce:	4770      	bx	lr

08002dd0 <ADC_DeInit>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));


  if((ADCx == ADC1) || (ADCx == ADC2))
 8002dd0:	f1b0 4fa0 	cmp.w	r0, #1342177280	; 0x50000000
  * @brief  Deinitializes the ADCx peripheral registers to their default reset values.
  * @param  ADCx: where x can be 1, 2,3 or 4 to select the ADC peripheral.
  * @retval None
  */
void ADC_DeInit(ADC_TypeDef* ADCx)
{
 8002dd4:	b508      	push	{r3, lr}
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));


  if((ADCx == ADC1) || (ADCx == ADC2))
 8002dd6:	d002      	beq.n	8002dde <ADC_DeInit+0xe>
 8002dd8:	4b0f      	ldr	r3, [pc, #60]	; (8002e18 <ADC_DeInit+0x48>)
 8002dda:	4298      	cmp	r0, r3
 8002ddc:	d107      	bne.n	8002dee <ADC_DeInit+0x1e>
  {
    /* Enable ADC1/ADC2 reset state */
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_ADC12, ENABLE);
 8002dde:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
 8002de2:	2101      	movs	r1, #1
 8002de4:	f001 fa8e 	bl	8004304 <RCC_AHBPeriphResetCmd>
    /* Release ADC1/ADC2 from reset state */
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_ADC12, DISABLE);
 8002de8:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
 8002dec:	e00d      	b.n	8002e0a <ADC_DeInit+0x3a>
  }
  else if((ADCx == ADC3) || (ADCx == ADC4))
 8002dee:	4b0b      	ldr	r3, [pc, #44]	; (8002e1c <ADC_DeInit+0x4c>)
 8002df0:	4298      	cmp	r0, r3
 8002df2:	d003      	beq.n	8002dfc <ADC_DeInit+0x2c>
 8002df4:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8002df8:	4298      	cmp	r0, r3
 8002dfa:	d10b      	bne.n	8002e14 <ADC_DeInit+0x44>
  {
    /* Enable ADC3/ADC4 reset state */
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_ADC34, ENABLE);
 8002dfc:	f04f 5000 	mov.w	r0, #536870912	; 0x20000000
 8002e00:	2101      	movs	r1, #1
 8002e02:	f001 fa7f 	bl	8004304 <RCC_AHBPeriphResetCmd>
    /* Release ADC3/ADC4 from reset state */
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_ADC34, DISABLE);
 8002e06:	f04f 5000 	mov.w	r0, #536870912	; 0x20000000
 8002e0a:	2100      	movs	r1, #0
  }
}
 8002e0c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  else if((ADCx == ADC3) || (ADCx == ADC4))
  {
    /* Enable ADC3/ADC4 reset state */
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_ADC34, ENABLE);
    /* Release ADC3/ADC4 from reset state */
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_ADC34, DISABLE);
 8002e10:	f001 ba78 	b.w	8004304 <RCC_AHBPeriphResetCmd>
 8002e14:	bd08      	pop	{r3, pc}
 8002e16:	bf00      	nop
 8002e18:	50000100 	.word	0x50000100
 8002e1c:	50000400 	.word	0x50000400

08002e20 <ADC_Init>:
  assert_param(IS_ADC_AUTOINJECMODE(ADC_InitStruct->ADC_AutoInjMode));
  assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfRegChannel));

  /*---------------------------- ADCx CFGR Configuration -----------------*/
  /* Get the ADCx CFGR value */
  tmpreg1 = ADCx->CFGR;
 8002e20:	68c2      	ldr	r2, [r0, #12]
  /* Clear SCAN bit */
  tmpreg1 &= CFGR_CLEAR_Mask; 
 8002e22:	4b0d      	ldr	r3, [pc, #52]	; (8002e58 <ADC_Init+0x38>)
  * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure that contains
  *         the configuration information for the specified ADC peripheral.
  * @retval None
  */
void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)
{
 8002e24:	b510      	push	{r4, lr}

  /*---------------------------- ADCx CFGR Configuration -----------------*/
  /* Get the ADCx CFGR value */
  tmpreg1 = ADCx->CFGR;
  /* Clear SCAN bit */
  tmpreg1 &= CFGR_CLEAR_Mask; 
 8002e26:	4013      	ands	r3, r2
  /* Configure ADCx: scan conversion mode */
  /* Set SCAN bit according to ADC_ScanConvMode value */
  tmpreg1 |= (uint32_t)ADC_InitStruct->ADC_ContinuousConvMode | 
 8002e28:	e891 0014 	ldmia.w	r1, {r2, r4}
 8002e2c:	4314      	orrs	r4, r2
  ADC_InitStruct->ADC_Resolution|                 
 8002e2e:	688a      	ldr	r2, [r1, #8]
 8002e30:	4314      	orrs	r4, r2
  ADC_InitStruct->ADC_ExternalTrigConvEvent|         
 8002e32:	68ca      	ldr	r2, [r1, #12]
 8002e34:	4314      	orrs	r4, r2
  ADC_InitStruct->ADC_ExternalTrigEventEdge|     
 8002e36:	690a      	ldr	r2, [r1, #16]
 8002e38:	4314      	orrs	r4, r2
  ADC_InitStruct->ADC_DataAlign|                 
 8002e3a:	694a      	ldr	r2, [r1, #20]
 8002e3c:	4314      	orrs	r4, r2
  ADC_InitStruct->ADC_OverrunMode|        
 8002e3e:	698a      	ldr	r2, [r1, #24]
 8002e40:	4322      	orrs	r2, r4
  tmpreg1 = ADCx->CFGR;
  /* Clear SCAN bit */
  tmpreg1 &= CFGR_CLEAR_Mask; 
  /* Configure ADCx: scan conversion mode */
  /* Set SCAN bit according to ADC_ScanConvMode value */
  tmpreg1 |= (uint32_t)ADC_InitStruct->ADC_ContinuousConvMode | 
 8002e42:	4313      	orrs	r3, r2
  ADC_InitStruct->ADC_DataAlign|                 
  ADC_InitStruct->ADC_OverrunMode|        
  ADC_InitStruct->ADC_AutoInjMode;
  
  /* Write to ADCx CFGR */
  ADCx->CFGR = tmpreg1;
 8002e44:	60c3      	str	r3, [r0, #12]
  
  /*---------------------------- ADCx SQR1 Configuration -----------------*/
  /* Get the ADCx SQR1 value */
  tmpreg1 = ADCx->SQR1;
 8002e46:	6b02      	ldr	r2, [r0, #48]	; 0x30
  /* Clear L bits */
  tmpreg1 &= ~(uint32_t)(ADC_SQR1_L);
  /* Configure ADCx: regular channel sequence length */
  /* Set L bits according to ADC_NbrOfRegChannel value */
  tmpreg1 |= (uint32_t) (ADC_InitStruct->ADC_NbrOfRegChannel - 1);
 8002e48:	7f0b      	ldrb	r3, [r1, #28]
  
  /*---------------------------- ADCx SQR1 Configuration -----------------*/
  /* Get the ADCx SQR1 value */
  tmpreg1 = ADCx->SQR1;
  /* Clear L bits */
  tmpreg1 &= ~(uint32_t)(ADC_SQR1_L);
 8002e4a:	f022 020f 	bic.w	r2, r2, #15
  /* Configure ADCx: regular channel sequence length */
  /* Set L bits according to ADC_NbrOfRegChannel value */
  tmpreg1 |= (uint32_t) (ADC_InitStruct->ADC_NbrOfRegChannel - 1);
 8002e4e:	3b01      	subs	r3, #1
 8002e50:	4313      	orrs	r3, r2
  /* Write to ADCx SQR1 */
  ADCx->SQR1 = tmpreg1; 
 8002e52:	6303      	str	r3, [r0, #48]	; 0x30
 8002e54:	bd10      	pop	{r4, pc}
 8002e56:	bf00      	nop
 8002e58:	fdffc007 	.word	0xfdffc007

08002e5c <ADC_StructInit>:
  * @retval None
  */
void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
{
  /* Reset ADC init structure parameters values */
  ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
 8002e5c:	2300      	movs	r3, #0
 8002e5e:	6003      	str	r3, [r0, #0]
  ADC_InitStruct->ADC_Resolution = ADC_Resolution_12b;                 
 8002e60:	6043      	str	r3, [r0, #4]
  ADC_InitStruct->ADC_ExternalTrigConvEvent = ADC_ExternalTrigConvEvent_0;         
 8002e62:	6083      	str	r3, [r0, #8]
  ADC_InitStruct->ADC_ExternalTrigEventEdge = ADC_ExternalTrigEventEdge_None;
 8002e64:	60c3      	str	r3, [r0, #12]
  ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;                 
 8002e66:	6103      	str	r3, [r0, #16]
  ADC_InitStruct->ADC_OverrunMode = DISABLE;   
 8002e68:	6143      	str	r3, [r0, #20]
  ADC_InitStruct->ADC_AutoInjMode = DISABLE;  
 8002e6a:	6183      	str	r3, [r0, #24]
  ADC_InitStruct->ADC_NbrOfRegChannel = 1; 
 8002e6c:	2301      	movs	r3, #1
 8002e6e:	7703      	strb	r3, [r0, #28]
 8002e70:	4770      	bx	lr

08002e72 <ADC_InjectedInit>:
  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedInitStruct->ADC_InjecSequence3));
  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedInitStruct->ADC_InjecSequence4));
  
  /*---------------------------- ADCx JSQR Configuration -----------------*/
  /* Get the ADCx JSQR value */
  tmpreg1 = ADCx->JSQR;
 8002e72:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
  /* Clear L bits */
  tmpreg1 &= JSQR_CLEAR_Mask;
  /* Configure ADCx: Injected channel sequence length, external trigger, 
     external trigger edge and sequences
  */
  tmpreg1 = (uint32_t) ((ADC_InjectedInitStruct->ADC_NbrOfInjecChannel - (uint8_t)1) |
 8002e74:	e891 000c 	ldmia.w	r1, {r2, r3}
 8002e78:	431a      	orrs	r2, r3
                         ADC_InjectedInitStruct->ADC_ExternalTrigInjecConvEvent |         
                         ADC_InjectedInitStruct->ADC_ExternalTrigInjecEventEdge |
                         (uint32_t)((ADC_InjectedInitStruct->ADC_InjecSequence1) << 8) |
 8002e7a:	68cb      	ldr	r3, [r1, #12]
  tmpreg1 &= JSQR_CLEAR_Mask;
  /* Configure ADCx: Injected channel sequence length, external trigger, 
     external trigger edge and sequences
  */
  tmpreg1 = (uint32_t) ((ADC_InjectedInitStruct->ADC_NbrOfInjecChannel - (uint8_t)1) |
                         ADC_InjectedInitStruct->ADC_ExternalTrigInjecConvEvent |         
 8002e7c:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
                         ADC_InjectedInitStruct->ADC_ExternalTrigInjecEventEdge |
                         (uint32_t)((ADC_InjectedInitStruct->ADC_InjecSequence1) << 8) |
                         (uint32_t)((ADC_InjectedInitStruct->ADC_InjecSequence2) << 14) |
 8002e80:	690b      	ldr	r3, [r1, #16]
  /* Configure ADCx: Injected channel sequence length, external trigger, 
     external trigger edge and sequences
  */
  tmpreg1 = (uint32_t) ((ADC_InjectedInitStruct->ADC_NbrOfInjecChannel - (uint8_t)1) |
                         ADC_InjectedInitStruct->ADC_ExternalTrigInjecConvEvent |         
                         ADC_InjectedInitStruct->ADC_ExternalTrigInjecEventEdge |
 8002e82:	ea42 3283 	orr.w	r2, r2, r3, lsl #14
                         (uint32_t)((ADC_InjectedInitStruct->ADC_InjecSequence1) << 8) |
                         (uint32_t)((ADC_InjectedInitStruct->ADC_InjecSequence2) << 14) |
                         (uint32_t)((ADC_InjectedInitStruct->ADC_InjecSequence3) << 20) |
 8002e86:	694b      	ldr	r3, [r1, #20]
     external trigger edge and sequences
  */
  tmpreg1 = (uint32_t) ((ADC_InjectedInitStruct->ADC_NbrOfInjecChannel - (uint8_t)1) |
                         ADC_InjectedInitStruct->ADC_ExternalTrigInjecConvEvent |         
                         ADC_InjectedInitStruct->ADC_ExternalTrigInjecEventEdge |
                         (uint32_t)((ADC_InjectedInitStruct->ADC_InjecSequence1) << 8) |
 8002e88:	ea42 5203 	orr.w	r2, r2, r3, lsl #20
                         (uint32_t)((ADC_InjectedInitStruct->ADC_InjecSequence2) << 14) |
                         (uint32_t)((ADC_InjectedInitStruct->ADC_InjecSequence3) << 20) |
                         (uint32_t)((ADC_InjectedInitStruct->ADC_InjecSequence4) << 26));
 8002e8c:	698b      	ldr	r3, [r1, #24]
  */
  tmpreg1 = (uint32_t) ((ADC_InjectedInitStruct->ADC_NbrOfInjecChannel - (uint8_t)1) |
                         ADC_InjectedInitStruct->ADC_ExternalTrigInjecConvEvent |         
                         ADC_InjectedInitStruct->ADC_ExternalTrigInjecEventEdge |
                         (uint32_t)((ADC_InjectedInitStruct->ADC_InjecSequence1) << 8) |
                         (uint32_t)((ADC_InjectedInitStruct->ADC_InjecSequence2) << 14) |
 8002e8e:	ea42 6383 	orr.w	r3, r2, r3, lsl #26
  /* Clear L bits */
  tmpreg1 &= JSQR_CLEAR_Mask;
  /* Configure ADCx: Injected channel sequence length, external trigger, 
     external trigger edge and sequences
  */
  tmpreg1 = (uint32_t) ((ADC_InjectedInitStruct->ADC_NbrOfInjecChannel - (uint8_t)1) |
 8002e92:	7a0a      	ldrb	r2, [r1, #8]
 8002e94:	3a01      	subs	r2, #1
 8002e96:	4313      	orrs	r3, r2
                         (uint32_t)((ADC_InjectedInitStruct->ADC_InjecSequence1) << 8) |
                         (uint32_t)((ADC_InjectedInitStruct->ADC_InjecSequence2) << 14) |
                         (uint32_t)((ADC_InjectedInitStruct->ADC_InjecSequence3) << 20) |
                         (uint32_t)((ADC_InjectedInitStruct->ADC_InjecSequence4) << 26));
  /* Write to ADCx SQR1 */
  ADCx->JSQR = tmpreg1;  
 8002e98:	64c3      	str	r3, [r0, #76]	; 0x4c
 8002e9a:	4770      	bx	lr

08002e9c <ADC_InjectedStructInit>:
  * @param  ADC_InjectedInitStruct : pointer to an ADC_InjectedInitTypeDef structure which will be initialized.
  * @retval None
  */
void ADC_InjectedStructInit(ADC_InjectedInitTypeDef* ADC_InjectedInitStruct)
{
  ADC_InjectedInitStruct->ADC_ExternalTrigInjecConvEvent = ADC_ExternalTrigInjecConvEvent_0;    
 8002e9c:	2300      	movs	r3, #0
 8002e9e:	6003      	str	r3, [r0, #0]
  ADC_InjectedInitStruct->ADC_ExternalTrigInjecEventEdge = ADC_ExternalTrigInjecEventEdge_None;     
 8002ea0:	6043      	str	r3, [r0, #4]
  ADC_InjectedInitStruct->ADC_NbrOfInjecChannel = 1;                                                             
 8002ea2:	2301      	movs	r3, #1
 8002ea4:	7203      	strb	r3, [r0, #8]
  ADC_InjectedInitStruct->ADC_InjecSequence1 = ADC_InjectedChannel_1; 
 8002ea6:	60c3      	str	r3, [r0, #12]
  ADC_InjectedInitStruct->ADC_InjecSequence2 = ADC_InjectedChannel_1;
 8002ea8:	6103      	str	r3, [r0, #16]
  ADC_InjectedInitStruct->ADC_InjecSequence3 = ADC_InjectedChannel_1;
 8002eaa:	6143      	str	r3, [r0, #20]
  ADC_InjectedInitStruct->ADC_InjecSequence4 = ADC_InjectedChannel_1; 
 8002eac:	6183      	str	r3, [r0, #24]
 8002eae:	4770      	bx	lr

08002eb0 <ADC_CommonInit>:
  assert_param(IS_ADC_CLOCKMODE(ADC_CommonInitStruct->ADC_Clock));
  assert_param(IS_ADC_DMA_MODE(ADC_CommonInitStruct->ADC_DMAMode));
  assert_param(IS_ADC_DMA_ACCESS_MODE(ADC_CommonInitStruct->ADC_DMAAccessMode));
  assert_param(IS_ADC_TWOSAMPLING_DELAY(ADC_CommonInitStruct->ADC_TwoSamplingDelay));

  if((ADCx == ADC1) || (ADCx == ADC2))
 8002eb0:	f1b0 4fa0 	cmp.w	r0, #1342177280	; 0x50000000
  * @param  ADC_CommonInitStruct: pointer to an ADC_CommonInitTypeDef structure 
  *         that contains the configuration information for  All ADCs peripherals.
  * @retval None
  */
void ADC_CommonInit(ADC_TypeDef* ADCx, ADC_CommonInitTypeDef* ADC_CommonInitStruct)
{
 8002eb4:	b510      	push	{r4, lr}
  assert_param(IS_ADC_CLOCKMODE(ADC_CommonInitStruct->ADC_Clock));
  assert_param(IS_ADC_DMA_MODE(ADC_CommonInitStruct->ADC_DMAMode));
  assert_param(IS_ADC_DMA_ACCESS_MODE(ADC_CommonInitStruct->ADC_DMAAccessMode));
  assert_param(IS_ADC_TWOSAMPLING_DELAY(ADC_CommonInitStruct->ADC_TwoSamplingDelay));

  if((ADCx == ADC1) || (ADCx == ADC2))
 8002eb6:	d002      	beq.n	8002ebe <ADC_CommonInit+0xe>
 8002eb8:	4b10      	ldr	r3, [pc, #64]	; (8002efc <ADC_CommonInit+0x4c>)
 8002eba:	4298      	cmp	r0, r3
 8002ebc:	d101      	bne.n	8002ec2 <ADC_CommonInit+0x12>
  {
    /* Get the ADC CCR value */
    tmpreg1 = ADC1_2->CCR;
 8002ebe:	4b10      	ldr	r3, [pc, #64]	; (8002f00 <ADC_CommonInit+0x50>)
 8002ec0:	e000      	b.n	8002ec4 <ADC_CommonInit+0x14>
    tmpreg1 &= CCR_CLEAR_MASK;
  }
  else
  {
    /* Get the ADC CCR value */
    tmpreg1 = ADC3_4->CCR;
 8002ec2:	4b10      	ldr	r3, [pc, #64]	; (8002f04 <ADC_CommonInit+0x54>)
 8002ec4:	689a      	ldr	r2, [r3, #8]
  
    /* Clear MULTI, DELAY, DMA and ADCPRE bits */
    tmpreg1 &= CCR_CLEAR_MASK;
 8002ec6:	4b10      	ldr	r3, [pc, #64]	; (8002f08 <ADC_CommonInit+0x58>)
 8002ec8:	4013      	ands	r3, r2
  /* Set MULTI bits according to ADC_Mode value */
  /* Set CKMODE bits according to ADC_Clock value */
  /* Set MDMA bits according to ADC_DMAAccessMode value */
  /* Set DMACFG bits according to ADC_DMAMode value */
  /* Set DELAY bits according to ADC_TwoSamplingDelay value */    
  tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
 8002eca:	e891 0014 	ldmia.w	r1, {r2, r4}
 8002ece:	4314      	orrs	r4, r2
                        ADC_CommonInitStruct->ADC_Clock | 
 8002ed0:	688a      	ldr	r2, [r1, #8]
 8002ed2:	4314      	orrs	r4, r2
                        ADC_CommonInitStruct->ADC_DMAAccessMode | 
                        (uint32_t)(ADC_CommonInitStruct->ADC_DMAMode << 12) |
 8002ed4:	68ca      	ldr	r2, [r1, #12]
                        (uint32_t)((uint32_t)ADC_CommonInitStruct->ADC_TwoSamplingDelay << 8));
 8002ed6:	7c09      	ldrb	r1, [r1, #16]
  /* Set MDMA bits according to ADC_DMAAccessMode value */
  /* Set DMACFG bits according to ADC_DMAMode value */
  /* Set DELAY bits according to ADC_TwoSamplingDelay value */    
  tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
                        ADC_CommonInitStruct->ADC_Clock | 
                        ADC_CommonInitStruct->ADC_DMAAccessMode | 
 8002ed8:	ea44 3202 	orr.w	r2, r4, r2, lsl #12
  /* Set MULTI bits according to ADC_Mode value */
  /* Set CKMODE bits according to ADC_Clock value */
  /* Set MDMA bits according to ADC_DMAAccessMode value */
  /* Set DMACFG bits according to ADC_DMAMode value */
  /* Set DELAY bits according to ADC_TwoSamplingDelay value */    
  tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
 8002edc:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
                        ADC_CommonInitStruct->ADC_Clock | 
                        ADC_CommonInitStruct->ADC_DMAAccessMode | 
                        (uint32_t)(ADC_CommonInitStruct->ADC_DMAMode << 12) |
                        (uint32_t)((uint32_t)ADC_CommonInitStruct->ADC_TwoSamplingDelay << 8));

  if((ADCx == ADC1) || (ADCx == ADC2))
 8002ee0:	f1b0 4fa0 	cmp.w	r0, #1342177280	; 0x50000000
  /* Set MULTI bits according to ADC_Mode value */
  /* Set CKMODE bits according to ADC_Clock value */
  /* Set MDMA bits according to ADC_DMAAccessMode value */
  /* Set DMACFG bits according to ADC_DMAMode value */
  /* Set DELAY bits according to ADC_TwoSamplingDelay value */    
  tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
 8002ee4:	ea42 0303 	orr.w	r3, r2, r3
                        ADC_CommonInitStruct->ADC_Clock | 
                        ADC_CommonInitStruct->ADC_DMAAccessMode | 
                        (uint32_t)(ADC_CommonInitStruct->ADC_DMAMode << 12) |
                        (uint32_t)((uint32_t)ADC_CommonInitStruct->ADC_TwoSamplingDelay << 8));

  if((ADCx == ADC1) || (ADCx == ADC2))
 8002ee8:	d002      	beq.n	8002ef0 <ADC_CommonInit+0x40>
 8002eea:	4a04      	ldr	r2, [pc, #16]	; (8002efc <ADC_CommonInit+0x4c>)
 8002eec:	4290      	cmp	r0, r2
 8002eee:	d101      	bne.n	8002ef4 <ADC_CommonInit+0x44>
  {                        
    /* Write to ADC CCR */
    ADC1_2->CCR = tmpreg1;
 8002ef0:	4a03      	ldr	r2, [pc, #12]	; (8002f00 <ADC_CommonInit+0x50>)
 8002ef2:	e000      	b.n	8002ef6 <ADC_CommonInit+0x46>
  }
  else
  {
    /* Write to ADC CCR */
    ADC3_4->CCR = tmpreg1;
 8002ef4:	4a03      	ldr	r2, [pc, #12]	; (8002f04 <ADC_CommonInit+0x54>)
 8002ef6:	6093      	str	r3, [r2, #8]
 8002ef8:	bd10      	pop	{r4, pc}
 8002efa:	bf00      	nop
 8002efc:	50000100 	.word	0x50000100
 8002f00:	50000300 	.word	0x50000300
 8002f04:	50000700 	.word	0x50000700
 8002f08:	fffc10e0 	.word	0xfffc10e0

08002f0c <ADC_CommonStructInit>:
  * @retval None
  */
void ADC_CommonStructInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct)
{
  /* Initialize the ADC_Mode member */
  ADC_CommonInitStruct->ADC_Mode = ADC_Mode_Independent;
 8002f0c:	2300      	movs	r3, #0
 8002f0e:	6003      	str	r3, [r0, #0]

  /* initialize the ADC_Clock member */
  ADC_CommonInitStruct->ADC_Clock = ADC_Clock_AsynClkMode;
 8002f10:	6043      	str	r3, [r0, #4]

  /* Initialize the ADC_DMAAccessMode member */
  ADC_CommonInitStruct->ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;
 8002f12:	6083      	str	r3, [r0, #8]

  /* Initialize the ADC_DMAMode member */
  ADC_CommonInitStruct->ADC_DMAMode = ADC_DMAMode_OneShot;
 8002f14:	60c3      	str	r3, [r0, #12]

  /* Initialize the ADC_TwoSamplingDelay member */
  ADC_CommonInitStruct->ADC_TwoSamplingDelay = 0;
 8002f16:	7403      	strb	r3, [r0, #16]
 8002f18:	4770      	bx	lr

08002f1a <ADC_Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Set the ADEN bit */
    ADCx->CR |= ADC_CR_ADEN;
 8002f1a:	6883      	ldr	r3, [r0, #8]
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8002f1c:	b111      	cbz	r1, 8002f24 <ADC_Cmd+0xa>
  {
    /* Set the ADEN bit */
    ADCx->CR |= ADC_CR_ADEN;
 8002f1e:	f043 0301 	orr.w	r3, r3, #1
 8002f22:	e001      	b.n	8002f28 <ADC_Cmd+0xe>
  }
  else
  {
    /* Disable the selected ADC peripheral: Set the ADDIS bit */
    ADCx->CR |= ADC_CR_ADDIS;
 8002f24:	f043 0302 	orr.w	r3, r3, #2
 8002f28:	6083      	str	r3, [r0, #8]
 8002f2a:	4770      	bx	lr

08002f2c <ADC_StartCalibration>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  /* Set the ADCAL bit */
  ADCx->CR |= ADC_CR_ADCAL;
 8002f2c:	6883      	ldr	r3, [r0, #8]
 8002f2e:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8002f32:	6083      	str	r3, [r0, #8]
 8002f34:	4770      	bx	lr

08002f36 <ADC_GetCalibrationValue>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  /* Return the selected ADC calibration value */
  return (uint32_t)ADCx->CALFACT;
 8002f36:	f8d0 00b4 	ldr.w	r0, [r0, #180]	; 0xb4
}
 8002f3a:	4770      	bx	lr

08002f3c <ADC_SetCalibrationValue>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  /* Set the ADC calibration register value */
  ADCx->CALFACT = ADC_Calibration;
 8002f3c:	f8c0 10b4 	str.w	r1, [r0, #180]	; 0xb4
 8002f40:	4770      	bx	lr

08002f42 <ADC_SelectCalibrationMode>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CALIBRATION_MODE(ADC_CalibrationMode));
  /* Set or Reset the ADCALDIF bit */
  ADCx->CR &= (~ADC_CR_ADCALDIF);
 8002f42:	6883      	ldr	r3, [r0, #8]
 8002f44:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 8002f48:	6083      	str	r3, [r0, #8]
  ADCx->CR |= ADC_CalibrationMode;
 8002f4a:	6883      	ldr	r3, [r0, #8]
 8002f4c:	4319      	orrs	r1, r3
 8002f4e:	6081      	str	r1, [r0, #8]
 8002f50:	4770      	bx	lr

08002f52 <ADC_GetCalibrationStatus>:
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  /* Check the status of CAL bit */
  if ((ADCx->CR & ADC_CR_ADCAL) != (uint32_t)RESET)
 8002f52:	6880      	ldr	r0, [r0, #8]
    /* CAL bit is reset: end of calibration */
    bitstatus = RESET;
  }
  /* Return the CAL bit status */
  return  bitstatus;
}
 8002f54:	0fc0      	lsrs	r0, r0, #31
 8002f56:	4770      	bx	lr

08002f58 <ADC_DisableCmd>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  /* Set the ADDIS bit */
  ADCx->CR |= ADC_CR_ADDIS;
 8002f58:	6883      	ldr	r3, [r0, #8]
 8002f5a:	f043 0302 	orr.w	r3, r3, #2
 8002f5e:	6083      	str	r3, [r0, #8]
 8002f60:	4770      	bx	lr

08002f62 <ADC_GetDisableCmdStatus>:
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  /* Check the status of ADDIS bit */
  if ((ADCx->CR & ADC_CR_ADDIS) != (uint32_t)RESET)
 8002f62:	6880      	ldr	r0, [r0, #8]
    /* ADDIS bit is reset */
    bitstatus = RESET;
  }
  /* Return the ADDIS bit status */
  return  bitstatus;
}
 8002f64:	f3c0 0040 	ubfx	r0, r0, #1, #1
 8002f68:	4770      	bx	lr

08002f6a <ADC_VoltageRegulatorCmd>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* set the intermediate state before moving the ADC voltage regulator 
  from enable state to disable state or from disable state to enable state */
  ADCx->CR &= ~(ADC_CR_ADVREGEN);
 8002f6a:	6883      	ldr	r3, [r0, #8]
 8002f6c:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
 8002f70:	6083      	str	r3, [r0, #8]
  
  if (NewState != DISABLE)
  {
    /* Set the ADVREGEN bit 0 */
    ADCx->CR |= ADC_CR_ADVREGEN_0;
 8002f72:	6883      	ldr	r3, [r0, #8]

  /* set the intermediate state before moving the ADC voltage regulator 
  from enable state to disable state or from disable state to enable state */
  ADCx->CR &= ~(ADC_CR_ADVREGEN);
  
  if (NewState != DISABLE)
 8002f74:	b111      	cbz	r1, 8002f7c <ADC_VoltageRegulatorCmd+0x12>
  {
    /* Set the ADVREGEN bit 0 */
    ADCx->CR |= ADC_CR_ADVREGEN_0;
 8002f76:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8002f7a:	e001      	b.n	8002f80 <ADC_VoltageRegulatorCmd+0x16>
  }
  else
  {
    /* Set the ADVREGEN bit 1 */
    ADCx->CR |=ADC_CR_ADVREGEN_1;
 8002f7c:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8002f80:	6083      	str	r3, [r0, #8]
 8002f82:	4770      	bx	lr

08002f84 <ADC_SelectDifferentialMode>:
  *     @arg ADC_Channel_14: ADC Channel14 selected
  * @note : Channel 15, 16 and 17 are fixed to single-ended inputs mode.
  * @retval None
  */
void ADC_SelectDifferentialMode(ADC_TypeDef* ADCx, uint8_t ADC_Channel, FunctionalState NewState)
{
 8002f84:	2301      	movs	r3, #1
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx)); 
  assert_param(IS_ADC_DIFFCHANNEL(ADC_Channel)); 
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8002f86:	b122      	cbz	r2, 8002f92 <ADC_SelectDifferentialMode+0xe>
  {
    /* Set the DIFSEL bit */
   ADCx->DIFSEL |= (uint32_t)(1 << ADC_Channel );
 8002f88:	f8d0 20b0 	ldr.w	r2, [r0, #176]	; 0xb0
 8002f8c:	408b      	lsls	r3, r1
 8002f8e:	4313      	orrs	r3, r2
 8002f90:	e004      	b.n	8002f9c <ADC_SelectDifferentialMode+0x18>
  }
  else
  {
    /* Reset the DIFSEL bit */
   ADCx->DIFSEL &= ~(uint32_t)(1 << ADC_Channel);
 8002f92:	f8d0 20b0 	ldr.w	r2, [r0, #176]	; 0xb0
 8002f96:	408b      	lsls	r3, r1
 8002f98:	ea22 0303 	bic.w	r3, r2, r3
 8002f9c:	f8c0 30b0 	str.w	r3, [r0, #176]	; 0xb0
 8002fa0:	4770      	bx	lr

08002fa2 <ADC_SelectQueueOfContextMode>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Set the JQM bit */
    ADCx->CFGR |= (uint32_t)(ADC_CFGR_JQM );
 8002fa2:	68c3      	ldr	r3, [r0, #12]
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx)); 
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8002fa4:	b111      	cbz	r1, 8002fac <ADC_SelectQueueOfContextMode+0xa>
  {
    /* Set the JQM bit */
    ADCx->CFGR |= (uint32_t)(ADC_CFGR_JQM );
 8002fa6:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8002faa:	e001      	b.n	8002fb0 <ADC_SelectQueueOfContextMode+0xe>
  }
  else
  {
    /* Reset the JQM bit */
    ADCx->CFGR &= ~(uint32_t)(ADC_CFGR_JQM);
 8002fac:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 8002fb0:	60c3      	str	r3, [r0, #12]
 8002fb2:	4770      	bx	lr

08002fb4 <ADC_AutoDelayCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Set the AUTDLY bit */
    ADCx->CFGR |= (uint32_t)(ADC_CFGR_AUTDLY );
 8002fb4:	68c3      	ldr	r3, [r0, #12]
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx)); 
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8002fb6:	b111      	cbz	r1, 8002fbe <ADC_AutoDelayCmd+0xa>
  {
    /* Set the AUTDLY bit */
    ADCx->CFGR |= (uint32_t)(ADC_CFGR_AUTDLY );
 8002fb8:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8002fbc:	e001      	b.n	8002fc2 <ADC_AutoDelayCmd+0xe>
  }
  else
  {
    /* Reset the AUTDLY bit */
    ADCx->CFGR &= ~(uint32_t)(ADC_CFGR_AUTDLY);
 8002fbe:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8002fc2:	60c3      	str	r3, [r0, #12]
 8002fc4:	4770      	bx	lr

08002fc6 <ADC_AnalogWatchdogCmd>:
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_ANALOG_WATCHDOG(ADC_AnalogWatchdog));
  /* Get the old register value */
  tmpreg = ADCx->CFGR;
 8002fc6:	68c3      	ldr	r3, [r0, #12]
  /* Clear AWDEN, AWDENJ and AWDSGL bits */
  tmpreg &= ~(uint32_t)(ADC_CFGR_AWD1SGL|ADC_CFGR_AWD1EN|ADC_CFGR_JAWD1EN);
 8002fc8:	f023 73e0 	bic.w	r3, r3, #29360128	; 0x1c00000
  /* Set the analog watchdog enable mode */
  tmpreg |= ADC_AnalogWatchdog;
 8002fcc:	4319      	orrs	r1, r3
  /* Store the new register value */
  ADCx->CFGR = tmpreg;
 8002fce:	60c1      	str	r1, [r0, #12]
 8002fd0:	4770      	bx	lr

08002fd2 <ADC_AnalogWatchdog1ThresholdsConfig>:
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_THRESHOLD(HighThreshold));
  assert_param(IS_ADC_THRESHOLD(LowThreshold));
  /* Set the ADCx high threshold */
  ADCx->TR1 &= ~(uint32_t)ADC_TR1_HT1;
 8002fd2:	6a03      	ldr	r3, [r0, #32]
 8002fd4:	f023 637f 	bic.w	r3, r3, #267386880	; 0xff00000
 8002fd8:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
 8002fdc:	6203      	str	r3, [r0, #32]
  ADCx->TR1 |= (uint32_t)((uint32_t)HighThreshold << 16);
 8002fde:	6a03      	ldr	r3, [r0, #32]
 8002fe0:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 8002fe4:	6201      	str	r1, [r0, #32]

  /* Set the ADCx low threshold */
  ADCx->TR1 &= ~(uint32_t)ADC_TR1_LT1;
 8002fe6:	6a03      	ldr	r3, [r0, #32]
 8002fe8:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 8002fec:	f023 030f 	bic.w	r3, r3, #15
 8002ff0:	6203      	str	r3, [r0, #32]
  ADCx->TR1 |= LowThreshold;
 8002ff2:	6a03      	ldr	r3, [r0, #32]
 8002ff4:	431a      	orrs	r2, r3
 8002ff6:	6202      	str	r2, [r0, #32]
 8002ff8:	4770      	bx	lr

08002ffa <ADC_AnalogWatchdog2ThresholdsConfig>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  
  /* Set the ADCx high threshold */
  ADCx->TR2 &= ~(uint32_t)ADC_TR2_HT2;
 8002ffa:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8002ffc:	f423 037f 	bic.w	r3, r3, #16711680	; 0xff0000
 8003000:	6243      	str	r3, [r0, #36]	; 0x24
  ADCx->TR2 |= (uint32_t)((uint32_t)HighThreshold << 16);
 8003002:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8003004:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 8003008:	6241      	str	r1, [r0, #36]	; 0x24

  /* Set the ADCx low threshold */
  ADCx->TR2 &= ~(uint32_t)ADC_TR2_LT2;
 800300a:	6a43      	ldr	r3, [r0, #36]	; 0x24
 800300c:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 8003010:	6243      	str	r3, [r0, #36]	; 0x24
  ADCx->TR2 |= LowThreshold;
 8003012:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8003014:	431a      	orrs	r2, r3
 8003016:	6242      	str	r2, [r0, #36]	; 0x24
 8003018:	4770      	bx	lr

0800301a <ADC_AnalogWatchdog3ThresholdsConfig>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  /* Set the ADCx high threshold */
  ADCx->TR3 &= ~(uint32_t)ADC_TR3_HT3;
 800301a:	6a83      	ldr	r3, [r0, #40]	; 0x28
 800301c:	f423 037f 	bic.w	r3, r3, #16711680	; 0xff0000
 8003020:	6283      	str	r3, [r0, #40]	; 0x28
  ADCx->TR3 |= (uint32_t)((uint32_t)HighThreshold << 16);
 8003022:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8003024:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 8003028:	6281      	str	r1, [r0, #40]	; 0x28

  /* Set the ADCx low threshold */
  ADCx->TR3 &= ~(uint32_t)ADC_TR3_LT3;
 800302a:	6a83      	ldr	r3, [r0, #40]	; 0x28
 800302c:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 8003030:	6283      	str	r3, [r0, #40]	; 0x28
  ADCx->TR3 |= LowThreshold;
 8003032:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8003034:	431a      	orrs	r2, r3
 8003036:	6282      	str	r2, [r0, #40]	; 0x28
 8003038:	4770      	bx	lr

0800303a <ADC_AnalogWatchdog1SingleChannelConfig>:
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  /* Get the old register value */
  tmpreg = ADCx->CFGR;
 800303a:	68c3      	ldr	r3, [r0, #12]
  /* Clear the Analog watchdog channel select bits */
  tmpreg &= ~(uint32_t)ADC_CFGR_AWD1CH;
 800303c:	f023 43f8 	bic.w	r3, r3, #2080374784	; 0x7c000000
  /* Set the Analog watchdog channel */
  tmpreg |= (uint32_t)((uint32_t)ADC_Channel << 26);
 8003040:	ea43 6181 	orr.w	r1, r3, r1, lsl #26
  /* Store the new register value */
  ADCx->CFGR = tmpreg;
 8003044:	60c1      	str	r1, [r0, #12]
 8003046:	4770      	bx	lr

08003048 <ADC_AnalogWatchdog2SingleChannelConfig>:
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  /* Get the old register value */
  tmpreg = ADCx->AWD2CR;
 8003048:	f8d0 20a0 	ldr.w	r2, [r0, #160]	; 0xa0
  /* Clear the Analog watchdog channel select bits */
  tmpreg &= ~(uint32_t)ADC_AWD2CR_AWD2CH;
 800304c:	4b05      	ldr	r3, [pc, #20]	; (8003064 <ADC_AnalogWatchdog2SingleChannelConfig+0x1c>)
 800304e:	4013      	ands	r3, r2
  /* Set the Analog watchdog channel */
  tmpreg |= (uint32_t)1 << (ADC_Channel);
  /* Store the new register value */
  ADCx->AWD2CR |= tmpreg;
 8003050:	f8d0 20a0 	ldr.w	r2, [r0, #160]	; 0xa0
  /* Get the old register value */
  tmpreg = ADCx->AWD2CR;
  /* Clear the Analog watchdog channel select bits */
  tmpreg &= ~(uint32_t)ADC_AWD2CR_AWD2CH;
  /* Set the Analog watchdog channel */
  tmpreg |= (uint32_t)1 << (ADC_Channel);
 8003054:	4313      	orrs	r3, r2
 8003056:	2201      	movs	r2, #1
 8003058:	fa02 f101 	lsl.w	r1, r2, r1
  /* Store the new register value */
  ADCx->AWD2CR |= tmpreg;
 800305c:	430b      	orrs	r3, r1
 800305e:	f8c0 30a0 	str.w	r3, [r0, #160]	; 0xa0
 8003062:	4770      	bx	lr
 8003064:	fff80001 	.word	0xfff80001

08003068 <ADC_AnalogWatchdog3SingleChannelConfig>:
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  /* Get the old register value */
  tmpreg = ADCx->AWD3CR;
 8003068:	f8d0 20a4 	ldr.w	r2, [r0, #164]	; 0xa4
  /* Clear the Analog watchdog channel select bits */
  tmpreg &= ~(uint32_t)ADC_AWD3CR_AWD3CH;
 800306c:	4b05      	ldr	r3, [pc, #20]	; (8003084 <ADC_AnalogWatchdog3SingleChannelConfig+0x1c>)
 800306e:	4013      	ands	r3, r2
  /* Set the Analog watchdog channel */
  tmpreg |= (uint32_t)1 << (ADC_Channel);
  /* Store the new register value */
  ADCx->AWD3CR |= tmpreg;
 8003070:	f8d0 20a4 	ldr.w	r2, [r0, #164]	; 0xa4
  /* Get the old register value */
  tmpreg = ADCx->AWD3CR;
  /* Clear the Analog watchdog channel select bits */
  tmpreg &= ~(uint32_t)ADC_AWD3CR_AWD3CH;
  /* Set the Analog watchdog channel */
  tmpreg |= (uint32_t)1 << (ADC_Channel);
 8003074:	4313      	orrs	r3, r2
 8003076:	2201      	movs	r2, #1
 8003078:	fa02 f101 	lsl.w	r1, r2, r1
  /* Store the new register value */
  ADCx->AWD3CR |= tmpreg;
 800307c:	430b      	orrs	r3, r1
 800307e:	f8c0 30a4 	str.w	r3, [r0, #164]	; 0xa4
 8003082:	4770      	bx	lr
 8003084:	fff80001 	.word	0xfff80001

08003088 <ADC_TempSensorCmd>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if((ADCx == ADC1) || (ADCx == ADC2))
 8003088:	f1b0 4fa0 	cmp.w	r0, #1342177280	; 0x50000000
 800308c:	d002      	beq.n	8003094 <ADC_TempSensorCmd+0xc>
 800308e:	4b07      	ldr	r3, [pc, #28]	; (80030ac <ADC_TempSensorCmd+0x24>)
 8003090:	4298      	cmp	r0, r3
 8003092:	d101      	bne.n	8003098 <ADC_TempSensorCmd+0x10>
 8003094:	4b06      	ldr	r3, [pc, #24]	; (80030b0 <ADC_TempSensorCmd+0x28>)
 8003096:	e000      	b.n	800309a <ADC_TempSensorCmd+0x12>
 8003098:	4b06      	ldr	r3, [pc, #24]	; (80030b4 <ADC_TempSensorCmd+0x2c>)
  else
  {
    if (NewState != DISABLE)
    {
      /* Enable the temperature sensor channel*/
      ADC3_4->CCR |= ADC34_CCR_TSEN;
 800309a:	689a      	ldr	r2, [r3, #8]
      ADC1_2->CCR &= ~(uint32_t)ADC12_CCR_TSEN;
    }
  }
  else
  {
    if (NewState != DISABLE)
 800309c:	b111      	cbz	r1, 80030a4 <ADC_TempSensorCmd+0x1c>
    {
      /* Enable the temperature sensor channel*/
      ADC3_4->CCR |= ADC34_CCR_TSEN;
 800309e:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
 80030a2:	e001      	b.n	80030a8 <ADC_TempSensorCmd+0x20>
    }
    else
    {
      /* Disable the temperature sensor channel*/
      ADC3_4->CCR &= ~(uint32_t)ADC34_CCR_TSEN;
 80030a4:	f422 0200 	bic.w	r2, r2, #8388608	; 0x800000
 80030a8:	609a      	str	r2, [r3, #8]
 80030aa:	4770      	bx	lr
 80030ac:	50000100 	.word	0x50000100
 80030b0:	50000300 	.word	0x50000300
 80030b4:	50000700 	.word	0x50000700

080030b8 <ADC_VrefintCmd>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if((ADCx == ADC1) || (ADCx == ADC2))
 80030b8:	f1b0 4fa0 	cmp.w	r0, #1342177280	; 0x50000000
 80030bc:	d002      	beq.n	80030c4 <ADC_VrefintCmd+0xc>
 80030be:	4b07      	ldr	r3, [pc, #28]	; (80030dc <ADC_VrefintCmd+0x24>)
 80030c0:	4298      	cmp	r0, r3
 80030c2:	d101      	bne.n	80030c8 <ADC_VrefintCmd+0x10>
 80030c4:	4b06      	ldr	r3, [pc, #24]	; (80030e0 <ADC_VrefintCmd+0x28>)
 80030c6:	e000      	b.n	80030ca <ADC_VrefintCmd+0x12>
 80030c8:	4b06      	ldr	r3, [pc, #24]	; (80030e4 <ADC_VrefintCmd+0x2c>)
  else
  {
    if (NewState != DISABLE)
    {
      /* Enable the Vrefint channel*/
      ADC3_4->CCR |= ADC34_CCR_VREFEN;
 80030ca:	689a      	ldr	r2, [r3, #8]
      ADC1_2->CCR &= ~(uint32_t)ADC12_CCR_VREFEN;
    }
  }
  else
  {
    if (NewState != DISABLE)
 80030cc:	b111      	cbz	r1, 80030d4 <ADC_VrefintCmd+0x1c>
    {
      /* Enable the Vrefint channel*/
      ADC3_4->CCR |= ADC34_CCR_VREFEN;
 80030ce:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 80030d2:	e001      	b.n	80030d8 <ADC_VrefintCmd+0x20>
    }
    else
    {
      /* Disable the Vrefint channel*/
      ADC3_4->CCR &= ~(uint32_t)ADC34_CCR_VREFEN;
 80030d4:	f422 0280 	bic.w	r2, r2, #4194304	; 0x400000
 80030d8:	609a      	str	r2, [r3, #8]
 80030da:	4770      	bx	lr
 80030dc:	50000100 	.word	0x50000100
 80030e0:	50000300 	.word	0x50000300
 80030e4:	50000700 	.word	0x50000700

080030e8 <ADC_VbatCmd>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if((ADCx == ADC1) || (ADCx == ADC2))
 80030e8:	f1b0 4fa0 	cmp.w	r0, #1342177280	; 0x50000000
 80030ec:	d002      	beq.n	80030f4 <ADC_VbatCmd+0xc>
 80030ee:	4b07      	ldr	r3, [pc, #28]	; (800310c <ADC_VbatCmd+0x24>)
 80030f0:	4298      	cmp	r0, r3
 80030f2:	d101      	bne.n	80030f8 <ADC_VbatCmd+0x10>
 80030f4:	4b06      	ldr	r3, [pc, #24]	; (8003110 <ADC_VbatCmd+0x28>)
 80030f6:	e000      	b.n	80030fa <ADC_VbatCmd+0x12>
 80030f8:	4b06      	ldr	r3, [pc, #24]	; (8003114 <ADC_VbatCmd+0x2c>)
  else
  {
    if (NewState != DISABLE)
    {
      /* Enable the Vbat channel*/
      ADC3_4->CCR |= ADC34_CCR_VBATEN;
 80030fa:	689a      	ldr	r2, [r3, #8]
      ADC1_2->CCR &= ~(uint32_t)ADC12_CCR_VBATEN;
    }
  }
  else
  {
    if (NewState != DISABLE)
 80030fc:	b111      	cbz	r1, 8003104 <ADC_VbatCmd+0x1c>
    {
      /* Enable the Vbat channel*/
      ADC3_4->CCR |= ADC34_CCR_VBATEN;
 80030fe:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8003102:	e001      	b.n	8003108 <ADC_VbatCmd+0x20>
    }
    else
    {
      /* Disable the Vbat channel*/
      ADC3_4->CCR &= ~(uint32_t)ADC34_CCR_VBATEN;
 8003104:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 8003108:	609a      	str	r2, [r3, #8]
 800310a:	4770      	bx	lr
 800310c:	50000100 	.word	0x50000100
 8003110:	50000300 	.word	0x50000300
 8003114:	50000700 	.word	0x50000700

08003118 <ADC_RegularChannelConfig>:
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));

  /* Regular sequence configuration */
  /* For Rank 1 to 4 */
  if (Rank < 5)
 8003118:	2a04      	cmp	r2, #4
  *     @arg ADC_SampleTime_181Cycles5: Sample time equal to 181.5 cycles	
  *     @arg ADC_SampleTime_601Cycles5: Sample time equal to 601.5 cycles	
  * @retval None
  */
void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
{
 800311a:	b530      	push	{r4, r5, lr}
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));

  /* Regular sequence configuration */
  /* For Rank 1 to 4 */
  if (Rank < 5)
 800311c:	d80c      	bhi.n	8003138 <ADC_RegularChannelConfig+0x20>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR1;
    /* Calculate the mask to clear */
    tmpreg2 = 0x1F << (6 * (Rank ));
 800311e:	eb02 0242 	add.w	r2, r2, r2, lsl #1
  /* Regular sequence configuration */
  /* For Rank 1 to 4 */
  if (Rank < 5)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR1;
 8003122:	6b05      	ldr	r5, [r0, #48]	; 0x30
    /* Calculate the mask to clear */
    tmpreg2 = 0x1F << (6 * (Rank ));
 8003124:	0052      	lsls	r2, r2, #1
 8003126:	241f      	movs	r4, #31
 8003128:	4094      	lsls	r4, r2
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 800312a:	ea25 0404 	bic.w	r4, r5, r4
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)(ADC_Channel) << (6 * (Rank));
 800312e:	fa01 f202 	lsl.w	r2, r1, r2
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 8003132:	4322      	orrs	r2, r4
    /* Store the new register value */
    ADCx->SQR1 = tmpreg1;
 8003134:	6302      	str	r2, [r0, #48]	; 0x30
 8003136:	e029      	b.n	800318c <ADC_RegularChannelConfig+0x74>
  }
  /* For Rank 5 to 9 */
  else if (Rank < 10)
 8003138:	2a09      	cmp	r2, #9
 800313a:	d80c      	bhi.n	8003156 <ADC_RegularChannelConfig+0x3e>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR2;
    /* Calculate the mask to clear */
    tmpreg2 = ADC_SQR2_SQ5 << (6 * (Rank - 5));
 800313c:	2406      	movs	r4, #6
 800313e:	3a05      	subs	r2, #5
 8003140:	4362      	muls	r2, r4
  }
  /* For Rank 5 to 9 */
  else if (Rank < 10)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR2;
 8003142:	6b45      	ldr	r5, [r0, #52]	; 0x34
    /* Calculate the mask to clear */
    tmpreg2 = ADC_SQR2_SQ5 << (6 * (Rank - 5));
 8003144:	241f      	movs	r4, #31
 8003146:	4094      	lsls	r4, r2
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 8003148:	ea25 0404 	bic.w	r4, r5, r4
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)(ADC_Channel) << (6 * (Rank - 5));
 800314c:	fa01 f202 	lsl.w	r2, r1, r2
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 8003150:	4322      	orrs	r2, r4
    /* Store the new register value */
    ADCx->SQR2 = tmpreg1;
 8003152:	6342      	str	r2, [r0, #52]	; 0x34
 8003154:	e01a      	b.n	800318c <ADC_RegularChannelConfig+0x74>
  }
  /* For Rank 10 to 14 */
  else if (Rank < 15)
 8003156:	2a0e      	cmp	r2, #14
 8003158:	f04f 0406 	mov.w	r4, #6
 800315c:	d80b      	bhi.n	8003176 <ADC_RegularChannelConfig+0x5e>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR3;
    /* Calculate the mask to clear */
    tmpreg2 = ADC_SQR3_SQ10 << (6 * (Rank - 10));
 800315e:	3a0a      	subs	r2, #10
 8003160:	4354      	muls	r4, r2
  }
  /* For Rank 10 to 14 */
  else if (Rank < 15)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR3;
 8003162:	6b85      	ldr	r5, [r0, #56]	; 0x38
    /* Calculate the mask to clear */
    tmpreg2 = ADC_SQR3_SQ10 << (6 * (Rank - 10));
 8003164:	221f      	movs	r2, #31
 8003166:	40a2      	lsls	r2, r4
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 8003168:	ea25 0202 	bic.w	r2, r5, r2
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)(ADC_Channel) << (6 * (Rank - 10));
 800316c:	fa01 f404 	lsl.w	r4, r1, r4
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 8003170:	4314      	orrs	r4, r2
    /* Store the new register value */
    ADCx->SQR3 = tmpreg1;
 8003172:	6384      	str	r4, [r0, #56]	; 0x38
 8003174:	e00a      	b.n	800318c <ADC_RegularChannelConfig+0x74>
  else 
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR4;
    /* Calculate the mask to clear */
    tmpreg2 = ADC_SQR3_SQ15 << (6 * (Rank - 15));
 8003176:	3a0f      	subs	r2, #15
 8003178:	4362      	muls	r2, r4
    ADCx->SQR3 = tmpreg1;
  }
  else 
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR4;
 800317a:	6bc5      	ldr	r5, [r0, #60]	; 0x3c
    /* Calculate the mask to clear */
    tmpreg2 = ADC_SQR3_SQ15 << (6 * (Rank - 15));
 800317c:	241f      	movs	r4, #31
 800317e:	4094      	lsls	r4, r2
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 8003180:	ea25 0404 	bic.w	r4, r5, r4
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)(ADC_Channel) << (6 * (Rank - 15));
 8003184:	fa01 f202 	lsl.w	r2, r1, r2
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 8003188:	4322      	orrs	r2, r4
    /* Store the new register value */
    ADCx->SQR4 = tmpreg1;
 800318a:	63c2      	str	r2, [r0, #60]	; 0x3c
  }

  /* Channel sampling configuration */
  /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
  if (ADC_Channel > ADC_Channel_9)
 800318c:	2909      	cmp	r1, #9
 800318e:	d90f      	bls.n	80031b0 <ADC_RegularChannelConfig+0x98>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR2;
    /* Calculate the mask to clear */
    tmpreg2 = ADC_SMPR2_SMP10 << (3 * (ADC_Channel - 10));
 8003190:	390a      	subs	r1, #10
  /* Channel sampling configuration */
  /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
  if (ADC_Channel > ADC_Channel_9)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR2;
 8003192:	6982      	ldr	r2, [r0, #24]
    /* Calculate the mask to clear */
    tmpreg2 = ADC_SMPR2_SMP10 << (3 * (ADC_Channel - 10));
    /* Clear the old channel sample time */
	ADCx->SMPR2 &= ~tmpreg2;
 8003194:	6984      	ldr	r4, [r0, #24]
  if (ADC_Channel > ADC_Channel_9)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR2;
    /* Calculate the mask to clear */
    tmpreg2 = ADC_SMPR2_SMP10 << (3 * (ADC_Channel - 10));
 8003196:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 800319a:	2207      	movs	r2, #7
 800319c:	408a      	lsls	r2, r1
    /* Clear the old channel sample time */
	ADCx->SMPR2 &= ~tmpreg2;
 800319e:	ea24 0202 	bic.w	r2, r4, r2
 80031a2:	6182      	str	r2, [r0, #24]
    /* Calculate the mask to set */
	ADCx->SMPR2 |= (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
 80031a4:	6982      	ldr	r2, [r0, #24]
 80031a6:	fa03 f101 	lsl.w	r1, r3, r1
 80031aa:	4311      	orrs	r1, r2
 80031ac:	6181      	str	r1, [r0, #24]
 80031ae:	bd30      	pop	{r4, r5, pc}
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR1;
    /* Calculate the mask to clear */
    tmpreg2 = ADC_SMPR1_SMP1 << (3 * (ADC_Channel - 1));
 80031b0:	3901      	subs	r1, #1

  }
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR1;
 80031b2:	6942      	ldr	r2, [r0, #20]
    /* Calculate the mask to clear */
    tmpreg2 = ADC_SMPR1_SMP1 << (3 * (ADC_Channel - 1));
    /* Clear the old channel sample time */
	ADCx->SMPR1 &= ~tmpreg2;
 80031b4:	6944      	ldr	r4, [r0, #20]
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR1;
    /* Calculate the mask to clear */
    tmpreg2 = ADC_SMPR1_SMP1 << (3 * (ADC_Channel - 1));
 80031b6:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 80031ba:	2238      	movs	r2, #56	; 0x38
 80031bc:	408a      	lsls	r2, r1
    /* Clear the old channel sample time */
	ADCx->SMPR1 &= ~tmpreg2;
 80031be:	ea24 0202 	bic.w	r2, r4, r2
 80031c2:	6142      	str	r2, [r0, #20]
    /* Calculate the mask to set */
	ADCx->SMPR1 |= (uint32_t)ADC_SampleTime << (3 * (ADC_Channel));
 80031c4:	6942      	ldr	r2, [r0, #20]
 80031c6:	3103      	adds	r1, #3
 80031c8:	408b      	lsls	r3, r1
 80031ca:	4313      	orrs	r3, r2
 80031cc:	6143      	str	r3, [r0, #20]
 80031ce:	bd30      	pop	{r4, r5, pc}

080031d0 <ADC_RegularChannelSequencerLengthConfig>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  /* Configure the ADC sequence lenght */  
  ADCx->SQR1 &= ~(uint32_t)ADC_SQR1_L;
 80031d0:	6b03      	ldr	r3, [r0, #48]	; 0x30
 80031d2:	f023 030f 	bic.w	r3, r3, #15
 80031d6:	6303      	str	r3, [r0, #48]	; 0x30
  ADCx->SQR1 |= (uint32_t)(SequencerLength - 1);   
 80031d8:	6b03      	ldr	r3, [r0, #48]	; 0x30
 80031da:	3901      	subs	r1, #1
 80031dc:	430b      	orrs	r3, r1
 80031de:	6303      	str	r3, [r0, #48]	; 0x30
 80031e0:	4770      	bx	lr

080031e2 <ADC_ExternalTriggerConfig>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_EXT_TRIG(ADC_ExternalTrigConvEvent));
  assert_param(IS_EXTERNALTRIG_EDGE(ADC_ExternalTrigEventEdge));

  /* Disable the selected ADC conversion on external event */
  ADCx->CFGR &= ~(ADC_CFGR_EXTEN | ADC_CFGR_EXTSEL);
 80031e2:	68c3      	ldr	r3, [r0, #12]
 80031e4:	f423 637c 	bic.w	r3, r3, #4032	; 0xfc0
 80031e8:	60c3      	str	r3, [r0, #12]
  ADCx->CFGR |= (uint32_t)(ADC_ExternalTrigEventEdge | ADC_ExternalTrigConvEvent);
 80031ea:	68c3      	ldr	r3, [r0, #12]
 80031ec:	430a      	orrs	r2, r1
 80031ee:	4313      	orrs	r3, r2
 80031f0:	60c3      	str	r3, [r0, #12]
 80031f2:	4770      	bx	lr

080031f4 <ADC_StartConversion>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  /* Set the ADSTART bit */
  ADCx->CR |= ADC_CR_ADSTART;
 80031f4:	6883      	ldr	r3, [r0, #8]
 80031f6:	f043 0304 	orr.w	r3, r3, #4
 80031fa:	6083      	str	r3, [r0, #8]
 80031fc:	4770      	bx	lr

080031fe <ADC_GetStartConversionStatus>:
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  /* Check the status of ADSTART bit */
  if ((ADCx->CR & ADC_CR_ADSTART) != (uint32_t)RESET)
 80031fe:	6880      	ldr	r0, [r0, #8]
    /* ADSTART bit is reset */
    bitstatus = RESET;
  }
  /* Return the ADSTART bit status */
  return  bitstatus;
}
 8003200:	f3c0 0080 	ubfx	r0, r0, #2, #1
 8003204:	4770      	bx	lr

08003206 <ADC_StopConversion>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  /* Set the ADSTP bit */
   ADCx->CR |= ADC_CR_ADSTP;
 8003206:	6883      	ldr	r3, [r0, #8]
 8003208:	f043 0310 	orr.w	r3, r3, #16
 800320c:	6083      	str	r3, [r0, #8]
 800320e:	4770      	bx	lr

08003210 <ADC_DiscModeChannelCountConfig>:
  uint32_t tmpreg2 = 0;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));
  /* Get the old register value */
  tmpreg1 = ADCx->CFGR;
 8003210:	68c3      	ldr	r3, [r0, #12]
  /* Clear the old discontinuous mode channel count */
  tmpreg1 &= ~(uint32_t)(ADC_CFGR_DISCNUM);
  /* Set the discontinuous mode channel count */
  tmpreg2 = Number - 1;
 8003212:	3901      	subs	r1, #1
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));
  /* Get the old register value */
  tmpreg1 = ADCx->CFGR;
  /* Clear the old discontinuous mode channel count */
  tmpreg1 &= ~(uint32_t)(ADC_CFGR_DISCNUM);
 8003214:	f423 2360 	bic.w	r3, r3, #917504	; 0xe0000
  /* Set the discontinuous mode channel count */
  tmpreg2 = Number - 1;
  tmpreg1 |= tmpreg2 << 17;
 8003218:	ea43 4341 	orr.w	r3, r3, r1, lsl #17
  /* Store the new register value */
  ADCx->CFGR = tmpreg1;
 800321c:	60c3      	str	r3, [r0, #12]
 800321e:	4770      	bx	lr

08003220 <ADC_DiscModeCmd>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected ADC regular discontinuous mode */
    ADCx->CFGR |= ADC_CFGR_DISCEN;
 8003220:	68c3      	ldr	r3, [r0, #12]
void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8003222:	b111      	cbz	r1, 800322a <ADC_DiscModeCmd+0xa>
  {
    /* Enable the selected ADC regular discontinuous mode */
    ADCx->CFGR |= ADC_CFGR_DISCEN;
 8003224:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8003228:	e001      	b.n	800322e <ADC_DiscModeCmd+0xe>
  }
  else
  {
    /* Disable the selected ADC regular discontinuous mode */
    ADCx->CFGR &= ~(uint32_t)(ADC_CFGR_DISCEN);
 800322a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800322e:	60c3      	str	r3, [r0, #12]
 8003230:	4770      	bx	lr

08003232 <ADC_GetConversionValue>:
uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  /* Return the selected ADC conversion value */
  return (uint16_t) ADCx->DR;
 8003232:	6c00      	ldr	r0, [r0, #64]	; 0x40
}
 8003234:	b280      	uxth	r0, r0
 8003236:	4770      	bx	lr

08003238 <ADC_GetDualModeConversionValue>:
  uint32_t tmpreg1 = 0;

  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  if((ADCx == ADC1) || (ADCx== ADC2))
 8003238:	f1b0 4fa0 	cmp.w	r0, #1342177280	; 0x50000000
 800323c:	d002      	beq.n	8003244 <ADC_GetDualModeConversionValue+0xc>
 800323e:	4b04      	ldr	r3, [pc, #16]	; (8003250 <ADC_GetDualModeConversionValue+0x18>)
 8003240:	4298      	cmp	r0, r3
 8003242:	d101      	bne.n	8003248 <ADC_GetDualModeConversionValue+0x10>
  {
    /* Get the dual mode conversion value */
    tmpreg1 = ADC1_2->CDR;
 8003244:	4b03      	ldr	r3, [pc, #12]	; (8003254 <ADC_GetDualModeConversionValue+0x1c>)
 8003246:	e000      	b.n	800324a <ADC_GetDualModeConversionValue+0x12>
  }
  else
  {	
    /* Get the dual mode conversion value */
    tmpreg1 = ADC3_4->CDR;
 8003248:	4b03      	ldr	r3, [pc, #12]	; (8003258 <ADC_GetDualModeConversionValue+0x20>)
 800324a:	68d8      	ldr	r0, [r3, #12]
  }
  /* Return the dual mode conversion value */
  return (uint32_t) tmpreg1;
}
 800324c:	4770      	bx	lr
 800324e:	bf00      	nop
 8003250:	50000100 	.word	0x50000100
 8003254:	50000300 	.word	0x50000300
 8003258:	50000700 	.word	0x50000700

0800325c <ADC_SetChannelOffset1>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_OFFSET(Offset));
    
  /* Select the Channel */
  ADCx->OFR1 &= ~ (uint32_t) ADC_OFR1_OFFSET1_CH;
 800325c:	6e03      	ldr	r3, [r0, #96]	; 0x60
 800325e:	f023 43f8 	bic.w	r3, r3, #2080374784	; 0x7c000000
 8003262:	6603      	str	r3, [r0, #96]	; 0x60
  ADCx->OFR1 |=	(uint32_t)((uint32_t)ADC_Channel << 26);
 8003264:	6e03      	ldr	r3, [r0, #96]	; 0x60
 8003266:	ea43 6181 	orr.w	r1, r3, r1, lsl #26
 800326a:	6601      	str	r1, [r0, #96]	; 0x60

  /* Set the data offset */
  ADCx->OFR1 &= ~ (uint32_t) ADC_OFR1_OFFSET1;
 800326c:	6e03      	ldr	r3, [r0, #96]	; 0x60
 800326e:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 8003272:	f023 030f 	bic.w	r3, r3, #15
 8003276:	6603      	str	r3, [r0, #96]	; 0x60
  ADCx->OFR1 |= (uint32_t)Offset;
 8003278:	6e03      	ldr	r3, [r0, #96]	; 0x60
 800327a:	431a      	orrs	r2, r3
 800327c:	6602      	str	r2, [r0, #96]	; 0x60
 800327e:	4770      	bx	lr

08003280 <ADC_SetChannelOffset2>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_OFFSET(Offset));
    
  /* Select the Channel */
  ADCx->OFR2 &= ~ (uint32_t) ADC_OFR2_OFFSET2_CH;
 8003280:	6e43      	ldr	r3, [r0, #100]	; 0x64
 8003282:	f023 43f8 	bic.w	r3, r3, #2080374784	; 0x7c000000
 8003286:	6643      	str	r3, [r0, #100]	; 0x64
  ADCx->OFR2 |=	(uint32_t)((uint32_t)ADC_Channel << 26);
 8003288:	6e43      	ldr	r3, [r0, #100]	; 0x64
 800328a:	ea43 6181 	orr.w	r1, r3, r1, lsl #26
 800328e:	6641      	str	r1, [r0, #100]	; 0x64

  /* Set the data offset */
  ADCx->OFR2 &= ~ (uint32_t) ADC_OFR2_OFFSET2;
 8003290:	6e43      	ldr	r3, [r0, #100]	; 0x64
 8003292:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 8003296:	f023 030f 	bic.w	r3, r3, #15
 800329a:	6643      	str	r3, [r0, #100]	; 0x64
  ADCx->OFR2 |= (uint32_t)Offset;
 800329c:	6e43      	ldr	r3, [r0, #100]	; 0x64
 800329e:	431a      	orrs	r2, r3
 80032a0:	6642      	str	r2, [r0, #100]	; 0x64
 80032a2:	4770      	bx	lr

080032a4 <ADC_SetChannelOffset3>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_OFFSET(Offset));
    
  /* Select the Channel */
  ADCx->OFR3 &= ~ (uint32_t) ADC_OFR3_OFFSET3_CH;
 80032a4:	6e83      	ldr	r3, [r0, #104]	; 0x68
 80032a6:	f023 43f8 	bic.w	r3, r3, #2080374784	; 0x7c000000
 80032aa:	6683      	str	r3, [r0, #104]	; 0x68
  ADCx->OFR3 |=	(uint32_t)((uint32_t)ADC_Channel << 26);
 80032ac:	6e83      	ldr	r3, [r0, #104]	; 0x68
 80032ae:	ea43 6181 	orr.w	r1, r3, r1, lsl #26
 80032b2:	6681      	str	r1, [r0, #104]	; 0x68

  /* Set the data offset */
  ADCx->OFR3 &= ~ (uint32_t) ADC_OFR3_OFFSET3;
 80032b4:	6e83      	ldr	r3, [r0, #104]	; 0x68
 80032b6:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 80032ba:	f023 030f 	bic.w	r3, r3, #15
 80032be:	6683      	str	r3, [r0, #104]	; 0x68
  ADCx->OFR3 |= (uint32_t)Offset;
 80032c0:	6e83      	ldr	r3, [r0, #104]	; 0x68
 80032c2:	431a      	orrs	r2, r3
 80032c4:	6682      	str	r2, [r0, #104]	; 0x68
 80032c6:	4770      	bx	lr

080032c8 <ADC_SetChannelOffset4>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_OFFSET(Offset));
    
  /* Select the Channel */
  ADCx->OFR4 &= ~ (uint32_t) ADC_OFR4_OFFSET4_CH;
 80032c8:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 80032ca:	f023 43f8 	bic.w	r3, r3, #2080374784	; 0x7c000000
 80032ce:	66c3      	str	r3, [r0, #108]	; 0x6c
  ADCx->OFR4 |=	(uint32_t)((uint32_t)ADC_Channel << 26);
 80032d0:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 80032d2:	ea43 6181 	orr.w	r1, r3, r1, lsl #26
 80032d6:	66c1      	str	r1, [r0, #108]	; 0x6c

  /* Set the data offset */
  ADCx->OFR4 &= ~ (uint32_t) ADC_OFR4_OFFSET4;
 80032d8:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 80032da:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 80032de:	f023 030f 	bic.w	r3, r3, #15
 80032e2:	66c3      	str	r3, [r0, #108]	; 0x6c
  ADCx->OFR4 |= (uint32_t)Offset;
 80032e4:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 80032e6:	431a      	orrs	r2, r3
 80032e8:	66c2      	str	r2, [r0, #108]	; 0x6c
 80032ea:	4770      	bx	lr

080032ec <ADC_ChannelOffset1Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Set the OFFSET1_EN bit */
    ADCx->OFR1 |= ADC_OFR1_OFFSET1_EN;
 80032ec:	6e03      	ldr	r3, [r0, #96]	; 0x60
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80032ee:	b111      	cbz	r1, 80032f6 <ADC_ChannelOffset1Cmd+0xa>
  {
    /* Set the OFFSET1_EN bit */
    ADCx->OFR1 |= ADC_OFR1_OFFSET1_EN;
 80032f0:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80032f4:	e001      	b.n	80032fa <ADC_ChannelOffset1Cmd+0xe>
  }
  else
  {
    /* Reset the OFFSET1_EN bit */
    ADCx->OFR1 &= ~(ADC_OFR1_OFFSET1_EN);
 80032f6:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 80032fa:	6603      	str	r3, [r0, #96]	; 0x60
 80032fc:	4770      	bx	lr

080032fe <ADC_ChannelOffset2Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Set the OFFSET1_EN bit */
    ADCx->OFR2 |= ADC_OFR2_OFFSET2_EN;
 80032fe:	6e43      	ldr	r3, [r0, #100]	; 0x64
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8003300:	b111      	cbz	r1, 8003308 <ADC_ChannelOffset2Cmd+0xa>
  {
    /* Set the OFFSET1_EN bit */
    ADCx->OFR2 |= ADC_OFR2_OFFSET2_EN;
 8003302:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8003306:	e001      	b.n	800330c <ADC_ChannelOffset2Cmd+0xe>
  }
  else
  {
    /* Reset the OFFSET1_EN bit */
    ADCx->OFR2 &= ~(ADC_OFR2_OFFSET2_EN);
 8003308:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 800330c:	6643      	str	r3, [r0, #100]	; 0x64
 800330e:	4770      	bx	lr

08003310 <ADC_ChannelOffset3Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Set the OFFSET1_EN bit */
    ADCx->OFR3 |= ADC_OFR3_OFFSET3_EN;
 8003310:	6e83      	ldr	r3, [r0, #104]	; 0x68
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8003312:	b111      	cbz	r1, 800331a <ADC_ChannelOffset3Cmd+0xa>
  {
    /* Set the OFFSET1_EN bit */
    ADCx->OFR3 |= ADC_OFR3_OFFSET3_EN;
 8003314:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8003318:	e001      	b.n	800331e <ADC_ChannelOffset3Cmd+0xe>
  }
  else
  {
    /* Reset the OFFSET1_EN bit */
    ADCx->OFR3 &= ~(ADC_OFR3_OFFSET3_EN);
 800331a:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 800331e:	6683      	str	r3, [r0, #104]	; 0x68
 8003320:	4770      	bx	lr

08003322 <ADC_ChannelOffset4Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Set the OFFSET1_EN bit */
    ADCx->OFR4 |= ADC_OFR4_OFFSET4_EN;
 8003322:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8003324:	b111      	cbz	r1, 800332c <ADC_ChannelOffset4Cmd+0xa>
  {
    /* Set the OFFSET1_EN bit */
    ADCx->OFR4 |= ADC_OFR4_OFFSET4_EN;
 8003326:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800332a:	e001      	b.n	8003330 <ADC_ChannelOffset4Cmd+0xe>
  }
  else
  {
    /* Reset the OFFSET1_EN bit */
    ADCx->OFR4 &= ~(ADC_OFR4_OFFSET4_EN);
 800332c:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8003330:	66c3      	str	r3, [r0, #108]	; 0x6c
 8003332:	4770      	bx	lr

08003334 <ADC_DMACmd>:
  assert_param(IS_ADC_DMA_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected ADC DMA request */
    ADCx->CFGR |= ADC_CFGR_DMAEN;
 8003334:	68c3      	ldr	r3, [r0, #12]
void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_DMA_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8003336:	b111      	cbz	r1, 800333e <ADC_DMACmd+0xa>
  {
    /* Enable the selected ADC DMA request */
    ADCx->CFGR |= ADC_CFGR_DMAEN;
 8003338:	f043 0301 	orr.w	r3, r3, #1
 800333c:	e001      	b.n	8003342 <ADC_DMACmd+0xe>
  }
  else
  {
    /* Disable the selected ADC DMA request */
    ADCx->CFGR &= ~(uint32_t)ADC_CFGR_DMAEN;
 800333e:	f023 0301 	bic.w	r3, r3, #1
 8003342:	60c3      	str	r3, [r0, #12]
 8003344:	4770      	bx	lr

08003346 <ADC_DMAConfig>:
  /* Check the parameters */
  assert_param(IS_ADC_DMA_PERIPH(ADCx));
  assert_param(IS_ADC_DMA_MODE(ADC_DMAMode));

  /* Set or reset the DMACFG bit */
   ADCx->CFGR &= ~(uint32_t)ADC_CFGR_DMACFG;
 8003346:	68c3      	ldr	r3, [r0, #12]
 8003348:	f023 0302 	bic.w	r3, r3, #2
 800334c:	60c3      	str	r3, [r0, #12]
   ADCx->CFGR |= ADC_DMAMode;
 800334e:	68c3      	ldr	r3, [r0, #12]
 8003350:	4319      	orrs	r1, r3
 8003352:	60c1      	str	r1, [r0, #12]
 8003354:	4770      	bx	lr

08003356 <ADC_InjectedChannelSampleTimeConfig>:
  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));

  /* Channel sampling configuration */
  /* if ADC_InjectedChannel_10 ... ADC_InjectedChannel_18 is selected */
  if (ADC_InjectedChannel > ADC_InjectedChannel_9)
 8003356:	2909      	cmp	r1, #9
  *     @arg ADC_SampleTime_181Cycles5: Sample time equal to 181.5 cycles	
  *     @arg ADC_SampleTime_601Cycles5: Sample time equal to 601.5 cycles	
  * @retval None
  */
void ADC_InjectedChannelSampleTimeConfig(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel, uint8_t ADC_SampleTime)
{
 8003358:	b510      	push	{r4, lr}
  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));

  /* Channel sampling configuration */
  /* if ADC_InjectedChannel_10 ... ADC_InjectedChannel_18 is selected */
  if (ADC_InjectedChannel > ADC_InjectedChannel_9)
 800335a:	d90e      	bls.n	800337a <ADC_InjectedChannelSampleTimeConfig+0x24>
  {
    /* Calculate the mask to clear */
    tmpreg1 = ADC_SMPR2_SMP10 << (3 * (ADC_InjectedChannel - 10));
 800335c:	390a      	subs	r1, #10
    /* Clear the old channel sample time */
	ADCx->SMPR2 &= ~tmpreg1;
 800335e:	6984      	ldr	r4, [r0, #24]
  /* Channel sampling configuration */
  /* if ADC_InjectedChannel_10 ... ADC_InjectedChannel_18 is selected */
  if (ADC_InjectedChannel > ADC_InjectedChannel_9)
  {
    /* Calculate the mask to clear */
    tmpreg1 = ADC_SMPR2_SMP10 << (3 * (ADC_InjectedChannel - 10));
 8003360:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 8003364:	2307      	movs	r3, #7
 8003366:	408b      	lsls	r3, r1
    /* Clear the old channel sample time */
	ADCx->SMPR2 &= ~tmpreg1;
 8003368:	ea24 0303 	bic.w	r3, r4, r3
 800336c:	6183      	str	r3, [r0, #24]
    /* Calculate the mask to set */
	ADCx->SMPR2 |= (uint32_t)ADC_SampleTime << (3 * (ADC_InjectedChannel - 10));
 800336e:	6983      	ldr	r3, [r0, #24]
 8003370:	fa02 f101 	lsl.w	r1, r2, r1
 8003374:	4319      	orrs	r1, r3
 8003376:	6181      	str	r1, [r0, #24]
 8003378:	bd10      	pop	{r4, pc}

  }
  else /* ADC_InjectedChannel include in ADC_InjectedChannel_[0..9] */
  {
    /* Calculate the mask to clear */
    tmpreg1 = ADC_SMPR1_SMP1 << (3 * (ADC_InjectedChannel - 1));
 800337a:	3901      	subs	r1, #1
    /* Clear the old channel sample time */
	ADCx->SMPR1 &= ~tmpreg1;
 800337c:	6944      	ldr	r4, [r0, #20]

  }
  else /* ADC_InjectedChannel include in ADC_InjectedChannel_[0..9] */
  {
    /* Calculate the mask to clear */
    tmpreg1 = ADC_SMPR1_SMP1 << (3 * (ADC_InjectedChannel - 1));
 800337e:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 8003382:	2338      	movs	r3, #56	; 0x38
 8003384:	408b      	lsls	r3, r1
    /* Clear the old channel sample time */
	ADCx->SMPR1 &= ~tmpreg1;
 8003386:	ea24 0303 	bic.w	r3, r4, r3
 800338a:	6143      	str	r3, [r0, #20]
    /* Calculate the mask to set */
	ADCx->SMPR1 |= (uint32_t)ADC_SampleTime << (3 * (ADC_InjectedChannel));
 800338c:	6943      	ldr	r3, [r0, #20]
 800338e:	3103      	adds	r1, #3
 8003390:	408a      	lsls	r2, r1
 8003392:	431a      	orrs	r2, r3
 8003394:	6142      	str	r2, [r0, #20]
 8003396:	bd10      	pop	{r4, pc}

08003398 <ADC_StartInjectedConversion>:
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  /* Enable the selected ADC conversion for injected group on external event and start the selected
     ADC injected conversion */
  ADCx->CR |= ADC_CR_JADSTART;
 8003398:	6883      	ldr	r3, [r0, #8]
 800339a:	f043 0308 	orr.w	r3, r3, #8
 800339e:	6083      	str	r3, [r0, #8]
 80033a0:	4770      	bx	lr

080033a2 <ADC_StopInjectedConversion>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  /* Set the JADSTP bit */
   ADCx->CR |= ADC_CR_JADSTP;
 80033a2:	6883      	ldr	r3, [r0, #8]
 80033a4:	f043 0320 	orr.w	r3, r3, #32
 80033a8:	6083      	str	r3, [r0, #8]
 80033aa:	4770      	bx	lr

080033ac <ADC_GetStartInjectedConversionStatus>:
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  /* Check the status of JADSTART bit */
  if ((ADCx->CR & ADC_CR_JADSTART) != (uint32_t)RESET)
 80033ac:	6880      	ldr	r0, [r0, #8]
    /* JADSTART bit is reset */
    bitstatus = RESET;
  }
  /* Return the JADSTART bit status */
  return  bitstatus;
}
 80033ae:	f3c0 00c0 	ubfx	r0, r0, #3, #1
 80033b2:	4770      	bx	lr

080033b4 <ADC_AutoInjectedConvCmd>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected ADC automatic injected group conversion */
    ADCx->CFGR |= ADC_CFGR_JAUTO;
 80033b4:	68c3      	ldr	r3, [r0, #12]
void ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80033b6:	b111      	cbz	r1, 80033be <ADC_AutoInjectedConvCmd+0xa>
  {
    /* Enable the selected ADC automatic injected group conversion */
    ADCx->CFGR |= ADC_CFGR_JAUTO;
 80033b8:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 80033bc:	e001      	b.n	80033c2 <ADC_AutoInjectedConvCmd+0xe>
  }
  else
  {
    /* Disable the selected ADC automatic injected group conversion */
    ADCx->CFGR &= ~ADC_CFGR_JAUTO;
 80033be:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
 80033c2:	60c3      	str	r3, [r0, #12]
 80033c4:	4770      	bx	lr

080033c6 <ADC_InjectedDiscModeCmd>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected ADC injected discontinuous mode */
    ADCx->CFGR |= ADC_CFGR_JDISCEN;
 80033c6:	68c3      	ldr	r3, [r0, #12]
void ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80033c8:	b111      	cbz	r1, 80033d0 <ADC_InjectedDiscModeCmd+0xa>
  {
    /* Enable the selected ADC injected discontinuous mode */
    ADCx->CFGR |= ADC_CFGR_JDISCEN;
 80033ca:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 80033ce:	e001      	b.n	80033d4 <ADC_InjectedDiscModeCmd+0xe>
  }
  else
  {
    /* Disable the selected ADC injected discontinuous mode */
    ADCx->CFGR &= ~ADC_CFGR_JDISCEN;
 80033d0:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
 80033d4:	60c3      	str	r3, [r0, #12]
 80033d6:	4770      	bx	lr

080033d8 <ADC_GetInjectedConversionValue>:
  *     @arg ADC_InjectedSequence_3: Injected Sequence3 selected
  *     @arg ADC_InjectedSequence_4: Injected Sequence4 selected
  * @retval The Data conversion value.
  */
uint16_t ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, uint8_t ADC_InjectedSequence)
{
 80033d8:	b082      	sub	sp, #8
  __IO uint32_t tmp = 0;
 80033da:	2300      	movs	r3, #0
 80033dc:	9301      	str	r3, [sp, #4]
  
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_INJECTED_SEQUENCE(ADC_InjectedSequence));

  tmp = (uint32_t)ADCx;
 80033de:	9001      	str	r0, [sp, #4]
  tmp += ((ADC_InjectedSequence - 1 )<< 2) + JDR_Offset;
 80033e0:	9b01      	ldr	r3, [sp, #4]
 80033e2:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 80033e6:	f101 037c 	add.w	r3, r1, #124	; 0x7c
 80033ea:	9301      	str	r3, [sp, #4]
  
  /* Returns the selected injected channel conversion data value */
  return (uint16_t) (*(__IO uint32_t*)  tmp);   
 80033ec:	9b01      	ldr	r3, [sp, #4]
 80033ee:	6818      	ldr	r0, [r3, #0]
}
 80033f0:	b280      	uxth	r0, r0
 80033f2:	b002      	add	sp, #8
 80033f4:	4770      	bx	lr

080033f6 <ADC_ITConfig>:
  assert_param(IS_ADC_IT(ADC_IT));

  if (NewState != DISABLE)
  {
    /* Enable the selected ADC interrupts */
    ADCx->IER |= ADC_IT;
 80033f6:	6843      	ldr	r3, [r0, #4]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_ADC_IT(ADC_IT));

  if (NewState != DISABLE)
 80033f8:	b10a      	cbz	r2, 80033fe <ADC_ITConfig+0x8>
  {
    /* Enable the selected ADC interrupts */
    ADCx->IER |= ADC_IT;
 80033fa:	4319      	orrs	r1, r3
 80033fc:	e001      	b.n	8003402 <ADC_ITConfig+0xc>
  }
  else
  {
    /* Disable the selected ADC interrupts */
    ADCx->IER &= (~(uint32_t)ADC_IT);
 80033fe:	ea23 0101 	bic.w	r1, r3, r1
 8003402:	6041      	str	r1, [r0, #4]
 8003404:	4770      	bx	lr

08003406 <ADC_GetFlagStatus>:
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_GET_FLAG(ADC_FLAG));

  /* Check the status of the specified ADC flag */
  if ((ADCx->ISR & ADC_FLAG) != (uint32_t)RESET)
 8003406:	6803      	ldr	r3, [r0, #0]
 8003408:	4219      	tst	r1, r3
    /* ADC_FLAG is reset */
    bitstatus = RESET;
  }
  /* Return the ADC_FLAG status */
  return  bitstatus;
}
 800340a:	bf0c      	ite	eq
 800340c:	2000      	moveq	r0, #0
 800340e:	2001      	movne	r0, #1
 8003410:	4770      	bx	lr

08003412 <ADC_ClearFlag>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));
  /* Clear the selected ADC flags */
  ADCx->ISR = (uint32_t)ADC_FLAG;
 8003412:	6001      	str	r1, [r0, #0]
 8003414:	4770      	bx	lr

08003416 <ADC_GetCommonFlagStatus>:

  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_GET_COMMONFLAG(ADC_FLAG));

  if((ADCx == ADC1) || (ADCx == ADC2))
 8003416:	f1b0 4fa0 	cmp.w	r0, #1342177280	; 0x50000000
 800341a:	d002      	beq.n	8003422 <ADC_GetCommonFlagStatus+0xc>
 800341c:	4b05      	ldr	r3, [pc, #20]	; (8003434 <ADC_GetCommonFlagStatus+0x1e>)
 800341e:	4298      	cmp	r0, r3
 8003420:	d101      	bne.n	8003426 <ADC_GetCommonFlagStatus+0x10>
  {
    tmpreg1 = ADC1_2->CSR;
 8003422:	4b05      	ldr	r3, [pc, #20]	; (8003438 <ADC_GetCommonFlagStatus+0x22>)
 8003424:	e000      	b.n	8003428 <ADC_GetCommonFlagStatus+0x12>
  }
  else
  {
    tmpreg1 = ADC3_4->CSR;
 8003426:	4b05      	ldr	r3, [pc, #20]	; (800343c <ADC_GetCommonFlagStatus+0x26>)
 8003428:	681b      	ldr	r3, [r3, #0]
  }  
  /* Check the status of the specified ADC flag */
  if ((tmpreg1 & ADC_FLAG) != (uint32_t)RESET)
 800342a:	420b      	tst	r3, r1
    /* ADC_FLAG is reset */
    bitstatus = RESET;
  }
  /* Return the ADC_FLAG status */
  return  bitstatus;
}
 800342c:	bf0c      	ite	eq
 800342e:	2000      	moveq	r0, #0
 8003430:	2001      	movne	r0, #1
 8003432:	4770      	bx	lr
 8003434:	50000100 	.word	0x50000100
 8003438:	50000300 	.word	0x50000300
 800343c:	50000700 	.word	0x50000700

08003440 <ADC_ClearCommonFlag>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CLEAR_COMMONFLAG(ADC_FLAG));

  if((ADCx == ADC1) || (ADCx == ADC2))
 8003440:	f1b0 4fa0 	cmp.w	r0, #1342177280	; 0x50000000
 8003444:	d002      	beq.n	800344c <ADC_ClearCommonFlag+0xc>
 8003446:	4b05      	ldr	r3, [pc, #20]	; (800345c <ADC_ClearCommonFlag+0x1c>)
 8003448:	4298      	cmp	r0, r3
 800344a:	d101      	bne.n	8003450 <ADC_ClearCommonFlag+0x10>
  {
    /* Clear the selected ADC flags */
    ADC1_2->CSR |= (uint32_t)ADC_FLAG;
 800344c:	4b04      	ldr	r3, [pc, #16]	; (8003460 <ADC_ClearCommonFlag+0x20>)
 800344e:	e000      	b.n	8003452 <ADC_ClearCommonFlag+0x12>
  }
  else
  {
    /* Clear the selected ADC flags */
    ADC3_4->CSR |= (uint32_t)ADC_FLAG;
 8003450:	4b04      	ldr	r3, [pc, #16]	; (8003464 <ADC_ClearCommonFlag+0x24>)
 8003452:	681a      	ldr	r2, [r3, #0]
 8003454:	4311      	orrs	r1, r2
 8003456:	6019      	str	r1, [r3, #0]
 8003458:	4770      	bx	lr
 800345a:	bf00      	nop
 800345c:	50000100 	.word	0x50000100
 8003460:	50000300 	.word	0x50000300
 8003464:	50000700 	.word	0x50000700

08003468 <ADC_GetITStatus>:
  uint16_t itstatus = 0x0, itenable = 0x0;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_GET_IT(ADC_IT));
   
  itstatus = ADCx->ISR & ADC_IT;
 8003468:	6803      	ldr	r3, [r0, #0]
  
  itenable = ADCx->IER & ADC_IT;
 800346a:	6842      	ldr	r2, [r0, #4]
  uint16_t itstatus = 0x0, itenable = 0x0;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_GET_IT(ADC_IT));
   
  itstatus = ADCx->ISR & ADC_IT;
 800346c:	b289      	uxth	r1, r1
  
  itenable = ADCx->IER & ADC_IT;
  if ((itstatus != (uint32_t)RESET) && (itenable != (uint32_t)RESET))
 800346e:	ea11 0003 	ands.w	r0, r1, r3
 8003472:	d003      	beq.n	800347c <ADC_GetITStatus+0x14>
 8003474:	4211      	tst	r1, r2
  {
    bitstatus = SET;
 8003476:	bf0c      	ite	eq
 8003478:	2000      	moveq	r0, #0
 800347a:	2001      	movne	r0, #1
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 800347c:	4770      	bx	lr

0800347e <ADC_ClearITPendingBit>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_IT(ADC_IT));
  /* Clear the selected ADC interrupt pending bit */
  ADCx->ISR |= (uint32_t)ADC_IT;
 800347e:	6803      	ldr	r3, [r0, #0]
 8003480:	4319      	orrs	r1, r3
 8003482:	6001      	str	r1, [r0, #0]
 8003484:	4770      	bx	lr
 8003486:	bf00      	nop

08003488 <DMA_DeInit>:
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));

  /* Disable the selected DMAy Channelx */
  DMAy_Channelx->CCR &= (uint16_t)(~DMA_CCR_EN);
 8003488:	6802      	ldr	r2, [r0, #0]
 800348a:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 800348e:	4013      	ands	r3, r2
 8003490:	6003      	str	r3, [r0, #0]

  /* Reset DMAy Channelx control register */
  DMAy_Channelx->CCR  = 0;
 8003492:	2300      	movs	r3, #0
 8003494:	6003      	str	r3, [r0, #0]

  /* Reset DMAy Channelx remaining bytes register */
  DMAy_Channelx->CNDTR = 0;
 8003496:	6043      	str	r3, [r0, #4]

  /* Reset DMAy Channelx peripheral address register */
  DMAy_Channelx->CPAR  = 0;
 8003498:	6083      	str	r3, [r0, #8]

  /* Reset DMAy Channelx memory address register */
  DMAy_Channelx->CMAR = 0;
 800349a:	60c3      	str	r3, [r0, #12]

  if (DMAy_Channelx == DMA1_Channel1)
 800349c:	4b2a      	ldr	r3, [pc, #168]	; (8003548 <DMA_DeInit+0xc0>)
 800349e:	4298      	cmp	r0, r3
 80034a0:	d022      	beq.n	80034e8 <DMA_DeInit+0x60>
  {
    /* Reset interrupt pending bits for DMA1 Channel1 */
    DMA1->IFCR |= DMA1_CHANNEL1_IT_MASK;
  }
  else if (DMAy_Channelx == DMA1_Channel2)
 80034a2:	4b2a      	ldr	r3, [pc, #168]	; (800354c <DMA_DeInit+0xc4>)
 80034a4:	4298      	cmp	r0, r3
 80034a6:	d029      	beq.n	80034fc <DMA_DeInit+0x74>
  {
    /* Reset interrupt pending bits for DMA1 Channel2 */
    DMA1->IFCR |= DMA1_CHANNEL2_IT_MASK;
  }
  else if (DMAy_Channelx == DMA1_Channel3)
 80034a8:	4b29      	ldr	r3, [pc, #164]	; (8003550 <DMA_DeInit+0xc8>)
 80034aa:	4298      	cmp	r0, r3
 80034ac:	d030      	beq.n	8003510 <DMA_DeInit+0x88>
  {
    /* Reset interrupt pending bits for DMA1 Channel3 */
    DMA1->IFCR |= DMA1_CHANNEL3_IT_MASK;
  }
  else if (DMAy_Channelx == DMA1_Channel4)
 80034ae:	4b29      	ldr	r3, [pc, #164]	; (8003554 <DMA_DeInit+0xcc>)
 80034b0:	4298      	cmp	r0, r3
 80034b2:	d037      	beq.n	8003524 <DMA_DeInit+0x9c>
  {
    /* Reset interrupt pending bits for DMA1 Channel4 */
    DMA1->IFCR |= DMA1_CHANNEL4_IT_MASK;
  }
  else if (DMAy_Channelx == DMA1_Channel5)
 80034b4:	4b28      	ldr	r3, [pc, #160]	; (8003558 <DMA_DeInit+0xd0>)
 80034b6:	4298      	cmp	r0, r3
 80034b8:	d03e      	beq.n	8003538 <DMA_DeInit+0xb0>
  {
    /* Reset interrupt pending bits for DMA1 Channel5 */
    DMA1->IFCR |= DMA1_CHANNEL5_IT_MASK;
  }
  else if (DMAy_Channelx == DMA1_Channel6)
 80034ba:	4b28      	ldr	r3, [pc, #160]	; (800355c <DMA_DeInit+0xd4>)
 80034bc:	4298      	cmp	r0, r3
 80034be:	d106      	bne.n	80034ce <DMA_DeInit+0x46>
  {
    /* Reset interrupt pending bits for DMA1 Channel6 */
    DMA1->IFCR |= DMA1_CHANNEL6_IT_MASK;
 80034c0:	f853 2c68 	ldr.w	r2, [r3, #-104]
 80034c4:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 80034c8:	f843 2c68 	str.w	r2, [r3, #-104]
 80034cc:	4770      	bx	lr
  }
  else if (DMAy_Channelx == DMA1_Channel7)
 80034ce:	4b24      	ldr	r3, [pc, #144]	; (8003560 <DMA_DeInit+0xd8>)
 80034d0:	4298      	cmp	r0, r3
 80034d2:	d106      	bne.n	80034e2 <DMA_DeInit+0x5a>
  {
    /* Reset interrupt pending bits for DMA1 Channel7 */
    DMA1->IFCR |= DMA1_CHANNEL7_IT_MASK;
 80034d4:	f853 2c7c 	ldr.w	r2, [r3, #-124]
 80034d8:	f042 6270 	orr.w	r2, r2, #251658240	; 0xf000000
 80034dc:	f843 2c7c 	str.w	r2, [r3, #-124]
 80034e0:	4770      	bx	lr
  }
  else if (DMAy_Channelx == DMA2_Channel1)
 80034e2:	4b20      	ldr	r3, [pc, #128]	; (8003564 <DMA_DeInit+0xdc>)
 80034e4:	4298      	cmp	r0, r3
 80034e6:	d106      	bne.n	80034f6 <DMA_DeInit+0x6e>
  {
    /* Reset interrupt pending bits for DMA2 Channel1 */
    DMA2->IFCR |= DMA2_CHANNEL1_IT_MASK;
 80034e8:	f853 2c04 	ldr.w	r2, [r3, #-4]
 80034ec:	f042 020f 	orr.w	r2, r2, #15
 80034f0:	f843 2c04 	str.w	r2, [r3, #-4]
 80034f4:	4770      	bx	lr
  }
  else if (DMAy_Channelx == DMA2_Channel2)
 80034f6:	4b1c      	ldr	r3, [pc, #112]	; (8003568 <DMA_DeInit+0xe0>)
 80034f8:	4298      	cmp	r0, r3
 80034fa:	d106      	bne.n	800350a <DMA_DeInit+0x82>
  {
    /* Reset interrupt pending bits for DMA2 Channel2 */
    DMA2->IFCR |= DMA2_CHANNEL2_IT_MASK;
 80034fc:	f853 2c18 	ldr.w	r2, [r3, #-24]
 8003500:	f042 02f0 	orr.w	r2, r2, #240	; 0xf0
 8003504:	f843 2c18 	str.w	r2, [r3, #-24]
 8003508:	4770      	bx	lr
  }
  else if (DMAy_Channelx == DMA2_Channel3)
 800350a:	4b18      	ldr	r3, [pc, #96]	; (800356c <DMA_DeInit+0xe4>)
 800350c:	4298      	cmp	r0, r3
 800350e:	d106      	bne.n	800351e <DMA_DeInit+0x96>
  {
    /* Reset interrupt pending bits for DMA2 Channel3 */
    DMA2->IFCR |= DMA2_CHANNEL3_IT_MASK;
 8003510:	f853 2c2c 	ldr.w	r2, [r3, #-44]
 8003514:	f442 6270 	orr.w	r2, r2, #3840	; 0xf00
 8003518:	f843 2c2c 	str.w	r2, [r3, #-44]
 800351c:	4770      	bx	lr
  }
  else if (DMAy_Channelx == DMA2_Channel4)
 800351e:	4b14      	ldr	r3, [pc, #80]	; (8003570 <DMA_DeInit+0xe8>)
 8003520:	4298      	cmp	r0, r3
 8003522:	d106      	bne.n	8003532 <DMA_DeInit+0xaa>
  {
    /* Reset interrupt pending bits for DMA2 Channel4 */
    DMA2->IFCR |= DMA2_CHANNEL4_IT_MASK;
 8003524:	f853 2c40 	ldr.w	r2, [r3, #-64]
 8003528:	f442 4270 	orr.w	r2, r2, #61440	; 0xf000
 800352c:	f843 2c40 	str.w	r2, [r3, #-64]
 8003530:	4770      	bx	lr
  }
  else
  { 
    if (DMAy_Channelx == DMA2_Channel5)
 8003532:	4b10      	ldr	r3, [pc, #64]	; (8003574 <DMA_DeInit+0xec>)
 8003534:	4298      	cmp	r0, r3
 8003536:	d105      	bne.n	8003544 <DMA_DeInit+0xbc>
    {
      /* Reset interrupt pending bits for DMA2 Channel5 */
      DMA2->IFCR |= DMA2_CHANNEL5_IT_MASK;
 8003538:	f853 2c54 	ldr.w	r2, [r3, #-84]
 800353c:	f442 2270 	orr.w	r2, r2, #983040	; 0xf0000
 8003540:	f843 2c54 	str.w	r2, [r3, #-84]
 8003544:	4770      	bx	lr
 8003546:	bf00      	nop
 8003548:	40020008 	.word	0x40020008
 800354c:	4002001c 	.word	0x4002001c
 8003550:	40020030 	.word	0x40020030
 8003554:	40020044 	.word	0x40020044
 8003558:	40020058 	.word	0x40020058
 800355c:	4002006c 	.word	0x4002006c
 8003560:	40020080 	.word	0x40020080
 8003564:	40020408 	.word	0x40020408
 8003568:	4002041c 	.word	0x4002041c
 800356c:	40020430 	.word	0x40020430
 8003570:	40020444 	.word	0x40020444
 8003574:	40020458 	.word	0x40020458

08003578 <DMA_Init>:
  /* Set MINC bit according to DMA_MemoryInc value */
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
 8003578:	688a      	ldr	r2, [r1, #8]
  assert_param(IS_DMA_PRIORITY(DMA_InitStruct->DMA_Priority));
  assert_param(IS_DMA_M2M_STATE(DMA_InitStruct->DMA_M2M));

/*--------------------------- DMAy Channelx CCR Configuration ----------------*/
  /* Get the DMAy_Channelx CCR value */
  tmpreg = DMAy_Channelx->CCR;
 800357a:	6803      	ldr	r3, [r0, #0]
  * @param  DMA_InitStruct: pointer to a DMA_InitTypeDef structure that contains
  *         the configuration information for the specified DMA Channel.
  * @retval None
  */
void DMA_Init(DMA_Channel_TypeDef* DMAy_Channelx, DMA_InitTypeDef* DMA_InitStruct)
{
 800357c:	b510      	push	{r4, lr}
  /* Set MINC bit according to DMA_MemoryInc value */
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
 800357e:	6a0c      	ldr	r4, [r1, #32]
 8003580:	4314      	orrs	r4, r2
 8003582:	690a      	ldr	r2, [r1, #16]
 8003584:	4314      	orrs	r4, r2
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 8003586:	694a      	ldr	r2, [r1, #20]
 8003588:	4314      	orrs	r4, r2
 800358a:	698a      	ldr	r2, [r1, #24]
 800358c:	4314      	orrs	r4, r2
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
 800358e:	69ca      	ldr	r2, [r1, #28]
 8003590:	4314      	orrs	r4, r2
 8003592:	6a4a      	ldr	r2, [r1, #36]	; 0x24
 8003594:	4314      	orrs	r4, r2
            DMA_InitStruct->DMA_Priority | DMA_InitStruct->DMA_M2M;
 8003596:	6a8a      	ldr	r2, [r1, #40]	; 0x28
/*--------------------------- DMAy Channelx CCR Configuration ----------------*/
  /* Get the DMAy_Channelx CCR value */
  tmpreg = DMAy_Channelx->CCR;

  /* Clear MEM2MEM, PL, MSIZE, PSIZE, MINC, PINC, CIRC and DIR bits */
  tmpreg &= CCR_CLEAR_MASK;
 8003598:	f423 43ff 	bic.w	r3, r3, #32640	; 0x7f80
 800359c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
            DMA_InitStruct->DMA_Priority | DMA_InitStruct->DMA_M2M;
 80035a0:	4322      	orrs	r2, r4
  /* Set MINC bit according to DMA_MemoryInc value */
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
 80035a2:	4313      	orrs	r3, r2
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
            DMA_InitStruct->DMA_Priority | DMA_InitStruct->DMA_M2M;

  /* Write to DMAy Channelx CCR */
  DMAy_Channelx->CCR = tmpreg;
 80035a4:	6003      	str	r3, [r0, #0]

/*--------------------------- DMAy Channelx CNDTR Configuration --------------*/
  /* Write to DMAy Channelx CNDTR */
  DMAy_Channelx->CNDTR = DMA_InitStruct->DMA_BufferSize;
 80035a6:	898b      	ldrh	r3, [r1, #12]
 80035a8:	6043      	str	r3, [r0, #4]

/*--------------------------- DMAy Channelx CPAR Configuration ---------------*/
  /* Write to DMAy Channelx CPAR */
  DMAy_Channelx->CPAR = DMA_InitStruct->DMA_PeripheralBaseAddr;
 80035aa:	680b      	ldr	r3, [r1, #0]
 80035ac:	6083      	str	r3, [r0, #8]

/*--------------------------- DMAy Channelx CMAR Configuration ---------------*/
  /* Write to DMAy Channelx CMAR */
  DMAy_Channelx->CMAR = DMA_InitStruct->DMA_MemoryBaseAddr;
 80035ae:	684b      	ldr	r3, [r1, #4]
 80035b0:	60c3      	str	r3, [r0, #12]
 80035b2:	bd10      	pop	{r4, pc}

080035b4 <DMA_StructInit>:
  */
void DMA_StructInit(DMA_InitTypeDef* DMA_InitStruct)
{
/*-------------- Reset DMA init structure parameters values ------------------*/
  /* Initialize the DMA_PeripheralBaseAddr member */
  DMA_InitStruct->DMA_PeripheralBaseAddr = 0;
 80035b4:	2300      	movs	r3, #0
 80035b6:	6003      	str	r3, [r0, #0]
  /* Initialize the DMA_MemoryBaseAddr member */
  DMA_InitStruct->DMA_MemoryBaseAddr = 0;
 80035b8:	6043      	str	r3, [r0, #4]
  /* Initialize the DMA_DIR member */
  DMA_InitStruct->DMA_DIR = DMA_DIR_PeripheralSRC;
 80035ba:	6083      	str	r3, [r0, #8]
  /* Initialize the DMA_BufferSize member */
  DMA_InitStruct->DMA_BufferSize = 0;
 80035bc:	8183      	strh	r3, [r0, #12]
  /* Initialize the DMA_PeripheralInc member */
  DMA_InitStruct->DMA_PeripheralInc = DMA_PeripheralInc_Disable;
 80035be:	6103      	str	r3, [r0, #16]
  /* Initialize the DMA_MemoryInc member */
  DMA_InitStruct->DMA_MemoryInc = DMA_MemoryInc_Disable;
 80035c0:	6143      	str	r3, [r0, #20]
  /* Initialize the DMA_PeripheralDataSize member */
  DMA_InitStruct->DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
 80035c2:	6183      	str	r3, [r0, #24]
  /* Initialize the DMA_MemoryDataSize member */
  DMA_InitStruct->DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
 80035c4:	61c3      	str	r3, [r0, #28]
  /* Initialize the DMA_Mode member */
  DMA_InitStruct->DMA_Mode = DMA_Mode_Normal;
 80035c6:	6203      	str	r3, [r0, #32]
  /* Initialize the DMA_Priority member */
  DMA_InitStruct->DMA_Priority = DMA_Priority_Low;
 80035c8:	6243      	str	r3, [r0, #36]	; 0x24
  /* Initialize the DMA_M2M member */
  DMA_InitStruct->DMA_M2M = DMA_M2M_Disable;
 80035ca:	6283      	str	r3, [r0, #40]	; 0x28
 80035cc:	4770      	bx	lr

080035ce <DMA_Cmd>:
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80035ce:	b119      	cbz	r1, 80035d8 <DMA_Cmd+0xa>
  {
    /* Enable the selected DMAy Channelx */
    DMAy_Channelx->CCR |= DMA_CCR_EN;
 80035d0:	6803      	ldr	r3, [r0, #0]
 80035d2:	f043 0301 	orr.w	r3, r3, #1
 80035d6:	e003      	b.n	80035e0 <DMA_Cmd+0x12>
  }
  else
  {
    /* Disable the selected DMAy Channelx */
    DMAy_Channelx->CCR &= (uint16_t)(~DMA_CCR_EN);
 80035d8:	6802      	ldr	r2, [r0, #0]
 80035da:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 80035de:	4013      	ands	r3, r2
 80035e0:	6003      	str	r3, [r0, #0]
 80035e2:	4770      	bx	lr

080035e4 <DMA_SetCurrDataCounter>:
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));

/*--------------------------- DMAy Channelx CNDTR Configuration --------------*/
  /* Write to DMAy Channelx CNDTR */
  DMAy_Channelx->CNDTR = DataNumber;
 80035e4:	6041      	str	r1, [r0, #4]
 80035e6:	4770      	bx	lr

080035e8 <DMA_GetCurrDataCounter>:
uint16_t DMA_GetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx)
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
  /* Return the number of remaining data units for DMAy Channelx */
  return ((uint16_t)(DMAy_Channelx->CNDTR));
 80035e8:	6840      	ldr	r0, [r0, #4]
}
 80035ea:	b280      	uxth	r0, r0
 80035ec:	4770      	bx	lr

080035ee <DMA_ITConfig>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the selected DMA interrupts */
    DMAy_Channelx->CCR |= DMA_IT;
 80035ee:	6803      	ldr	r3, [r0, #0]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
  assert_param(IS_DMA_CONFIG_IT(DMA_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80035f0:	b10a      	cbz	r2, 80035f6 <DMA_ITConfig+0x8>
  {
    /* Enable the selected DMA interrupts */
    DMAy_Channelx->CCR |= DMA_IT;
 80035f2:	4319      	orrs	r1, r3
 80035f4:	e001      	b.n	80035fa <DMA_ITConfig+0xc>
  }
  else
  {
    /* Disable the selected DMA interrupts */
    DMAy_Channelx->CCR &= ~DMA_IT;
 80035f6:	ea23 0101 	bic.w	r1, r3, r1
 80035fa:	6001      	str	r1, [r0, #0]
 80035fc:	4770      	bx	lr

080035fe <DMA_GetFlagStatus>:
  
  /* Check the parameters */
  assert_param(IS_DMA_GET_FLAG(DMAy_FLAG));

  /* Calculate the used DMAy */
  if ((DMAy_FLAG & FLAG_Mask) != (uint32_t)RESET)
 80035fe:	00c3      	lsls	r3, r0, #3
  {
    /* Get DMA2 ISR register value */
    tmpreg = DMA2->ISR ;
 8003600:	bf4c      	ite	mi
 8003602:	4b04      	ldrmi	r3, [pc, #16]	; (8003614 <DMA_GetFlagStatus+0x16>)
  }
  else
  {
    /* Get DMA1 ISR register value */
    tmpreg = DMA1->ISR ;
 8003604:	4b04      	ldrpl	r3, [pc, #16]	; (8003618 <DMA_GetFlagStatus+0x1a>)
 8003606:	681b      	ldr	r3, [r3, #0]
  }

  /* Check the status of the specified DMAy flag */
  if ((tmpreg & DMAy_FLAG) != (uint32_t)RESET)
 8003608:	4203      	tst	r3, r0
    bitstatus = RESET;
  }
  
  /* Return the DMAy_FLAG status */
  return  bitstatus;
}
 800360a:	bf0c      	ite	eq
 800360c:	2000      	moveq	r0, #0
 800360e:	2001      	movne	r0, #1
 8003610:	4770      	bx	lr
 8003612:	bf00      	nop
 8003614:	40020400 	.word	0x40020400
 8003618:	40020000 	.word	0x40020000

0800361c <DMA_ClearFlag>:
{
  /* Check the parameters */
  assert_param(IS_DMA_CLEAR_FLAG(DMAy_FLAG));

/* Calculate the used DMAy */
  if ((DMAy_FLAG & FLAG_Mask) != (uint32_t)RESET)
 800361c:	00c3      	lsls	r3, r0, #3
  {
    /* Clear the selected DMAy flags */
    DMA2->IFCR = DMAy_FLAG;
 800361e:	bf4c      	ite	mi
 8003620:	4b01      	ldrmi	r3, [pc, #4]	; (8003628 <DMA_ClearFlag+0xc>)
  }
  else
  {
    /* Clear the selected DMAy flags */
    DMA1->IFCR = DMAy_FLAG;
 8003622:	4b02      	ldrpl	r3, [pc, #8]	; (800362c <DMA_ClearFlag+0x10>)
 8003624:	6058      	str	r0, [r3, #4]
 8003626:	4770      	bx	lr
 8003628:	40020400 	.word	0x40020400
 800362c:	40020000 	.word	0x40020000

08003630 <DMA_GetITStatus>:

  /* Check the parameters */
  assert_param(IS_DMA_GET_IT(DMAy_IT));

  /* Calculate the used DMA */
  if ((DMAy_IT & FLAG_Mask) != (uint32_t)RESET)
 8003630:	00c3      	lsls	r3, r0, #3
  {
    /* Get DMA2 ISR register value */
    tmpreg = DMA2->ISR;
 8003632:	bf4c      	ite	mi
 8003634:	4b03      	ldrmi	r3, [pc, #12]	; (8003644 <DMA_GetITStatus+0x14>)
  }
  else
  {
    /* Get DMA1 ISR register value */
    tmpreg = DMA1->ISR;
 8003636:	4b04      	ldrpl	r3, [pc, #16]	; (8003648 <DMA_GetITStatus+0x18>)
 8003638:	681b      	ldr	r3, [r3, #0]
  }

  /* Check the status of the specified DMAy interrupt */
  if ((tmpreg & DMAy_IT) != (uint32_t)RESET)
 800363a:	4203      	tst	r3, r0
    /* DMAy_IT is reset */
    bitstatus = RESET;
  }
  /* Return the DMAy_IT status */
  return  bitstatus;
}
 800363c:	bf0c      	ite	eq
 800363e:	2000      	moveq	r0, #0
 8003640:	2001      	movne	r0, #1
 8003642:	4770      	bx	lr
 8003644:	40020400 	.word	0x40020400
 8003648:	40020000 	.word	0x40020000

0800364c <DMA_ClearITPendingBit>:
{
  /* Check the parameters */
  assert_param(IS_DMA_CLEAR_IT(DMAy_IT));
  
  /* Calculate the used DMAy */
  if ((DMAy_IT & FLAG_Mask) != (uint32_t)RESET)
 800364c:	00c3      	lsls	r3, r0, #3
  {
    /* Clear the selected DMAy interrupt pending bits */
    DMA2->IFCR = DMAy_IT;
 800364e:	bf4c      	ite	mi
 8003650:	4b01      	ldrmi	r3, [pc, #4]	; (8003658 <DMA_ClearITPendingBit+0xc>)
  }
  else
  {
    /* Clear the selected DMAy interrupt pending bits */
    DMA1->IFCR = DMAy_IT;
 8003652:	4b02      	ldrpl	r3, [pc, #8]	; (800365c <DMA_ClearITPendingBit+0x10>)
 8003654:	6058      	str	r0, [r3, #4]
 8003656:	4770      	bx	lr
 8003658:	40020400 	.word	0x40020400
 800365c:	40020000 	.word	0x40020000

08003660 <EXTI_DeInit>:
  * @param  None
  * @retval None
  */
void EXTI_DeInit(void)
{
  EXTI->IMR    = 0x1F800000;
 8003660:	4b0a      	ldr	r3, [pc, #40]	; (800368c <EXTI_DeInit+0x2c>)
 8003662:	f04f 52fc 	mov.w	r2, #528482304	; 0x1f800000
 8003666:	601a      	str	r2, [r3, #0]
  EXTI->EMR    = 0x00000000;
  EXTI->RTSR   = 0x00000000;
  EXTI->FTSR   = 0x00000000;
  EXTI->SWIER  = 0x00000000;
  EXTI->PR     = 0xE07FFFFF;
 8003668:	f06f 51fc 	mvn.w	r1, #528482304	; 0x1f800000
  * @retval None
  */
void EXTI_DeInit(void)
{
  EXTI->IMR    = 0x1F800000;
  EXTI->EMR    = 0x00000000;
 800366c:	2200      	movs	r2, #0
 800366e:	605a      	str	r2, [r3, #4]
  EXTI->RTSR   = 0x00000000;
 8003670:	609a      	str	r2, [r3, #8]
  EXTI->FTSR   = 0x00000000;
 8003672:	60da      	str	r2, [r3, #12]
  EXTI->SWIER  = 0x00000000;
 8003674:	611a      	str	r2, [r3, #16]
  EXTI->PR     = 0xE07FFFFF;
 8003676:	6159      	str	r1, [r3, #20]
  EXTI->IMR2   = 0x0000000C;
 8003678:	210c      	movs	r1, #12
 800367a:	6219      	str	r1, [r3, #32]
  EXTI->EMR2   = 0x00000000;
 800367c:	625a      	str	r2, [r3, #36]	; 0x24
  EXTI->RTSR2  = 0x00000000;
 800367e:	629a      	str	r2, [r3, #40]	; 0x28
  EXTI->FTSR2  = 0x00000000;
 8003680:	62da      	str	r2, [r3, #44]	; 0x2c
  EXTI->SWIER2 = 0x00000000;
 8003682:	631a      	str	r2, [r3, #48]	; 0x30
  EXTI->PR2    = 0x00000003;
 8003684:	2203      	movs	r2, #3
 8003686:	635a      	str	r2, [r3, #52]	; 0x34
 8003688:	4770      	bx	lr
 800368a:	bf00      	nop
 800368c:	40010400 	.word	0x40010400

08003690 <EXTI_Init>:
  assert_param(IS_EXTI_LINE_ALL(EXTI_InitStruct->EXTI_Line));
  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct->EXTI_LineCmd));

  tmp = (uint32_t)EXTI_BASE;
      
  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
 8003690:	7983      	ldrb	r3, [r0, #6]
 8003692:	6802      	ldr	r2, [r0, #0]
  * @retval None
  */
  

void EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct)
{
 8003694:	b570      	push	{r4, r5, r6, lr}
 8003696:	7904      	ldrb	r4, [r0, #4]
  assert_param(IS_EXTI_LINE_ALL(EXTI_InitStruct->EXTI_Line));
  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct->EXTI_LineCmd));

  tmp = (uint32_t)EXTI_BASE;
      
  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
 8003698:	2b00      	cmp	r3, #0
 800369a:	d064      	beq.n	8003766 <EXTI_Init+0xd6>
  {
    /* Clear EXTI line configuration */   
    *(__IO uint32_t *) (((uint32_t) &(EXTI->IMR)) + ((EXTI_InitStruct->EXTI_Line) >> 5 ) * 0x20) &= ~(uint32_t)(1 << (EXTI_InitStruct->EXTI_Line & 0x1F));   
 800369c:	f022 011f 	bic.w	r1, r2, #31
 80036a0:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 80036a4:	f501 3182 	add.w	r1, r1, #66560	; 0x10400
 80036a8:	2301      	movs	r3, #1
 80036aa:	680d      	ldr	r5, [r1, #0]
 80036ac:	f002 021f 	and.w	r2, r2, #31
 80036b0:	fa03 f202 	lsl.w	r2, r3, r2
 80036b4:	ea25 0202 	bic.w	r2, r5, r2
 80036b8:	600a      	str	r2, [r1, #0]
    *(__IO uint32_t *) (((uint32_t) &(EXTI->EMR)) + ((EXTI_InitStruct->EXTI_Line) >> 5 ) * 0x20) &= ~(uint32_t)(1 << (EXTI_InitStruct->EXTI_Line & 0x1F));
 80036ba:	6805      	ldr	r5, [r0, #0]
 80036bc:	4a32      	ldr	r2, [pc, #200]	; (8003788 <EXTI_Init+0xf8>)
 80036be:	f025 011f 	bic.w	r1, r5, #31
 80036c2:	f005 051f 	and.w	r5, r5, #31
 80036c6:	588e      	ldr	r6, [r1, r2]
 80036c8:	fa03 f505 	lsl.w	r5, r3, r5
 80036cc:	ea26 0505 	bic.w	r5, r6, r5
 80036d0:	508d      	str	r5, [r1, r2]
     
    tmp += EXTI_InitStruct->EXTI_Mode + (((EXTI_InitStruct->EXTI_Line) >> 5 ) * 0x20);
 80036d2:	6805      	ldr	r5, [r0, #0]
 80036d4:	f104 4280 	add.w	r2, r4, #1073741824	; 0x40000000
 80036d8:	f025 011f 	bic.w	r1, r5, #31
 80036dc:	f502 3282 	add.w	r2, r2, #66560	; 0x10400

    *(__IO uint32_t *) tmp |= (uint32_t)(1 << (EXTI_InitStruct->EXTI_Line & 0x1F));
 80036e0:	f005 051f 	and.w	r5, r5, #31
 80036e4:	5854      	ldr	r4, [r2, r1]
 80036e6:	fa03 f505 	lsl.w	r5, r3, r5
 80036ea:	4325      	orrs	r5, r4
 80036ec:	5055      	str	r5, [r2, r1]
    
    tmp = (uint32_t)EXTI_BASE;

    /* Clear Rising Falling edge configuration */
    *(__IO uint32_t *) (((uint32_t) &(EXTI->RTSR)) + ((EXTI_InitStruct->EXTI_Line) >> 5 ) * 0x20) &= ~(uint32_t)(1 << (EXTI_InitStruct->EXTI_Line & 0x1F));
 80036ee:	6801      	ldr	r1, [r0, #0]
 80036f0:	4d26      	ldr	r5, [pc, #152]	; (800378c <EXTI_Init+0xfc>)
 80036f2:	f021 021f 	bic.w	r2, r1, #31
 80036f6:	f001 011f 	and.w	r1, r1, #31
 80036fa:	5954      	ldr	r4, [r2, r5]
 80036fc:	fa03 f101 	lsl.w	r1, r3, r1
 8003700:	ea24 0101 	bic.w	r1, r4, r1
 8003704:	5151      	str	r1, [r2, r5]
    *(__IO uint32_t *) (((uint32_t) &(EXTI->FTSR)) + ((EXTI_InitStruct->EXTI_Line) >> 5 ) * 0x20) &= ~(uint32_t)(1 << (EXTI_InitStruct->EXTI_Line & 0x1F));
 8003706:	6801      	ldr	r1, [r0, #0]
 8003708:	4c21      	ldr	r4, [pc, #132]	; (8003790 <EXTI_Init+0x100>)
 800370a:	f021 021f 	bic.w	r2, r1, #31
 800370e:	f001 011f 	and.w	r1, r1, #31
 8003712:	5916      	ldr	r6, [r2, r4]
 8003714:	fa03 f101 	lsl.w	r1, r3, r1
 8003718:	ea26 0101 	bic.w	r1, r6, r1
 800371c:	5111      	str	r1, [r2, r4]
    
      /* Select the trigger for the selected interrupts */
    if (EXTI_InitStruct->EXTI_Trigger == EXTI_Trigger_Rising_Falling)
 800371e:	7942      	ldrb	r2, [r0, #5]
 8003720:	6801      	ldr	r1, [r0, #0]
 8003722:	2a10      	cmp	r2, #16
 8003724:	d112      	bne.n	800374c <EXTI_Init+0xbc>
    {
      /* Rising Falling edge */
    *(__IO uint32_t *) (((uint32_t) &(EXTI->RTSR)) + ((EXTI_InitStruct->EXTI_Line) >> 5 ) * 0x20) |= (uint32_t)(1 << (EXTI_InitStruct->EXTI_Line & 0x1F));
 8003726:	f021 021f 	bic.w	r2, r1, #31
 800372a:	f001 011f 	and.w	r1, r1, #31
 800372e:	5956      	ldr	r6, [r2, r5]
 8003730:	fa03 f101 	lsl.w	r1, r3, r1
 8003734:	4331      	orrs	r1, r6
 8003736:	5151      	str	r1, [r2, r5]
    *(__IO uint32_t *) (((uint32_t) &(EXTI->FTSR)) + ((EXTI_InitStruct->EXTI_Line) >> 5 ) * 0x20) |= (uint32_t)(1 << (EXTI_InitStruct->EXTI_Line & 0x1F));      
 8003738:	6801      	ldr	r1, [r0, #0]
 800373a:	f021 021f 	bic.w	r2, r1, #31
 800373e:	f001 011f 	and.w	r1, r1, #31
 8003742:	5910      	ldr	r0, [r2, r4]
 8003744:	408b      	lsls	r3, r1
 8003746:	4303      	orrs	r3, r0
 8003748:	5113      	str	r3, [r2, r4]
 800374a:	bd70      	pop	{r4, r5, r6, pc}
    }
    else
    {
      tmp += EXTI_InitStruct->EXTI_Trigger + (((EXTI_InitStruct->EXTI_Line) >> 5 ) * 0x20);
 800374c:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
 8003750:	f021 001f 	bic.w	r0, r1, #31
 8003754:	f502 3282 	add.w	r2, r2, #66560	; 0x10400

      *(__IO uint32_t *) tmp |= (uint32_t)(1 << (EXTI_InitStruct->EXTI_Line & 0x1F));
 8003758:	f001 011f 	and.w	r1, r1, #31
 800375c:	5814      	ldr	r4, [r2, r0]
 800375e:	408b      	lsls	r3, r1
 8003760:	4323      	orrs	r3, r4
 8003762:	5013      	str	r3, [r2, r0]
 8003764:	bd70      	pop	{r4, r5, r6, pc}
    }
  }
      
  else
  {
    tmp += EXTI_InitStruct->EXTI_Mode + (((EXTI_InitStruct->EXTI_Line) >> 5 ) * 0x20);
 8003766:	f104 4380 	add.w	r3, r4, #1073741824	; 0x40000000
 800376a:	f022 011f 	bic.w	r1, r2, #31
 800376e:	f503 3382 	add.w	r3, r3, #66560	; 0x10400

    /* Disable the selected external lines */
    *(__IO uint32_t *) tmp &= ~(uint32_t)(1 << (EXTI_InitStruct->EXTI_Line & 0x1F));
 8003772:	f002 021f 	and.w	r2, r2, #31
 8003776:	5858      	ldr	r0, [r3, r1]
 8003778:	2401      	movs	r4, #1
 800377a:	fa04 f202 	lsl.w	r2, r4, r2
 800377e:	ea20 0202 	bic.w	r2, r0, r2
 8003782:	505a      	str	r2, [r3, r1]
 8003784:	bd70      	pop	{r4, r5, r6, pc}
 8003786:	bf00      	nop
 8003788:	40010404 	.word	0x40010404
 800378c:	40010408 	.word	0x40010408
 8003790:	4001040c 	.word	0x4001040c

08003794 <EXTI_StructInit>:
  *         be initialized.
  * @retval None
  */
void EXTI_StructInit(EXTI_InitTypeDef* EXTI_InitStruct)
{
  EXTI_InitStruct->EXTI_Line = EXTI_LINENONE;
 8003794:	2300      	movs	r3, #0
  EXTI_InitStruct->EXTI_Mode = EXTI_Mode_Interrupt;
  EXTI_InitStruct->EXTI_Trigger = EXTI_Trigger_Rising_Falling;
 8003796:	2210      	movs	r2, #16
  *         be initialized.
  * @retval None
  */
void EXTI_StructInit(EXTI_InitTypeDef* EXTI_InitStruct)
{
  EXTI_InitStruct->EXTI_Line = EXTI_LINENONE;
 8003798:	6003      	str	r3, [r0, #0]
  EXTI_InitStruct->EXTI_Mode = EXTI_Mode_Interrupt;
 800379a:	7103      	strb	r3, [r0, #4]
  EXTI_InitStruct->EXTI_Trigger = EXTI_Trigger_Rising_Falling;
 800379c:	7142      	strb	r2, [r0, #5]
  EXTI_InitStruct->EXTI_LineCmd = DISABLE;
 800379e:	7183      	strb	r3, [r0, #6]
 80037a0:	4770      	bx	lr

080037a2 <EXTI_GenerateSWInterrupt>:
void EXTI_GenerateSWInterrupt(uint32_t EXTI_Line)
{
  /* Check the parameters */
  assert_param(IS_EXTI_LINE_EXT(EXTI_Line));

  *(__IO uint32_t *) (((uint32_t) &(EXTI->SWIER)) + ((EXTI_Line) >> 5 ) * 0x20) |= (uint32_t)(1 << (EXTI_Line & 0x1F));
 80037a2:	f020 021f 	bic.w	r2, r0, #31
  *         will be generated.
  *   This parameter can be any combination of EXTI_Linex where x can be (0..20).
  * @retval None
  */
void EXTI_GenerateSWInterrupt(uint32_t EXTI_Line)
{
 80037a6:	b510      	push	{r4, lr}
  /* Check the parameters */
  assert_param(IS_EXTI_LINE_EXT(EXTI_Line));

  *(__IO uint32_t *) (((uint32_t) &(EXTI->SWIER)) + ((EXTI_Line) >> 5 ) * 0x20) |= (uint32_t)(1 << (EXTI_Line & 0x1F));
 80037a8:	4b04      	ldr	r3, [pc, #16]	; (80037bc <EXTI_GenerateSWInterrupt+0x1a>)
 80037aa:	f000 001f 	and.w	r0, r0, #31
 80037ae:	58d1      	ldr	r1, [r2, r3]
 80037b0:	2401      	movs	r4, #1
 80037b2:	fa04 f000 	lsl.w	r0, r4, r0
 80037b6:	4308      	orrs	r0, r1
 80037b8:	50d0      	str	r0, [r2, r3]
 80037ba:	bd10      	pop	{r4, pc}
 80037bc:	40010410 	.word	0x40010410

080037c0 <EXTI_GetFlagStatus>:
  FlagStatus bitstatus = RESET;
  
  /* Check the parameters */
  assert_param(IS_GET_EXTI_LINE(EXTI_Line));
   
  if ((*(__IO uint32_t *) (((uint32_t) &(EXTI->PR)) + ((EXTI_Line) >> 5 ) * 0x20)& (uint32_t)(1 << (EXTI_Line & 0x1F))) != (uint32_t)RESET)
 80037c0:	f020 021f 	bic.w	r2, r0, #31
 80037c4:	4b05      	ldr	r3, [pc, #20]	; (80037dc <EXTI_GetFlagStatus+0x1c>)
 80037c6:	f000 001f 	and.w	r0, r0, #31
 80037ca:	58d3      	ldr	r3, [r2, r3]
 80037cc:	2201      	movs	r2, #1
 80037ce:	fa02 f000 	lsl.w	r0, r2, r0
 80037d2:	4203      	tst	r3, r0
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 80037d4:	bf0c      	ite	eq
 80037d6:	2000      	moveq	r0, #0
 80037d8:	2001      	movne	r0, #1
 80037da:	4770      	bx	lr
 80037dc:	40010414 	.word	0x40010414

080037e0 <EXTI_ClearFlag>:
void EXTI_ClearFlag(uint32_t EXTI_Line)
{
  /* Check the parameters */
  assert_param(IS_EXTI_LINE_EXT(EXTI_Line));

  *(__IO uint32_t *) (((uint32_t) &(EXTI->PR)) + ((EXTI_Line) >> 5 ) * 0x20) = (1 << (EXTI_Line & 0x1F));  
 80037e0:	f020 021f 	bic.w	r2, r0, #31
 80037e4:	2301      	movs	r3, #1
 80037e6:	f000 001f 	and.w	r0, r0, #31
 80037ea:	fa03 f000 	lsl.w	r0, r3, r0
 80037ee:	4b01      	ldr	r3, [pc, #4]	; (80037f4 <EXTI_ClearFlag+0x14>)
 80037f0:	50d0      	str	r0, [r2, r3]
 80037f2:	4770      	bx	lr
 80037f4:	40010414 	.word	0x40010414

080037f8 <EXTI_GetITStatus>:
  uint32_t enablestatus = 0;
  
  /* Check the parameters */
  assert_param(IS_GET_EXTI_LINE(EXTI_Line));
  
  enablestatus =  *(__IO uint32_t *) (((uint32_t) &(EXTI->IMR)) + ((EXTI_Line) >> 5 ) * 0x20) & (uint32_t)(1 << (EXTI_Line & 0x1F));
 80037f8:	f020 031f 	bic.w	r3, r0, #31
 80037fc:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8003800:	f503 3382 	add.w	r3, r3, #66560	; 0x10400
 8003804:	f000 001f 	and.w	r0, r0, #31
 8003808:	2201      	movs	r2, #1
 800380a:	4082      	lsls	r2, r0
 800380c:	6819      	ldr	r1, [r3, #0]
 
  if ( (((*(__IO uint32_t *) (((uint32_t) &(EXTI->PR)) + (((EXTI_Line) >> 5 ) * 0x20) )) & (uint32_t)(1 << (EXTI_Line & 0x1F))) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))
 800380e:	6958      	ldr	r0, [r3, #20]
 8003810:	4010      	ands	r0, r2
 8003812:	d003      	beq.n	800381c <EXTI_GetITStatus+0x24>
 8003814:	4211      	tst	r1, r2
  {
    bitstatus = SET;
 8003816:	bf0c      	ite	eq
 8003818:	2000      	moveq	r0, #0
 800381a:	2001      	movne	r0, #1
  {
    bitstatus = RESET;
  }
  return bitstatus;
  
}
 800381c:	4770      	bx	lr

0800381e <EXTI_ClearITPendingBit>:
void EXTI_ClearITPendingBit(uint32_t EXTI_Line)
{
  /* Check the parameters */
  assert_param(IS_EXTI_LINE_EXT(EXTI_Line));
  
  *(__IO uint32_t *) (((uint32_t) &(EXTI->PR)) + ((EXTI_Line) >> 5 ) * 0x20) = (1 << (EXTI_Line & 0x1F));
 800381e:	f020 021f 	bic.w	r2, r0, #31
 8003822:	2301      	movs	r3, #1
 8003824:	f000 001f 	and.w	r0, r0, #31
 8003828:	fa03 f000 	lsl.w	r0, r3, r0
 800382c:	4b01      	ldr	r3, [pc, #4]	; (8003834 <EXTI_ClearITPendingBit+0x16>)
 800382e:	50d0      	str	r0, [r2, r3]
 8003830:	4770      	bx	lr
 8003832:	bf00      	nop
 8003834:	40010414 	.word	0x40010414

08003838 <GPIO_DeInit>:
void GPIO_DeInit(GPIO_TypeDef* GPIOx)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  if(GPIOx == GPIOA)
 8003838:	f1b0 4f90 	cmp.w	r0, #1207959552	; 0x48000000
  *         values.
  * @param  GPIOx: where x can be (A, B, C, D, E or F) to select the GPIO peripheral.
  * @retval None
  */
void GPIO_DeInit(GPIO_TypeDef* GPIOx)
{
 800383c:	b508      	push	{r3, lr}
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  if(GPIOx == GPIOA)
 800383e:	d107      	bne.n	8003850 <GPIO_DeInit+0x18>
  {
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOA, ENABLE);
 8003840:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 8003844:	2101      	movs	r1, #1
 8003846:	f000 fd5d 	bl	8004304 <RCC_AHBPeriphResetCmd>
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOA, DISABLE);
 800384a:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 800384e:	e035      	b.n	80038bc <GPIO_DeInit+0x84>
  }
  else if(GPIOx == GPIOB)
 8003850:	4b1d      	ldr	r3, [pc, #116]	; (80038c8 <GPIO_DeInit+0x90>)
 8003852:	4298      	cmp	r0, r3
 8003854:	d107      	bne.n	8003866 <GPIO_DeInit+0x2e>
  {
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOB, ENABLE);
 8003856:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 800385a:	2101      	movs	r1, #1
 800385c:	f000 fd52 	bl	8004304 <RCC_AHBPeriphResetCmd>
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOB, DISABLE);
 8003860:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 8003864:	e02a      	b.n	80038bc <GPIO_DeInit+0x84>
  }
  else if(GPIOx == GPIOC)
 8003866:	4b19      	ldr	r3, [pc, #100]	; (80038cc <GPIO_DeInit+0x94>)
 8003868:	4298      	cmp	r0, r3
 800386a:	d107      	bne.n	800387c <GPIO_DeInit+0x44>
  {
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOC, ENABLE);
 800386c:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 8003870:	2101      	movs	r1, #1
 8003872:	f000 fd47 	bl	8004304 <RCC_AHBPeriphResetCmd>
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOC, DISABLE);
 8003876:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 800387a:	e01f      	b.n	80038bc <GPIO_DeInit+0x84>
  }
  else if(GPIOx == GPIOD)
 800387c:	4b14      	ldr	r3, [pc, #80]	; (80038d0 <GPIO_DeInit+0x98>)
 800387e:	4298      	cmp	r0, r3
 8003880:	d107      	bne.n	8003892 <GPIO_DeInit+0x5a>
  {
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOD, ENABLE);
 8003882:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 8003886:	2101      	movs	r1, #1
 8003888:	f000 fd3c 	bl	8004304 <RCC_AHBPeriphResetCmd>
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOD, DISABLE);
 800388c:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 8003890:	e014      	b.n	80038bc <GPIO_DeInit+0x84>
  }
  else if(GPIOx == GPIOE)
 8003892:	4b10      	ldr	r3, [pc, #64]	; (80038d4 <GPIO_DeInit+0x9c>)
 8003894:	4298      	cmp	r0, r3
 8003896:	d107      	bne.n	80038a8 <GPIO_DeInit+0x70>
  {
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOE, ENABLE);
 8003898:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 800389c:	2101      	movs	r1, #1
 800389e:	f000 fd31 	bl	8004304 <RCC_AHBPeriphResetCmd>
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOE, DISABLE);
 80038a2:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 80038a6:	e009      	b.n	80038bc <GPIO_DeInit+0x84>
  }
  else
  {
    if(GPIOx == GPIOF)
 80038a8:	4b0b      	ldr	r3, [pc, #44]	; (80038d8 <GPIO_DeInit+0xa0>)
 80038aa:	4298      	cmp	r0, r3
 80038ac:	d10b      	bne.n	80038c6 <GPIO_DeInit+0x8e>
    {
      RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOF, ENABLE);
 80038ae:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
 80038b2:	2101      	movs	r1, #1
 80038b4:	f000 fd26 	bl	8004304 <RCC_AHBPeriphResetCmd>
      RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOF, DISABLE);
 80038b8:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
 80038bc:	2100      	movs	r1, #0
    }
  }
}
 80038be:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  else
  {
    if(GPIOx == GPIOF)
    {
      RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOF, ENABLE);
      RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOF, DISABLE);
 80038c2:	f000 bd1f 	b.w	8004304 <RCC_AHBPeriphResetCmd>
 80038c6:	bd08      	pop	{r3, pc}
 80038c8:	48000400 	.word	0x48000400
 80038cc:	48000800 	.word	0x48000800
 80038d0:	48000c00 	.word	0x48000c00
 80038d4:	48001000 	.word	0x48001000
 80038d8:	48001400 	.word	0x48001400

080038dc <GPIO_Init>:
  *         GPIO_Pin_0->GPIO_Pin_2, GPIO_Pin_4, GPIO_Pin_6, GPIO_Pin_9 
  *                       and GPIO_Pin_10 for GPIOF.
  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
{ 
 80038dc:	b5f0      	push	{r4, r5, r6, r7, lr}
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
  {
    pos = ((uint32_t)0x01) << pinpos;

    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 80038de:	2300      	movs	r3, #0
 80038e0:	680e      	ldr	r6, [r1, #0]
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /*-------------------------- Configure the port pins -----------------------*/
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 80038e2:	461a      	mov	r2, r3
  {
    pos = ((uint32_t)0x01) << pinpos;
 80038e4:	2501      	movs	r5, #1
 80038e6:	4095      	lsls	r5, r2

    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 80038e8:	ea05 0406 	and.w	r4, r5, r6

    if (currentpin == pos)
 80038ec:	42ac      	cmp	r4, r5
 80038ee:	d131      	bne.n	8003954 <GPIO_Init+0x78>
    {
      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 80038f0:	790d      	ldrb	r5, [r1, #4]
 80038f2:	1e6f      	subs	r7, r5, #1
 80038f4:	b2ff      	uxtb	r7, r7
 80038f6:	2f01      	cmp	r7, #1
 80038f8:	d81a      	bhi.n	8003930 <GPIO_Init+0x54>
      {
        /* Check Speed mode parameters */
        assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));

        /* Speed mode configuration */
        GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
 80038fa:	6887      	ldr	r7, [r0, #8]
 80038fc:	f04f 0c03 	mov.w	ip, #3
 8003900:	fa0c fc03 	lsl.w	ip, ip, r3
 8003904:	ea27 070c 	bic.w	r7, r7, ip
 8003908:	6087      	str	r7, [r0, #8]
        GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
 800390a:	f891 c005 	ldrb.w	ip, [r1, #5]
 800390e:	6887      	ldr	r7, [r0, #8]
 8003910:	fa0c fc03 	lsl.w	ip, ip, r3
 8003914:	ea4c 0707 	orr.w	r7, ip, r7
 8003918:	6087      	str	r7, [r0, #8]

        /* Check Output mode parameters */
        assert_param(IS_GPIO_OTYPE(GPIO_InitStruct->GPIO_OType));

        /* Output mode configuration */
        GPIOx->OTYPER &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos));
 800391a:	8887      	ldrh	r7, [r0, #4]
 800391c:	b2bf      	uxth	r7, r7
 800391e:	ea27 0404 	bic.w	r4, r7, r4
 8003922:	8084      	strh	r4, [r0, #4]
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
 8003924:	798c      	ldrb	r4, [r1, #6]
 8003926:	8887      	ldrh	r7, [r0, #4]
 8003928:	4094      	lsls	r4, r2
 800392a:	433c      	orrs	r4, r7
 800392c:	b2a4      	uxth	r4, r4
 800392e:	8084      	strh	r4, [r0, #4]
      }
      
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 8003930:	2403      	movs	r4, #3
 8003932:	6807      	ldr	r7, [r0, #0]
 8003934:	409c      	lsls	r4, r3
 8003936:	43e4      	mvns	r4, r4
 8003938:	4027      	ands	r7, r4
 800393a:	6007      	str	r7, [r0, #0]

      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 800393c:	6807      	ldr	r7, [r0, #0]
 800393e:	409d      	lsls	r5, r3
 8003940:	433d      	orrs	r5, r7
 8003942:	6005      	str	r5, [r0, #0]

      /* Pull-up Pull down resistor configuration */
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
 8003944:	68c5      	ldr	r5, [r0, #12]
 8003946:	402c      	ands	r4, r5
 8003948:	60c4      	str	r4, [r0, #12]
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 800394a:	79cc      	ldrb	r4, [r1, #7]
 800394c:	68c5      	ldr	r5, [r0, #12]
 800394e:	409c      	lsls	r4, r3
 8003950:	432c      	orrs	r4, r5
 8003952:	60c4      	str	r4, [r0, #12]
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /*-------------------------- Configure the port pins -----------------------*/
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 8003954:	3201      	adds	r2, #1
 8003956:	2a10      	cmp	r2, #16
 8003958:	f103 0302 	add.w	r3, r3, #2
 800395c:	d1c2      	bne.n	80038e4 <GPIO_Init+0x8>
      /* Pull-up Pull down resistor configuration */
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
    }
  }
}
 800395e:	bdf0      	pop	{r4, r5, r6, r7, pc}

08003960 <GPIO_StructInit>:
  * @retval None
  */
void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
{
  /* Reset GPIO init structure parameters values */
  GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
 8003960:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8003964:	6003      	str	r3, [r0, #0]
  GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN;
  GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
 8003966:	2202      	movs	r2, #2
  */
void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
{
  /* Reset GPIO init structure parameters values */
  GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
  GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN;
 8003968:	2300      	movs	r3, #0
 800396a:	7103      	strb	r3, [r0, #4]
  GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
 800396c:	7142      	strb	r2, [r0, #5]
  GPIO_InitStruct->GPIO_OType = GPIO_OType_PP;
 800396e:	7183      	strb	r3, [r0, #6]
  GPIO_InitStruct->GPIO_PuPd = GPIO_PuPd_NOPULL;
 8003970:	71c3      	strb	r3, [r0, #7]
 8003972:	4770      	bx	lr

08003974 <GPIO_PinLockConfig>:
  
  /* Check the parameters */
  assert_param(IS_GPIO_LIST_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  
  tmp |= GPIO_Pin;
 8003974:	f441 3380 	orr.w	r3, r1, #65536	; 0x10000
  /* Set LCKK bit */
  GPIOx->LCKR = tmp;
 8003978:	61c3      	str	r3, [r0, #28]
  /* Reset LCKK bit */
  GPIOx->LCKR =  GPIO_Pin;
 800397a:	61c1      	str	r1, [r0, #28]
  /* Set LCKK bit */
  GPIOx->LCKR = tmp;
 800397c:	61c3      	str	r3, [r0, #28]
  /* Read LCKK bit */
  tmp = GPIOx->LCKR;
 800397e:	69c3      	ldr	r3, [r0, #28]
  /* Read LCKK bit */
  tmp = GPIOx->LCKR;
 8003980:	69c3      	ldr	r3, [r0, #28]
 8003982:	4770      	bx	lr

08003984 <GPIO_ReadInputDataBit>:
  
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)Bit_RESET)
 8003984:	8a03      	ldrh	r3, [r0, #16]
 8003986:	4219      	tst	r1, r3
  else
  {
    bitstatus = (uint8_t)Bit_RESET;
  }
  return bitstatus;
}
 8003988:	bf0c      	ite	eq
 800398a:	2000      	moveq	r0, #0
 800398c:	2001      	movne	r0, #1
 800398e:	4770      	bx	lr

08003990 <GPIO_ReadInputData>:
uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  return ((uint16_t)GPIOx->IDR);
 8003990:	8a00      	ldrh	r0, [r0, #16]
}
 8003992:	b280      	uxth	r0, r0
 8003994:	4770      	bx	lr

08003996 <GPIO_ReadOutputDataBit>:

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
  
  if ((GPIOx->ODR & GPIO_Pin) != (uint32_t)Bit_RESET)
 8003996:	8a83      	ldrh	r3, [r0, #20]
 8003998:	4219      	tst	r1, r3
  else
  {
    bitstatus = (uint8_t)Bit_RESET;
  }
  return bitstatus;
}
 800399a:	bf0c      	ite	eq
 800399c:	2000      	moveq	r0, #0
 800399e:	2001      	movne	r0, #1
 80039a0:	4770      	bx	lr

080039a2 <GPIO_ReadOutputData>:
uint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  
  return ((uint16_t)GPIOx->ODR);
 80039a2:	8a80      	ldrh	r0, [r0, #20]
}
 80039a4:	b280      	uxth	r0, r0
 80039a6:	4770      	bx	lr

080039a8 <GPIO_SetBits>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  
  GPIOx->BSRR = GPIO_Pin;
 80039a8:	6181      	str	r1, [r0, #24]
 80039aa:	4770      	bx	lr

080039ac <GPIO_ResetBits>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  
  GPIOx->BRR = GPIO_Pin;
 80039ac:	8501      	strh	r1, [r0, #40]	; 0x28
 80039ae:	4770      	bx	lr

080039b0 <GPIO_WriteBit>:
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_BIT_ACTION(BitVal));
  
  if (BitVal != Bit_RESET)
 80039b0:	b10a      	cbz	r2, 80039b6 <GPIO_WriteBit+0x6>
  {
    GPIOx->BSRR = GPIO_Pin;
 80039b2:	6181      	str	r1, [r0, #24]
 80039b4:	4770      	bx	lr
  }
  else
  {
    GPIOx->BRR = GPIO_Pin ;
 80039b6:	8501      	strh	r1, [r0, #40]	; 0x28
 80039b8:	4770      	bx	lr

080039ba <GPIO_Write>:
void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  
  GPIOx->ODR = PortVal;
 80039ba:	8281      	strh	r1, [r0, #20]
 80039bc:	4770      	bx	lr

080039be <GPIO_PinAFConfig>:
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  assert_param(IS_GPIO_AF(GPIO_AF));
  
  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4));
 80039be:	f001 0307 	and.w	r3, r1, #7
 80039c2:	08c9      	lsrs	r1, r1, #3
 80039c4:	eb00 0081 	add.w	r0, r0, r1, lsl #2
  *        for the detailed mapping of the system and peripherals alternate 
  *        function I/O pins.
  * @retval None
  */
void GPIO_PinAFConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_PinSource, uint8_t GPIO_AF)
{
 80039c8:	b510      	push	{r4, lr}
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  assert_param(IS_GPIO_AF(GPIO_AF));
  
  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4));
 80039ca:	009b      	lsls	r3, r3, #2
  GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4));
 80039cc:	6a04      	ldr	r4, [r0, #32]
 80039ce:	210f      	movs	r1, #15
 80039d0:	4099      	lsls	r1, r3
 80039d2:	ea24 0101 	bic.w	r1, r4, r1
 80039d6:	6201      	str	r1, [r0, #32]
  temp_2 = GPIOx->AFR[GPIO_PinSource >> 0x03] | temp;
 80039d8:	6a01      	ldr	r1, [r0, #32]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  assert_param(IS_GPIO_AF(GPIO_AF));
  
  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4));
 80039da:	409a      	lsls	r2, r3
  GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4));
  temp_2 = GPIOx->AFR[GPIO_PinSource >> 0x03] | temp;
 80039dc:	4311      	orrs	r1, r2
  GPIOx->AFR[GPIO_PinSource >> 0x03] = temp_2;
 80039de:	6201      	str	r1, [r0, #32]
 80039e0:	bd10      	pop	{r4, pc}
 80039e2:	bf00      	nop

080039e4 <I2C_DeInit>:
  * @brief  Deinitializes the I2Cx peripheral registers to their default reset values.
  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
  * @retval None
  */
void I2C_DeInit(I2C_TypeDef* I2Cx)
{
 80039e4:	b508      	push	{r3, lr}
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));

  if (I2Cx == I2C1)
 80039e6:	4b0b      	ldr	r3, [pc, #44]	; (8003a14 <I2C_DeInit+0x30>)
 80039e8:	4298      	cmp	r0, r3
 80039ea:	d107      	bne.n	80039fc <I2C_DeInit+0x18>
  {
    /* Enable I2C1 reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
 80039ec:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 80039f0:	2101      	movs	r1, #1
 80039f2:	f000 fc9f 	bl	8004334 <RCC_APB1PeriphResetCmd>
    /* Release I2C1 from reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);
 80039f6:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 80039fa:	e006      	b.n	8003a0a <I2C_DeInit+0x26>
  }
  else
  {
    /* Enable I2C2 reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
 80039fc:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
 8003a00:	2101      	movs	r1, #1
 8003a02:	f000 fc97 	bl	8004334 <RCC_APB1PeriphResetCmd>
    /* Release I2C2 from reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);
 8003a06:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
 8003a0a:	2100      	movs	r1, #0
  }
}
 8003a0c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  else
  {
    /* Enable I2C2 reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
    /* Release I2C2 from reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);
 8003a10:	f000 bc90 	b.w	8004334 <RCC_APB1PeriphResetCmd>
 8003a14:	40005400 	.word	0x40005400

08003a18 <I2C_Init>:
  assert_param(IS_I2C_OWN_ADDRESS1(I2C_InitStruct->I2C_OwnAddress1));
  assert_param(IS_I2C_ACK(I2C_InitStruct->I2C_Ack));
  assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct->I2C_AcknowledgedAddress));

  /* Disable I2Cx Peripheral */
  I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_PE);
 8003a18:	6803      	ldr	r3, [r0, #0]
 8003a1a:	f023 0301 	bic.w	r3, r3, #1
 8003a1e:	6003      	str	r3, [r0, #0]

  /*---------------------------- I2Cx FILTERS Configuration ------------------*/
  /* Get the I2Cx CR1 value */
  tmpreg = I2Cx->CR1;
 8003a20:	6802      	ldr	r2, [r0, #0]
  /* Clear I2Cx CR1 register */
  tmpreg &= CR1_CLEAR_MASK;
 8003a22:	4b14      	ldr	r3, [pc, #80]	; (8003a74 <I2C_Init+0x5c>)
 8003a24:	4013      	ands	r3, r2
  /* Configure I2Cx: analog and digital filter */
  /* Set ANFOFF bit according to I2C_AnalogFilter value */
  /* Set DFN bits according to I2C_DigitalFilter value */
  tmpreg |= (uint32_t)I2C_InitStruct->I2C_AnalogFilter |(I2C_InitStruct->I2C_DigitalFilter << 8);
 8003a26:	688a      	ldr	r2, [r1, #8]
 8003a28:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8003a2c:	684a      	ldr	r2, [r1, #4]
 8003a2e:	431a      	orrs	r2, r3

  /*---------------------------- I2Cx TIMING Configuration -------------------*/
  /* Configure I2Cx: Timing */
  /* Set TIMINGR bits according to I2C_Timing */
  /* Write to I2Cx TIMING */
  I2Cx->TIMINGR = I2C_InitStruct->I2C_Timing & TIMING_CLEAR_MASK;
 8003a30:	680b      	ldr	r3, [r1, #0]
  /* Set ANFOFF bit according to I2C_AnalogFilter value */
  /* Set DFN bits according to I2C_DigitalFilter value */
  tmpreg |= (uint32_t)I2C_InitStruct->I2C_AnalogFilter |(I2C_InitStruct->I2C_DigitalFilter << 8);
  
  /* Write to I2Cx CR1 */
  I2Cx->CR1 = tmpreg;
 8003a32:	6002      	str	r2, [r0, #0]

  /*---------------------------- I2Cx TIMING Configuration -------------------*/
  /* Configure I2Cx: Timing */
  /* Set TIMINGR bits according to I2C_Timing */
  /* Write to I2Cx TIMING */
  I2Cx->TIMINGR = I2C_InitStruct->I2C_Timing & TIMING_CLEAR_MASK;
 8003a34:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
 8003a38:	6103      	str	r3, [r0, #16]

  /* Enable I2Cx Peripheral */
  I2Cx->CR1 |= I2C_CR1_PE;
 8003a3a:	6803      	ldr	r3, [r0, #0]
  /* Clear OAR2 register */
  I2Cx->OAR2 = (uint32_t)tmpreg;
  /* Configure I2Cx: Own Address1 and acknowledged address */
  /* Set OA1MODE bit according to I2C_AcknowledgedAddress value */
  /* Set OA1 bits according to I2C_OwnAddress1 value */
  tmpreg = (uint32_t)((uint32_t)I2C_InitStruct->I2C_AcknowledgedAddress | \
 8003a3c:	690a      	ldr	r2, [r1, #16]
  /* Set TIMINGR bits according to I2C_Timing */
  /* Write to I2Cx TIMING */
  I2Cx->TIMINGR = I2C_InitStruct->I2C_Timing & TIMING_CLEAR_MASK;

  /* Enable I2Cx Peripheral */
  I2Cx->CR1 |= I2C_CR1_PE;
 8003a3e:	f043 0301 	orr.w	r3, r3, #1
 8003a42:	6003      	str	r3, [r0, #0]

  /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
  /* Clear tmpreg local variable */
  tmpreg = 0;
  /* Clear OAR1 register */
  I2Cx->OAR1 = (uint32_t)tmpreg;
 8003a44:	2300      	movs	r3, #0
 8003a46:	6083      	str	r3, [r0, #8]
  /* Clear OAR2 register */
  I2Cx->OAR2 = (uint32_t)tmpreg;
 8003a48:	60c3      	str	r3, [r0, #12]
  /* Configure I2Cx: Own Address1 and acknowledged address */
  /* Set OA1MODE bit according to I2C_AcknowledgedAddress value */
  /* Set OA1 bits according to I2C_OwnAddress1 value */
  tmpreg = (uint32_t)((uint32_t)I2C_InitStruct->I2C_AcknowledgedAddress | \
 8003a4a:	698b      	ldr	r3, [r1, #24]
 8003a4c:	4313      	orrs	r3, r2
                      (uint32_t)I2C_InitStruct->I2C_OwnAddress1);
  /* Write to I2Cx OAR1 */
  I2Cx->OAR1 = tmpreg;
 8003a4e:	6083      	str	r3, [r0, #8]
  /* Enable Own Address1 acknowledgement */
  I2Cx->OAR1 |= I2C_OAR1_OA1EN;
 8003a50:	6883      	ldr	r3, [r0, #8]
 8003a52:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8003a56:	6083      	str	r3, [r0, #8]
  /*---------------------------- I2Cx MODE Configuration ---------------------*/
  /* Configure I2Cx: mode */
  /* Set SMBDEN and SMBHEN bits according to I2C_Mode value */
  tmpreg = I2C_InitStruct->I2C_Mode;
  /* Write to I2Cx CR1 */
  I2Cx->CR1 |= tmpreg;
 8003a58:	6802      	ldr	r2, [r0, #0]
 8003a5a:	68cb      	ldr	r3, [r1, #12]
 8003a5c:	4313      	orrs	r3, r2
 8003a5e:	6003      	str	r3, [r0, #0]

  /*---------------------------- I2Cx ACK Configuration ----------------------*/
  /* Get the I2Cx CR2 value */
  tmpreg = I2Cx->CR2;
 8003a60:	6843      	ldr	r3, [r0, #4]
  /* Clear I2Cx CR2 register */
  tmpreg &= CR2_CLEAR_MASK;
  /* Configure I2Cx: acknowledgement */
  /* Set NACK bit according to I2C_Ack value */
  tmpreg |= I2C_InitStruct->I2C_Ack;
 8003a62:	694a      	ldr	r2, [r1, #20]

  /*---------------------------- I2Cx ACK Configuration ----------------------*/
  /* Get the I2Cx CR2 value */
  tmpreg = I2Cx->CR2;
  /* Clear I2Cx CR2 register */
  tmpreg &= CR2_CLEAR_MASK;
 8003a64:	f023 4378 	bic.w	r3, r3, #4160749568	; 0xf8000000
 8003a68:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
  /* Configure I2Cx: acknowledgement */
  /* Set NACK bit according to I2C_Ack value */
  tmpreg |= I2C_InitStruct->I2C_Ack;
 8003a6c:	4313      	orrs	r3, r2
  /* Write to I2Cx CR2 */
  I2Cx->CR2 = tmpreg;
 8003a6e:	6043      	str	r3, [r0, #4]
 8003a70:	4770      	bx	lr
 8003a72:	bf00      	nop
 8003a74:	00cfe0ff 	.word	0x00cfe0ff

08003a78 <I2C_StructInit>:
  */
void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
{
  /*---------------- Reset I2C init structure parameters values --------------*/
  /* Initialize the I2C_Timing member */
  I2C_InitStruct->I2C_Timing = 0;
 8003a78:	2300      	movs	r3, #0
  /* Initialize the I2C_Mode member */
  I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
  /* Initialize the I2C_OwnAddress1 member */
  I2C_InitStruct->I2C_OwnAddress1 = 0;
  /* Initialize the I2C_Ack member */
  I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
 8003a7a:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  */
void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
{
  /*---------------- Reset I2C init structure parameters values --------------*/
  /* Initialize the I2C_Timing member */
  I2C_InitStruct->I2C_Timing = 0;
 8003a7e:	6003      	str	r3, [r0, #0]
  /* Initialize the I2C_AnalogFilter member */
  I2C_InitStruct->I2C_AnalogFilter = I2C_AnalogFilter_Enable;
 8003a80:	6043      	str	r3, [r0, #4]
  /* Initialize the I2C_DigitalFilter member */
  I2C_InitStruct->I2C_DigitalFilter = 0;
 8003a82:	6083      	str	r3, [r0, #8]
  /* Initialize the I2C_Mode member */
  I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
 8003a84:	60c3      	str	r3, [r0, #12]
  /* Initialize the I2C_OwnAddress1 member */
  I2C_InitStruct->I2C_OwnAddress1 = 0;
 8003a86:	6103      	str	r3, [r0, #16]
  /* Initialize the I2C_Ack member */
  I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
 8003a88:	6142      	str	r2, [r0, #20]
  /* Initialize the I2C_AcknowledgedAddress member */
  I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 8003a8a:	6183      	str	r3, [r0, #24]
 8003a8c:	4770      	bx	lr

08003a8e <I2C_Cmd>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected I2C peripheral */
    I2Cx->CR1 |= I2C_CR1_PE;
 8003a8e:	6803      	ldr	r3, [r0, #0]
void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8003a90:	b111      	cbz	r1, 8003a98 <I2C_Cmd+0xa>
  {
    /* Enable the selected I2C peripheral */
    I2Cx->CR1 |= I2C_CR1_PE;
 8003a92:	f043 0301 	orr.w	r3, r3, #1
 8003a96:	e001      	b.n	8003a9c <I2C_Cmd+0xe>
  }
  else
  {
    /* Disable the selected I2C peripheral */
    I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_PE);
 8003a98:	f023 0301 	bic.w	r3, r3, #1
 8003a9c:	6003      	str	r3, [r0, #0]
 8003a9e:	4770      	bx	lr

08003aa0 <I2C_SoftwareResetCmd>:
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));

  /* Disable peripheral */
  I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_PE);
 8003aa0:	6803      	ldr	r3, [r0, #0]
 8003aa2:	f023 0301 	bic.w	r3, r3, #1
 8003aa6:	6003      	str	r3, [r0, #0]

  /* Perform a dummy read to delay the disable of peripheral for minimum
     3 APB clock cycles to perform the software reset functionality */
  *(__IO uint32_t *)(uint32_t)I2Cx; 
 8003aa8:	6803      	ldr	r3, [r0, #0]

  /* Enable peripheral */
  I2Cx->CR1 |= I2C_CR1_PE;
 8003aaa:	6803      	ldr	r3, [r0, #0]
 8003aac:	f043 0301 	orr.w	r3, r3, #1
 8003ab0:	6003      	str	r3, [r0, #0]
 8003ab2:	4770      	bx	lr

08003ab4 <I2C_ITConfig>:
  assert_param(IS_I2C_CONFIG_IT(I2C_IT));
  
  if (NewState != DISABLE)
  {
    /* Enable the selected I2C interrupts */
    I2Cx->CR1 |= I2C_IT;
 8003ab4:	6803      	ldr	r3, [r0, #0]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_I2C_CONFIG_IT(I2C_IT));
  
  if (NewState != DISABLE)
 8003ab6:	b10a      	cbz	r2, 8003abc <I2C_ITConfig+0x8>
  {
    /* Enable the selected I2C interrupts */
    I2Cx->CR1 |= I2C_IT;
 8003ab8:	4319      	orrs	r1, r3
 8003aba:	e001      	b.n	8003ac0 <I2C_ITConfig+0xc>
  }
  else
  {
    /* Disable the selected I2C interrupts */
    I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_IT);
 8003abc:	ea23 0101 	bic.w	r1, r3, r1
 8003ac0:	6001      	str	r1, [r0, #0]
 8003ac2:	4770      	bx	lr

08003ac4 <I2C_StretchClockCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable clock stretching */
    I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_NOSTRETCH);    
 8003ac4:	6803      	ldr	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003ac6:	b111      	cbz	r1, 8003ace <I2C_StretchClockCmd+0xa>
  {
    /* Enable clock stretching */
    I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_NOSTRETCH);    
 8003ac8:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 8003acc:	e001      	b.n	8003ad2 <I2C_StretchClockCmd+0xe>
  }
  else
  {
    /* Disable clock stretching  */
    I2Cx->CR1 |= I2C_CR1_NOSTRETCH;
 8003ace:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8003ad2:	6003      	str	r3, [r0, #0]
 8003ad4:	4770      	bx	lr

08003ad6 <I2C_StopModeCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable wakeup from stop mode */
    I2Cx->CR1 |= I2C_CR1_WUPEN;   
 8003ad6:	6803      	ldr	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003ad8:	b111      	cbz	r1, 8003ae0 <I2C_StopModeCmd+0xa>
  {
    /* Enable wakeup from stop mode */
    I2Cx->CR1 |= I2C_CR1_WUPEN;   
 8003ada:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8003ade:	e001      	b.n	8003ae4 <I2C_StopModeCmd+0xe>
  }
  else
  {
    /* Disable wakeup from stop mode */    
    I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_WUPEN); 
 8003ae0:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8003ae4:	6003      	str	r3, [r0, #0]
 8003ae6:	4770      	bx	lr

08003ae8 <I2C_DualAddressCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable own address 2 */
    I2Cx->OAR2 |= I2C_OAR2_OA2EN;
 8003ae8:	68c3      	ldr	r3, [r0, #12]
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003aea:	b111      	cbz	r1, 8003af2 <I2C_DualAddressCmd+0xa>
  {
    /* Enable own address 2 */
    I2Cx->OAR2 |= I2C_OAR2_OA2EN;
 8003aec:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8003af0:	e001      	b.n	8003af6 <I2C_DualAddressCmd+0xe>
  }
  else
  {
    /* Disable own address 2 */
    I2Cx->OAR2 &= (uint32_t)~((uint32_t)I2C_OAR2_OA2EN);
 8003af2:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8003af6:	60c3      	str	r3, [r0, #12]
 8003af8:	4770      	bx	lr

08003afa <I2C_OwnAddress2Config>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_OWN_ADDRESS2(Address));
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(Mask));
  
  /* Get the old register value */
  tmpreg = I2Cx->OAR2;
 8003afa:	68c3      	ldr	r3, [r0, #12]
  /* Reset I2Cx OA2 bit [7:1] and OA2MSK bit [1:0]  */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_OAR2_OA2 | I2C_OAR2_OA2MSK));

  /* Set I2Cx SADD */
  tmpreg |= (uint32_t)(((uint32_t)Address & I2C_OAR2_OA2) | \
            (((uint32_t)Mask << 8) & I2C_OAR2_OA2MSK)) ;
 8003afc:	0212      	lsls	r2, r2, #8
  
  /* Get the old register value */
  tmpreg = I2Cx->OAR2;

  /* Reset I2Cx OA2 bit [7:1] and OA2MSK bit [1:0]  */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_OAR2_OA2 | I2C_OAR2_OA2MSK));
 8003afe:	f423 63ff 	bic.w	r3, r3, #2040	; 0x7f8

  /* Set I2Cx SADD */
  tmpreg |= (uint32_t)(((uint32_t)Address & I2C_OAR2_OA2) | \
 8003b02:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
            (((uint32_t)Mask << 8) & I2C_OAR2_OA2MSK)) ;
 8003b06:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
  
  /* Get the old register value */
  tmpreg = I2Cx->OAR2;

  /* Reset I2Cx OA2 bit [7:1] and OA2MSK bit [1:0]  */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_OAR2_OA2 | I2C_OAR2_OA2MSK));
 8003b0a:	f023 0306 	bic.w	r3, r3, #6

  /* Set I2Cx SADD */
  tmpreg |= (uint32_t)(((uint32_t)Address & I2C_OAR2_OA2) | \
 8003b0e:	4311      	orrs	r1, r2
 8003b10:	430b      	orrs	r3, r1
            (((uint32_t)Mask << 8) & I2C_OAR2_OA2MSK)) ;

  /* Store the new register value */
  I2Cx->OAR2 = tmpreg;
 8003b12:	60c3      	str	r3, [r0, #12]
 8003b14:	4770      	bx	lr

08003b16 <I2C_GeneralCallCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable general call mode */
    I2Cx->CR1 |= I2C_CR1_GCEN;
 8003b16:	6803      	ldr	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003b18:	b111      	cbz	r1, 8003b20 <I2C_GeneralCallCmd+0xa>
  {
    /* Enable general call mode */
    I2Cx->CR1 |= I2C_CR1_GCEN;
 8003b1a:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8003b1e:	e001      	b.n	8003b24 <I2C_GeneralCallCmd+0xe>
  }
  else
  {
    /* Disable general call mode */
    I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_GCEN);
 8003b20:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 8003b24:	6003      	str	r3, [r0, #0]
 8003b26:	4770      	bx	lr

08003b28 <I2C_SlaveByteControlCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable slave byte control */
    I2Cx->CR1 |= I2C_CR1_SBC;
 8003b28:	6803      	ldr	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003b2a:	b111      	cbz	r1, 8003b32 <I2C_SlaveByteControlCmd+0xa>
  {
    /* Enable slave byte control */
    I2Cx->CR1 |= I2C_CR1_SBC;
 8003b2c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8003b30:	e001      	b.n	8003b36 <I2C_SlaveByteControlCmd+0xe>
  }
  else
  {
    /* Disable slave byte control */
    I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_SBC);
 8003b32:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8003b36:	6003      	str	r3, [r0, #0]
 8003b38:	4770      	bx	lr

08003b3a <I2C_SlaveAddressConfig>:
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_SLAVE_ADDRESS(Address));
               
  /* Get the old register value */
  tmpreg = I2Cx->CR2;
 8003b3a:	6843      	ldr	r3, [r0, #4]

  /* Reset I2Cx SADD bit [9:0] */
  tmpreg &= (uint32_t)~((uint32_t)I2C_CR2_SADD);
 8003b3c:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
 8003b40:	f023 0303 	bic.w	r3, r3, #3

  /* Set I2Cx SADD */
  tmpreg |= (uint32_t)((uint32_t)Address & I2C_CR2_SADD);
 8003b44:	f3c1 0109 	ubfx	r1, r1, #0, #10
 8003b48:	430b      	orrs	r3, r1

  /* Store the new register value */
  I2Cx->CR2 = tmpreg;
 8003b4a:	6043      	str	r3, [r0, #4]
 8003b4c:	4770      	bx	lr

08003b4e <I2C_10BitAddressingModeCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable 10-bit addressing mode */
    I2Cx->CR2 |= I2C_CR2_ADD10;
 8003b4e:	6843      	ldr	r3, [r0, #4]
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003b50:	b111      	cbz	r1, 8003b58 <I2C_10BitAddressingModeCmd+0xa>
  {
    /* Enable 10-bit addressing mode */
    I2Cx->CR2 |= I2C_CR2_ADD10;
 8003b52:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8003b56:	e001      	b.n	8003b5c <I2C_10BitAddressingModeCmd+0xe>
  }
  else
  {
    /* Disable 10-bit addressing mode */
    I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_ADD10);
 8003b58:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8003b5c:	6043      	str	r3, [r0, #4]
 8003b5e:	4770      	bx	lr

08003b60 <I2C_AutoEndCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable Auto end mode */
    I2Cx->CR2 |= I2C_CR2_AUTOEND;
 8003b60:	6843      	ldr	r3, [r0, #4]
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003b62:	b111      	cbz	r1, 8003b6a <I2C_AutoEndCmd+0xa>
  {
    /* Enable Auto end mode */
    I2Cx->CR2 |= I2C_CR2_AUTOEND;
 8003b64:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 8003b68:	e001      	b.n	8003b6e <I2C_AutoEndCmd+0xe>
  }
  else
  {
    /* Disable Auto end mode */
    I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_AUTOEND);
 8003b6a:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
 8003b6e:	6043      	str	r3, [r0, #4]
 8003b70:	4770      	bx	lr

08003b72 <I2C_ReloadCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable Auto Reload mode */
    I2Cx->CR2 |= I2C_CR2_RELOAD;
 8003b72:	6843      	ldr	r3, [r0, #4]
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003b74:	b111      	cbz	r1, 8003b7c <I2C_ReloadCmd+0xa>
  {
    /* Enable Auto Reload mode */
    I2Cx->CR2 |= I2C_CR2_RELOAD;
 8003b76:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8003b7a:	e001      	b.n	8003b80 <I2C_ReloadCmd+0xe>
  }
  else
  {
    /* Disable Auto Reload mode */
    I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_RELOAD);
 8003b7c:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8003b80:	6043      	str	r3, [r0, #4]
 8003b82:	4770      	bx	lr

08003b84 <I2C_NumberOfBytesConfig>:

  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));

  /* Get the old register value */
  tmpreg = I2Cx->CR2;
 8003b84:	6843      	ldr	r3, [r0, #4]

  /* Reset I2Cx Nbytes bit [7:0] */
  tmpreg &= (uint32_t)~((uint32_t)I2C_CR2_NBYTES);
 8003b86:	f423 037f 	bic.w	r3, r3, #16711680	; 0xff0000

  /* Set I2Cx Nbytes */
  tmpreg |= (uint32_t)(((uint32_t)Number_Bytes << 16 ) & I2C_CR2_NBYTES);
 8003b8a:	ea43 4101 	orr.w	r1, r3, r1, lsl #16

  /* Store the new register value */
  I2Cx->CR2 = tmpreg;
 8003b8e:	6041      	str	r1, [r0, #4]
 8003b90:	4770      	bx	lr

08003b92 <I2C_MasterRequestConfig>:
  
  /* Test on the direction to set/reset the read/write bit */
  if (I2C_Direction == I2C_Direction_Transmitter)
  {
    /* Request a write Transfer */
    I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_RD_WRN);
 8003b92:	6843      	ldr	r3, [r0, #4]
/* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_DIRECTION(I2C_Direction));
  
  /* Test on the direction to set/reset the read/write bit */
  if (I2C_Direction == I2C_Direction_Transmitter)
 8003b94:	b911      	cbnz	r1, 8003b9c <I2C_MasterRequestConfig+0xa>
  {
    /* Request a write Transfer */
    I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_RD_WRN);
 8003b96:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8003b9a:	e001      	b.n	8003ba0 <I2C_MasterRequestConfig+0xe>
  }
  else
  {
    /* Request a read Transfer */
    I2Cx->CR2 |= I2C_CR2_RD_WRN;
 8003b9c:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8003ba0:	6043      	str	r3, [r0, #4]
 8003ba2:	4770      	bx	lr

08003ba4 <I2C_GenerateSTART>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Generate a START condition */
    I2Cx->CR2 |= I2C_CR2_START;
 8003ba4:	6843      	ldr	r3, [r0, #4]
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003ba6:	b111      	cbz	r1, 8003bae <I2C_GenerateSTART+0xa>
  {
    /* Generate a START condition */
    I2Cx->CR2 |= I2C_CR2_START;
 8003ba8:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8003bac:	e001      	b.n	8003bb2 <I2C_GenerateSTART+0xe>
  }
  else
  {
    /* Disable the START condition generation */
    I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_START);
 8003bae:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8003bb2:	6043      	str	r3, [r0, #4]
 8003bb4:	4770      	bx	lr

08003bb6 <I2C_GenerateSTOP>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Generate a STOP condition */
    I2Cx->CR2 |= I2C_CR2_STOP;
 8003bb6:	6843      	ldr	r3, [r0, #4]
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003bb8:	b111      	cbz	r1, 8003bc0 <I2C_GenerateSTOP+0xa>
  {
    /* Generate a STOP condition */
    I2Cx->CR2 |= I2C_CR2_STOP;
 8003bba:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8003bbe:	e001      	b.n	8003bc4 <I2C_GenerateSTOP+0xe>
  }
  else
  {
    /* Disable the STOP condition generation */
    I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_STOP);
 8003bc0:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8003bc4:	6043      	str	r3, [r0, #4]
 8003bc6:	4770      	bx	lr

08003bc8 <I2C_10BitAddressHeaderCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable 10-bit header only mode */
    I2Cx->CR2 |= I2C_CR2_HEAD10R;
 8003bc8:	6843      	ldr	r3, [r0, #4]
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003bca:	b111      	cbz	r1, 8003bd2 <I2C_10BitAddressHeaderCmd+0xa>
  {
    /* Enable 10-bit header only mode */
    I2Cx->CR2 |= I2C_CR2_HEAD10R;
 8003bcc:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8003bd0:	e001      	b.n	8003bd6 <I2C_10BitAddressHeaderCmd+0xe>
  }
  else
  {
    /* Disable 10-bit header only mode */
    I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_HEAD10R);
 8003bd2:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8003bd6:	6043      	str	r3, [r0, #4]
 8003bd8:	4770      	bx	lr

08003bda <I2C_AcknowledgeConfig>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable ACK generation */
    I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_NACK);    
 8003bda:	6843      	ldr	r3, [r0, #4]
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003bdc:	b111      	cbz	r1, 8003be4 <I2C_AcknowledgeConfig+0xa>
  {
    /* Enable ACK generation */
    I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_NACK);    
 8003bde:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8003be2:	e001      	b.n	8003be8 <I2C_AcknowledgeConfig+0xe>
  }
  else
  {
    /* Enable NACK generation */
    I2Cx->CR2 |= I2C_CR2_NACK;
 8003be4:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8003be8:	6043      	str	r3, [r0, #4]
 8003bea:	4770      	bx	lr

08003bec <I2C_GetAddressMatched>:
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  
  /* Return the slave matched address in the SR1 register */
  return (uint8_t)(((uint32_t)I2Cx->ISR & I2C_ISR_ADDCODE) >> 16) ;
 8003bec:	6980      	ldr	r0, [r0, #24]
 8003bee:	f400 007e 	and.w	r0, r0, #16646144	; 0xfe0000
}
 8003bf2:	0c00      	lsrs	r0, r0, #16
 8003bf4:	4770      	bx	lr

08003bf6 <I2C_GetTransferDirection>:
  
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  
  /* Return the slave matched address in the SR1 register */
  tmpreg = (uint32_t)(I2Cx->ISR & I2C_ISR_DIR);
 8003bf6:	6983      	ldr	r3, [r0, #24]
  
  /* If write transfer is requested */
  if (tmpreg == 0)
 8003bf8:	f413 3f80 	tst.w	r3, #65536	; 0x10000
  {
    /* Read transfer is requested */
    direction = I2C_Direction_Receiver;
  }  
  return direction;
}
 8003bfc:	bf14      	ite	ne
 8003bfe:	f44f 6080 	movne.w	r0, #1024	; 0x400
 8003c02:	2000      	moveq	r0, #0
 8003c04:	4770      	bx	lr

08003c06 <I2C_TransferHandling>:
  *     @arg I2C_Generate_Start_Read: Generate Restart for read request.
  *     @arg I2C_Generate_Start_Write: Generate Restart for write request.
  * @retval None
  */
void I2C_TransferHandling(I2C_TypeDef* I2Cx, uint16_t Address, uint8_t Number_Bytes, uint32_t ReloadEndMode, uint32_t StartStopMode)
{
 8003c06:	b530      	push	{r4, r5, lr}
  assert_param(IS_I2C_SLAVE_ADDRESS(Address));  
  assert_param(IS_RELOAD_END_MODE(ReloadEndMode));
  assert_param(IS_START_STOP_MODE(StartStopMode));
    
  /* Get the CR2 register value */
  tmpreg = I2Cx->CR2;
 8003c08:	6845      	ldr	r5, [r0, #4]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)Address & I2C_CR2_SADD) | (((uint32_t)Number_Bytes << 16 ) & I2C_CR2_NBYTES) | \
 8003c0a:	9c03      	ldr	r4, [sp, #12]
    
  /* Get the CR2 register value */
  tmpreg = I2Cx->CR2;
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 8003c0c:	f025 757f 	bic.w	r5, r5, #66846720	; 0x3fc0000
 8003c10:	f425 3559 	bic.w	r5, r5, #222208	; 0x36400
 8003c14:	f425 757f 	bic.w	r5, r5, #1020	; 0x3fc
 8003c18:	f025 0503 	bic.w	r5, r5, #3
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)Address & I2C_CR2_SADD) | (((uint32_t)Number_Bytes << 16 ) & I2C_CR2_NBYTES) | \
 8003c1c:	432c      	orrs	r4, r5
 8003c1e:	4323      	orrs	r3, r4
 8003c20:	f3c1 0109 	ubfx	r1, r1, #0, #10
 8003c24:	ea43 0401 	orr.w	r4, r3, r1
 8003c28:	ea44 4202 	orr.w	r2, r4, r2, lsl #16
            (uint32_t)ReloadEndMode | (uint32_t)StartStopMode);
  
  /* update CR2 register */
  I2Cx->CR2 = tmpreg;  
 8003c2c:	6042      	str	r2, [r0, #4]
 8003c2e:	bd30      	pop	{r4, r5, pc}

08003c30 <I2C_SMBusAlertCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable SMBus alert */
    I2Cx->CR1 |= I2C_CR1_ALERTEN;   
 8003c30:	6803      	ldr	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003c32:	b111      	cbz	r1, 8003c3a <I2C_SMBusAlertCmd+0xa>
  {
    /* Enable SMBus alert */
    I2Cx->CR1 |= I2C_CR1_ALERTEN;   
 8003c34:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8003c38:	e001      	b.n	8003c3e <I2C_SMBusAlertCmd+0xe>
  }
  else
  {
    /* Disable SMBus alert */    
    I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_ALERTEN); 
 8003c3a:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
 8003c3e:	6003      	str	r3, [r0, #0]
 8003c40:	4770      	bx	lr

08003c42 <I2C_ClockTimeoutCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable Clock Timeout */
    I2Cx->TIMEOUTR |= I2C_TIMEOUTR_TIMOUTEN;   
 8003c42:	6943      	ldr	r3, [r0, #20]
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003c44:	b111      	cbz	r1, 8003c4c <I2C_ClockTimeoutCmd+0xa>
  {
    /* Enable Clock Timeout */
    I2Cx->TIMEOUTR |= I2C_TIMEOUTR_TIMOUTEN;   
 8003c46:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8003c4a:	e001      	b.n	8003c50 <I2C_ClockTimeoutCmd+0xe>
  }
  else
  {
    /* Disable Clock Timeout */    
    I2Cx->TIMEOUTR &= (uint32_t)~((uint32_t)I2C_TIMEOUTR_TIMOUTEN); 
 8003c4c:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8003c50:	6143      	str	r3, [r0, #20]
 8003c52:	4770      	bx	lr

08003c54 <I2C_ExtendedClockTimeoutCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable Clock Timeout */
    I2Cx->TIMEOUTR |= I2C_TIMEOUTR_TEXTEN;   
 8003c54:	6943      	ldr	r3, [r0, #20]
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003c56:	b111      	cbz	r1, 8003c5e <I2C_ExtendedClockTimeoutCmd+0xa>
  {
    /* Enable Clock Timeout */
    I2Cx->TIMEOUTR |= I2C_TIMEOUTR_TEXTEN;   
 8003c58:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8003c5c:	e001      	b.n	8003c62 <I2C_ExtendedClockTimeoutCmd+0xe>
  }
  else
  {
    /* Disable Clock Timeout */    
    I2Cx->TIMEOUTR &= (uint32_t)~((uint32_t)I2C_TIMEOUTR_TEXTEN); 
 8003c5e:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8003c62:	6143      	str	r3, [r0, #20]
 8003c64:	4770      	bx	lr

08003c66 <I2C_IdleClockTimeoutCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable Clock Timeout */
    I2Cx->TIMEOUTR |= I2C_TIMEOUTR_TIDLE;   
 8003c66:	6943      	ldr	r3, [r0, #20]
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003c68:	b111      	cbz	r1, 8003c70 <I2C_IdleClockTimeoutCmd+0xa>
  {
    /* Enable Clock Timeout */
    I2Cx->TIMEOUTR |= I2C_TIMEOUTR_TIDLE;   
 8003c6a:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8003c6e:	e001      	b.n	8003c74 <I2C_IdleClockTimeoutCmd+0xe>
  }
  else
  {
    /* Disable Clock Timeout */    
    I2Cx->TIMEOUTR &= (uint32_t)~((uint32_t)I2C_TIMEOUTR_TIDLE); 
 8003c70:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8003c74:	6143      	str	r3, [r0, #20]
 8003c76:	4770      	bx	lr

08003c78 <I2C_TimeoutAConfig>:
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_TIMEOUT(Timeout));
    
  /* Get the old register value */
  tmpreg = I2Cx->TIMEOUTR;
 8003c78:	6943      	ldr	r3, [r0, #20]

  /* Reset I2Cx TIMEOUTA bit [11:0] */
  tmpreg &= (uint32_t)~((uint32_t)I2C_TIMEOUTR_TIMEOUTA);
 8003c7a:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 8003c7e:	f023 030f 	bic.w	r3, r3, #15

  /* Set I2Cx TIMEOUTA */
  tmpreg |= (uint32_t)((uint32_t)Timeout & I2C_TIMEOUTR_TIMEOUTA) ;
 8003c82:	f3c1 010b 	ubfx	r1, r1, #0, #12
 8003c86:	430b      	orrs	r3, r1

  /* Store the new register value */
  I2Cx->TIMEOUTR = tmpreg;
 8003c88:	6143      	str	r3, [r0, #20]
 8003c8a:	4770      	bx	lr

08003c8c <I2C_TimeoutBConfig>:
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_TIMEOUT(Timeout));

  /* Get the old register value */
  tmpreg = I2Cx->TIMEOUTR;
 8003c8c:	6943      	ldr	r3, [r0, #20]

  /* Reset I2Cx TIMEOUTB bit [11:0] */
  tmpreg &= (uint32_t)~((uint32_t)I2C_TIMEOUTR_TIMEOUTB);

  /* Set I2Cx TIMEOUTB */
  tmpreg |= (uint32_t)(((uint32_t)Timeout << 16) & I2C_TIMEOUTR_TIMEOUTB) ;
 8003c8e:	4a05      	ldr	r2, [pc, #20]	; (8003ca4 <I2C_TimeoutBConfig+0x18>)

  /* Get the old register value */
  tmpreg = I2Cx->TIMEOUTR;

  /* Reset I2Cx TIMEOUTB bit [11:0] */
  tmpreg &= (uint32_t)~((uint32_t)I2C_TIMEOUTR_TIMEOUTB);
 8003c90:	f023 637f 	bic.w	r3, r3, #267386880	; 0xff00000
 8003c94:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000

  /* Set I2Cx TIMEOUTB */
  tmpreg |= (uint32_t)(((uint32_t)Timeout << 16) & I2C_TIMEOUTR_TIMEOUTB) ;
 8003c98:	ea02 4101 	and.w	r1, r2, r1, lsl #16
 8003c9c:	430b      	orrs	r3, r1

  /* Store the new register value */
  I2Cx->TIMEOUTR = tmpreg;
 8003c9e:	6143      	str	r3, [r0, #20]
 8003ca0:	4770      	bx	lr
 8003ca2:	bf00      	nop
 8003ca4:	0fff0000 	.word	0x0fff0000

08003ca8 <I2C_CalculatePEC>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable PEC calculation */
    I2Cx->CR1 |= I2C_CR1_PECEN;   
 8003ca8:	6803      	ldr	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003caa:	b111      	cbz	r1, 8003cb2 <I2C_CalculatePEC+0xa>
  {
    /* Enable PEC calculation */
    I2Cx->CR1 |= I2C_CR1_PECEN;   
 8003cac:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8003cb0:	e001      	b.n	8003cb6 <I2C_CalculatePEC+0xe>
  }
  else
  {
    /* Disable PEC calculation */    
    I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_PECEN); 
 8003cb2:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
 8003cb6:	6003      	str	r3, [r0, #0]
 8003cb8:	4770      	bx	lr

08003cba <I2C_PECRequestCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable PEC transmission/reception request */
    I2Cx->CR1 |= I2C_CR2_PECBYTE;   
 8003cba:	6803      	ldr	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003cbc:	b111      	cbz	r1, 8003cc4 <I2C_PECRequestCmd+0xa>
  {
    /* Enable PEC transmission/reception request */
    I2Cx->CR1 |= I2C_CR2_PECBYTE;   
 8003cbe:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 8003cc2:	e001      	b.n	8003cc8 <I2C_PECRequestCmd+0xe>
  }
  else
  {
    /* Disable PEC transmission/reception request */    
    I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR2_PECBYTE); 
 8003cc4:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 8003cc8:	6003      	str	r3, [r0, #0]
 8003cca:	4770      	bx	lr

08003ccc <I2C_GetPEC>:
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  
  /* Return the slave matched address in the SR1 register */
  return (uint8_t)((uint32_t)I2Cx->PECR & I2C_PECR_PEC);
 8003ccc:	6a00      	ldr	r0, [r0, #32]
}
 8003cce:	b2c0      	uxtb	r0, r0
 8003cd0:	4770      	bx	lr

08003cd2 <I2C_ReadRegister>:
  *     @arg I2C_Register_RXDR: RXDR register.
  *     @arg I2C_Register_TXDR: TXDR register.
  * @retval The value of the read register.
  */
uint32_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register)
{
 8003cd2:	b082      	sub	sp, #8
  __IO uint32_t tmp = 0;
 8003cd4:	2300      	movs	r3, #0
 8003cd6:	9301      	str	r3, [sp, #4]

  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_REGISTER(I2C_Register));

  tmp = (uint32_t)I2Cx;
 8003cd8:	9001      	str	r0, [sp, #4]
  tmp += I2C_Register;
 8003cda:	9b01      	ldr	r3, [sp, #4]
 8003cdc:	4419      	add	r1, r3
 8003cde:	9101      	str	r1, [sp, #4]

  /* Return the selected register value */
  return (*(__IO uint32_t *) tmp);
 8003ce0:	9b01      	ldr	r3, [sp, #4]
 8003ce2:	6818      	ldr	r0, [r3, #0]
}
 8003ce4:	b002      	add	sp, #8
 8003ce6:	4770      	bx	lr

08003ce8 <I2C_SendData>:
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  
  /* Write in the DR register the data to be sent */
  I2Cx->TXDR = (uint8_t)Data;
 8003ce8:	6281      	str	r1, [r0, #40]	; 0x28
 8003cea:	4770      	bx	lr

08003cec <I2C_ReceiveData>:
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  
  /* Return the data in the DR register */
  return (uint8_t)I2Cx->RXDR;
 8003cec:	6a40      	ldr	r0, [r0, #36]	; 0x24
}  
 8003cee:	b2c0      	uxtb	r0, r0
 8003cf0:	4770      	bx	lr

08003cf2 <I2C_DMACmd>:
  assert_param(IS_I2C_DMA_REQ(I2C_DMAReq));

  if (NewState != DISABLE)
  {
    /* Enable the selected I2C DMA requests */
    I2Cx->CR1 |= I2C_DMAReq;
 8003cf2:	6803      	ldr	r3, [r0, #0]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_I2C_DMA_REQ(I2C_DMAReq));

  if (NewState != DISABLE)
 8003cf4:	b10a      	cbz	r2, 8003cfa <I2C_DMACmd+0x8>
  {
    /* Enable the selected I2C DMA requests */
    I2Cx->CR1 |= I2C_DMAReq;
 8003cf6:	4319      	orrs	r1, r3
 8003cf8:	e001      	b.n	8003cfe <I2C_DMACmd+0xc>
  }
  else
  {
    /* Disable the selected I2C DMA requests */
    I2Cx->CR1 &= (uint32_t)~I2C_DMAReq;
 8003cfa:	ea23 0101 	bic.w	r1, r3, r1
 8003cfe:	6001      	str	r1, [r0, #0]
 8003d00:	4770      	bx	lr

08003d02 <I2C_GetFlagStatus>:
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_GET_FLAG(I2C_FLAG));
  
  /* Get the ISR register value */
  tmpreg = I2Cx->ISR;
 8003d02:	6983      	ldr	r3, [r0, #24]
  
  /* Get flag status */
  tmpreg &= I2C_FLAG;
  
  if(tmpreg != 0)
 8003d04:	4219      	tst	r1, r3
  {
    /* I2C_FLAG is reset */
    bitstatus = RESET;
  }
  return bitstatus;
}  
 8003d06:	bf0c      	ite	eq
 8003d08:	2000      	moveq	r0, #0
 8003d0a:	2001      	movne	r0, #1
 8003d0c:	4770      	bx	lr

08003d0e <I2C_ClearFlag>:
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));

  /* Clear the selected flag */
  I2Cx->ICR = I2C_FLAG;
 8003d0e:	61c1      	str	r1, [r0, #28]
 8003d10:	4770      	bx	lr

08003d12 <I2C_GetITStatus>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_GET_IT(I2C_IT));

  /* Check if the interrupt source is enabled or not */
  /* If Error interrupt */
  if((uint32_t)(I2C_IT & ERROR_IT_MASK))
 8003d12:	f411 5f7c 	tst.w	r1, #16128	; 0x3f00
  {
    enablestatus = (uint32_t)((I2C_CR1_ERRIE) & (I2Cx->CR1));
 8003d16:	6803      	ldr	r3, [r0, #0]
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_GET_IT(I2C_IT));

  /* Check if the interrupt source is enabled or not */
  /* If Error interrupt */
  if((uint32_t)(I2C_IT & ERROR_IT_MASK))
 8003d18:	d002      	beq.n	8003d20 <I2C_GetITStatus+0xe>
  {
    enablestatus = (uint32_t)((I2C_CR1_ERRIE) & (I2Cx->CR1));
 8003d1a:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8003d1e:	e005      	b.n	8003d2c <I2C_GetITStatus+0x1a>
  }
  /* If TC interrupt */
  else if((uint32_t)(I2C_IT & TC_IT_MASK))
 8003d20:	f011 0fc0 	tst.w	r1, #192	; 0xc0
  {
    enablestatus = (uint32_t)((I2C_CR1_TCIE) & (I2Cx->CR1));
 8003d24:	bf14      	ite	ne
 8003d26:	f003 0340 	andne.w	r3, r3, #64	; 0x40
  }
  else
  {
    enablestatus = (uint32_t)((I2C_IT) & (I2Cx->CR1));
 8003d2a:	400b      	andeq	r3, r1
  }
  
  /* Get the ISR register value */
  tmpreg = I2Cx->ISR;
 8003d2c:	6980      	ldr	r0, [r0, #24]

  /* Get flag status */
  tmpreg &= I2C_IT;

  /* Check the status of the specified I2C flag */
  if((tmpreg != RESET) && enablestatus)
 8003d2e:	4008      	ands	r0, r1
 8003d30:	d002      	beq.n	8003d38 <I2C_GetITStatus+0x26>
  {
    /* I2C_IT is set */
    bitstatus = SET;
 8003d32:	1c18      	adds	r0, r3, #0
 8003d34:	bf18      	it	ne
 8003d36:	2001      	movne	r0, #1
    bitstatus = RESET;
  }

  /* Return the I2C_IT status */
  return bitstatus;
}
 8003d38:	4770      	bx	lr

08003d3a <I2C_ClearITPendingBit>:
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_CLEAR_IT(I2C_IT));

  /* Clear the selected flag */
  I2Cx->ICR = I2C_IT;
 8003d3a:	61c1      	str	r1, [r0, #28]
 8003d3c:	4770      	bx	lr
 8003d3e:	bf00      	nop

08003d40 <NVIC_PriorityGroupConfig>:
{
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */
  SCB->AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;
 8003d40:	f040 60bf 	orr.w	r0, r0, #100139008	; 0x5f80000
 8003d44:	4b02      	ldr	r3, [pc, #8]	; (8003d50 <NVIC_PriorityGroupConfig+0x10>)
 8003d46:	f440 3000 	orr.w	r0, r0, #131072	; 0x20000
 8003d4a:	60d8      	str	r0, [r3, #12]
 8003d4c:	4770      	bx	lr
 8003d4e:	bf00      	nop
 8003d50:	e000ed00 	.word	0xe000ed00

08003d54 <NVIC_Init>:
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority));  
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
 8003d54:	78c2      	ldrb	r2, [r0, #3]
 8003d56:	7803      	ldrb	r3, [r0, #0]
  * @param  NVIC_InitStruct: pointer to a NVIC_InitTypeDef structure that contains
  *         the configuration information for the specified NVIC peripheral.
  * @retval None
  */
void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct)
{
 8003d58:	b510      	push	{r4, lr}
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority));  
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
 8003d5a:	b1fa      	cbz	r2, 8003d9c <NVIC_Init+0x48>
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
 8003d5c:	4a15      	ldr	r2, [pc, #84]	; (8003db4 <NVIC_Init+0x60>)
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (uint32_t)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 8003d5e:	7844      	ldrb	r4, [r0, #1]
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
 8003d60:	68d2      	ldr	r2, [r2, #12]
 8003d62:	43d2      	mvns	r2, r2
 8003d64:	f3c2 2202 	ubfx	r2, r2, #8, #3
    tmppre = (0x4 - tmppriority);
 8003d68:	f1c2 0104 	rsb	r1, r2, #4
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (uint32_t)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 8003d6c:	fa04 f101 	lsl.w	r1, r4, r1
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;
 8003d70:	240f      	movs	r4, #15
 8003d72:	fa24 f202 	lsr.w	r2, r4, r2

    tmppriority = (uint32_t)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
 8003d76:	7884      	ldrb	r4, [r0, #2]
 8003d78:	4022      	ands	r2, r4
 8003d7a:	430a      	orrs	r2, r1
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 8003d7c:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
 8003d80:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (uint32_t)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
    tmppriority = tmppriority << 0x04;
 8003d84:	0112      	lsls	r2, r2, #4
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 8003d86:	b2d2      	uxtb	r2, r2
 8003d88:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8003d8c:	7803      	ldrb	r3, [r0, #0]
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8003d8e:	2201      	movs	r2, #1
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8003d90:	0959      	lsrs	r1, r3, #5
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8003d92:	f003 031f 	and.w	r3, r3, #31
 8003d96:	fa02 f303 	lsl.w	r3, r2, r3
 8003d9a:	e006      	b.n	8003daa <NVIC_Init+0x56>
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8003d9c:	0959      	lsrs	r1, r3, #5
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8003d9e:	2201      	movs	r2, #1
 8003da0:	f003 031f 	and.w	r3, r3, #31
 8003da4:	fa02 f303 	lsl.w	r3, r2, r3
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8003da8:	3120      	adds	r1, #32
 8003daa:	4a03      	ldr	r2, [pc, #12]	; (8003db8 <NVIC_Init+0x64>)
 8003dac:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
 8003db0:	bd10      	pop	{r4, pc}
 8003db2:	bf00      	nop
 8003db4:	e000ed00 	.word	0xe000ed00
 8003db8:	e000e100 	.word	0xe000e100

08003dbc <NVIC_SetVectorTable>:
{ 
  /* Check the parameters */
  assert_param(IS_NVIC_VECTTAB(NVIC_VectTab));
  assert_param(IS_NVIC_OFFSET(Offset));  
   
  SCB->VTOR = NVIC_VectTab | (Offset & (uint32_t)0x1FFFFF80);
 8003dbc:	f021 4160 	bic.w	r1, r1, #3758096384	; 0xe0000000
 8003dc0:	f021 017f 	bic.w	r1, r1, #127	; 0x7f
 8003dc4:	4b01      	ldr	r3, [pc, #4]	; (8003dcc <NVIC_SetVectorTable+0x10>)
 8003dc6:	4308      	orrs	r0, r1
 8003dc8:	6098      	str	r0, [r3, #8]
 8003dca:	4770      	bx	lr
 8003dcc:	e000ed00 	.word	0xe000ed00

08003dd0 <NVIC_SystemLPConfig>:
  *     @arg NVIC_LP_SLEEPONEXIT
  * @param  NewState: new state of LP condition. This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void NVIC_SystemLPConfig(uint8_t LowPowerMode, FunctionalState NewState)
{
 8003dd0:	4b04      	ldr	r3, [pc, #16]	; (8003de4 <NVIC_SystemLPConfig+0x14>)
  assert_param(IS_NVIC_LP(LowPowerMode));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if (NewState != DISABLE)
  {
    SCB->SCR |= LowPowerMode;
 8003dd2:	691a      	ldr	r2, [r3, #16]
{
  /* Check the parameters */
  assert_param(IS_NVIC_LP(LowPowerMode));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if (NewState != DISABLE)
 8003dd4:	b109      	cbz	r1, 8003dda <NVIC_SystemLPConfig+0xa>
  {
    SCB->SCR |= LowPowerMode;
 8003dd6:	4310      	orrs	r0, r2
 8003dd8:	e001      	b.n	8003dde <NVIC_SystemLPConfig+0xe>
  }
  else
  {
    SCB->SCR &= (uint32_t)(~(uint32_t)LowPowerMode);
 8003dda:	ea22 0000 	bic.w	r0, r2, r0
 8003dde:	6118      	str	r0, [r3, #16]
 8003de0:	4770      	bx	lr
 8003de2:	bf00      	nop
 8003de4:	e000ed00 	.word	0xe000ed00

08003de8 <SysTick_CLKSourceConfig>:
  *     @arg SysTick_CLKSource_HCLK_Div8: AHB clock divided by 8 selected as SysTick clock source.
  *     @arg SysTick_CLKSource_HCLK: AHB clock selected as SysTick clock source.
  * @retval None
  */
void SysTick_CLKSourceConfig(uint32_t SysTick_CLKSource)
{
 8003de8:	4b04      	ldr	r3, [pc, #16]	; (8003dfc <SysTick_CLKSourceConfig+0x14>)
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));
  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
  {
    SysTick->CTRL |= SysTick_CLKSource_HCLK;
 8003dea:	681a      	ldr	r2, [r3, #0]
  */
void SysTick_CLKSourceConfig(uint32_t SysTick_CLKSource)
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));
  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
 8003dec:	2804      	cmp	r0, #4
  {
    SysTick->CTRL |= SysTick_CLKSource_HCLK;
 8003dee:	bf0c      	ite	eq
 8003df0:	f042 0204 	orreq.w	r2, r2, #4
  }
  else
  {
    SysTick->CTRL &= SysTick_CLKSource_HCLK_Div8;
 8003df4:	f022 0204 	bicne.w	r2, r2, #4
 8003df8:	601a      	str	r2, [r3, #0]
 8003dfa:	4770      	bx	lr
 8003dfc:	e000e010 	.word	0xe000e010

08003e00 <RCC_DeInit>:
  * @retval None
  */
void RCC_DeInit(void)
{
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8003e00:	4b11      	ldr	r3, [pc, #68]	; (8003e48 <RCC_DeInit+0x48>)
 8003e02:	681a      	ldr	r2, [r3, #0]
 8003e04:	f042 0201 	orr.w	r2, r2, #1
 8003e08:	601a      	str	r2, [r3, #0]

  /* Reset SW[1:0], HPRE[3:0], PPRE[2:0] and MCOSEL[2:0] bits */
  RCC->CFGR &= (uint32_t)0xF8FFC000;
 8003e0a:	6859      	ldr	r1, [r3, #4]
 8003e0c:	4a0f      	ldr	r2, [pc, #60]	; (8003e4c <RCC_DeInit+0x4c>)
 8003e0e:	400a      	ands	r2, r1
 8003e10:	605a      	str	r2, [r3, #4]
  
  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8003e12:	681a      	ldr	r2, [r3, #0]
 8003e14:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 8003e18:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8003e1c:	601a      	str	r2, [r3, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8003e1e:	681a      	ldr	r2, [r3, #0]
 8003e20:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8003e24:	601a      	str	r2, [r3, #0]

  /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE bits */
  RCC->CFGR &= (uint32_t)0xFF80FFFF;
 8003e26:	685a      	ldr	r2, [r3, #4]
 8003e28:	f422 02fe 	bic.w	r2, r2, #8323072	; 0x7f0000
 8003e2c:	605a      	str	r2, [r3, #4]

  /* Reset PREDIV1[3:0] and ADCPRE[13:4] bits */
  RCC->CFGR2 &= (uint32_t)0xFFFFC000;
 8003e2e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8003e30:	f422 527f 	bic.w	r2, r2, #16320	; 0x3fc0
 8003e34:	f022 023f 	bic.w	r2, r2, #63	; 0x3f
 8003e38:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Reset USARTSW[1:0], I2CSW and TIMSW bits */
  RCC->CFGR3 &= (uint32_t)0xF00FCCC;
 8003e3a:	6b19      	ldr	r1, [r3, #48]	; 0x30
 8003e3c:	4a04      	ldr	r2, [pc, #16]	; (8003e50 <RCC_DeInit+0x50>)
 8003e3e:	400a      	ands	r2, r1
 8003e40:	631a      	str	r2, [r3, #48]	; 0x30
  
  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 8003e42:	2200      	movs	r2, #0
 8003e44:	609a      	str	r2, [r3, #8]
 8003e46:	4770      	bx	lr
 8003e48:	40021000 	.word	0x40021000
 8003e4c:	f8ffc000 	.word	0xf8ffc000
 8003e50:	0f00fccc 	.word	0x0f00fccc

08003e54 <RCC_HSEConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_HSE(RCC_HSE));

  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
  *(__IO uint8_t *) CR_BYTE2_ADDRESS = RCC_HSE_OFF;
 8003e54:	4b02      	ldr	r3, [pc, #8]	; (8003e60 <RCC_HSEConfig+0xc>)
 8003e56:	2200      	movs	r2, #0
 8003e58:	701a      	strb	r2, [r3, #0]

  /* Set the new HSE configuration -------------------------------------------*/
  *(__IO uint8_t *) CR_BYTE2_ADDRESS = RCC_HSE;
 8003e5a:	7018      	strb	r0, [r3, #0]
 8003e5c:	4770      	bx	lr
 8003e5e:	bf00      	nop
 8003e60:	40021002 	.word	0x40021002

08003e64 <RCC_AdjustHSICalibrationValue>:
  uint32_t tmpreg = 0;
  
  /* Check the parameters */
  assert_param(IS_RCC_HSI_CALIBRATION_VALUE(HSICalibrationValue));
  
  tmpreg = RCC->CR;
 8003e64:	4b03      	ldr	r3, [pc, #12]	; (8003e74 <RCC_AdjustHSICalibrationValue+0x10>)
 8003e66:	681a      	ldr	r2, [r3, #0]
  
  /* Clear HSITRIM[4:0] bits */
  tmpreg &= ~RCC_CR_HSITRIM;
 8003e68:	f022 02f8 	bic.w	r2, r2, #248	; 0xf8
  
  /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
  tmpreg |= (uint32_t)HSICalibrationValue << 3;
 8003e6c:	ea42 00c0 	orr.w	r0, r2, r0, lsl #3
  
  /* Store the new value */
  RCC->CR = tmpreg;
 8003e70:	6018      	str	r0, [r3, #0]
 8003e72:	4770      	bx	lr
 8003e74:	40021000 	.word	0x40021000

08003e78 <RCC_HSICmd>:
void RCC_HSICmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
 8003e78:	4b01      	ldr	r3, [pc, #4]	; (8003e80 <RCC_HSICmd+0x8>)
 8003e7a:	6018      	str	r0, [r3, #0]
 8003e7c:	4770      	bx	lr
 8003e7e:	bf00      	nop
 8003e80:	42420000 	.word	0x42420000

08003e84 <RCC_LSEConfig>:
  /* Check the parameters */
  assert_param(IS_RCC_LSE(RCC_LSE));

  /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
  /* Reset LSEON bit */
  RCC->BDCR &= ~(RCC_BDCR_LSEON);
 8003e84:	4b06      	ldr	r3, [pc, #24]	; (8003ea0 <RCC_LSEConfig+0x1c>)
 8003e86:	6a1a      	ldr	r2, [r3, #32]
 8003e88:	f022 0201 	bic.w	r2, r2, #1
 8003e8c:	621a      	str	r2, [r3, #32]

  /* Reset LSEBYP bit */
  RCC->BDCR &= ~(RCC_BDCR_LSEBYP);
 8003e8e:	6a1a      	ldr	r2, [r3, #32]
 8003e90:	f022 0204 	bic.w	r2, r2, #4
 8003e94:	621a      	str	r2, [r3, #32]

  /* Configure LSE */
  RCC->BDCR |= RCC_LSE;
 8003e96:	6a1a      	ldr	r2, [r3, #32]
 8003e98:	4310      	orrs	r0, r2
 8003e9a:	6218      	str	r0, [r3, #32]
 8003e9c:	4770      	bx	lr
 8003e9e:	bf00      	nop
 8003ea0:	40021000 	.word	0x40021000

08003ea4 <RCC_LSEDriveConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_LSE_DRIVE(RCC_LSEDrive));
  
  /* Clear LSEDRV[1:0] bits */
  RCC->BDCR &= ~(RCC_BDCR_LSEDRV);
 8003ea4:	4b04      	ldr	r3, [pc, #16]	; (8003eb8 <RCC_LSEDriveConfig+0x14>)
 8003ea6:	6a1a      	ldr	r2, [r3, #32]
 8003ea8:	f022 0218 	bic.w	r2, r2, #24
 8003eac:	621a      	str	r2, [r3, #32]

  /* Set the LSE Drive */
  RCC->BDCR |= RCC_LSEDrive;
 8003eae:	6a1a      	ldr	r2, [r3, #32]
 8003eb0:	4310      	orrs	r0, r2
 8003eb2:	6218      	str	r0, [r3, #32]
 8003eb4:	4770      	bx	lr
 8003eb6:	bf00      	nop
 8003eb8:	40021000 	.word	0x40021000

08003ebc <RCC_LSICmd>:
void RCC_LSICmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
 8003ebc:	4b01      	ldr	r3, [pc, #4]	; (8003ec4 <RCC_LSICmd+0x8>)
 8003ebe:	6018      	str	r0, [r3, #0]
 8003ec0:	4770      	bx	lr
 8003ec2:	bf00      	nop
 8003ec4:	42420480 	.word	0x42420480

08003ec8 <RCC_PLLConfig>:
  /* Check the parameters */
  assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
  assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));
  
  /* Clear PLL Source [16] and Multiplier [21:18] bits */
  RCC->CFGR &= ~(RCC_CFGR_PLLMULL | RCC_CFGR_PLLSRC);
 8003ec8:	4b04      	ldr	r3, [pc, #16]	; (8003edc <RCC_PLLConfig+0x14>)
 8003eca:	685a      	ldr	r2, [r3, #4]
 8003ecc:	f422 1274 	bic.w	r2, r2, #3997696	; 0x3d0000
 8003ed0:	605a      	str	r2, [r3, #4]

  /* Set the PLL Source and Multiplier */
  RCC->CFGR |= (uint32_t)(RCC_PLLSource | RCC_PLLMul);
 8003ed2:	685a      	ldr	r2, [r3, #4]
 8003ed4:	4311      	orrs	r1, r2
 8003ed6:	4308      	orrs	r0, r1
 8003ed8:	6058      	str	r0, [r3, #4]
 8003eda:	4770      	bx	lr
 8003edc:	40021000 	.word	0x40021000

08003ee0 <RCC_PLLCmd>:
void RCC_PLLCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
 8003ee0:	4b01      	ldr	r3, [pc, #4]	; (8003ee8 <RCC_PLLCmd+0x8>)
 8003ee2:	6018      	str	r0, [r3, #0]
 8003ee4:	4770      	bx	lr
 8003ee6:	bf00      	nop
 8003ee8:	42420060 	.word	0x42420060

08003eec <RCC_PREDIV1Config>:
  uint32_t tmpreg = 0;
  
  /* Check the parameters */
  assert_param(IS_RCC_PREDIV1(RCC_PREDIV1_Div));

  tmpreg = RCC->CFGR2;
 8003eec:	4b03      	ldr	r3, [pc, #12]	; (8003efc <RCC_PREDIV1Config+0x10>)
 8003eee:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  /* Clear PREDIV1[3:0] bits */
  tmpreg &= ~(RCC_CFGR2_PREDIV1);
 8003ef0:	f022 020f 	bic.w	r2, r2, #15

  /* Set the PREDIV1 division factor */
  tmpreg |= RCC_PREDIV1_Div;
 8003ef4:	4310      	orrs	r0, r2

  /* Store the new value */
  RCC->CFGR2 = tmpreg;
 8003ef6:	62d8      	str	r0, [r3, #44]	; 0x2c
 8003ef8:	4770      	bx	lr
 8003efa:	bf00      	nop
 8003efc:	40021000 	.word	0x40021000

08003f00 <RCC_ClockSecuritySystemCmd>:
void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
 8003f00:	4b01      	ldr	r3, [pc, #4]	; (8003f08 <RCC_ClockSecuritySystemCmd+0x8>)
 8003f02:	6018      	str	r0, [r3, #0]
 8003f04:	4770      	bx	lr
 8003f06:	bf00      	nop
 8003f08:	4242004c 	.word	0x4242004c

08003f0c <RCC_MCOConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_MCO_SOURCE(RCC_MCOSource));
    
  /* Select MCO clock source and prescaler */
  *(__IO uint8_t *) CFGR_BYTE3_ADDRESS =  RCC_MCOSource; 
 8003f0c:	4b01      	ldr	r3, [pc, #4]	; (8003f14 <RCC_MCOConfig+0x8>)
 8003f0e:	7018      	strb	r0, [r3, #0]
 8003f10:	4770      	bx	lr
 8003f12:	bf00      	nop
 8003f14:	40021007 	.word	0x40021007

08003f18 <RCC_SYSCLKConfig>:
  uint32_t tmpreg = 0;
  
  /* Check the parameters */
  assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
  
  tmpreg = RCC->CFGR;
 8003f18:	4b03      	ldr	r3, [pc, #12]	; (8003f28 <RCC_SYSCLKConfig+0x10>)
 8003f1a:	685a      	ldr	r2, [r3, #4]
  
  /* Clear SW[1:0] bits */
  tmpreg &= ~RCC_CFGR_SW;
 8003f1c:	f022 0203 	bic.w	r2, r2, #3
  
  /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
  tmpreg |= RCC_SYSCLKSource;
 8003f20:	4310      	orrs	r0, r2
  
  /* Store the new value */
  RCC->CFGR = tmpreg;
 8003f22:	6058      	str	r0, [r3, #4]
 8003f24:	4770      	bx	lr
 8003f26:	bf00      	nop
 8003f28:	40021000 	.word	0x40021000

08003f2c <RCC_GetSYSCLKSource>:
  *              - 0x04: HSE used as system clock  
  *              - 0x08: PLL used as system clock
  */
uint8_t RCC_GetSYSCLKSource(void)
{
  return ((uint8_t)(RCC->CFGR & RCC_CFGR_SWS));
 8003f2c:	4b02      	ldr	r3, [pc, #8]	; (8003f38 <RCC_GetSYSCLKSource+0xc>)
 8003f2e:	6858      	ldr	r0, [r3, #4]
}
 8003f30:	f000 000c 	and.w	r0, r0, #12
 8003f34:	4770      	bx	lr
 8003f36:	bf00      	nop
 8003f38:	40021000 	.word	0x40021000

08003f3c <RCC_HCLKConfig>:
  uint32_t tmpreg = 0;
  
  /* Check the parameters */
  assert_param(IS_RCC_HCLK(RCC_SYSCLK));
  
  tmpreg = RCC->CFGR;
 8003f3c:	4b03      	ldr	r3, [pc, #12]	; (8003f4c <RCC_HCLKConfig+0x10>)
 8003f3e:	685a      	ldr	r2, [r3, #4]
  
  /* Clear HPRE[3:0] bits */
  tmpreg &= ~RCC_CFGR_HPRE;
 8003f40:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
  
  /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
  tmpreg |= RCC_SYSCLK;
 8003f44:	4310      	orrs	r0, r2
  
  /* Store the new value */
  RCC->CFGR = tmpreg;
 8003f46:	6058      	str	r0, [r3, #4]
 8003f48:	4770      	bx	lr
 8003f4a:	bf00      	nop
 8003f4c:	40021000 	.word	0x40021000

08003f50 <RCC_PCLK1Config>:
  uint32_t tmpreg = 0;
  
  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));
  
  tmpreg = RCC->CFGR;
 8003f50:	4b03      	ldr	r3, [pc, #12]	; (8003f60 <RCC_PCLK1Config+0x10>)
 8003f52:	685a      	ldr	r2, [r3, #4]
  /* Clear PPRE1[2:0] bits */
  tmpreg &= ~RCC_CFGR_PPRE1;
 8003f54:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
  
  /* Set PPRE1[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK;
 8003f58:	4310      	orrs	r0, r2
  
  /* Store the new value */
  RCC->CFGR = tmpreg;
 8003f5a:	6058      	str	r0, [r3, #4]
 8003f5c:	4770      	bx	lr
 8003f5e:	bf00      	nop
 8003f60:	40021000 	.word	0x40021000

08003f64 <RCC_PCLK2Config>:
  uint32_t tmpreg = 0;
  
  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));
  
  tmpreg = RCC->CFGR;
 8003f64:	4b03      	ldr	r3, [pc, #12]	; (8003f74 <RCC_PCLK2Config+0x10>)
 8003f66:	685a      	ldr	r2, [r3, #4]
  /* Clear PPRE2[2:0] bits */
  tmpreg &= ~RCC_CFGR_PPRE2;
 8003f68:	f422 5260 	bic.w	r2, r2, #14336	; 0x3800
  /* Set PPRE2[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK << 3;
 8003f6c:	ea42 00c0 	orr.w	r0, r2, r0, lsl #3
  /* Store the new value */
  RCC->CFGR = tmpreg;
 8003f70:	6058      	str	r0, [r3, #4]
 8003f72:	4770      	bx	lr
 8003f74:	40021000 	.word	0x40021000

08003f78 <RCC_GetClocksFreq>:
{
  uint32_t tmp = 0, pllmull = 0, pllsource = 0, prediv1factor = 0, presc = 0, pllclk = 0;
  uint32_t apb2presc = 0, ahbpresc = 0;
  
  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 8003f78:	4b92      	ldr	r3, [pc, #584]	; (80041c4 <RCC_GetClocksFreq+0x24c>)
 8003f7a:	6859      	ldr	r1, [r3, #4]
 8003f7c:	f001 010c 	and.w	r1, r1, #12
  
  switch (tmp)
 8003f80:	2904      	cmp	r1, #4
  *           configuration based on this function will be incorrect.
  *    
  * @retval None
  */
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
 8003f82:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t apb2presc = 0, ahbpresc = 0;
  
  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
  
  switch (tmp)
 8003f86:	d005      	beq.n	8003f94 <RCC_GetClocksFreq+0x1c>
 8003f88:	2908      	cmp	r1, #8
 8003f8a:	d006      	beq.n	8003f9a <RCC_GetClocksFreq+0x22>
 8003f8c:	4a8e      	ldr	r2, [pc, #568]	; (80041c8 <RCC_GetClocksFreq+0x250>)
  {
    case 0x00:  /* HSI used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 8003f8e:	6002      	str	r2, [r0, #0]
  uint32_t apb2presc = 0, ahbpresc = 0;
  
  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
  
  switch (tmp)
 8003f90:	b9b9      	cbnz	r1, 8003fc2 <RCC_GetClocksFreq+0x4a>
 8003f92:	e017      	b.n	8003fc4 <RCC_GetClocksFreq+0x4c>
  {
    case 0x00:  /* HSI used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
      break;
    case 0x04:  /* HSE used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
 8003f94:	4a8c      	ldr	r2, [pc, #560]	; (80041c8 <RCC_GetClocksFreq+0x250>)
 8003f96:	6002      	str	r2, [r0, #0]
 8003f98:	e013      	b.n	8003fc2 <RCC_GetClocksFreq+0x4a>
      break;
    case 0x08:  /* PLL used as system clock */
      /* Get PLL clock source and multiplication factor ----------------------*/
      pllmull = RCC->CFGR & RCC_CFGR_PLLMULL;
 8003f9a:	685a      	ldr	r2, [r3, #4]
      pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
 8003f9c:	685c      	ldr	r4, [r3, #4]
      pllmull = ( pllmull >> 18) + 2;
 8003f9e:	f3c2 4283 	ubfx	r2, r2, #18, #4
      
      if (pllsource == 0x00)
 8003fa2:	03e1      	lsls	r1, r4, #15
      break;
    case 0x08:  /* PLL used as system clock */
      /* Get PLL clock source and multiplication factor ----------------------*/
      pllmull = RCC->CFGR & RCC_CFGR_PLLMULL;
      pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
      pllmull = ( pllmull >> 18) + 2;
 8003fa4:	f102 0202 	add.w	r2, r2, #2
      
      if (pllsource == 0x00)
 8003fa8:	d401      	bmi.n	8003fae <RCC_GetClocksFreq+0x36>
      {
        /* HSI oscillator clock divided by 2 selected as PLL clock entry */
        pllclk = (HSI_VALUE >> 1) * pllmull;
 8003faa:	4988      	ldr	r1, [pc, #544]	; (80041cc <RCC_GetClocksFreq+0x254>)
 8003fac:	e006      	b.n	8003fbc <RCC_GetClocksFreq+0x44>
      }
      else
      {
        prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
 8003fae:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
        /* HSE oscillator clock selected as PREDIV1 clock entry */
        pllclk = (HSE_VALUE / prediv1factor) * pllmull; 
 8003fb0:	4c85      	ldr	r4, [pc, #532]	; (80041c8 <RCC_GetClocksFreq+0x250>)
        /* HSI oscillator clock divided by 2 selected as PLL clock entry */
        pllclk = (HSI_VALUE >> 1) * pllmull;
      }
      else
      {
        prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
 8003fb2:	f001 010f 	and.w	r1, r1, #15
 8003fb6:	3101      	adds	r1, #1
        /* HSE oscillator clock selected as PREDIV1 clock entry */
        pllclk = (HSE_VALUE / prediv1factor) * pllmull; 
 8003fb8:	fbb4 f1f1 	udiv	r1, r4, r1
 8003fbc:	4351      	muls	r1, r2
      }
      RCC_Clocks->SYSCLK_Frequency = pllclk;      
 8003fbe:	6001      	str	r1, [r0, #0]
      break;
 8003fc0:	e000      	b.n	8003fc4 <RCC_GetClocksFreq+0x4c>
  *    
  * @retval None
  */
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
  uint32_t tmp = 0, pllmull = 0, pllsource = 0, prediv1factor = 0, presc = 0, pllclk = 0;
 8003fc2:	2100      	movs	r1, #0
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
      break;
  }
    /* Compute HCLK, PCLK clocks frequencies -----------------------------------*/
  /* Get HCLK prescaler */
  tmp = RCC->CFGR & RCC_CFGR_HPRE;
 8003fc4:	685a      	ldr	r2, [r3, #4]
  tmp = tmp >> 4;
  ahbpresc = APBAHBPrescTable[tmp]; 
 8003fc6:	4d82      	ldr	r5, [pc, #520]	; (80041d0 <RCC_GetClocksFreq+0x258>)
      break;
  }
    /* Compute HCLK, PCLK clocks frequencies -----------------------------------*/
  /* Get HCLK prescaler */
  tmp = RCC->CFGR & RCC_CFGR_HPRE;
  tmp = tmp >> 4;
 8003fc8:	f3c2 1203 	ubfx	r2, r2, #4, #4
  ahbpresc = APBAHBPrescTable[tmp]; 
 8003fcc:	5caf      	ldrb	r7, [r5, r2]
  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> ahbpresc;
 8003fce:	6802      	ldr	r2, [r0, #0]
  }
    /* Compute HCLK, PCLK clocks frequencies -----------------------------------*/
  /* Get HCLK prescaler */
  tmp = RCC->CFGR & RCC_CFGR_HPRE;
  tmp = tmp >> 4;
  ahbpresc = APBAHBPrescTable[tmp]; 
 8003fd0:	b2ff      	uxtb	r7, r7
  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> ahbpresc;
 8003fd2:	fa22 f607 	lsr.w	r6, r2, r7
 8003fd6:	6046      	str	r6, [r0, #4]

  /* Get PCLK1 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE1;
 8003fd8:	685c      	ldr	r4, [r3, #4]
  tmp = tmp >> 8;
 8003fda:	f3c4 2402 	ubfx	r4, r4, #8, #3
  presc = APBAHBPrescTable[tmp];
 8003fde:	5d2c      	ldrb	r4, [r5, r4]
  /* PCLK1 clock frequency */
  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 8003fe0:	fa26 f404 	lsr.w	r4, r6, r4
 8003fe4:	6084      	str	r4, [r0, #8]
  
  /* Get PCLK2 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE2;
 8003fe6:	f8d3 c004 	ldr.w	ip, [r3, #4]
  tmp = tmp >> 11;
 8003fea:	f3cc 2cc2 	ubfx	ip, ip, #11, #3
  apb2presc = APBAHBPrescTable[tmp];
 8003fee:	f815 c00c 	ldrb.w	ip, [r5, ip]
 8003ff2:	fa5f fc8c 	uxtb.w	ip, ip
  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> apb2presc;
 8003ff6:	fa26 f60c 	lsr.w	r6, r6, ip
 8003ffa:	60c6      	str	r6, [r0, #12]
  
  /* Get ADC12CLK prescaler */
  tmp = RCC->CFGR2 & RCC_CFGR2_ADCPRE12;
 8003ffc:	f8d3 802c 	ldr.w	r8, [r3, #44]	; 0x2c
  tmp = tmp >> 4;
 8004000:	f3c8 1804 	ubfx	r8, r8, #4, #5
  presc = ADCPrescTable[tmp];
 8004004:	eb05 0848 	add.w	r8, r5, r8, lsl #1
 8004008:	f8b8 8010 	ldrh.w	r8, [r8, #16]
 800400c:	fa1f f888 	uxth.w	r8, r8
  if ((presc & 0x10) != 0)
 8004010:	f018 0f10 	tst.w	r8, #16
  {
     /* ADC12CLK clock frequency is derived from PLL clock */
     RCC_Clocks->ADC12CLK_Frequency = pllclk / presc;
 8004014:	bf1a      	itte	ne
 8004016:	fbb1 f8f8 	udivne	r8, r1, r8
 800401a:	f8c0 8010 	strne.w	r8, [r0, #16]
  }
  else
  {
   /* ADC12CLK clock frequency is AHB clock */
     RCC_Clocks->ADC12CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 800401e:	6102      	streq	r2, [r0, #16]
  }
  
  /* Get ADC34CLK prescaler */
  tmp = RCC->CFGR2 & RCC_CFGR2_ADCPRE34;
 8004020:	f8d3 802c 	ldr.w	r8, [r3, #44]	; 0x2c
  tmp = tmp >> 9;
 8004024:	f3c8 2844 	ubfx	r8, r8, #9, #5
  presc = ADCPrescTable[tmp];
 8004028:	eb05 0548 	add.w	r5, r5, r8, lsl #1
 800402c:	8a2d      	ldrh	r5, [r5, #16]
 800402e:	b2ad      	uxth	r5, r5
  if ((presc & 0x10) != 0)
 8004030:	f015 0f10 	tst.w	r5, #16
  {
     /* ADC34CLK clock frequency is derived from PLL clock */
     RCC_Clocks->ADC34CLK_Frequency = pllclk / presc;
 8004034:	bf1a      	itte	ne
 8004036:	fbb1 f5f5 	udivne	r5, r1, r5
 800403a:	6145      	strne	r5, [r0, #20]
  }
  else
  {
   /* ADC34CLK clock frequency is AHB clock */
     RCC_Clocks->ADC34CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 800403c:	6142      	streq	r2, [r0, #20]
  }

  /* I2C1CLK clock frequency */
  if((RCC->CFGR3 & RCC_CFGR3_I2C1SW) != RCC_CFGR3_I2C1SW)
 800403e:	6b1d      	ldr	r5, [r3, #48]	; 0x30
 8004040:	06ed      	lsls	r5, r5, #27
  {
    /* I2C1 Clock is HSI Osc. */
    RCC_Clocks->I2C1CLK_Frequency = HSI_VALUE;
 8004042:	bf5a      	itte	pl
 8004044:	4d60      	ldrpl	r5, [pc, #384]	; (80041c8 <RCC_GetClocksFreq+0x250>)
 8004046:	6185      	strpl	r5, [r0, #24]
  }
  else
  {
    /* I2C1 Clock is System Clock */
    RCC_Clocks->I2C1CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 8004048:	6182      	strmi	r2, [r0, #24]
  }

  /* I2C2CLK clock frequency */
  if((RCC->CFGR3 & RCC_CFGR3_I2C2SW) != RCC_CFGR3_I2C2SW)
 800404a:	6b1d      	ldr	r5, [r3, #48]	; 0x30
 800404c:	06ad      	lsls	r5, r5, #26
  {
    /* I2C2 Clock is HSI Osc. */
    RCC_Clocks->I2C2CLK_Frequency = HSI_VALUE;
 800404e:	bf5a      	itte	pl
 8004050:	4d5d      	ldrpl	r5, [pc, #372]	; (80041c8 <RCC_GetClocksFreq+0x250>)
 8004052:	61c5      	strpl	r5, [r0, #28]
  }
  else
  {
    /* I2C2 Clock is System Clock */
    RCC_Clocks->I2C2CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 8004054:	61c2      	strmi	r2, [r0, #28]
  }
  
    /* TIM1CLK clock frequency */
  if(((RCC->CFGR3 & RCC_CFGR3_TIM1SW) == RCC_CFGR3_TIM1SW)&& (RCC_Clocks->SYSCLK_Frequency == pllclk) \
 8004056:	6b1d      	ldr	r5, [r3, #48]	; 0x30
 8004058:	05ed      	lsls	r5, r5, #23
 800405a:	d506      	bpl.n	800406a <RCC_GetClocksFreq+0xf2>
 800405c:	428a      	cmp	r2, r1
 800405e:	d104      	bne.n	800406a <RCC_GetClocksFreq+0xf2>
  && (apb2presc == ahbpresc)) 
 8004060:	45bc      	cmp	ip, r7
 8004062:	d102      	bne.n	800406a <RCC_GetClocksFreq+0xf2>
  {
    /* TIM1 Clock is 2 * pllclk */
    RCC_Clocks->TIM1CLK_Frequency = pllclk * 2;
 8004064:	0055      	lsls	r5, r2, #1
 8004066:	6205      	str	r5, [r0, #32]
 8004068:	e000      	b.n	800406c <RCC_GetClocksFreq+0xf4>
  }
  else
  {
    /* TIM1 Clock is APB2 clock. */
    RCC_Clocks->TIM1CLK_Frequency = RCC_Clocks->PCLK2_Frequency;
 800406a:	6206      	str	r6, [r0, #32]
  }

    /* TIM8CLK clock frequency */
  if(((RCC->CFGR3 & RCC_CFGR3_TIM8SW) == RCC_CFGR3_TIM8SW)&& (RCC_Clocks->SYSCLK_Frequency == pllclk) \
 800406c:	6b1d      	ldr	r5, [r3, #48]	; 0x30
 800406e:	05ad      	lsls	r5, r5, #22
 8004070:	d506      	bpl.n	8004080 <RCC_GetClocksFreq+0x108>
 8004072:	428a      	cmp	r2, r1
 8004074:	d104      	bne.n	8004080 <RCC_GetClocksFreq+0x108>
  && (apb2presc == ahbpresc))
 8004076:	45bc      	cmp	ip, r7
 8004078:	d102      	bne.n	8004080 <RCC_GetClocksFreq+0x108>
  {
    /* TIM8 Clock is 2 * pllclk */
    RCC_Clocks->TIM8CLK_Frequency = pllclk * 2;
 800407a:	0051      	lsls	r1, r2, #1
 800407c:	6241      	str	r1, [r0, #36]	; 0x24
 800407e:	e000      	b.n	8004082 <RCC_GetClocksFreq+0x10a>
  }
  else
  {
    /* TIM8 Clock is APB2 clock. */
    RCC_Clocks->TIM8CLK_Frequency = RCC_Clocks->PCLK2_Frequency;
 8004080:	6246      	str	r6, [r0, #36]	; 0x24
  }
  
  /* USART1CLK clock frequency */
  if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == 0x0)
 8004082:	6b1d      	ldr	r5, [r3, #48]	; 0x30
 8004084:	494f      	ldr	r1, [pc, #316]	; (80041c4 <RCC_GetClocksFreq+0x24c>)
 8004086:	07ad      	lsls	r5, r5, #30
 8004088:	d101      	bne.n	800408e <RCC_GetClocksFreq+0x116>
  {
    /* USART Clock is PCLK */
    RCC_Clocks->USART1CLK_Frequency = RCC_Clocks->PCLK2_Frequency;
 800408a:	6286      	str	r6, [r0, #40]	; 0x28
 800408c:	e015      	b.n	80040ba <RCC_GetClocksFreq+0x142>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == RCC_CFGR3_USART1SW_0)
 800408e:	6b0d      	ldr	r5, [r1, #48]	; 0x30
 8004090:	f005 0503 	and.w	r5, r5, #3
 8004094:	2d01      	cmp	r5, #1
 8004096:	d101      	bne.n	800409c <RCC_GetClocksFreq+0x124>
  {
    /* USART Clock is System Clock */
    RCC_Clocks->USART1CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 8004098:	6282      	str	r2, [r0, #40]	; 0x28
 800409a:	e00e      	b.n	80040ba <RCC_GetClocksFreq+0x142>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == RCC_CFGR3_USART1SW_1)
 800409c:	6b0d      	ldr	r5, [r1, #48]	; 0x30
 800409e:	f005 0503 	and.w	r5, r5, #3
 80040a2:	2d02      	cmp	r5, #2
 80040a4:	d102      	bne.n	80040ac <RCC_GetClocksFreq+0x134>
  {
    /* USART Clock is LSE Osc. */
    RCC_Clocks->USART1CLK_Frequency = LSE_VALUE;
 80040a6:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 80040aa:	e005      	b.n	80040b8 <RCC_GetClocksFreq+0x140>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == RCC_CFGR3_USART1SW)
 80040ac:	6b09      	ldr	r1, [r1, #48]	; 0x30
 80040ae:	f001 0103 	and.w	r1, r1, #3
 80040b2:	2903      	cmp	r1, #3
 80040b4:	d101      	bne.n	80040ba <RCC_GetClocksFreq+0x142>
  {
    /* USART Clock is HSI Osc. */
    RCC_Clocks->USART1CLK_Frequency = HSI_VALUE;
 80040b6:	4944      	ldr	r1, [pc, #272]	; (80041c8 <RCC_GetClocksFreq+0x250>)
 80040b8:	6281      	str	r1, [r0, #40]	; 0x28
  }

  /* USART2CLK clock frequency */
  if((RCC->CFGR3 & RCC_CFGR3_USART2SW) == 0x0)
 80040ba:	6b1d      	ldr	r5, [r3, #48]	; 0x30
 80040bc:	4941      	ldr	r1, [pc, #260]	; (80041c4 <RCC_GetClocksFreq+0x24c>)
 80040be:	f415 3f40 	tst.w	r5, #196608	; 0x30000
 80040c2:	d101      	bne.n	80040c8 <RCC_GetClocksFreq+0x150>
  {
    /* USART Clock is PCLK */
    RCC_Clocks->USART2CLK_Frequency = RCC_Clocks->PCLK1_Frequency;
 80040c4:	62c4      	str	r4, [r0, #44]	; 0x2c
 80040c6:	e018      	b.n	80040fa <RCC_GetClocksFreq+0x182>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART2SW) == RCC_CFGR3_USART2SW_0)
 80040c8:	6b0d      	ldr	r5, [r1, #48]	; 0x30
 80040ca:	f405 3540 	and.w	r5, r5, #196608	; 0x30000
 80040ce:	f5b5 3f80 	cmp.w	r5, #65536	; 0x10000
 80040d2:	d101      	bne.n	80040d8 <RCC_GetClocksFreq+0x160>
  {
    /* USART Clock is System Clock */
    RCC_Clocks->USART2CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 80040d4:	62c2      	str	r2, [r0, #44]	; 0x2c
 80040d6:	e010      	b.n	80040fa <RCC_GetClocksFreq+0x182>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART2SW) == RCC_CFGR3_USART2SW_1)
 80040d8:	6b0d      	ldr	r5, [r1, #48]	; 0x30
 80040da:	f405 3540 	and.w	r5, r5, #196608	; 0x30000
 80040de:	f5b5 3f00 	cmp.w	r5, #131072	; 0x20000
 80040e2:	d102      	bne.n	80040ea <RCC_GetClocksFreq+0x172>
  {
    /* USART Clock is LSE Osc. */
    RCC_Clocks->USART2CLK_Frequency = LSE_VALUE;
 80040e4:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 80040e8:	e006      	b.n	80040f8 <RCC_GetClocksFreq+0x180>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART2SW) == RCC_CFGR3_USART2SW)
 80040ea:	6b09      	ldr	r1, [r1, #48]	; 0x30
 80040ec:	f401 3140 	and.w	r1, r1, #196608	; 0x30000
 80040f0:	f5b1 3f40 	cmp.w	r1, #196608	; 0x30000
 80040f4:	d101      	bne.n	80040fa <RCC_GetClocksFreq+0x182>
  {
    /* USART Clock is HSI Osc. */
    RCC_Clocks->USART2CLK_Frequency = HSI_VALUE;
 80040f6:	4934      	ldr	r1, [pc, #208]	; (80041c8 <RCC_GetClocksFreq+0x250>)
 80040f8:	62c1      	str	r1, [r0, #44]	; 0x2c
  }    

  /* USART3CLK clock frequency */
  if((RCC->CFGR3 & RCC_CFGR3_USART3SW) == 0x0)
 80040fa:	6b1d      	ldr	r5, [r3, #48]	; 0x30
 80040fc:	4931      	ldr	r1, [pc, #196]	; (80041c4 <RCC_GetClocksFreq+0x24c>)
 80040fe:	f415 2f40 	tst.w	r5, #786432	; 0xc0000
 8004102:	d101      	bne.n	8004108 <RCC_GetClocksFreq+0x190>
  {
    /* USART Clock is PCLK */
    RCC_Clocks->USART3CLK_Frequency = RCC_Clocks->PCLK1_Frequency;
 8004104:	6304      	str	r4, [r0, #48]	; 0x30
 8004106:	e018      	b.n	800413a <RCC_GetClocksFreq+0x1c2>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART3SW) == RCC_CFGR3_USART3SW_0)
 8004108:	6b0d      	ldr	r5, [r1, #48]	; 0x30
 800410a:	f405 2540 	and.w	r5, r5, #786432	; 0xc0000
 800410e:	f5b5 2f80 	cmp.w	r5, #262144	; 0x40000
 8004112:	d101      	bne.n	8004118 <RCC_GetClocksFreq+0x1a0>
  {
    /* USART Clock is System Clock */
    RCC_Clocks->USART3CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 8004114:	6302      	str	r2, [r0, #48]	; 0x30
 8004116:	e010      	b.n	800413a <RCC_GetClocksFreq+0x1c2>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART3SW) == RCC_CFGR3_USART3SW_1)
 8004118:	6b0d      	ldr	r5, [r1, #48]	; 0x30
 800411a:	f405 2540 	and.w	r5, r5, #786432	; 0xc0000
 800411e:	f5b5 2f00 	cmp.w	r5, #524288	; 0x80000
 8004122:	d102      	bne.n	800412a <RCC_GetClocksFreq+0x1b2>
  {
    /* USART Clock is LSE Osc. */
    RCC_Clocks->USART3CLK_Frequency = LSE_VALUE;
 8004124:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8004128:	e006      	b.n	8004138 <RCC_GetClocksFreq+0x1c0>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART3SW) == RCC_CFGR3_USART3SW)
 800412a:	6b09      	ldr	r1, [r1, #48]	; 0x30
 800412c:	f401 2140 	and.w	r1, r1, #786432	; 0xc0000
 8004130:	f5b1 2f40 	cmp.w	r1, #786432	; 0xc0000
 8004134:	d101      	bne.n	800413a <RCC_GetClocksFreq+0x1c2>
  {
    /* USART Clock is HSI Osc. */
    RCC_Clocks->USART3CLK_Frequency = HSI_VALUE;
 8004136:	4924      	ldr	r1, [pc, #144]	; (80041c8 <RCC_GetClocksFreq+0x250>)
 8004138:	6301      	str	r1, [r0, #48]	; 0x30
  }
  
    /* UART4CLK clock frequency */
  if((RCC->CFGR3 & RCC_CFGR3_UART4SW) == 0x0)
 800413a:	6b1d      	ldr	r5, [r3, #48]	; 0x30
 800413c:	4921      	ldr	r1, [pc, #132]	; (80041c4 <RCC_GetClocksFreq+0x24c>)
 800413e:	f415 1f40 	tst.w	r5, #3145728	; 0x300000
 8004142:	d101      	bne.n	8004148 <RCC_GetClocksFreq+0x1d0>
  {
    /* USART Clock is PCLK */
    RCC_Clocks->UART4CLK_Frequency = RCC_Clocks->PCLK1_Frequency;
 8004144:	6344      	str	r4, [r0, #52]	; 0x34
 8004146:	e018      	b.n	800417a <RCC_GetClocksFreq+0x202>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_UART4SW) == RCC_CFGR3_UART4SW_0)
 8004148:	6b0d      	ldr	r5, [r1, #48]	; 0x30
 800414a:	f405 1540 	and.w	r5, r5, #3145728	; 0x300000
 800414e:	f5b5 1f80 	cmp.w	r5, #1048576	; 0x100000
 8004152:	d101      	bne.n	8004158 <RCC_GetClocksFreq+0x1e0>
  {
    /* USART Clock is System Clock */
    RCC_Clocks->UART4CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 8004154:	6342      	str	r2, [r0, #52]	; 0x34
 8004156:	e010      	b.n	800417a <RCC_GetClocksFreq+0x202>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_UART4SW) == RCC_CFGR3_UART4SW_1)
 8004158:	6b0d      	ldr	r5, [r1, #48]	; 0x30
 800415a:	f405 1540 	and.w	r5, r5, #3145728	; 0x300000
 800415e:	f5b5 1f00 	cmp.w	r5, #2097152	; 0x200000
 8004162:	d102      	bne.n	800416a <RCC_GetClocksFreq+0x1f2>
  {
    /* USART Clock is LSE Osc. */
    RCC_Clocks->UART4CLK_Frequency = LSE_VALUE;
 8004164:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8004168:	e006      	b.n	8004178 <RCC_GetClocksFreq+0x200>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_UART4SW) == RCC_CFGR3_UART4SW)
 800416a:	6b09      	ldr	r1, [r1, #48]	; 0x30
 800416c:	f401 1140 	and.w	r1, r1, #3145728	; 0x300000
 8004170:	f5b1 1f40 	cmp.w	r1, #3145728	; 0x300000
 8004174:	d101      	bne.n	800417a <RCC_GetClocksFreq+0x202>
  {
    /* USART Clock is HSI Osc. */
    RCC_Clocks->UART4CLK_Frequency = HSI_VALUE;
 8004176:	4914      	ldr	r1, [pc, #80]	; (80041c8 <RCC_GetClocksFreq+0x250>)
 8004178:	6341      	str	r1, [r0, #52]	; 0x34
  }   
  
  /* UART5CLK clock frequency */
  if((RCC->CFGR3 & RCC_CFGR3_UART5SW) == 0x0)
 800417a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800417c:	4911      	ldr	r1, [pc, #68]	; (80041c4 <RCC_GetClocksFreq+0x24c>)
 800417e:	f413 0f40 	tst.w	r3, #12582912	; 0xc00000
 8004182:	d102      	bne.n	800418a <RCC_GetClocksFreq+0x212>
  {
    /* USART Clock is PCLK */
    RCC_Clocks->UART5CLK_Frequency = RCC_Clocks->PCLK1_Frequency;
 8004184:	6384      	str	r4, [r0, #56]	; 0x38
 8004186:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  }
  else if((RCC->CFGR3 & RCC_CFGR3_UART5SW) == RCC_CFGR3_UART5SW_0)
 800418a:	6b0b      	ldr	r3, [r1, #48]	; 0x30
 800418c:	f403 0340 	and.w	r3, r3, #12582912	; 0xc00000
 8004190:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 8004194:	d102      	bne.n	800419c <RCC_GetClocksFreq+0x224>
  {
    /* USART Clock is System Clock */
    RCC_Clocks->UART5CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 8004196:	6382      	str	r2, [r0, #56]	; 0x38
 8004198:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  }
  else if((RCC->CFGR3 & RCC_CFGR3_UART5SW) == RCC_CFGR3_UART5SW_1)
 800419c:	6b0b      	ldr	r3, [r1, #48]	; 0x30
 800419e:	f403 0340 	and.w	r3, r3, #12582912	; 0xc00000
 80041a2:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 80041a6:	d102      	bne.n	80041ae <RCC_GetClocksFreq+0x236>
  {
    /* USART Clock is LSE Osc. */
    RCC_Clocks->UART5CLK_Frequency = LSE_VALUE;
 80041a8:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 80041ac:	e006      	b.n	80041bc <RCC_GetClocksFreq+0x244>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_UART5SW) == RCC_CFGR3_UART5SW)
 80041ae:	6b0b      	ldr	r3, [r1, #48]	; 0x30
 80041b0:	f403 0340 	and.w	r3, r3, #12582912	; 0xc00000
 80041b4:	f5b3 0f40 	cmp.w	r3, #12582912	; 0xc00000
 80041b8:	d101      	bne.n	80041be <RCC_GetClocksFreq+0x246>
  {
    /* USART Clock is HSI Osc. */
    RCC_Clocks->UART5CLK_Frequency = HSI_VALUE;
 80041ba:	4b03      	ldr	r3, [pc, #12]	; (80041c8 <RCC_GetClocksFreq+0x250>)
 80041bc:	6383      	str	r3, [r0, #56]	; 0x38
 80041be:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80041c2:	bf00      	nop
 80041c4:	40021000 	.word	0x40021000
 80041c8:	007a1200 	.word	0x007a1200
 80041cc:	003d0900 	.word	0x003d0900
 80041d0:	20000002 	.word	0x20000002

080041d4 <RCC_ADCCLKConfig>:
  assert_param(IS_RCC_ADCCLK(RCC_PLLCLK));

  tmp = (RCC_PLLCLK >> 28);
  
  /* Clears ADCPRE34 bits */
  if (tmp != 0)
 80041d4:	0f03      	lsrs	r3, r0, #28
 80041d6:	4b06      	ldr	r3, [pc, #24]	; (80041f0 <RCC_ADCCLKConfig+0x1c>)
  {
    RCC->CFGR2 &= ~RCC_CFGR2_ADCPRE34;
 80041d8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80041da:	bf14      	ite	ne
 80041dc:	f422 5278 	bicne.w	r2, r2, #15872	; 0x3e00
  }
   /* Clears ADCPRE12 bits */
  else
  {
    RCC->CFGR2 &= ~RCC_CFGR2_ADCPRE12;
 80041e0:	f422 72f8 	biceq.w	r2, r2, #496	; 0x1f0
 80041e4:	62da      	str	r2, [r3, #44]	; 0x2c
  }
  /* Set ADCPRE bits according to RCC_PLLCLK value */
  RCC->CFGR2 |= RCC_PLLCLK;
 80041e6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80041e8:	4310      	orrs	r0, r2
 80041ea:	62d8      	str	r0, [r3, #44]	; 0x2c
 80041ec:	4770      	bx	lr
 80041ee:	bf00      	nop
 80041f0:	40021000 	.word	0x40021000

080041f4 <RCC_I2CCLKConfig>:
  assert_param(IS_RCC_I2CCLK(RCC_I2CCLK));

  tmp = (RCC_I2CCLK >> 28);
  
  /* Clear I2CSW bit */
  if (tmp != 0)
 80041f4:	0f03      	lsrs	r3, r0, #28
 80041f6:	4b06      	ldr	r3, [pc, #24]	; (8004210 <RCC_I2CCLKConfig+0x1c>)
  {
    RCC->CFGR3 &= ~RCC_CFGR3_I2C2SW;
 80041f8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80041fa:	bf14      	ite	ne
 80041fc:	f022 0220 	bicne.w	r2, r2, #32
  }
  else
  {
    RCC->CFGR3 &= ~RCC_CFGR3_I2C1SW;
 8004200:	f022 0210 	biceq.w	r2, r2, #16
 8004204:	631a      	str	r2, [r3, #48]	; 0x30
  }
  /* Set I2CSW bits according to RCC_I2CCLK value */
  RCC->CFGR3 |= RCC_I2CCLK;
 8004206:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8004208:	4310      	orrs	r0, r2
 800420a:	6318      	str	r0, [r3, #48]	; 0x30
 800420c:	4770      	bx	lr
 800420e:	bf00      	nop
 8004210:	40021000 	.word	0x40021000

08004214 <RCC_TIMCLKConfig>:
  assert_param(IS_RCC_TIMCLK(RCC_TIMCLK));

  tmp = (RCC_TIMCLK >> 28);
  
  /* Clear I2CSW bit */
  if (tmp != 0)
 8004214:	0f03      	lsrs	r3, r0, #28
 8004216:	4b06      	ldr	r3, [pc, #24]	; (8004230 <RCC_TIMCLKConfig+0x1c>)
  {
    RCC->CFGR3 &= ~RCC_CFGR3_TIM8SW;
 8004218:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800421a:	bf14      	ite	ne
 800421c:	f422 7200 	bicne.w	r2, r2, #512	; 0x200
  }
  else
  {
    RCC->CFGR3 &= ~RCC_CFGR3_TIM1SW;
 8004220:	f422 7280 	biceq.w	r2, r2, #256	; 0x100
 8004224:	631a      	str	r2, [r3, #48]	; 0x30
  }
  /* Set I2CSW bits according to RCC_TIMCLK value */
  RCC->CFGR3 |= RCC_TIMCLK;
 8004226:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8004228:	4310      	orrs	r0, r2
 800422a:	6318      	str	r0, [r3, #48]	; 0x30
 800422c:	4770      	bx	lr
 800422e:	bf00      	nop
 8004230:	40021000 	.word	0x40021000

08004234 <RCC_USARTCLKConfig>:
  uint32_t tmp = 0;
  
  /* Check the parameters */
  assert_param(IS_RCC_USARTCLK(RCC_USARTCLK));

  tmp = (RCC_USARTCLK >> 28);
 8004234:	0f02      	lsrs	r2, r0, #28

  /* Clear USARTSW[1:0] bit */
  switch (tmp)
 8004236:	3a01      	subs	r2, #1
 8004238:	4b0f      	ldr	r3, [pc, #60]	; (8004278 <RCC_USARTCLKConfig+0x44>)
 800423a:	2a04      	cmp	r2, #4
 800423c:	d818      	bhi.n	8004270 <RCC_USARTCLKConfig+0x3c>
 800423e:	e8df f002 	tbb	[pc, r2]
 8004242:	0703      	.short	0x0703
 8004244:	0f0b      	.short	0x0f0b
 8004246:	13          	.byte	0x13
 8004247:	00          	.byte	0x00
  {
    case 0x01:  /* clear USART1SW */
      RCC->CFGR3 &= ~RCC_CFGR3_USART1SW;
 8004248:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800424a:	f022 0203 	bic.w	r2, r2, #3
 800424e:	e00e      	b.n	800426e <RCC_USARTCLKConfig+0x3a>
      break;
    case 0x02:  /* clear USART2SW */
      RCC->CFGR3 &= ~RCC_CFGR3_USART2SW;
 8004250:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8004252:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
 8004256:	e00a      	b.n	800426e <RCC_USARTCLKConfig+0x3a>
      break;
    case 0x03:  /* clear USART3SW */
      RCC->CFGR3 &= ~RCC_CFGR3_USART3SW;
 8004258:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800425a:	f422 2240 	bic.w	r2, r2, #786432	; 0xc0000
 800425e:	e006      	b.n	800426e <RCC_USARTCLKConfig+0x3a>
      break;
    case 0x04:  /* clear UART4SW */
      RCC->CFGR3 &= ~RCC_CFGR3_UART4SW;
 8004260:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8004262:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
 8004266:	e002      	b.n	800426e <RCC_USARTCLKConfig+0x3a>
      break;
    case 0x05:  /* clear UART5SW */
      RCC->CFGR3 &= ~RCC_CFGR3_UART5SW;
 8004268:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800426a:	f422 0240 	bic.w	r2, r2, #12582912	; 0xc00000
 800426e:	631a      	str	r2, [r3, #48]	; 0x30
    default:
      break;
  }

  /* Set USARTSW bits according to RCC_USARTCLK value */
  RCC->CFGR3 |= RCC_USARTCLK;
 8004270:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8004272:	4310      	orrs	r0, r2
 8004274:	6318      	str	r0, [r3, #48]	; 0x30
 8004276:	4770      	bx	lr
 8004278:	40021000 	.word	0x40021000

0800427c <RCC_USBCLKConfig>:
void RCC_USBCLKConfig(uint32_t RCC_USBCLKSource)
{
  /* Check the parameters */
  assert_param(IS_RCC_USBCLK_SOURCE(RCC_USBCLKSource));

  *(__IO uint32_t *) CFGR_USBPRE_BB = RCC_USBCLKSource;
 800427c:	4b01      	ldr	r3, [pc, #4]	; (8004284 <RCC_USBCLKConfig+0x8>)
 800427e:	6018      	str	r0, [r3, #0]
 8004280:	4770      	bx	lr
 8004282:	bf00      	nop
 8004284:	424200d8 	.word	0x424200d8

08004288 <RCC_RTCCLKConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
  
  /* Select the RTC clock source */
  RCC->BDCR |= RCC_RTCCLKSource;
 8004288:	4b02      	ldr	r3, [pc, #8]	; (8004294 <RCC_RTCCLKConfig+0xc>)
 800428a:	6a1a      	ldr	r2, [r3, #32]
 800428c:	4310      	orrs	r0, r2
 800428e:	6218      	str	r0, [r3, #32]
 8004290:	4770      	bx	lr
 8004292:	bf00      	nop
 8004294:	40021000 	.word	0x40021000

08004298 <RCC_I2SCLKConfig>:
void RCC_I2SCLKConfig(uint32_t RCC_I2SCLKSource)
{
  /* Check the parameters */
  assert_param(IS_RCC_I2SCLK_SOURCE(RCC_I2SCLKSource));

  *(__IO uint32_t *) CFGR_I2SSRC_BB = RCC_I2SCLKSource;
 8004298:	4b01      	ldr	r3, [pc, #4]	; (80042a0 <RCC_I2SCLKConfig+0x8>)
 800429a:	6018      	str	r0, [r3, #0]
 800429c:	4770      	bx	lr
 800429e:	bf00      	nop
 80042a0:	424200dc 	.word	0x424200dc

080042a4 <RCC_RTCCLKCmd>:
void RCC_RTCCLKCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
 80042a4:	4b01      	ldr	r3, [pc, #4]	; (80042ac <RCC_RTCCLKCmd+0x8>)
 80042a6:	6018      	str	r0, [r3, #0]
 80042a8:	4770      	bx	lr
 80042aa:	bf00      	nop
 80042ac:	4242043c 	.word	0x4242043c

080042b0 <RCC_BackupResetCmd>:
void RCC_BackupResetCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
 80042b0:	4b01      	ldr	r3, [pc, #4]	; (80042b8 <RCC_BackupResetCmd+0x8>)
 80042b2:	6018      	str	r0, [r3, #0]
 80042b4:	4770      	bx	lr
 80042b6:	bf00      	nop
 80042b8:	42420440 	.word	0x42420440

080042bc <RCC_AHBPeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
{
 80042bc:	4b04      	ldr	r3, [pc, #16]	; (80042d0 <RCC_AHBPeriphClockCmd+0x14>)
  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    RCC->AHBENR |= RCC_AHBPeriph;
 80042be:	695a      	ldr	r2, [r3, #20]
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80042c0:	b109      	cbz	r1, 80042c6 <RCC_AHBPeriphClockCmd+0xa>
  {
    RCC->AHBENR |= RCC_AHBPeriph;
 80042c2:	4310      	orrs	r0, r2
 80042c4:	e001      	b.n	80042ca <RCC_AHBPeriphClockCmd+0xe>
  }
  else
  {
    RCC->AHBENR &= ~RCC_AHBPeriph;
 80042c6:	ea22 0000 	bic.w	r0, r2, r0
 80042ca:	6158      	str	r0, [r3, #20]
 80042cc:	4770      	bx	lr
 80042ce:	bf00      	nop
 80042d0:	40021000 	.word	0x40021000

080042d4 <RCC_APB2PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
 80042d4:	4b04      	ldr	r3, [pc, #16]	; (80042e8 <RCC_APB2PeriphClockCmd+0x14>)
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->APB2ENR |= RCC_APB2Periph;
 80042d6:	699a      	ldr	r2, [r3, #24]
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80042d8:	b109      	cbz	r1, 80042de <RCC_APB2PeriphClockCmd+0xa>
  {
    RCC->APB2ENR |= RCC_APB2Periph;
 80042da:	4310      	orrs	r0, r2
 80042dc:	e001      	b.n	80042e2 <RCC_APB2PeriphClockCmd+0xe>
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
 80042de:	ea22 0000 	bic.w	r0, r2, r0
 80042e2:	6198      	str	r0, [r3, #24]
 80042e4:	4770      	bx	lr
 80042e6:	bf00      	nop
 80042e8:	40021000 	.word	0x40021000

080042ec <RCC_APB1PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
 80042ec:	4b04      	ldr	r3, [pc, #16]	; (8004300 <RCC_APB1PeriphClockCmd+0x14>)
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->APB1ENR |= RCC_APB1Periph;
 80042ee:	69da      	ldr	r2, [r3, #28]
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80042f0:	b109      	cbz	r1, 80042f6 <RCC_APB1PeriphClockCmd+0xa>
  {
    RCC->APB1ENR |= RCC_APB1Periph;
 80042f2:	4310      	orrs	r0, r2
 80042f4:	e001      	b.n	80042fa <RCC_APB1PeriphClockCmd+0xe>
  }
  else
  {
    RCC->APB1ENR &= ~RCC_APB1Periph;
 80042f6:	ea22 0000 	bic.w	r0, r2, r0
 80042fa:	61d8      	str	r0, [r3, #28]
 80042fc:	4770      	bx	lr
 80042fe:	bf00      	nop
 8004300:	40021000 	.word	0x40021000

08004304 <RCC_AHBPeriphResetCmd>:
  * @param  NewState: new state of the specified peripheral reset.
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHBPeriphResetCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
{
 8004304:	4b04      	ldr	r3, [pc, #16]	; (8004318 <RCC_AHBPeriphResetCmd+0x14>)
  assert_param(IS_RCC_AHB_RST_PERIPH(RCC_AHBPeriph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHBRSTR |= RCC_AHBPeriph;
 8004306:	6a9a      	ldr	r2, [r3, #40]	; 0x28
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB_RST_PERIPH(RCC_AHBPeriph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8004308:	b109      	cbz	r1, 800430e <RCC_AHBPeriphResetCmd+0xa>
  {
    RCC->AHBRSTR |= RCC_AHBPeriph;
 800430a:	4310      	orrs	r0, r2
 800430c:	e001      	b.n	8004312 <RCC_AHBPeriphResetCmd+0xe>
  }
  else
  {
    RCC->AHBRSTR &= ~RCC_AHBPeriph;
 800430e:	ea22 0000 	bic.w	r0, r2, r0
 8004312:	6298      	str	r0, [r3, #40]	; 0x28
 8004314:	4770      	bx	lr
 8004316:	bf00      	nop
 8004318:	40021000 	.word	0x40021000

0800431c <RCC_APB2PeriphResetCmd>:
  * @param  NewState: new state of the specified peripheral reset.
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
 800431c:	4b04      	ldr	r3, [pc, #16]	; (8004330 <RCC_APB2PeriphResetCmd+0x14>)
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->APB2RSTR |= RCC_APB2Periph;
 800431e:	68da      	ldr	r2, [r3, #12]
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8004320:	b109      	cbz	r1, 8004326 <RCC_APB2PeriphResetCmd+0xa>
  {
    RCC->APB2RSTR |= RCC_APB2Periph;
 8004322:	4310      	orrs	r0, r2
 8004324:	e001      	b.n	800432a <RCC_APB2PeriphResetCmd+0xe>
  }
  else
  {
    RCC->APB2RSTR &= ~RCC_APB2Periph;
 8004326:	ea22 0000 	bic.w	r0, r2, r0
 800432a:	60d8      	str	r0, [r3, #12]
 800432c:	4770      	bx	lr
 800432e:	bf00      	nop
 8004330:	40021000 	.word	0x40021000

08004334 <RCC_APB1PeriphResetCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
 8004334:	4b04      	ldr	r3, [pc, #16]	; (8004348 <RCC_APB1PeriphResetCmd+0x14>)
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
 8004336:	691a      	ldr	r2, [r3, #16]
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8004338:	b109      	cbz	r1, 800433e <RCC_APB1PeriphResetCmd+0xa>
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
 800433a:	4310      	orrs	r0, r2
 800433c:	e001      	b.n	8004342 <RCC_APB1PeriphResetCmd+0xe>
  }
  else
  {
    RCC->APB1RSTR &= ~RCC_APB1Periph;
 800433e:	ea22 0000 	bic.w	r0, r2, r0
 8004342:	6118      	str	r0, [r3, #16]
 8004344:	4770      	bx	lr
 8004346:	bf00      	nop
 8004348:	40021000 	.word	0x40021000

0800434c <RCC_ITConfig>:
  * @param  NewState: new state of the specified RCC interrupts.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
{
 800434c:	4b04      	ldr	r3, [pc, #16]	; (8004360 <RCC_ITConfig+0x14>)
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Perform Byte access to RCC_CIR[13:8] bits to enable the selected interrupts */
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
 800434e:	781a      	ldrb	r2, [r3, #0]
{
  /* Check the parameters */
  assert_param(IS_RCC_IT(RCC_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8004350:	b109      	cbz	r1, 8004356 <RCC_ITConfig+0xa>
  {
    /* Perform Byte access to RCC_CIR[13:8] bits to enable the selected interrupts */
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
 8004352:	4310      	orrs	r0, r2
 8004354:	e001      	b.n	800435a <RCC_ITConfig+0xe>
  }
  else
  {
    /* Perform Byte access to RCC_CIR[13:8] bits to disable the selected interrupts */
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
 8004356:	ea22 0000 	bic.w	r0, r2, r0
 800435a:	7018      	strb	r0, [r3, #0]
 800435c:	4770      	bx	lr
 800435e:	bf00      	nop
 8004360:	40021009 	.word	0x40021009

08004364 <RCC_GetFlagStatus>:
  assert_param(IS_RCC_FLAG(RCC_FLAG));

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;

   if (tmp == 0)               /* The flag to check is in CR register */
 8004364:	0943      	lsrs	r3, r0, #5
 8004366:	4a09      	ldr	r2, [pc, #36]	; (800438c <RCC_GetFlagStatus+0x28>)
 8004368:	d101      	bne.n	800436e <RCC_GetFlagStatus+0xa>
  {
    statusreg = RCC->CR;
 800436a:	6813      	ldr	r3, [r2, #0]
 800436c:	e007      	b.n	800437e <RCC_GetFlagStatus+0x1a>
  }
  else if (tmp == 1)          /* The flag to check is in BDCR register */
 800436e:	2b01      	cmp	r3, #1
 8004370:	d101      	bne.n	8004376 <RCC_GetFlagStatus+0x12>
  {
    statusreg = RCC->BDCR;
 8004372:	6a13      	ldr	r3, [r2, #32]
 8004374:	e003      	b.n	800437e <RCC_GetFlagStatus+0x1a>
  }
  else if (tmp == 4)          /* The flag to check is in CFGR register */
 8004376:	2b04      	cmp	r3, #4
  {
    statusreg = RCC->CFGR;
 8004378:	bf0c      	ite	eq
 800437a:	6853      	ldreq	r3, [r2, #4]
  }
  else                       /* The flag to check is in CSR register */
  {
    statusreg = RCC->CSR;
 800437c:	6a53      	ldrne	r3, [r2, #36]	; 0x24
  }

  /* Get the flag position */
  tmp = RCC_FLAG & FLAG_MASK;

  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
 800437e:	f000 001f 	and.w	r0, r0, #31
 8004382:	fa23 f000 	lsr.w	r0, r3, r0
  {
    bitstatus = RESET;
  }
  /* Return the flag status */
  return bitstatus;
}
 8004386:	f000 0001 	and.w	r0, r0, #1
 800438a:	4770      	bx	lr
 800438c:	40021000 	.word	0x40021000

08004390 <RCC_WaitForHSEStartUp>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: HSE oscillator is stable and ready to use
  *          - ERROR: HSE oscillator not yet ready
  */
ErrorStatus RCC_WaitForHSEStartUp(void)
{
 8004390:	b507      	push	{r0, r1, r2, lr}
  __IO uint32_t StartUpCounter = 0;
 8004392:	2300      	movs	r3, #0
 8004394:	9301      	str	r3, [sp, #4]
  FlagStatus HSEStatus = RESET;
  
  /* Wait till HSE is ready and if timeout is reached exit */
  do
  {
    HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
 8004396:	2011      	movs	r0, #17
 8004398:	f7ff ffe4 	bl	8004364 <RCC_GetFlagStatus>
    StartUpCounter++;  
 800439c:	9b01      	ldr	r3, [sp, #4]
 800439e:	3301      	adds	r3, #1
 80043a0:	9301      	str	r3, [sp, #4]
  } while((StartUpCounter != HSE_STARTUP_TIMEOUT) && (HSEStatus == RESET));
 80043a2:	9b01      	ldr	r3, [sp, #4]
 80043a4:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 80043a8:	d001      	beq.n	80043ae <RCC_WaitForHSEStartUp+0x1e>
 80043aa:	2800      	cmp	r0, #0
 80043ac:	d0f3      	beq.n	8004396 <RCC_WaitForHSEStartUp+0x6>
  
  if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
 80043ae:	2011      	movs	r0, #17
 80043b0:	f7ff ffd8 	bl	8004364 <RCC_GetFlagStatus>
  else
  {
    status = ERROR;
  }  
  return (status);
}
 80043b4:	3000      	adds	r0, #0
 80043b6:	bf18      	it	ne
 80043b8:	2001      	movne	r0, #1
 80043ba:	b003      	add	sp, #12
 80043bc:	f85d fb04 	ldr.w	pc, [sp], #4

080043c0 <RCC_ClearFlag>:
  * @retval None
  */
void RCC_ClearFlag(void)
{
  /* Set RMVF bit to clear the reset flags */
  RCC->CSR |= RCC_CSR_RMVF;
 80043c0:	4b02      	ldr	r3, [pc, #8]	; (80043cc <RCC_ClearFlag+0xc>)
 80043c2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80043c4:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 80043c8:	625a      	str	r2, [r3, #36]	; 0x24
 80043ca:	4770      	bx	lr
 80043cc:	40021000 	.word	0x40021000

080043d0 <RCC_GetITStatus>:
  
  /* Check the parameters */
  assert_param(IS_RCC_GET_IT(RCC_IT));
  
  /* Check the status of the specified RCC interrupt */
  if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
 80043d0:	4b03      	ldr	r3, [pc, #12]	; (80043e0 <RCC_GetITStatus+0x10>)
 80043d2:	689b      	ldr	r3, [r3, #8]
 80043d4:	4218      	tst	r0, r3
  {
    bitstatus = RESET;
  }
  /* Return the RCC_IT status */
  return  bitstatus;
}
 80043d6:	bf0c      	ite	eq
 80043d8:	2000      	moveq	r0, #0
 80043da:	2001      	movne	r0, #1
 80043dc:	4770      	bx	lr
 80043de:	bf00      	nop
 80043e0:	40021000 	.word	0x40021000

080043e4 <RCC_ClearITPendingBit>:
  /* Check the parameters */
  assert_param(IS_RCC_CLEAR_IT(RCC_IT));
  
  /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
     pending bits */
  *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
 80043e4:	4b01      	ldr	r3, [pc, #4]	; (80043ec <RCC_ClearITPendingBit+0x8>)
 80043e6:	7018      	strb	r0, [r3, #0]
 80043e8:	4770      	bx	lr
 80043ea:	bf00      	nop
 80043ec:	4002100a 	.word	0x4002100a

080043f0 <SPI_I2S_DeInit>:
  * @param  SPIx: To select the SPIx peripheral, where x can be: 1, 2 or 3 
  *         in SPI mode.
  * @retval None
  */
void SPI_I2S_DeInit(SPI_TypeDef* SPIx)
{
 80043f0:	b508      	push	{r3, lr}
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));

  if (SPIx == SPI1)
 80043f2:	4b15      	ldr	r3, [pc, #84]	; (8004448 <SPI_I2S_DeInit+0x58>)
 80043f4:	4298      	cmp	r0, r3
 80043f6:	d10b      	bne.n	8004410 <SPI_I2S_DeInit+0x20>
  {
    /* Enable SPI1 reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
 80043f8:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 80043fc:	2101      	movs	r1, #1
 80043fe:	f7ff ff8d 	bl	800431c <RCC_APB2PeriphResetCmd>
    /* Release SPI1 from reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
 8004402:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 8004406:	2100      	movs	r1, #0
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
      /* Release SPI3 from reset state */
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
    }
  }
}
 8004408:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  if (SPIx == SPI1)
  {
    /* Enable SPI1 reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
    /* Release SPI1 from reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
 800440c:	f7ff bf86 	b.w	800431c <RCC_APB2PeriphResetCmd>
  }
  else if (SPIx == SPI2)
 8004410:	4b0e      	ldr	r3, [pc, #56]	; (800444c <SPI_I2S_DeInit+0x5c>)
 8004412:	4298      	cmp	r0, r3
 8004414:	d107      	bne.n	8004426 <SPI_I2S_DeInit+0x36>
  {
    /* Enable SPI2 reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, ENABLE);
 8004416:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 800441a:	2101      	movs	r1, #1
 800441c:	f7ff ff8a 	bl	8004334 <RCC_APB1PeriphResetCmd>
    /* Release SPI2 from reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, DISABLE);
 8004420:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8004424:	e009      	b.n	800443a <SPI_I2S_DeInit+0x4a>
  }
  else
  {
    if (SPIx == SPI3)
 8004426:	4b0a      	ldr	r3, [pc, #40]	; (8004450 <SPI_I2S_DeInit+0x60>)
 8004428:	4298      	cmp	r0, r3
 800442a:	d10b      	bne.n	8004444 <SPI_I2S_DeInit+0x54>
    {
      /* Enable SPI3 reset state */
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
 800442c:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 8004430:	2101      	movs	r1, #1
 8004432:	f7ff ff7f 	bl	8004334 <RCC_APB1PeriphResetCmd>
      /* Release SPI3 from reset state */
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
 8004436:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 800443a:	2100      	movs	r1, #0
    }
  }
}
 800443c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    if (SPIx == SPI3)
    {
      /* Enable SPI3 reset state */
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
      /* Release SPI3 from reset state */
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
 8004440:	f7ff bf78 	b.w	8004334 <RCC_APB1PeriphResetCmd>
 8004444:	bd08      	pop	{r3, pc}
 8004446:	bf00      	nop
 8004448:	40013000 	.word	0x40013000
 800444c:	40003800 	.word	0x40003800
 8004450:	40003c00 	.word	0x40003c00

08004454 <SPI_StructInit>:
  */
void SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct)
{
/*--------------- Reset SPI init structure parameters values -----------------*/
  /* Initialize the SPI_Direction member */
  SPI_InitStruct->SPI_Direction = SPI_Direction_2Lines_FullDuplex;
 8004454:	2300      	movs	r3, #0
 8004456:	8003      	strh	r3, [r0, #0]
  /* Initialize the SPI_Mode member */
  SPI_InitStruct->SPI_Mode = SPI_Mode_Slave;
 8004458:	8043      	strh	r3, [r0, #2]
  /* Initialize the SPI_DataSize member */
  SPI_InitStruct->SPI_DataSize = SPI_DataSize_8b;
 800445a:	f44f 62e0 	mov.w	r2, #1792	; 0x700
  /* Initialize the SPI_CPOL member */
  SPI_InitStruct->SPI_CPOL = SPI_CPOL_Low;
 800445e:	80c3      	strh	r3, [r0, #6]
  /* Initialize the SPI_CPHA member */
  SPI_InitStruct->SPI_CPHA = SPI_CPHA_1Edge;
 8004460:	8103      	strh	r3, [r0, #8]
  /* Initialize the SPI_NSS member */
  SPI_InitStruct->SPI_NSS = SPI_NSS_Hard;
 8004462:	8143      	strh	r3, [r0, #10]
  /* Initialize the SPI_BaudRatePrescaler member */
  SPI_InitStruct->SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
 8004464:	8183      	strh	r3, [r0, #12]
  /* Initialize the SPI_FirstBit member */
  SPI_InitStruct->SPI_FirstBit = SPI_FirstBit_MSB;
 8004466:	81c3      	strh	r3, [r0, #14]
  /* Initialize the SPI_CRCPolynomial member */
  SPI_InitStruct->SPI_CRCPolynomial = 7;
 8004468:	2307      	movs	r3, #7
  /* Initialize the SPI_Direction member */
  SPI_InitStruct->SPI_Direction = SPI_Direction_2Lines_FullDuplex;
  /* Initialize the SPI_Mode member */
  SPI_InitStruct->SPI_Mode = SPI_Mode_Slave;
  /* Initialize the SPI_DataSize member */
  SPI_InitStruct->SPI_DataSize = SPI_DataSize_8b;
 800446a:	8082      	strh	r2, [r0, #4]
  /* Initialize the SPI_BaudRatePrescaler member */
  SPI_InitStruct->SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
  /* Initialize the SPI_FirstBit member */
  SPI_InitStruct->SPI_FirstBit = SPI_FirstBit_MSB;
  /* Initialize the SPI_CRCPolynomial member */
  SPI_InitStruct->SPI_CRCPolynomial = 7;
 800446c:	8203      	strh	r3, [r0, #16]
 800446e:	4770      	bx	lr

08004470 <SPI_Init>:
  * @param  SPI_InitStruct: pointer to a SPI_InitTypeDef structure that
  *         contains the configuration information for the specified SPI peripheral.
  * @retval None
  */
void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)
{
 8004470:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  assert_param(IS_SPI_BAUDRATE_PRESCALER(SPI_InitStruct->SPI_BaudRatePrescaler));
  assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct->SPI_FirstBit));
  assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct->SPI_CRCPolynomial));

  /* Configuring the SPI in master mode */
  if(SPI_InitStruct->SPI_Mode == SPI_Mode_Master)
 8004474:	f8b1 9002 	ldrh.w	r9, [r1, #2]
 8004478:	f8b1 8000 	ldrh.w	r8, [r1]
 800447c:	f8b1 c006 	ldrh.w	ip, [r1, #6]
 8004480:	890f      	ldrh	r7, [r1, #8]
 8004482:	894e      	ldrh	r6, [r1, #10]
 8004484:	898d      	ldrh	r5, [r1, #12]
 8004486:	89cc      	ldrh	r4, [r1, #14]
 8004488:	f8b1 a004 	ldrh.w	sl, [r1, #4]
 800448c:	f5b9 7f82 	cmp.w	r9, #260	; 0x104
 8004490:	d118      	bne.n	80044c4 <SPI_Init+0x54>
    /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
    /* Set LSBFirst bit according to SPI_FirstBit value */
    /* Set BR bits according to SPI_BaudRatePrescaler value */
    /* Set CPOL bit according to SPI_CPOL value */
    /* Set CPHA bit according to SPI_CPHA value */
    tmpreg |= (uint16_t)((uint16_t)(SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode) |
 8004492:	ea48 0c0c 	orr.w	ip, r8, ip
                         (uint16_t)((uint16_t)(SPI_InitStruct->SPI_CPOL | SPI_InitStruct->SPI_CPHA) |
                         (uint16_t)((uint16_t)(SPI_InitStruct->SPI_NSS | SPI_InitStruct->SPI_BaudRatePrescaler) | 
 8004496:	f44c 7c82 	orr.w	ip, ip, #260	; 0x104
 800449a:	ea4c 0707 	orr.w	r7, ip, r7
  /* Configuring the SPI in master mode */
  if(SPI_InitStruct->SPI_Mode == SPI_Mode_Master)
  {
/*---------------------------- SPIx CR1 Configuration ------------------------*/
    /* Get the SPIx CR1 value */
    tmpreg = SPIx->CR1;
 800449e:	8803      	ldrh	r3, [r0, #0]
    /* Set LSBFirst bit according to SPI_FirstBit value */
    /* Set BR bits according to SPI_BaudRatePrescaler value */
    /* Set CPOL bit according to SPI_CPOL value */
    /* Set CPHA bit according to SPI_CPHA value */
    tmpreg |= (uint16_t)((uint16_t)(SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode) |
                         (uint16_t)((uint16_t)(SPI_InitStruct->SPI_CPOL | SPI_InitStruct->SPI_CPHA) |
 80044a0:	433e      	orrs	r6, r7
 80044a2:	4335      	orrs	r5, r6
  {
/*---------------------------- SPIx CR1 Configuration ------------------------*/
    /* Get the SPIx CR1 value */
    tmpreg = SPIx->CR1;
    /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, MSTR, CPOL and CPHA bits */
    tmpreg &= CR1_CLEAR_MASK;
 80044a4:	f403 5341 	and.w	r3, r3, #12352	; 0x3040
    /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
    /* Set LSBFirst bit according to SPI_FirstBit value */
    /* Set BR bits according to SPI_BaudRatePrescaler value */
    /* Set CPOL bit according to SPI_CPOL value */
    /* Set CPHA bit according to SPI_CPHA value */
    tmpreg |= (uint16_t)((uint16_t)(SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode) |
 80044a8:	432c      	orrs	r4, r5
 80044aa:	431c      	orrs	r4, r3
 80044ac:	b2a4      	uxth	r4, r4
                         (uint16_t)((uint16_t)(SPI_InitStruct->SPI_CPOL | SPI_InitStruct->SPI_CPHA) |
                         (uint16_t)((uint16_t)(SPI_InitStruct->SPI_NSS | SPI_InitStruct->SPI_BaudRatePrescaler) | 
                         SPI_InitStruct->SPI_FirstBit)));
    /* Write to SPIx CR1 */
    SPIx->CR1 = tmpreg;
 80044ae:	8004      	strh	r4, [r0, #0]
    /*-------------------------Data Size Configuration -----------------------*/
    /* Get the SPIx CR2 value */
    tmpreg = SPIx->CR2;
 80044b0:	8882      	ldrh	r2, [r0, #4]
    /* Clear DS[3:0] bits */
    tmpreg &= (uint16_t)~SPI_CR2_DS;
 80044b2:	f422 6270 	bic.w	r2, r2, #3840	; 0xf00
 80044b6:	0412      	lsls	r2, r2, #16
 80044b8:	0c12      	lsrs	r2, r2, #16
    /* Configure SPIx: Data Size */
    tmpreg |= (uint16_t)(SPI_InitStruct->SPI_DataSize);
 80044ba:	ea42 020a 	orr.w	r2, r2, sl
 80044be:	b292      	uxth	r2, r2
    /* Write to SPIx CR2 */
    SPIx->CR2 = tmpreg;
 80044c0:	8082      	strh	r2, [r0, #4]
 80044c2:	e017      	b.n	80044f4 <SPI_Init+0x84>
  /* Configuring the SPI in slave mode */
  else
  {
/*---------------------------- Data size Configuration -----------------------*/
    /* Get the SPIx CR2 value */
    tmpreg = SPIx->CR2;
 80044c4:	8883      	ldrh	r3, [r0, #4]
    /* Clear DS[3:0] bits */
    tmpreg &= (uint16_t)~SPI_CR2_DS;
 80044c6:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
 80044ca:	041b      	lsls	r3, r3, #16
 80044cc:	0c1b      	lsrs	r3, r3, #16
    /* Configure SPIx: Data Size */
    tmpreg |= (uint16_t)(SPI_InitStruct->SPI_DataSize);
 80044ce:	ea43 030a 	orr.w	r3, r3, sl
    /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
    /* Set LSBFirst bit according to SPI_FirstBit value */
    /* Set BR bits according to SPI_BaudRatePrescaler value */
    /* Set CPOL bit according to SPI_CPOL value */
    /* Set CPHA bit according to SPI_CPHA value */
    tmpreg |= (uint16_t)((uint16_t)(SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode) | 
 80044d2:	ea49 0808 	orr.w	r8, r9, r8
    /* Get the SPIx CR2 value */
    tmpreg = SPIx->CR2;
    /* Clear DS[3:0] bits */
    tmpreg &= (uint16_t)~SPI_CR2_DS;
    /* Configure SPIx: Data Size */
    tmpreg |= (uint16_t)(SPI_InitStruct->SPI_DataSize);
 80044d6:	b29b      	uxth	r3, r3
    /* Set BR bits according to SPI_BaudRatePrescaler value */
    /* Set CPOL bit according to SPI_CPOL value */
    /* Set CPHA bit according to SPI_CPHA value */
    tmpreg |= (uint16_t)((uint16_t)(SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode) | 
                         (uint16_t)((uint16_t)(SPI_InitStruct->SPI_CPOL | SPI_InitStruct->SPI_CPHA) | 
                         (uint16_t)((uint16_t)(SPI_InitStruct->SPI_NSS | SPI_InitStruct->SPI_BaudRatePrescaler) | 
 80044d8:	ea48 0c0c 	orr.w	ip, r8, ip
    /* Clear DS[3:0] bits */
    tmpreg &= (uint16_t)~SPI_CR2_DS;
    /* Configure SPIx: Data Size */
    tmpreg |= (uint16_t)(SPI_InitStruct->SPI_DataSize);
    /* Write to SPIx CR2 */
    SPIx->CR2 = tmpreg;
 80044dc:	8083      	strh	r3, [r0, #4]
    /* Set BR bits according to SPI_BaudRatePrescaler value */
    /* Set CPOL bit according to SPI_CPOL value */
    /* Set CPHA bit according to SPI_CPHA value */
    tmpreg |= (uint16_t)((uint16_t)(SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode) | 
                         (uint16_t)((uint16_t)(SPI_InitStruct->SPI_CPOL | SPI_InitStruct->SPI_CPHA) | 
                         (uint16_t)((uint16_t)(SPI_InitStruct->SPI_NSS | SPI_InitStruct->SPI_BaudRatePrescaler) | 
 80044de:	ea4c 0707 	orr.w	r7, ip, r7
    tmpreg |= (uint16_t)(SPI_InitStruct->SPI_DataSize);
    /* Write to SPIx CR2 */
    SPIx->CR2 = tmpreg;
/*---------------------------- SPIx CR1 Configuration ------------------------*/
    /* Get the SPIx CR1 value */
    tmpreg = SPIx->CR1;
 80044e2:	8803      	ldrh	r3, [r0, #0]
    /* Set LSBFirst bit according to SPI_FirstBit value */
    /* Set BR bits according to SPI_BaudRatePrescaler value */
    /* Set CPOL bit according to SPI_CPOL value */
    /* Set CPHA bit according to SPI_CPHA value */
    tmpreg |= (uint16_t)((uint16_t)(SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode) | 
                         (uint16_t)((uint16_t)(SPI_InitStruct->SPI_CPOL | SPI_InitStruct->SPI_CPHA) | 
 80044e4:	433e      	orrs	r6, r7
 80044e6:	4335      	orrs	r5, r6
    SPIx->CR2 = tmpreg;
/*---------------------------- SPIx CR1 Configuration ------------------------*/
    /* Get the SPIx CR1 value */
    tmpreg = SPIx->CR1;
    /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, MSTR, CPOL and CPHA bits */
    tmpreg &= CR1_CLEAR_MASK;
 80044e8:	f403 5341 	and.w	r3, r3, #12352	; 0x3040
    /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
    /* Set LSBFirst bit according to SPI_FirstBit value */
    /* Set BR bits according to SPI_BaudRatePrescaler value */
    /* Set CPOL bit according to SPI_CPOL value */
    /* Set CPHA bit according to SPI_CPHA value */
    tmpreg |= (uint16_t)((uint16_t)(SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode) | 
 80044ec:	432c      	orrs	r4, r5
 80044ee:	431c      	orrs	r4, r3
 80044f0:	b2a4      	uxth	r4, r4
                         (uint16_t)((uint16_t)(SPI_InitStruct->SPI_CPOL | SPI_InitStruct->SPI_CPHA) | 
                         (uint16_t)((uint16_t)(SPI_InitStruct->SPI_NSS | SPI_InitStruct->SPI_BaudRatePrescaler) | 
                         SPI_InitStruct->SPI_FirstBit)));

    /* Write to SPIx CR1 */
    SPIx->CR1 = tmpreg;
 80044f2:	8004      	strh	r4, [r0, #0]
  }

  /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
  SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SMOD);
 80044f4:	8b83      	ldrh	r3, [r0, #28]
 80044f6:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 80044fa:	041b      	lsls	r3, r3, #16
 80044fc:	0c1b      	lsrs	r3, r3, #16
 80044fe:	8383      	strh	r3, [r0, #28]

/*---------------------------- SPIx CRCPOLY Configuration --------------------*/
  /* Write to SPIx CRCPOLY */
  SPIx->CRCPR = SPI_InitStruct->SPI_CRCPolynomial;
 8004500:	8a0b      	ldrh	r3, [r1, #16]
 8004502:	8203      	strh	r3, [r0, #16]
 8004504:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

08004508 <I2S_StructInit>:
  */
void I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct)
{
/*--------------- Reset I2S init structure parameters values -----------------*/
  /* Initialize the I2S_Mode member */
  I2S_InitStruct->I2S_Mode = I2S_Mode_SlaveTx;
 8004508:	2300      	movs	r3, #0

  /* Initialize the I2S_MCLKOutput member */
  I2S_InitStruct->I2S_MCLKOutput = I2S_MCLKOutput_Disable;

  /* Initialize the I2S_AudioFreq member */
  I2S_InitStruct->I2S_AudioFreq = I2S_AudioFreq_Default;
 800450a:	2202      	movs	r2, #2
  */
void I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct)
{
/*--------------- Reset I2S init structure parameters values -----------------*/
  /* Initialize the I2S_Mode member */
  I2S_InitStruct->I2S_Mode = I2S_Mode_SlaveTx;
 800450c:	8003      	strh	r3, [r0, #0]

  /* Initialize the I2S_Standard member */
  I2S_InitStruct->I2S_Standard = I2S_Standard_Phillips;
 800450e:	8043      	strh	r3, [r0, #2]

  /* Initialize the I2S_DataFormat member */
  I2S_InitStruct->I2S_DataFormat = I2S_DataFormat_16b;
 8004510:	8083      	strh	r3, [r0, #4]

  /* Initialize the I2S_MCLKOutput member */
  I2S_InitStruct->I2S_MCLKOutput = I2S_MCLKOutput_Disable;
 8004512:	80c3      	strh	r3, [r0, #6]

  /* Initialize the I2S_AudioFreq member */
  I2S_InitStruct->I2S_AudioFreq = I2S_AudioFreq_Default;
 8004514:	6082      	str	r2, [r0, #8]

  /* Initialize the I2S_CPOL member */
  I2S_InitStruct->I2S_CPOL = I2S_CPOL_Low;
 8004516:	8183      	strh	r3, [r0, #12]
 8004518:	4770      	bx	lr

0800451a <I2S_Init>:
  assert_param(IS_I2S_AUDIO_FREQ(I2S_InitStruct->I2S_AudioFreq));
  assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  

/*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  SPIx->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
 800451a:	8b83      	ldrh	r3, [r0, #28]
 800451c:	f423 637b 	bic.w	r3, r3, #4016	; 0xfb0
 8004520:	f023 030f 	bic.w	r3, r3, #15
 8004524:	041b      	lsls	r3, r3, #16
  *  and the product configuration). But in case the prescaler value is greater 
  *  than 511, the default value (0x02) will be configured instead.     
  * @retval None
  */
void I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct)
{
 8004526:	b5f0      	push	{r4, r5, r6, r7, lr}
  assert_param(IS_I2S_AUDIO_FREQ(I2S_InitStruct->I2S_AudioFreq));
  assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  

/*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  SPIx->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
 8004528:	0c1b      	lsrs	r3, r3, #16
 800452a:	8383      	strh	r3, [r0, #28]
  SPIx->I2SPR = 0x0002;
 800452c:	2302      	movs	r3, #2
 800452e:	8403      	strh	r3, [r0, #32]

  /* Get the I2SCFGR register value */
  tmpreg = SPIx->I2SCFGR;

  /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
  if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
 8004530:	688b      	ldr	r3, [r1, #8]
  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  SPIx->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
  SPIx->I2SPR = 0x0002;

  /* Get the I2SCFGR register value */
  tmpreg = SPIx->I2SCFGR;
 8004532:	8b86      	ldrh	r6, [r0, #28]

  /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
  if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
 8004534:	2b02      	cmp	r3, #2
  *  and the product configuration). But in case the prescaler value is greater 
  *  than 511, the default value (0x02) will be configured instead.     
  * @retval None
  */
void I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct)
{
 8004536:	b091      	sub	sp, #68	; 0x44
 8004538:	4605      	mov	r5, r0
 800453a:	460c      	mov	r4, r1
  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  SPIx->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
  SPIx->I2SPR = 0x0002;

  /* Get the I2SCFGR register value */
  tmpreg = SPIx->I2SCFGR;
 800453c:	b2b6      	uxth	r6, r6

  /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
  if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
 800453e:	d023      	beq.n	8004588 <I2S_Init+0x6e>
  }
  /* If the requested audio frequency is not the default, compute the prescaler */
  else
  {
    /* Check the frame length (For the Prescaler computing) */
    if(I2S_InitStruct->I2S_DataFormat == I2S_DataFormat_16b)
 8004540:	888b      	ldrh	r3, [r1, #4]
      /* Packet length is 32 bits */
      packetlength = 2;
    }

    /* I2S Clock source is System clock: Get System Clock frequency */
    RCC_GetClocksFreq(&RCC_Clocks);      
 8004542:	a801      	add	r0, sp, #4
  }
  /* If the requested audio frequency is not the default, compute the prescaler */
  else
  {
    /* Check the frame length (For the Prescaler computing) */
    if(I2S_InitStruct->I2S_DataFormat == I2S_DataFormat_16b)
 8004544:	2b00      	cmp	r3, #0
    {
      /* Packet length is 16 bits */
      packetlength = 1;
 8004546:	bf14      	ite	ne
 8004548:	2702      	movne	r7, #2
 800454a:	2701      	moveq	r7, #1
      /* Packet length is 32 bits */
      packetlength = 2;
    }

    /* I2S Clock source is System clock: Get System Clock frequency */
    RCC_GetClocksFreq(&RCC_Clocks);      
 800454c:	f7ff fd14 	bl	8003f78 <RCC_GetClocksFreq>

    /* Get the source clock value: based on System Clock value */
    sourceclock = RCC_Clocks.SYSCLK_Frequency;    

    /* Compute the Real divider depending on the MCLK output state with a floating point */
    if(I2S_InitStruct->I2S_MCLKOutput == I2S_MCLKOutput_Enable)
 8004550:	88e3      	ldrh	r3, [r4, #6]

    /* I2S Clock source is System clock: Get System Clock frequency */
    RCC_GetClocksFreq(&RCC_Clocks);      

    /* Get the source clock value: based on System Clock value */
    sourceclock = RCC_Clocks.SYSCLK_Frequency;    
 8004552:	9901      	ldr	r1, [sp, #4]
 8004554:	68a2      	ldr	r2, [r4, #8]

    /* Compute the Real divider depending on the MCLK output state with a floating point */
    if(I2S_InitStruct->I2S_MCLKOutput == I2S_MCLKOutput_Enable)
 8004556:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
      tmp = (uint16_t)(((((sourceclock / 256) * 10) / I2S_InitStruct->I2S_AudioFreq)) + 5);
    }
    else
    {
      /* MCLK output is disabled */
      tmp = (uint16_t)(((((sourceclock / (32 * packetlength)) *10 ) / I2S_InitStruct->I2S_AudioFreq)) + 5);
 800455a:	bf18      	it	ne
 800455c:	017f      	lslne	r7, r7, #5
 800455e:	f04f 030a 	mov.w	r3, #10

    /* Compute the Real divider depending on the MCLK output state with a floating point */
    if(I2S_InitStruct->I2S_MCLKOutput == I2S_MCLKOutput_Enable)
    {
      /* MCLK output is enabled */
      tmp = (uint16_t)(((((sourceclock / 256) * 10) / I2S_InitStruct->I2S_AudioFreq)) + 5);
 8004562:	bf0c      	ite	eq
 8004564:	0a09      	lsreq	r1, r1, #8
    }
    else
    {
      /* MCLK output is disabled */
      tmp = (uint16_t)(((((sourceclock / (32 * packetlength)) *10 ) / I2S_InitStruct->I2S_AudioFreq)) + 5);
 8004566:	fbb1 f1f7 	udivne	r1, r1, r7
 800456a:	434b      	muls	r3, r1
 800456c:	fbb3 f3f2 	udiv	r3, r3, r2
 8004570:	3305      	adds	r3, #5
    }
    
    /* Remove the floating point */
    tmp = tmp / 10;
 8004572:	220a      	movs	r2, #10
      tmp = (uint16_t)(((((sourceclock / 256) * 10) / I2S_InitStruct->I2S_AudioFreq)) + 5);
    }
    else
    {
      /* MCLK output is disabled */
      tmp = (uint16_t)(((((sourceclock / (32 * packetlength)) *10 ) / I2S_InitStruct->I2S_AudioFreq)) + 5);
 8004574:	b29b      	uxth	r3, r3
    }
    
    /* Remove the floating point */
    tmp = tmp / 10;
 8004576:	fbb3 f3f2 	udiv	r3, r3, r2

    /* Check the parity of the divider */
    i2sodd = (uint16_t)(tmp & (uint16_t)0x0001);

    /* Compute the i2sdiv prescaler */
    i2sdiv = (uint16_t)((tmp - i2sodd) / 2);
 800457a:	f003 0201 	and.w	r2, r3, #1

    /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
    i2sodd = (uint16_t) (i2sodd << 8);
 800457e:	0212      	lsls	r2, r2, #8

    /* Check the parity of the divider */
    i2sodd = (uint16_t)(tmp & (uint16_t)0x0001);

    /* Compute the i2sdiv prescaler */
    i2sdiv = (uint16_t)((tmp - i2sodd) / 2);
 8004580:	f3c3 034f 	ubfx	r3, r3, #1, #16

    /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
    i2sodd = (uint16_t) (i2sodd << 8);
 8004584:	b292      	uxth	r2, r2
 8004586:	e000      	b.n	800458a <I2S_Init+0x70>
  tmpreg = SPIx->I2SCFGR;

  /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
  if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
  {
    i2sodd = (uint16_t)0;
 8004588:	2200      	movs	r2, #0
    /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
    i2sodd = (uint16_t) (i2sodd << 8);
  }

  /* Test if the divider is 1 or 0 or greater than 0xFF */
  if ((i2sdiv < 2) || (i2sdiv > 0xFF))
 800458a:	1e99      	subs	r1, r3, #2
 800458c:	b289      	uxth	r1, r1
  {
    /* Set the default values */
    i2sdiv = 2;
    i2sodd = 0;
 800458e:	29fe      	cmp	r1, #254	; 0xfe
 8004590:	bf28      	it	cs
 8004592:	2200      	movcs	r2, #0
  }

  /* Write to SPIx I2SPR register the computed value */
  SPIx->I2SPR = (uint16_t)(i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct->I2S_MCLKOutput));
 8004594:	88e1      	ldrh	r1, [r4, #6]
  /* Test if the divider is 1 or 0 or greater than 0xFF */
  if ((i2sdiv < 2) || (i2sdiv > 0xFF))
  {
    /* Set the default values */
    i2sdiv = 2;
    i2sodd = 0;
 8004596:	bf28      	it	cs
 8004598:	2302      	movcs	r3, #2
  }

  /* Write to SPIx I2SPR register the computed value */
  SPIx->I2SPR = (uint16_t)(i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct->I2S_MCLKOutput));
 800459a:	4313      	orrs	r3, r2
 800459c:	430b      	orrs	r3, r1
 800459e:	b29b      	uxth	r3, r3
 80045a0:	842b      	strh	r3, [r5, #32]

  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)((uint16_t)(SPI_I2SCFGR_I2SMOD | I2S_InitStruct->I2S_Mode) | \
                       (uint16_t)((uint16_t)((uint16_t)(I2S_InitStruct->I2S_Standard |I2S_InitStruct->I2S_DataFormat) |\
 80045a2:	8823      	ldrh	r3, [r4, #0]

  /* Write to SPIx I2SPR register the computed value */
  SPIx->I2SPR = (uint16_t)(i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct->I2S_MCLKOutput));

  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)((uint16_t)(SPI_I2SCFGR_I2SMOD | I2S_InitStruct->I2S_Mode) | \
 80045a4:	8862      	ldrh	r2, [r4, #2]
                       (uint16_t)((uint16_t)((uint16_t)(I2S_InitStruct->I2S_Standard |I2S_InitStruct->I2S_DataFormat) |\
 80045a6:	4333      	orrs	r3, r6
 80045a8:	f443 6300 	orr.w	r3, r3, #2048	; 0x800

  /* Write to SPIx I2SPR register the computed value */
  SPIx->I2SPR = (uint16_t)(i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct->I2S_MCLKOutput));

  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)((uint16_t)(SPI_I2SCFGR_I2SMOD | I2S_InitStruct->I2S_Mode) | \
 80045ac:	4313      	orrs	r3, r2
 80045ae:	88a2      	ldrh	r2, [r4, #4]
 80045b0:	4313      	orrs	r3, r2
 80045b2:	89a2      	ldrh	r2, [r4, #12]
 80045b4:	4313      	orrs	r3, r2
 80045b6:	b29b      	uxth	r3, r3
                       (uint16_t)((uint16_t)((uint16_t)(I2S_InitStruct->I2S_Standard |I2S_InitStruct->I2S_DataFormat) |\
                       I2S_InitStruct->I2S_CPOL)));

  /* Write to SPIx I2SCFGR */
  SPIx->I2SCFGR = tmpreg;
 80045b8:	83ab      	strh	r3, [r5, #28]
}
 80045ba:	b011      	add	sp, #68	; 0x44
 80045bc:	bdf0      	pop	{r4, r5, r6, r7, pc}

080045be <SPI_Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the selected SPI peripheral */
    SPIx->CR1 |= SPI_CR1_SPE;
 80045be:	8803      	ldrh	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80045c0:	b119      	cbz	r1, 80045ca <SPI_Cmd+0xc>
  {
    /* Enable the selected SPI peripheral */
    SPIx->CR1 |= SPI_CR1_SPE;
 80045c2:	b29b      	uxth	r3, r3
 80045c4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80045c8:	e003      	b.n	80045d2 <SPI_Cmd+0x14>
  }
  else
  {
    /* Disable the selected SPI peripheral */
    SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_SPE);
 80045ca:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80045ce:	041b      	lsls	r3, r3, #16
 80045d0:	0c1b      	lsrs	r3, r3, #16
 80045d2:	8003      	strh	r3, [r0, #0]
 80045d4:	4770      	bx	lr

080045d6 <SPI_TIModeCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the TI mode for the selected SPI peripheral */
    SPIx->CR2 |= SPI_CR2_FRF;
 80045d6:	8883      	ldrh	r3, [r0, #4]
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80045d8:	b119      	cbz	r1, 80045e2 <SPI_TIModeCmd+0xc>
  {
    /* Enable the TI mode for the selected SPI peripheral */
    SPIx->CR2 |= SPI_CR2_FRF;
 80045da:	b29b      	uxth	r3, r3
 80045dc:	f043 0310 	orr.w	r3, r3, #16
 80045e0:	e003      	b.n	80045ea <SPI_TIModeCmd+0x14>
  }
  else
  {
    /* Disable the TI mode for the selected SPI peripheral */
    SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_FRF);
 80045e2:	f023 0310 	bic.w	r3, r3, #16
 80045e6:	041b      	lsls	r3, r3, #16
 80045e8:	0c1b      	lsrs	r3, r3, #16
 80045ea:	8083      	strh	r3, [r0, #4]
 80045ec:	4770      	bx	lr

080045ee <I2S_Cmd>:
  assert_param(IS_SPI_23_PERIPH_EXT(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected SPI peripheral in I2S mode */
    SPIx->I2SCFGR |= SPI_I2SCFGR_I2SE;
 80045ee:	8b83      	ldrh	r3, [r0, #28]
void I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_SPI_23_PERIPH_EXT(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80045f0:	b119      	cbz	r1, 80045fa <I2S_Cmd+0xc>
  {
    /* Enable the selected SPI peripheral in I2S mode */
    SPIx->I2SCFGR |= SPI_I2SCFGR_I2SE;
 80045f2:	b29b      	uxth	r3, r3
 80045f4:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 80045f8:	e003      	b.n	8004602 <I2S_Cmd+0x14>
  }
  else
  {
    /* Disable the selected SPI peripheral in I2S mode */
    SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SE);
 80045fa:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80045fe:	041b      	lsls	r3, r3, #16
 8004600:	0c1b      	lsrs	r3, r3, #16
 8004602:	8383      	strh	r3, [r0, #28]
 8004604:	4770      	bx	lr

08004606 <SPI_DataSizeConfig>:
  
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_DATA_SIZE(SPI_DataSize));
  /* Read the CR2 register */
  tmpreg = SPIx->CR2;
 8004606:	8883      	ldrh	r3, [r0, #4]
  /* Clear DS[3:0] bits */
  tmpreg &= (uint16_t)~SPI_CR2_DS;
 8004608:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
 800460c:	041b      	lsls	r3, r3, #16
 800460e:	0c1b      	lsrs	r3, r3, #16
  /* Set new DS[3:0] bits value */
  tmpreg |= SPI_DataSize;
 8004610:	4319      	orrs	r1, r3
  SPIx->CR2 = tmpreg;
 8004612:	8081      	strh	r1, [r0, #4]
 8004614:	4770      	bx	lr

08004616 <SPI_RxFIFOThresholdConfig>:
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_RX_FIFO_THRESHOLD(SPI_RxFIFOThreshold));

  /* Clear FRXTH bit */
  SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_FRXTH);
 8004616:	8883      	ldrh	r3, [r0, #4]
 8004618:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 800461c:	041b      	lsls	r3, r3, #16
 800461e:	0c1b      	lsrs	r3, r3, #16
 8004620:	8083      	strh	r3, [r0, #4]

  /* Set new FRXTH bit value */
  SPIx->CR2 |= SPI_RxFIFOThreshold;
 8004622:	8883      	ldrh	r3, [r0, #4]
 8004624:	b29b      	uxth	r3, r3
 8004626:	4319      	orrs	r1, r3
 8004628:	8081      	strh	r1, [r0, #4]
 800462a:	4770      	bx	lr

0800462c <SPI_BiDirectionalLineConfig>:
void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, uint16_t SPI_Direction)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_DIRECTION(SPI_Direction));
  if (SPI_Direction == SPI_Direction_Tx)
 800462c:	f5b1 4f80 	cmp.w	r1, #16384	; 0x4000
  {
    /* Set the Tx only mode */
    SPIx->CR1 |= SPI_Direction_Tx;
 8004630:	8803      	ldrh	r3, [r0, #0]
void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, uint16_t SPI_Direction)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_DIRECTION(SPI_Direction));
  if (SPI_Direction == SPI_Direction_Tx)
 8004632:	d103      	bne.n	800463c <SPI_BiDirectionalLineConfig+0x10>
  {
    /* Set the Tx only mode */
    SPIx->CR1 |= SPI_Direction_Tx;
 8004634:	b29b      	uxth	r3, r3
 8004636:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800463a:	e003      	b.n	8004644 <SPI_BiDirectionalLineConfig+0x18>
  }
  else
  {
    /* Set the Rx only mode */
    SPIx->CR1 &= SPI_Direction_Rx;
 800463c:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8004640:	041b      	lsls	r3, r3, #16
 8004642:	0c1b      	lsrs	r3, r3, #16
 8004644:	8003      	strh	r3, [r0, #0]
 8004646:	4770      	bx	lr

08004648 <SPI_NSSInternalSoftwareConfig>:
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_NSS_INTERNAL(SPI_NSSInternalSoft));

  if (SPI_NSSInternalSoft != SPI_NSSInternalSoft_Reset)
 8004648:	f64f 63ff 	movw	r3, #65279	; 0xfeff
 800464c:	4299      	cmp	r1, r3
  {
    /* Set NSS pin internally by software */
    SPIx->CR1 |= SPI_NSSInternalSoft_Set;
 800464e:	8803      	ldrh	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_NSS_INTERNAL(SPI_NSSInternalSoft));

  if (SPI_NSSInternalSoft != SPI_NSSInternalSoft_Reset)
 8004650:	d003      	beq.n	800465a <SPI_NSSInternalSoftwareConfig+0x12>
  {
    /* Set NSS pin internally by software */
    SPIx->CR1 |= SPI_NSSInternalSoft_Set;
 8004652:	b29b      	uxth	r3, r3
 8004654:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8004658:	e003      	b.n	8004662 <SPI_NSSInternalSoftwareConfig+0x1a>
  }
  else
  {
    /* Reset NSS pin internally by software */
    SPIx->CR1 &= SPI_NSSInternalSoft_Reset;
 800465a:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 800465e:	041b      	lsls	r3, r3, #16
 8004660:	0c1b      	lsrs	r3, r3, #16
 8004662:	8003      	strh	r3, [r0, #0]
 8004664:	4770      	bx	lr

08004666 <I2S_FullDuplexConfig>:
  assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct->I2S_DataFormat));
  assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  

/*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  I2Sxext->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
 8004666:	8b83      	ldrh	r3, [r0, #28]
  
  /* Get the I2SCFGR register value */
  tmpreg = I2Sxext->I2SCFGR;
  
  /* Get the mode to be configured for the extended I2S */
  if ((I2S_InitStruct->I2S_Mode == I2S_Mode_MasterTx) || (I2S_InitStruct->I2S_Mode == I2S_Mode_SlaveTx))
 8004668:	880a      	ldrh	r2, [r1, #0]
  assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct->I2S_DataFormat));
  assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  

/*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  I2Sxext->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
 800466a:	f423 637b 	bic.w	r3, r3, #4016	; 0xfb0
 800466e:	f023 030f 	bic.w	r3, r3, #15
 8004672:	041b      	lsls	r3, r3, #16
 8004674:	0c1b      	lsrs	r3, r3, #16
 8004676:	8383      	strh	r3, [r0, #28]
  I2Sxext->I2SPR = 0x0002;
 8004678:	2302      	movs	r3, #2
 800467a:	8403      	strh	r3, [r0, #32]
  
  /* Get the I2SCFGR register value */
  tmpreg = I2Sxext->I2SCFGR;
 800467c:	8b83      	ldrh	r3, [r0, #28]
  * @note   The I2S full duplex extension can be configured in slave mode only.    
  *  
  * @retval None
  */
void I2S_FullDuplexConfig(SPI_TypeDef* I2Sxext, I2S_InitTypeDef* I2S_InitStruct)
{
 800467e:	b510      	push	{r4, lr}
  }

 
  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(tmp | \
                  (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
 8004680:	884c      	ldrh	r4, [r1, #2]
  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  I2Sxext->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
  I2Sxext->I2SPR = 0x0002;
  
  /* Get the I2SCFGR register value */
  tmpreg = I2Sxext->I2SCFGR;
 8004682:	b29b      	uxth	r3, r3
  }

 
  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(tmp | \
                  (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
 8004684:	4323      	orrs	r3, r4
    }
  }

 
  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(tmp | \
 8004686:	888c      	ldrh	r4, [r1, #4]
 8004688:	8989      	ldrh	r1, [r1, #12]
  
  /* Get the I2SCFGR register value */
  tmpreg = I2Sxext->I2SCFGR;
  
  /* Get the mode to be configured for the extended I2S */
  if ((I2S_InitStruct->I2S_Mode == I2S_Mode_MasterTx) || (I2S_InitStruct->I2S_Mode == I2S_Mode_SlaveTx))
 800468a:	f422 7200 	bic.w	r2, r2, #512	; 0x200
  }

 
  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(tmp | \
                  (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
 800468e:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
  
  /* Get the I2SCFGR register value */
  tmpreg = I2Sxext->I2SCFGR;
  
  /* Get the mode to be configured for the extended I2S */
  if ((I2S_InitStruct->I2S_Mode == I2S_Mode_MasterTx) || (I2S_InitStruct->I2S_Mode == I2S_Mode_SlaveTx))
 8004692:	b292      	uxth	r2, r2
    }
  }

 
  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(tmp | \
 8004694:	4323      	orrs	r3, r4
  
  /* Get the I2SCFGR register value */
  tmpreg = I2Sxext->I2SCFGR;
  
  /* Get the mode to be configured for the extended I2S */
  if ((I2S_InitStruct->I2S_Mode == I2S_Mode_MasterTx) || (I2S_InitStruct->I2S_Mode == I2S_Mode_SlaveTx))
 8004696:	2a00      	cmp	r2, #0
    }
  }

 
  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(tmp | \
 8004698:	ea43 0301 	orr.w	r3, r3, r1
  tmpreg = I2Sxext->I2SCFGR;
  
  /* Get the mode to be configured for the extended I2S */
  if ((I2S_InitStruct->I2S_Mode == I2S_Mode_MasterTx) || (I2S_InitStruct->I2S_Mode == I2S_Mode_SlaveTx))
  {
    tmp = I2S_Mode_SlaveRx;
 800469c:	bf14      	ite	ne
 800469e:	2200      	movne	r2, #0
 80046a0:	f44f 7280 	moveq.w	r2, #256	; 0x100
    }
  }

 
  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(tmp | \
 80046a4:	b29b      	uxth	r3, r3
 80046a6:	4313      	orrs	r3, r2
                  (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
                  (uint16_t)I2S_InitStruct->I2S_CPOL))));
 
  /* Write to SPIx I2SCFGR */  
  I2Sxext->I2SCFGR = tmpreg;
 80046a8:	8383      	strh	r3, [r0, #28]
 80046aa:	bd10      	pop	{r4, pc}

080046ac <SPI_SSOutputCmd>:
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected SPI SS output */
    SPIx->CR2 |= (uint16_t)SPI_CR2_SSOE;
 80046ac:	8883      	ldrh	r3, [r0, #4]
void SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80046ae:	b119      	cbz	r1, 80046b8 <SPI_SSOutputCmd+0xc>
  {
    /* Enable the selected SPI SS output */
    SPIx->CR2 |= (uint16_t)SPI_CR2_SSOE;
 80046b0:	b29b      	uxth	r3, r3
 80046b2:	f043 0304 	orr.w	r3, r3, #4
 80046b6:	e003      	b.n	80046c0 <SPI_SSOutputCmd+0x14>
  }
  else
  {
    /* Disable the selected SPI SS output */
    SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_SSOE);
 80046b8:	f023 0304 	bic.w	r3, r3, #4
 80046bc:	041b      	lsls	r3, r3, #16
 80046be:	0c1b      	lsrs	r3, r3, #16
 80046c0:	8083      	strh	r3, [r0, #4]
 80046c2:	4770      	bx	lr

080046c4 <SPI_NSSPulseModeCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the NSS pulse management mode */
    SPIx->CR2 |= SPI_CR2_NSSP;
 80046c4:	8883      	ldrh	r3, [r0, #4]
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80046c6:	b119      	cbz	r1, 80046d0 <SPI_NSSPulseModeCmd+0xc>
  {
    /* Enable the NSS pulse management mode */
    SPIx->CR2 |= SPI_CR2_NSSP;
 80046c8:	b29b      	uxth	r3, r3
 80046ca:	f043 0308 	orr.w	r3, r3, #8
 80046ce:	e003      	b.n	80046d8 <SPI_NSSPulseModeCmd+0x14>
  }
  else
  {
    /* Disable the NSS pulse management mode */
    SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_NSSP);    
 80046d0:	f023 0308 	bic.w	r3, r3, #8
 80046d4:	041b      	lsls	r3, r3, #16
 80046d6:	0c1b      	lsrs	r3, r3, #16
 80046d8:	8083      	strh	r3, [r0, #4]
 80046da:	4770      	bx	lr

080046dc <SPI_SendData8>:
  assert_param(IS_SPI_ALL_PERIPH(SPIx));

  spixbase = (uint32_t)SPIx; 
  spixbase += 0x0C;
  
  *(__IO uint8_t *) spixbase = Data;
 80046dc:	7301      	strb	r1, [r0, #12]
 80046de:	4770      	bx	lr

080046e0 <SPI_I2S_SendData16>:
void SPI_I2S_SendData16(SPI_TypeDef* SPIx, uint16_t Data)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  
  SPIx->DR = (uint16_t)Data;
 80046e0:	8181      	strh	r1, [r0, #12]
 80046e2:	4770      	bx	lr

080046e4 <SPI_ReceiveData8>:
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  
  spixbase = (uint32_t)SPIx; 
  spixbase += 0x0C;
  
  return *(__IO uint8_t *) spixbase;
 80046e4:	7b00      	ldrb	r0, [r0, #12]
}
 80046e6:	4770      	bx	lr

080046e8 <SPI_I2S_ReceiveData16>:
uint16_t SPI_I2S_ReceiveData16(SPI_TypeDef* SPIx)
{  
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  
  return SPIx->DR;
 80046e8:	8980      	ldrh	r0, [r0, #12]
}
 80046ea:	b280      	uxth	r0, r0
 80046ec:	4770      	bx	lr

080046ee <SPI_CRCLengthConfig>:
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_CRC_LENGTH(SPI_CRCLength));

  /* Clear CRCL bit */
  SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_CRCL);
 80046ee:	8803      	ldrh	r3, [r0, #0]
 80046f0:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 80046f4:	041b      	lsls	r3, r3, #16
 80046f6:	0c1b      	lsrs	r3, r3, #16
 80046f8:	8003      	strh	r3, [r0, #0]

  /* Set new CRCL bit value */
  SPIx->CR1 |= SPI_CRCLength;
 80046fa:	8803      	ldrh	r3, [r0, #0]
 80046fc:	b29b      	uxth	r3, r3
 80046fe:	4319      	orrs	r1, r3
 8004700:	8001      	strh	r1, [r0, #0]
 8004702:	4770      	bx	lr

08004704 <SPI_CalculateCRC>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the selected SPI CRC calculation */
    SPIx->CR1 |= SPI_CR1_CRCEN;
 8004704:	8803      	ldrh	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8004706:	b119      	cbz	r1, 8004710 <SPI_CalculateCRC+0xc>
  {
    /* Enable the selected SPI CRC calculation */
    SPIx->CR1 |= SPI_CR1_CRCEN;
 8004708:	b29b      	uxth	r3, r3
 800470a:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 800470e:	e003      	b.n	8004718 <SPI_CalculateCRC+0x14>
  }
  else
  {
    /* Disable the selected SPI CRC calculation */
    SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_CRCEN);
 8004710:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8004714:	041b      	lsls	r3, r3, #16
 8004716:	0c1b      	lsrs	r3, r3, #16
 8004718:	8003      	strh	r3, [r0, #0]
 800471a:	4770      	bx	lr

0800471c <SPI_TransmitCRC>:
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));

  /* Enable the selected SPI CRC transmission */
  SPIx->CR1 |= SPI_CR1_CRCNEXT;
 800471c:	8803      	ldrh	r3, [r0, #0]
 800471e:	b29b      	uxth	r3, r3
 8004720:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8004724:	8003      	strh	r3, [r0, #0]
 8004726:	4770      	bx	lr

08004728 <SPI_GetCRC>:
  uint16_t crcreg = 0;
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_CRC(SPI_CRC));

  if (SPI_CRC != SPI_CRC_Rx)
 8004728:	2901      	cmp	r1, #1
  {
    /* Get the Tx CRC register */
    crcreg = SPIx->TXCRCR;
 800472a:	bf14      	ite	ne
 800472c:	8b00      	ldrhne	r0, [r0, #24]
  }
  else
  {
    /* Get the Rx CRC register */
    crcreg = SPIx->RXCRCR;
 800472e:	8a80      	ldrheq	r0, [r0, #20]
 8004730:	b280      	uxth	r0, r0
  }
  /* Return the selected CRC register */
  return crcreg;
}
 8004732:	4770      	bx	lr

08004734 <SPI_GetCRCPolynomial>:
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));

  /* Return the CRC polynomial register */
  return SPIx->CRCPR;
 8004734:	8a00      	ldrh	r0, [r0, #16]
}
 8004736:	b280      	uxth	r0, r0
 8004738:	4770      	bx	lr

0800473a <SPI_I2S_DMACmd>:
  assert_param(IS_SPI_I2S_DMA_REQ(SPI_I2S_DMAReq));

  if (NewState != DISABLE)
  {
    /* Enable the selected SPI DMA requests */
    SPIx->CR2 |= SPI_I2S_DMAReq;
 800473a:	8883      	ldrh	r3, [r0, #4]
 800473c:	b29b      	uxth	r3, r3
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_SPI_I2S_DMA_REQ(SPI_I2S_DMAReq));

  if (NewState != DISABLE)
 800473e:	b10a      	cbz	r2, 8004744 <SPI_I2S_DMACmd+0xa>
  {
    /* Enable the selected SPI DMA requests */
    SPIx->CR2 |= SPI_I2S_DMAReq;
 8004740:	4319      	orrs	r1, r3
 8004742:	e001      	b.n	8004748 <SPI_I2S_DMACmd+0xe>
  }
  else
  {
    /* Disable the selected SPI DMA requests */
    SPIx->CR2 &= (uint16_t)~SPI_I2S_DMAReq;
 8004744:	ea23 0101 	bic.w	r1, r3, r1
 8004748:	8081      	strh	r1, [r0, #4]
 800474a:	4770      	bx	lr

0800474c <SPI_LastDMATransferCmd>:
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_LAST_DMA_TRANSFER(SPI_LastDMATransfer));

  /* Clear LDMA_TX and LDMA_RX bits */
  SPIx->CR2 &= CR2_LDMA_MASK;
 800474c:	8883      	ldrh	r3, [r0, #4]
 800474e:	f423 43c0 	bic.w	r3, r3, #24576	; 0x6000
 8004752:	041b      	lsls	r3, r3, #16
 8004754:	0c1b      	lsrs	r3, r3, #16
 8004756:	8083      	strh	r3, [r0, #4]

  /* Set new LDMA_TX and LDMA_RX bits value */
  SPIx->CR2 |= SPI_LastDMATransfer; 
 8004758:	8883      	ldrh	r3, [r0, #4]
 800475a:	b29b      	uxth	r3, r3
 800475c:	4319      	orrs	r1, r3
 800475e:	8081      	strh	r1, [r0, #4]
 8004760:	4770      	bx	lr

08004762 <SPI_I2S_ITConfig>:

  /* Get the SPI IT index */
  itpos = SPI_I2S_IT >> 4;

  /* Set the IT mask */
  itmask = (uint16_t)1 << (uint16_t)itpos;
 8004762:	0909      	lsrs	r1, r1, #4
 8004764:	2301      	movs	r3, #1
 8004766:	408b      	lsls	r3, r1
 8004768:	b29b      	uxth	r3, r3

  if (NewState != DISABLE)
 800476a:	b11a      	cbz	r2, 8004774 <SPI_I2S_ITConfig+0x12>
  {
    /* Enable the selected SPI interrupt */
    SPIx->CR2 |= itmask;
 800476c:	8882      	ldrh	r2, [r0, #4]
 800476e:	b292      	uxth	r2, r2
 8004770:	4313      	orrs	r3, r2
 8004772:	e003      	b.n	800477c <SPI_I2S_ITConfig+0x1a>
  }
  else
  {
    /* Disable the selected SPI interrupt */
    SPIx->CR2 &= (uint16_t)~itmask;
 8004774:	8882      	ldrh	r2, [r0, #4]
 8004776:	b292      	uxth	r2, r2
 8004778:	ea22 0303 	bic.w	r3, r2, r3
 800477c:	8083      	strh	r3, [r0, #4]
 800477e:	4770      	bx	lr

08004780 <SPI_GetTransmissionFIFOStatus>:
  *   - SPI_TransmissionFIFOStatus_Full: when FIFO is full.
  */
uint16_t SPI_GetTransmissionFIFOStatus(SPI_TypeDef* SPIx)
{
  /* Get the SPIx Transmission FIFO level bits */
  return (uint16_t)((SPIx->SR & SPI_SR_FTLVL));
 8004780:	8900      	ldrh	r0, [r0, #8]
}
 8004782:	f400 50c0 	and.w	r0, r0, #6144	; 0x1800
 8004786:	4770      	bx	lr

08004788 <SPI_GetReceptionFIFOStatus>:
  *   - SPI_ReceptionFIFOStatus_Full: when FIFO is full.
  */
uint16_t SPI_GetReceptionFIFOStatus(SPI_TypeDef* SPIx)
{
  /* Get the SPIx Reception FIFO level bits */
  return (uint16_t)((SPIx->SR & SPI_SR_FRLVL));
 8004788:	8900      	ldrh	r0, [r0, #8]
}
 800478a:	f400 60c0 	and.w	r0, r0, #1536	; 0x600
 800478e:	4770      	bx	lr

08004790 <SPI_I2S_GetFlagStatus>:
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  assert_param(IS_SPI_I2S_GET_FLAG(SPI_I2S_FLAG));

  /* Check the status of the specified SPI flag */
  if ((SPIx->SR & SPI_I2S_FLAG) != (uint16_t)RESET)
 8004790:	8903      	ldrh	r3, [r0, #8]
 8004792:	4219      	tst	r1, r3
    /* SPI_I2S_FLAG is reset */
    bitstatus = RESET;
  }
  /* Return the SPI_I2S_FLAG status */
  return  bitstatus;
}
 8004794:	bf0c      	ite	eq
 8004796:	2000      	moveq	r0, #0
 8004798:	2001      	movne	r0, #1
 800479a:	4770      	bx	lr

0800479c <SPI_I2S_ClearFlag>:
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  assert_param(IS_SPI_CLEAR_FLAG(SPI_I2S_FLAG));

  /* Clear the selected SPI CRC Error (CRCERR) flag */
  SPIx->SR = (uint16_t)~SPI_I2S_FLAG;
 800479c:	43c9      	mvns	r1, r1
 800479e:	b289      	uxth	r1, r1
 80047a0:	8101      	strh	r1, [r0, #8]
 80047a2:	4770      	bx	lr

080047a4 <SPI_I2S_GetITStatus>:
  *     @arg I2S_IT_UDR: Underrun interrupt.  
  *     @arg SPI_I2S_IT_FRE: Format Error interrupt.  
  * @retval The new state of SPI_I2S_IT (SET or RESET).
  */
ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)
{
 80047a4:	b510      	push	{r4, lr}

  /* Set the IT mask */
  itmask = 0x01 << itmask;

  /* Get the SPI_I2S_IT enable bit status */
  enablestatus = (SPIx->CR2 & itmask) ;
 80047a6:	8884      	ldrh	r4, [r0, #4]

  /* Check the status of the specified SPI interrupt */
  if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)
 80047a8:	8900      	ldrh	r0, [r0, #8]
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  assert_param(IS_SPI_I2S_GET_IT(SPI_I2S_IT));

  /* Get the SPI_I2S_IT index */
  itpos = 0x01 << (SPI_I2S_IT & 0x0F);
 80047aa:	f001 020f 	and.w	r2, r1, #15
 80047ae:	2301      	movs	r3, #1

  /* Get the SPI_I2S_IT enable bit status */
  enablestatus = (SPIx->CR2 & itmask) ;

  /* Check the status of the specified SPI interrupt */
  if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)
 80047b0:	b280      	uxth	r0, r0
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  assert_param(IS_SPI_I2S_GET_IT(SPI_I2S_IT));

  /* Get the SPI_I2S_IT index */
  itpos = 0x01 << (SPI_I2S_IT & 0x0F);
 80047b2:	fa03 f202 	lsl.w	r2, r3, r2

  /* Get the SPI_I2S_IT enable bit status */
  enablestatus = (SPIx->CR2 & itmask) ;

  /* Check the status of the specified SPI interrupt */
  if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)
 80047b6:	4010      	ands	r0, r2

  /* Set the IT mask */
  itmask = 0x01 << itmask;

  /* Get the SPI_I2S_IT enable bit status */
  enablestatus = (SPIx->CR2 & itmask) ;
 80047b8:	b2a4      	uxth	r4, r4

  /* Check the status of the specified SPI interrupt */
  if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)
 80047ba:	d005      	beq.n	80047c8 <SPI_I2S_GetITStatus+0x24>

  /* Get the SPI_I2S_IT IT mask */
  itmask = SPI_I2S_IT >> 4;

  /* Set the IT mask */
  itmask = 0x01 << itmask;
 80047bc:	0909      	lsrs	r1, r1, #4
 80047be:	408b      	lsls	r3, r1

  /* Get the SPI_I2S_IT enable bit status */
  enablestatus = (SPIx->CR2 & itmask) ;

  /* Check the status of the specified SPI interrupt */
  if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)
 80047c0:	421c      	tst	r4, r3
  {
    /* SPI_I2S_IT is set */
    bitstatus = SET;
 80047c2:	bf0c      	ite	eq
 80047c4:	2000      	moveq	r0, #0
 80047c6:	2001      	movne	r0, #1
    /* SPI_I2S_IT is reset */
    bitstatus = RESET;
  }
  /* Return the SPI_I2S_IT status */
  return bitstatus;
}
 80047c8:	bd10      	pop	{r4, pc}
 80047ca:	bf00      	nop

080047cc <TI1_Config>:
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
 80047cc:	b530      	push	{r4, r5, lr}
  uint32_t tmpccmr1 = 0, tmpccer = 0;

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint32_t)~TIM_CCER_CC1E;
 80047ce:	6a04      	ldr	r4, [r0, #32]
 80047d0:	f024 0401 	bic.w	r4, r4, #1
 80047d4:	6204      	str	r4, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
 80047d6:	6985      	ldr	r5, [r0, #24]
  tmpccer = TIMx->CCER;
 80047d8:	6a04      	ldr	r4, [r0, #32]

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint32_t)~TIM_CCMR1_CC1S) & ((uint32_t)~TIM_CCMR1_IC1F);
 80047da:	f025 05f3 	bic.w	r5, r5, #243	; 0xf3
  tmpccmr1 |= (uint32_t)(TIM_ICSelection | (uint32_t)((uint32_t)TIM_ICFilter << 4));
 80047de:	ea42 1303 	orr.w	r3, r2, r3, lsl #4

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= (uint32_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 80047e2:	f024 040a 	bic.w	r4, r4, #10
  tmpccer |= (uint32_t)(TIM_ICPolarity | (uint32_t)TIM_CCER_CC1E);
 80047e6:	f041 0101 	orr.w	r1, r1, #1
  tmpccmr1 = TIMx->CCMR1;
  tmpccer = TIMx->CCER;

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint32_t)~TIM_CCMR1_CC1S) & ((uint32_t)~TIM_CCMR1_IC1F);
  tmpccmr1 |= (uint32_t)(TIM_ICSelection | (uint32_t)((uint32_t)TIM_ICFilter << 4));
 80047ea:	431d      	orrs	r5, r3

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= (uint32_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
  tmpccer |= (uint32_t)(TIM_ICPolarity | (uint32_t)TIM_CCER_CC1E);
 80047ec:	430c      	orrs	r4, r1

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1;
 80047ee:	6185      	str	r5, [r0, #24]
  TIMx->CCER = tmpccer;
 80047f0:	6204      	str	r4, [r0, #32]
 80047f2:	bd30      	pop	{r4, r5, pc}

080047f4 <TI2_Config>:
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
 80047f4:	b530      	push	{r4, r5, lr}
  uint32_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
 80047f6:	6a04      	ldr	r4, [r0, #32]
 80047f8:	f024 0410 	bic.w	r4, r4, #16
 80047fc:	0424      	lsls	r4, r4, #16
 80047fe:	0c24      	lsrs	r4, r4, #16
 8004800:	6204      	str	r4, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
 8004802:	6985      	ldr	r5, [r0, #24]
  tmpccer = TIMx->CCER;
 8004804:	6a04      	ldr	r4, [r0, #32]
  tmp = (uint16_t)(TIM_ICPolarity << 4);

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint32_t)~TIM_CCMR1_CC2S) & ((uint32_t)~TIM_CCMR1_IC2F);
 8004806:	f425 4573 	bic.w	r5, r5, #62208	; 0xf300
  tmpccmr1 |= (uint32_t)((uint32_t)TIM_ICFilter << 12);
 800480a:	ea45 2202 	orr.w	r2, r5, r2, lsl #8
  tmpccmr1 |= (uint32_t)((uint32_t)TIM_ICSelection << 8);

  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 800480e:	f024 04a0 	bic.w	r4, r4, #160	; 0xa0

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
  tmpccmr1 = TIMx->CCMR1;
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 4);
 8004812:	0109      	lsls	r1, r1, #4

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint32_t)~TIM_CCMR1_CC2S) & ((uint32_t)~TIM_CCMR1_IC2F);
  tmpccmr1 |= (uint32_t)((uint32_t)TIM_ICFilter << 12);
  tmpccmr1 |= (uint32_t)((uint32_t)TIM_ICSelection << 8);
 8004814:	ea42 3503 	orr.w	r5, r2, r3, lsl #12

  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 8004818:	0424      	lsls	r4, r4, #16
  tmpccer |=  (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);
 800481a:	f041 0310 	orr.w	r3, r1, #16
  tmpccmr1 &= ((uint32_t)~TIM_CCMR1_CC2S) & ((uint32_t)~TIM_CCMR1_IC2F);
  tmpccmr1 |= (uint32_t)((uint32_t)TIM_ICFilter << 12);
  tmpccmr1 |= (uint32_t)((uint32_t)TIM_ICSelection << 8);

  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 800481e:	0c24      	lsrs	r4, r4, #16
  tmpccer |=  (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);
 8004820:	b29b      	uxth	r3, r3
 8004822:	431c      	orrs	r4, r3

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1 ;
 8004824:	6185      	str	r5, [r0, #24]
  TIMx->CCER = tmpccer;
 8004826:	6204      	str	r4, [r0, #32]
 8004828:	bd30      	pop	{r4, r5, pc}

0800482a <TIM_DeInit>:
  * @param  TIMx: where x can be 1, 2, 3, 4, 6 ,7 ,8, 15, 16 or 17 to select the TIM peripheral.
  * @retval None

  */
void TIM_DeInit(TIM_TypeDef* TIMx)
{
 800482a:	b508      	push	{r3, lr}
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
 
  if (TIMx == TIM1)
 800482c:	4b36      	ldr	r3, [pc, #216]	; (8004908 <TIM_DeInit+0xde>)
 800482e:	4298      	cmp	r0, r3
 8004830:	d107      	bne.n	8004842 <TIM_DeInit+0x18>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
 8004832:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8004836:	2101      	movs	r1, #1
 8004838:	f7ff fd70 	bl	800431c <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
 800483c:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8004840:	e05b      	b.n	80048fa <TIM_DeInit+0xd0>
  } 
  else if (TIMx == TIM2) 
 8004842:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 8004846:	d105      	bne.n	8004854 <TIM_DeInit+0x2a>
  {     
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
 8004848:	2001      	movs	r0, #1
 800484a:	4601      	mov	r1, r0
 800484c:	f7ff fd72 	bl	8004334 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
 8004850:	2001      	movs	r0, #1
 8004852:	e007      	b.n	8004864 <TIM_DeInit+0x3a>
  }  
  else if (TIMx == TIM3)
 8004854:	4b2d      	ldr	r3, [pc, #180]	; (800490c <TIM_DeInit+0xe2>)
 8004856:	4298      	cmp	r0, r3
 8004858:	d109      	bne.n	800486e <TIM_DeInit+0x44>
  { 
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
 800485a:	2002      	movs	r0, #2
 800485c:	2101      	movs	r1, #1
 800485e:	f7ff fd69 	bl	8004334 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
 8004862:	2002      	movs	r0, #2
 8004864:	2100      	movs	r1, #0
    {     
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, ENABLE);
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, DISABLE); 
    }   
  }
}
 8004866:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
  }  
  else if (TIMx == TIM3)
  { 
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
 800486a:	f7ff bd63 	b.w	8004334 <RCC_APB1PeriphResetCmd>
  }  
  else if (TIMx == TIM4)
 800486e:	4b28      	ldr	r3, [pc, #160]	; (8004910 <TIM_DeInit+0xe6>)
 8004870:	4298      	cmp	r0, r3
 8004872:	d105      	bne.n	8004880 <TIM_DeInit+0x56>
  { 
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
 8004874:	2004      	movs	r0, #4
 8004876:	2101      	movs	r1, #1
 8004878:	f7ff fd5c 	bl	8004334 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
 800487c:	2004      	movs	r0, #4
 800487e:	e7f1      	b.n	8004864 <TIM_DeInit+0x3a>
  }   
  else if (TIMx == TIM6)  
 8004880:	4b24      	ldr	r3, [pc, #144]	; (8004914 <TIM_DeInit+0xea>)
 8004882:	4298      	cmp	r0, r3
 8004884:	d105      	bne.n	8004892 <TIM_DeInit+0x68>
  {    
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
 8004886:	2010      	movs	r0, #16
 8004888:	2101      	movs	r1, #1
 800488a:	f7ff fd53 	bl	8004334 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
 800488e:	2010      	movs	r0, #16
 8004890:	e7e8      	b.n	8004864 <TIM_DeInit+0x3a>
  }  
  else if (TIMx == TIM7)
 8004892:	4b21      	ldr	r3, [pc, #132]	; (8004918 <TIM_DeInit+0xee>)
 8004894:	4298      	cmp	r0, r3
 8004896:	d105      	bne.n	80048a4 <TIM_DeInit+0x7a>
  {      
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
 8004898:	2020      	movs	r0, #32
 800489a:	2101      	movs	r1, #1
 800489c:	f7ff fd4a 	bl	8004334 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
 80048a0:	2020      	movs	r0, #32
 80048a2:	e7df      	b.n	8004864 <TIM_DeInit+0x3a>
  }  
  else if (TIMx == TIM8)
 80048a4:	4b1d      	ldr	r3, [pc, #116]	; (800491c <TIM_DeInit+0xf2>)
 80048a6:	4298      	cmp	r0, r3
 80048a8:	d107      	bne.n	80048ba <TIM_DeInit+0x90>
  {      
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
 80048aa:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 80048ae:	2101      	movs	r1, #1
 80048b0:	f7ff fd34 	bl	800431c <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);  
 80048b4:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 80048b8:	e01f      	b.n	80048fa <TIM_DeInit+0xd0>
  }    
  else if (TIMx == TIM15)
 80048ba:	4b19      	ldr	r3, [pc, #100]	; (8004920 <TIM_DeInit+0xf6>)
 80048bc:	4298      	cmp	r0, r3
 80048be:	d107      	bne.n	80048d0 <TIM_DeInit+0xa6>
  {      
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM15, ENABLE);
 80048c0:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 80048c4:	2101      	movs	r1, #1
 80048c6:	f7ff fd29 	bl	800431c <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM15, DISABLE);  
 80048ca:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 80048ce:	e014      	b.n	80048fa <TIM_DeInit+0xd0>
  }  
  else if (TIMx == TIM16) 
 80048d0:	4b14      	ldr	r3, [pc, #80]	; (8004924 <TIM_DeInit+0xfa>)
 80048d2:	4298      	cmp	r0, r3
 80048d4:	d107      	bne.n	80048e6 <TIM_DeInit+0xbc>
  {       
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM16, ENABLE);
 80048d6:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 80048da:	2101      	movs	r1, #1
 80048dc:	f7ff fd1e 	bl	800431c <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM16, DISABLE);  
 80048e0:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 80048e4:	e009      	b.n	80048fa <TIM_DeInit+0xd0>
  }  
  else
  { 
    if (TIMx == TIM17) 
 80048e6:	4b10      	ldr	r3, [pc, #64]	; (8004928 <TIM_DeInit+0xfe>)
 80048e8:	4298      	cmp	r0, r3
 80048ea:	d10b      	bne.n	8004904 <TIM_DeInit+0xda>
    {     
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, ENABLE);
 80048ec:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 80048f0:	2101      	movs	r1, #1
 80048f2:	f7ff fd13 	bl	800431c <RCC_APB2PeriphResetCmd>
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, DISABLE); 
 80048f6:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 80048fa:	2100      	movs	r1, #0
    }   
  }
}
 80048fc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  else
  { 
    if (TIMx == TIM17) 
    {     
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, ENABLE);
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, DISABLE); 
 8004900:	f7ff bd0c 	b.w	800431c <RCC_APB2PeriphResetCmd>
 8004904:	bd08      	pop	{r3, pc}
 8004906:	bf00      	nop
 8004908:	40012c00 	.word	0x40012c00
 800490c:	40000400 	.word	0x40000400
 8004910:	40000800 	.word	0x40000800
 8004914:	40001000 	.word	0x40001000
 8004918:	40001400 	.word	0x40001400
 800491c:	40013400 	.word	0x40013400
 8004920:	40014000 	.word	0x40014000
 8004924:	40014400 	.word	0x40014400
 8004928:	40014800 	.word	0x40014800

0800492c <TIM_TimeBaseInit>:
  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));

  tmpcr1 = TIMx->CR1;  

  if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM2) || 
 800492c:	4a20      	ldr	r2, [pc, #128]	; (80049b0 <TIM_TimeBaseInit+0x84>)
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));

  tmpcr1 = TIMx->CR1;  
 800492e:	8803      	ldrh	r3, [r0, #0]

  if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM2) || 
 8004930:	4290      	cmp	r0, r2
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));

  tmpcr1 = TIMx->CR1;  
 8004932:	b29b      	uxth	r3, r3

  if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM2) || 
 8004934:	d00e      	beq.n	8004954 <TIM_TimeBaseInit+0x28>
 8004936:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 800493a:	4290      	cmp	r0, r2
 800493c:	d00a      	beq.n	8004954 <TIM_TimeBaseInit+0x28>
 800493e:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 8004942:	d007      	beq.n	8004954 <TIM_TimeBaseInit+0x28>
 8004944:	f5a2 3298 	sub.w	r2, r2, #77824	; 0x13000
 8004948:	4290      	cmp	r0, r2
 800494a:	d003      	beq.n	8004954 <TIM_TimeBaseInit+0x28>
     (TIMx == TIM3)|| (TIMx == TIM4)) 
 800494c:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8004950:	4290      	cmp	r0, r2
 8004952:	d103      	bne.n	800495c <TIM_TimeBaseInit+0x30>
  {
    /* Select the Counter Mode */
    tmpcr1 &= (uint16_t)(~(TIM_CR1_DIR | TIM_CR1_CMS));
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
 8004954:	884a      	ldrh	r2, [r1, #2]

  if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM2) || 
     (TIMx == TIM3)|| (TIMx == TIM4)) 
  {
    /* Select the Counter Mode */
    tmpcr1 &= (uint16_t)(~(TIM_CR1_DIR | TIM_CR1_CMS));
 8004956:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
 800495a:	4313      	orrs	r3, r2
  }
 
  if((TIMx != TIM6) && (TIMx != TIM7))
 800495c:	4a15      	ldr	r2, [pc, #84]	; (80049b4 <TIM_TimeBaseInit+0x88>)
 800495e:	4290      	cmp	r0, r2
 8004960:	d008      	beq.n	8004974 <TIM_TimeBaseInit+0x48>
 8004962:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8004966:	4290      	cmp	r0, r2
 8004968:	d004      	beq.n	8004974 <TIM_TimeBaseInit+0x48>
  {
    /* Set the clock division */
    tmpcr1 &=  (uint16_t)(~TIM_CR1_CKD);
 800496a:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
 800496e:	890a      	ldrh	r2, [r1, #8]
  }
 
  if((TIMx != TIM6) && (TIMx != TIM7))
  {
    /* Set the clock division */
    tmpcr1 &=  (uint16_t)(~TIM_CR1_CKD);
 8004970:	b29b      	uxth	r3, r3
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
 8004972:	4313      	orrs	r3, r2
  }

  TIMx->CR1 = tmpcr1;
 8004974:	8003      	strh	r3, [r0, #0]

  /* Set the Autoreload value */
  TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
 8004976:	684b      	ldr	r3, [r1, #4]
 8004978:	62c3      	str	r3, [r0, #44]	; 0x2c
 
  /* Set the Prescaler value */
  TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
 800497a:	880b      	ldrh	r3, [r1, #0]
 800497c:	8503      	strh	r3, [r0, #40]	; 0x28
    
  if ((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM15) || 
 800497e:	4b0c      	ldr	r3, [pc, #48]	; (80049b0 <TIM_TimeBaseInit+0x84>)
 8004980:	4298      	cmp	r0, r3
 8004982:	d00f      	beq.n	80049a4 <TIM_TimeBaseInit+0x78>
 8004984:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8004988:	4298      	cmp	r0, r3
 800498a:	d00b      	beq.n	80049a4 <TIM_TimeBaseInit+0x78>
 800498c:	f503 6340 	add.w	r3, r3, #3072	; 0xc00
 8004990:	4298      	cmp	r0, r3
 8004992:	d007      	beq.n	80049a4 <TIM_TimeBaseInit+0x78>
 8004994:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8004998:	4298      	cmp	r0, r3
 800499a:	d003      	beq.n	80049a4 <TIM_TimeBaseInit+0x78>
      (TIMx == TIM16) || (TIMx == TIM17))  
 800499c:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80049a0:	4298      	cmp	r0, r3
 80049a2:	d101      	bne.n	80049a8 <TIM_TimeBaseInit+0x7c>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
 80049a4:	7a8b      	ldrb	r3, [r1, #10]
 80049a6:	8603      	strh	r3, [r0, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler 
     and the repetition counter(only for TIM1 and TIM8) value immediatly */
  TIMx->EGR = TIM_PSCReloadMode_Immediate;          
 80049a8:	2301      	movs	r3, #1
 80049aa:	6143      	str	r3, [r0, #20]
 80049ac:	4770      	bx	lr
 80049ae:	bf00      	nop
 80049b0:	40012c00 	.word	0x40012c00
 80049b4:	40001000 	.word	0x40001000

080049b8 <TIM_TimeBaseStructInit>:
  * @retval None
  */
void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
{
  /* Set the default configuration */
  TIM_TimeBaseInitStruct->TIM_Period = 0xFFFFFFFF;
 80049b8:	f04f 33ff 	mov.w	r3, #4294967295
 80049bc:	6043      	str	r3, [r0, #4]
  TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
 80049be:	2300      	movs	r3, #0
 80049c0:	8003      	strh	r3, [r0, #0]
  TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
 80049c2:	8103      	strh	r3, [r0, #8]
  TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
 80049c4:	8043      	strh	r3, [r0, #2]
  TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
 80049c6:	7283      	strb	r3, [r0, #10]
 80049c8:	4770      	bx	lr

080049ca <TIM_PrescalerConfig>:
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
  /* Set the Prescaler value */
  TIMx->PSC = Prescaler;
 80049ca:	8501      	strh	r1, [r0, #40]	; 0x28
  /* Set or reset the UG Bit */
  TIMx->EGR = TIM_PSCReloadMode;
 80049cc:	6142      	str	r2, [r0, #20]
 80049ce:	4770      	bx	lr

080049d0 <TIM_CounterModeConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));

  tmpcr1 = TIMx->CR1;
 80049d0:	8803      	ldrh	r3, [r0, #0]

  /* Reset the CMS and DIR Bits */
  tmpcr1 &= (uint16_t)~(TIM_CR1_DIR | TIM_CR1_CMS);
 80049d2:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80049d6:	041b      	lsls	r3, r3, #16
 80049d8:	0c1b      	lsrs	r3, r3, #16

  /* Set the Counter Mode */
  tmpcr1 |= TIM_CounterMode;
 80049da:	4319      	orrs	r1, r3

  /* Write to TIMx CR1 register */
  TIMx->CR1 = tmpcr1;
 80049dc:	8001      	strh	r1, [r0, #0]
 80049de:	4770      	bx	lr

080049e0 <TIM_SetCounter>:
{
  /* Check the parameters */
   assert_param(IS_TIM_ALL_PERIPH(TIMx));

  /* Set the Counter Register value */
  TIMx->CNT = Counter;
 80049e0:	6241      	str	r1, [r0, #36]	; 0x24
 80049e2:	4770      	bx	lr

080049e4 <TIM_SetAutoreload>:
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  
  /* Set the Autoreload Register value */
  TIMx->ARR = Autoreload;
 80049e4:	62c1      	str	r1, [r0, #44]	; 0x2c
 80049e6:	4770      	bx	lr

080049e8 <TIM_GetCounter>:
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));

  /* Get the Counter Register value */
  return TIMx->CNT;
 80049e8:	6a40      	ldr	r0, [r0, #36]	; 0x24
}
 80049ea:	4770      	bx	lr

080049ec <TIM_GetPrescaler>:
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));

  /* Get the Prescaler Register value */
  return TIMx->PSC;
 80049ec:	8d00      	ldrh	r0, [r0, #40]	; 0x28
}
 80049ee:	b280      	uxth	r0, r0
 80049f0:	4770      	bx	lr

080049f2 <TIM_UpdateDisableConfig>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Set the Update Disable Bit */
    TIMx->CR1 |= TIM_CR1_UDIS;
 80049f2:	8803      	ldrh	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80049f4:	b119      	cbz	r1, 80049fe <TIM_UpdateDisableConfig+0xc>
  {
    /* Set the Update Disable Bit */
    TIMx->CR1 |= TIM_CR1_UDIS;
 80049f6:	b29b      	uxth	r3, r3
 80049f8:	f043 0302 	orr.w	r3, r3, #2
 80049fc:	e003      	b.n	8004a06 <TIM_UpdateDisableConfig+0x14>
  }
  else
  {
    /* Reset the Update Disable Bit */
    TIMx->CR1 &= (uint16_t)~TIM_CR1_UDIS;
 80049fe:	f023 0302 	bic.w	r3, r3, #2
 8004a02:	041b      	lsls	r3, r3, #16
 8004a04:	0c1b      	lsrs	r3, r3, #16
 8004a06:	8003      	strh	r3, [r0, #0]
 8004a08:	4770      	bx	lr

08004a0a <TIM_UpdateRequestConfig>:
  assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));

  if (TIM_UpdateSource != TIM_UpdateSource_Global)
  {
    /* Set the URS Bit */
    TIMx->CR1 |= TIM_CR1_URS;
 8004a0a:	8803      	ldrh	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));

  if (TIM_UpdateSource != TIM_UpdateSource_Global)
 8004a0c:	b119      	cbz	r1, 8004a16 <TIM_UpdateRequestConfig+0xc>
  {
    /* Set the URS Bit */
    TIMx->CR1 |= TIM_CR1_URS;
 8004a0e:	b29b      	uxth	r3, r3
 8004a10:	f043 0304 	orr.w	r3, r3, #4
 8004a14:	e003      	b.n	8004a1e <TIM_UpdateRequestConfig+0x14>
  }
  else
  {
    /* Reset the URS Bit */
    TIMx->CR1 &= (uint16_t)~TIM_CR1_URS;
 8004a16:	f023 0304 	bic.w	r3, r3, #4
 8004a1a:	041b      	lsls	r3, r3, #16
 8004a1c:	0c1b      	lsrs	r3, r3, #16
 8004a1e:	8003      	strh	r3, [r0, #0]
 8004a20:	4770      	bx	lr

08004a22 <TIM_UIFRemap>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the TIM Counter */
    TIMx->CR1 |= TIM_CR1_UIFREMAP;
 8004a22:	8803      	ldrh	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8004a24:	b119      	cbz	r1, 8004a2e <TIM_UIFRemap+0xc>
  {
    /* Enable the TIM Counter */
    TIMx->CR1 |= TIM_CR1_UIFREMAP;
 8004a26:	b29b      	uxth	r3, r3
 8004a28:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8004a2c:	e003      	b.n	8004a36 <TIM_UIFRemap+0x14>
  }
  else
  {
    /* Disable the TIM Counter */
    TIMx->CR1 &= (uint16_t)~TIM_CR1_UIFREMAP;
 8004a2e:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8004a32:	041b      	lsls	r3, r3, #16
 8004a34:	0c1b      	lsrs	r3, r3, #16
 8004a36:	8003      	strh	r3, [r0, #0]
 8004a38:	4770      	bx	lr

08004a3a <TIM_ARRPreloadConfig>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Set the ARR Preload Bit */
    TIMx->CR1 |= TIM_CR1_ARPE;
 8004a3a:	8803      	ldrh	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8004a3c:	b119      	cbz	r1, 8004a46 <TIM_ARRPreloadConfig+0xc>
  {
    /* Set the ARR Preload Bit */
    TIMx->CR1 |= TIM_CR1_ARPE;
 8004a3e:	b29b      	uxth	r3, r3
 8004a40:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8004a44:	e003      	b.n	8004a4e <TIM_ARRPreloadConfig+0x14>
  }
  else
  {
    /* Reset the ARR Preload Bit */
    TIMx->CR1 &= (uint16_t)~TIM_CR1_ARPE;
 8004a46:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8004a4a:	041b      	lsls	r3, r3, #16
 8004a4c:	0c1b      	lsrs	r3, r3, #16
 8004a4e:	8003      	strh	r3, [r0, #0]
 8004a50:	4770      	bx	lr

08004a52 <TIM_SelectOnePulseMode>:
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_OPM_MODE(TIM_OPMode));

  /* Reset the OPM Bit */
  TIMx->CR1 &= (uint16_t)~TIM_CR1_OPM;
 8004a52:	8803      	ldrh	r3, [r0, #0]
 8004a54:	f023 0308 	bic.w	r3, r3, #8
 8004a58:	041b      	lsls	r3, r3, #16
 8004a5a:	0c1b      	lsrs	r3, r3, #16
 8004a5c:	8003      	strh	r3, [r0, #0]

  /* Configure the OPM Mode */
  TIMx->CR1 |= TIM_OPMode;
 8004a5e:	8803      	ldrh	r3, [r0, #0]
 8004a60:	b29b      	uxth	r3, r3
 8004a62:	4319      	orrs	r1, r3
 8004a64:	8001      	strh	r1, [r0, #0]
 8004a66:	4770      	bx	lr

08004a68 <TIM_SetClockDivision>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_CKD_DIV(TIM_CKD));

  /* Reset the CKD Bits */
  TIMx->CR1 &= (uint16_t)(~TIM_CR1_CKD);
 8004a68:	8803      	ldrh	r3, [r0, #0]
 8004a6a:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8004a6e:	041b      	lsls	r3, r3, #16
 8004a70:	0c1b      	lsrs	r3, r3, #16
 8004a72:	8003      	strh	r3, [r0, #0]

  /* Set the CKD value */
  TIMx->CR1 |= TIM_CKD;
 8004a74:	8803      	ldrh	r3, [r0, #0]
 8004a76:	b29b      	uxth	r3, r3
 8004a78:	4319      	orrs	r1, r3
 8004a7a:	8001      	strh	r1, [r0, #0]
 8004a7c:	4770      	bx	lr

08004a7e <TIM_Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the TIM Counter */
    TIMx->CR1 |= TIM_CR1_CEN;
 8004a7e:	8803      	ldrh	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8004a80:	b119      	cbz	r1, 8004a8a <TIM_Cmd+0xc>
  {
    /* Enable the TIM Counter */
    TIMx->CR1 |= TIM_CR1_CEN;
 8004a82:	b29b      	uxth	r3, r3
 8004a84:	f043 0301 	orr.w	r3, r3, #1
 8004a88:	e003      	b.n	8004a92 <TIM_Cmd+0x14>
  }
  else
  {
    /* Disable the TIM Counter */
    TIMx->CR1 &= (uint16_t)~TIM_CR1_CEN;
 8004a8a:	f023 0301 	bic.w	r3, r3, #1
 8004a8e:	041b      	lsls	r3, r3, #16
 8004a90:	0c1b      	lsrs	r3, r3, #16
 8004a92:	8003      	strh	r3, [r0, #0]
 8004a94:	4770      	bx	lr

08004a96 <TIM_OC1Init>:
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint32_t)~TIM_CCER_CC1E;
 8004a96:	6a03      	ldr	r3, [r0, #32]
 8004a98:	f023 0301 	bic.w	r3, r3, #1
 8004a9c:	6203      	str	r3, [r0, #32]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8004a9e:	6a03      	ldr	r3, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8004aa0:	6842      	ldr	r2, [r0, #4]
  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 8004aa2:	b530      	push	{r4, r5, lr}
  tmpccer = TIMx->CCER;
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
  
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 8004aa4:	6984      	ldr	r4, [r0, #24]
    
  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= (uint32_t)~TIM_CCMR1_OC1M;
  tmpccmrx &= (uint32_t)~TIM_CCMR1_CC1S;
  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
 8004aa6:	680d      	ldr	r5, [r1, #0]
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
    
  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= (uint32_t)~TIM_CCMR1_OC1M;
  tmpccmrx &= (uint32_t)~TIM_CCMR1_CC1S;
 8004aa8:	f424 3480 	bic.w	r4, r4, #65536	; 0x10000
 8004aac:	f024 0473 	bic.w	r4, r4, #115	; 0x73
  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
 8004ab0:	432c      	orrs	r4, r5
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC1P;
  /* Set the Output Compare Polarity */
  tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
 8004ab2:	898d      	ldrh	r5, [r1, #12]
  tmpccmrx &= (uint32_t)~TIM_CCMR1_CC1S;
  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC1P;
 8004ab4:	f023 0302 	bic.w	r3, r3, #2
  /* Set the Output Compare Polarity */
  tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
 8004ab8:	432b      	orrs	r3, r5
  
  /* Set the Output State */
  tmpccer |= TIM_OCInitStruct->TIM_OutputState;
 8004aba:	888d      	ldrh	r5, [r1, #4]
 8004abc:	432b      	orrs	r3, r5
    
  if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM15) || (TIMx == TIM16) || (TIMx == TIM17))
 8004abe:	4d13      	ldr	r5, [pc, #76]	; (8004b0c <TIM_OC1Init+0x76>)
 8004ac0:	42a8      	cmp	r0, r5
 8004ac2:	d00f      	beq.n	8004ae4 <TIM_OC1Init+0x4e>
 8004ac4:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 8004ac8:	42a8      	cmp	r0, r5
 8004aca:	d00b      	beq.n	8004ae4 <TIM_OC1Init+0x4e>
 8004acc:	f505 6540 	add.w	r5, r5, #3072	; 0xc00
 8004ad0:	42a8      	cmp	r0, r5
 8004ad2:	d007      	beq.n	8004ae4 <TIM_OC1Init+0x4e>
 8004ad4:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8004ad8:	42a8      	cmp	r0, r5
 8004ada:	d003      	beq.n	8004ae4 <TIM_OC1Init+0x4e>
 8004adc:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8004ae0:	42a8      	cmp	r0, r5
 8004ae2:	d10d      	bne.n	8004b00 <TIM_OC1Init+0x6a>
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= (uint32_t)~TIM_CCER_CC1NP;
    /* Set the Output N Polarity */
    tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
 8004ae4:	89cd      	ldrh	r5, [r1, #14]
    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= (uint32_t)~TIM_CCER_CC1NP;
 8004ae6:	f023 0308 	bic.w	r3, r3, #8
    /* Set the Output N Polarity */
    tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
 8004aea:	432b      	orrs	r3, r5
    /* Reset the Output N State */
    tmpccer &= (uint32_t)~TIM_CCER_CC1NE;
    
    /* Set the Output N State */
    tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
 8004aec:	88cd      	ldrh	r5, [r1, #6]
    /* Reset the Output N Polarity level */
    tmpccer &= (uint32_t)~TIM_CCER_CC1NP;
    /* Set the Output N Polarity */
    tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
    /* Reset the Output N State */
    tmpccer &= (uint32_t)~TIM_CCER_CC1NE;
 8004aee:	f023 0304 	bic.w	r3, r3, #4
    
    /* Set the Output N State */
    tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
 8004af2:	432b      	orrs	r3, r5
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint32_t)~TIM_CR2_OIS1;
    tmpcr2 &= (uint32_t)~TIM_CR2_OIS1N;
    /* Set the Output Idle state */
    tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
 8004af4:	8a0d      	ldrh	r5, [r1, #16]
    
    /* Set the Output N State */
    tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint32_t)~TIM_CR2_OIS1;
    tmpcr2 &= (uint32_t)~TIM_CR2_OIS1N;
 8004af6:	f422 7240 	bic.w	r2, r2, #768	; 0x300
    /* Set the Output Idle state */
    tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
 8004afa:	432a      	orrs	r2, r5
    /* Set the Output N Idle state */
    tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
 8004afc:	8a4d      	ldrh	r5, [r1, #18]
 8004afe:	432a      	orrs	r2, r5
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8004b00:	6042      	str	r2, [r0, #4]
  
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
  
  /* Set the Capture Compare Register value */
  TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse;
 8004b02:	688a      	ldr	r2, [r1, #8]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
  
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 8004b04:	6184      	str	r4, [r0, #24]
  
  /* Set the Capture Compare Register value */
  TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse;
 8004b06:	6342      	str	r2, [r0, #52]	; 0x34
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8004b08:	6203      	str	r3, [r0, #32]
 8004b0a:	bd30      	pop	{r4, r5, pc}
 8004b0c:	40012c00 	.word	0x40012c00

08004b10 <TIM_OC2Init>:
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint32_t)~TIM_CCER_CC2E;
 8004b10:	6a03      	ldr	r3, [r0, #32]
 8004b12:	f023 0310 	bic.w	r3, r3, #16
 8004b16:	6203      	str	r3, [r0, #32]
  
  /* Get the TIMx CCER register value */  
  tmpccer = TIMx->CCER;
 8004b18:	6a03      	ldr	r3, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8004b1a:	6842      	ldr	r2, [r0, #4]
  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 8004b1c:	b570      	push	{r4, r5, r6, lr}
  tmpccer = TIMx->CCER;
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
  
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 8004b1e:	6984      	ldr	r4, [r0, #24]
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint32_t)~TIM_CCMR1_OC2M;
  tmpccmrx &= (uint32_t)~TIM_CCMR1_CC2S;
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint32_t)(TIM_OCInitStruct->TIM_OCMode << 8);
 8004b20:	680d      	ldr	r5, [r1, #0]
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC2P;
  /* Set the Output Compare Polarity */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCPolarity << 4);
 8004b22:	898e      	ldrh	r6, [r1, #12]
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint32_t)~TIM_CCMR1_OC2M;
  tmpccmrx &= (uint32_t)~TIM_CCMR1_CC2S;
 8004b24:	f024 7480 	bic.w	r4, r4, #16777216	; 0x1000000
 8004b28:	f424 44e6 	bic.w	r4, r4, #29440	; 0x7300
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint32_t)(TIM_OCInitStruct->TIM_OCMode << 8);
 8004b2c:	ea44 2405 	orr.w	r4, r4, r5, lsl #8
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC2P;
 8004b30:	f023 0520 	bic.w	r5, r3, #32
  /* Set the Output Compare Polarity */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCPolarity << 4);
  
  /* Set the Output State */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputState << 4);
 8004b34:	888b      	ldrh	r3, [r1, #4]
  tmpccmrx |= (uint32_t)(TIM_OCInitStruct->TIM_OCMode << 8);
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC2P;
  /* Set the Output Compare Polarity */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCPolarity << 4);
 8004b36:	4333      	orrs	r3, r6
  
  /* Set the Output State */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputState << 4);
 8004b38:	ea45 1303 	orr.w	r3, r5, r3, lsl #4
    
  if((TIMx == TIM1) || (TIMx == TIM8))
 8004b3c:	4d0e      	ldr	r5, [pc, #56]	; (8004b78 <TIM_OC2Init+0x68>)
 8004b3e:	42a8      	cmp	r0, r5
 8004b40:	d003      	beq.n	8004b4a <TIM_OC2Init+0x3a>
 8004b42:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 8004b46:	42a8      	cmp	r0, r5
 8004b48:	d110      	bne.n	8004b6c <TIM_OC2Init+0x5c>
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= (uint32_t)~TIM_CCER_CC2NP;
    /* Set the Output N Polarity */
    tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCNPolarity << 4);
 8004b4a:	89cd      	ldrh	r5, [r1, #14]
    tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputNState << 4);
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint32_t)~TIM_CR2_OIS2;
    tmpcr2 &= (uint32_t)~TIM_CR2_OIS2N;
    /* Set the Output Idle state */
    tmpcr2 |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCIdleState << 2);
 8004b4c:	8a0e      	ldrh	r6, [r1, #16]
    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= (uint32_t)~TIM_CCER_CC2NP;
 8004b4e:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    /* Set the Output N Polarity */
    tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCNPolarity << 4);
 8004b52:	ea43 1305 	orr.w	r3, r3, r5, lsl #4
    /* Reset the Output N State */
    tmpccer &= (uint32_t)~TIM_CCER_CC2NE;
    
    /* Set the Output N State */
    tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputNState << 4);
 8004b56:	88cd      	ldrh	r5, [r1, #6]
    /* Reset the Output N Polarity level */
    tmpccer &= (uint32_t)~TIM_CCER_CC2NP;
    /* Set the Output N Polarity */
    tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCNPolarity << 4);
    /* Reset the Output N State */
    tmpccer &= (uint32_t)~TIM_CCER_CC2NE;
 8004b58:	f023 0340 	bic.w	r3, r3, #64	; 0x40
    
    /* Set the Output N State */
    tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputNState << 4);
 8004b5c:	ea43 1305 	orr.w	r3, r3, r5, lsl #4
    tmpcr2 &= (uint32_t)~TIM_CR2_OIS2;
    tmpcr2 &= (uint32_t)~TIM_CR2_OIS2N;
    /* Set the Output Idle state */
    tmpcr2 |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCIdleState << 2);
    /* Set the Output N Idle state */
    tmpcr2 |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCNIdleState << 2);
 8004b60:	8a4d      	ldrh	r5, [r1, #18]
    
    /* Set the Output N State */
    tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputNState << 4);
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint32_t)~TIM_CR2_OIS2;
    tmpcr2 &= (uint32_t)~TIM_CR2_OIS2N;
 8004b62:	f422 6240 	bic.w	r2, r2, #3072	; 0xc00
    /* Set the Output Idle state */
    tmpcr2 |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCIdleState << 2);
 8004b66:	4335      	orrs	r5, r6
    /* Set the Output N Idle state */
    tmpcr2 |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCNIdleState << 2);
 8004b68:	ea42 0285 	orr.w	r2, r2, r5, lsl #2
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8004b6c:	6042      	str	r2, [r0, #4]
  
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
  
  /* Set the Capture Compare Register value */
  TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
 8004b6e:	688a      	ldr	r2, [r1, #8]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
  
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 8004b70:	6184      	str	r4, [r0, #24]
  
  /* Set the Capture Compare Register value */
  TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
 8004b72:	6382      	str	r2, [r0, #56]	; 0x38
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8004b74:	6203      	str	r3, [r0, #32]
 8004b76:	bd70      	pop	{r4, r5, r6, pc}
 8004b78:	40012c00 	.word	0x40012c00

08004b7c <TIM_OC3Init>:
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= (uint32_t)~TIM_CCER_CC3E;
 8004b7c:	6a03      	ldr	r3, [r0, #32]
 8004b7e:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8004b82:	6203      	str	r3, [r0, #32]
  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 8004b84:	b570      	push	{r4, r5, r6, lr}

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= (uint32_t)~TIM_CCER_CC3E;
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8004b86:	6a05      	ldr	r5, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8004b88:	6842      	ldr	r2, [r0, #4]
  
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 8004b8a:	69c3      	ldr	r3, [r0, #28]
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint32_t)~TIM_CCMR2_OC3M;
  tmpccmrx &= (uint32_t)~TIM_CCMR2_CC3S;  
  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
 8004b8c:	680c      	ldr	r4, [r1, #0]
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC3P;
  /* Set the Output Compare Polarity */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCPolarity << 8);
 8004b8e:	898e      	ldrh	r6, [r1, #12]
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint32_t)~TIM_CCMR2_OC3M;
  tmpccmrx &= (uint32_t)~TIM_CCMR2_CC3S;  
 8004b90:	f023 0373 	bic.w	r3, r3, #115	; 0x73
  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
 8004b94:	431c      	orrs	r4, r3
  tmpccer &= (uint32_t)~TIM_CCER_CC3P;
  /* Set the Output Compare Polarity */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCPolarity << 8);
  
  /* Set the Output State */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputState << 8);
 8004b96:	888b      	ldrh	r3, [r1, #4]
  tmpccmrx &= (uint32_t)~TIM_CCMR2_CC3S;  
  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC3P;
 8004b98:	f425 7500 	bic.w	r5, r5, #512	; 0x200
  /* Set the Output Compare Polarity */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCPolarity << 8);
 8004b9c:	4333      	orrs	r3, r6
  
  /* Set the Output State */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputState << 8);
 8004b9e:	ea45 2303 	orr.w	r3, r5, r3, lsl #8
    
  if((TIMx == TIM1) || (TIMx == TIM8))
 8004ba2:	4d0f      	ldr	r5, [pc, #60]	; (8004be0 <TIM_OC3Init+0x64>)
 8004ba4:	42a8      	cmp	r0, r5
 8004ba6:	d003      	beq.n	8004bb0 <TIM_OC3Init+0x34>
 8004ba8:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 8004bac:	42a8      	cmp	r0, r5
 8004bae:	d110      	bne.n	8004bd2 <TIM_OC3Init+0x56>
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= (uint32_t)~TIM_CCER_CC3NP;
    /* Set the Output N Polarity */
    tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCNPolarity << 8);
 8004bb0:	89cd      	ldrh	r5, [r1, #14]
    tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputNState << 8);
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint32_t)~TIM_CR2_OIS3;
    tmpcr2 &= (uint32_t)~TIM_CR2_OIS3N;
    /* Set the Output Idle state */
    tmpcr2 |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCIdleState << 4);
 8004bb2:	8a0e      	ldrh	r6, [r1, #16]
    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= (uint32_t)~TIM_CCER_CC3NP;
 8004bb4:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
    /* Set the Output N Polarity */
    tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCNPolarity << 8);
 8004bb8:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
    /* Reset the Output N State */
    tmpccer &= (uint32_t)~TIM_CCER_CC3NE;
    
    /* Set the Output N State */
    tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputNState << 8);
 8004bbc:	88cd      	ldrh	r5, [r1, #6]
    /* Reset the Output N Polarity level */
    tmpccer &= (uint32_t)~TIM_CCER_CC3NP;
    /* Set the Output N Polarity */
    tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCNPolarity << 8);
    /* Reset the Output N State */
    tmpccer &= (uint32_t)~TIM_CCER_CC3NE;
 8004bbe:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
    
    /* Set the Output N State */
    tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputNState << 8);
 8004bc2:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
    tmpcr2 &= (uint32_t)~TIM_CR2_OIS3;
    tmpcr2 &= (uint32_t)~TIM_CR2_OIS3N;
    /* Set the Output Idle state */
    tmpcr2 |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCIdleState << 4);
    /* Set the Output N Idle state */
    tmpcr2 |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCNIdleState << 4);
 8004bc6:	8a4d      	ldrh	r5, [r1, #18]
    
    /* Set the Output N State */
    tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputNState << 8);
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint32_t)~TIM_CR2_OIS3;
    tmpcr2 &= (uint32_t)~TIM_CR2_OIS3N;
 8004bc8:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
    /* Set the Output Idle state */
    tmpcr2 |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCIdleState << 4);
 8004bcc:	4335      	orrs	r5, r6
    /* Set the Output N Idle state */
    tmpcr2 |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCNIdleState << 4);
 8004bce:	ea42 1205 	orr.w	r2, r2, r5, lsl #4
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8004bd2:	6042      	str	r2, [r0, #4]
  
  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
  
  /* Set the Capture Compare Register value */
  TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
 8004bd4:	688a      	ldr	r2, [r1, #8]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
  
  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 8004bd6:	61c4      	str	r4, [r0, #28]
  
  /* Set the Capture Compare Register value */
  TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
 8004bd8:	63c2      	str	r2, [r0, #60]	; 0x3c
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8004bda:	6203      	str	r3, [r0, #32]
 8004bdc:	bd70      	pop	{r4, r5, r6, pc}
 8004bde:	bf00      	nop
 8004be0:	40012c00 	.word	0x40012c00

08004be4 <TIM_OC4Init>:
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= (uint32_t)~TIM_CCER_CC4E;
 8004be4:	6a03      	ldr	r3, [r0, #32]
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint32_t)~TIM_CCMR2_OC4M;
  tmpccmrx &= (uint32_t)~TIM_CCMR2_CC4S;
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint32_t)(TIM_OCInitStruct->TIM_OCMode << 8);
 8004be6:	680a      	ldr	r2, [r1, #0]
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= (uint32_t)~TIM_CCER_CC4E;
 8004be8:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8004bec:	6203      	str	r3, [r0, #32]
  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 8004bee:	b570      	push	{r4, r5, r6, lr}

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= (uint32_t)~TIM_CCER_CC4E;
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8004bf0:	6a05      	ldr	r5, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8004bf2:	6843      	ldr	r3, [r0, #4]
  
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 8004bf4:	69c4      	ldr	r4, [r0, #28]
  tmpccmrx |= (uint32_t)(TIM_OCInitStruct->TIM_OCMode << 8);
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC4P;
  /* Set the Output Compare Polarity */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCPolarity << 12);
 8004bf6:	898e      	ldrh	r6, [r1, #12]
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint32_t)~TIM_CCMR2_OC4M;
  tmpccmrx &= (uint32_t)~TIM_CCMR2_CC4S;
 8004bf8:	f424 44e6 	bic.w	r4, r4, #29440	; 0x7300
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint32_t)(TIM_OCInitStruct->TIM_OCMode << 8);
 8004bfc:	ea44 2202 	orr.w	r2, r4, r2, lsl #8
  tmpccer &= (uint32_t)~TIM_CCER_CC4P;
  /* Set the Output Compare Polarity */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCPolarity << 12);
  
  /* Set the Output State */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputState << 12);
 8004c00:	888c      	ldrh	r4, [r1, #4]
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint32_t)(TIM_OCInitStruct->TIM_OCMode << 8);
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC4P;
 8004c02:	f425 5500 	bic.w	r5, r5, #8192	; 0x2000
  /* Set the Output Compare Polarity */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCPolarity << 12);
 8004c06:	4334      	orrs	r4, r6
  
  /* Set the Output State */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputState << 12);
 8004c08:	ea45 3404 	orr.w	r4, r5, r4, lsl #12
  
  if((TIMx == TIM1) || (TIMx == TIM8))
 8004c0c:	4d08      	ldr	r5, [pc, #32]	; (8004c30 <TIM_OC4Init+0x4c>)
 8004c0e:	42a8      	cmp	r0, r5
 8004c10:	d003      	beq.n	8004c1a <TIM_OC4Init+0x36>
 8004c12:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 8004c16:	42a8      	cmp	r0, r5
 8004c18:	d104      	bne.n	8004c24 <TIM_OC4Init+0x40>
  {
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    /* Reset the Output Compare IDLE State */
    tmpcr2 &=(uint32_t) ~TIM_CR2_OIS4;
    /* Set the Output Idle state */
    tmpcr2 |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCIdleState << 6);
 8004c1a:	8a0d      	ldrh	r5, [r1, #16]
  
  if((TIMx == TIM1) || (TIMx == TIM8))
  {
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    /* Reset the Output Compare IDLE State */
    tmpcr2 &=(uint32_t) ~TIM_CR2_OIS4;
 8004c1c:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
    /* Set the Output Idle state */
    tmpcr2 |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCIdleState << 6);
 8004c20:	ea43 1385 	orr.w	r3, r3, r5, lsl #6
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8004c24:	6043      	str	r3, [r0, #4]
  
  /* Write to TIMx CCMR2 */  
  TIMx->CCMR2 = tmpccmrx;
    
  /* Set the Capture Compare Register value */
  TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
 8004c26:	688b      	ldr	r3, [r1, #8]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
  
  /* Write to TIMx CCMR2 */  
  TIMx->CCMR2 = tmpccmrx;
 8004c28:	61c2      	str	r2, [r0, #28]
    
  /* Set the Capture Compare Register value */
  TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
 8004c2a:	6403      	str	r3, [r0, #64]	; 0x40
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8004c2c:	6204      	str	r4, [r0, #32]
 8004c2e:	bd70      	pop	{r4, r5, r6, pc}
 8004c30:	40012c00 	.word	0x40012c00

08004c34 <TIM_OC5Init>:
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 5: Reset the CC5E Bit */
  TIMx->CCER &= (uint32_t)~TIM_CCER_CC5E; /* to be verified*/
 8004c34:	6a03      	ldr	r3, [r0, #32]
  
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint32_t)~TIM_CCMR3_OC5M;
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint32_t)(TIM_OCInitStruct->TIM_OCMode);
 8004c36:	680a      	ldr	r2, [r1, #0]
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 5: Reset the CC5E Bit */
  TIMx->CCER &= (uint32_t)~TIM_CCER_CC5E; /* to be verified*/
 8004c38:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8004c3c:	6203      	str	r3, [r0, #32]
  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_OC5Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 8004c3e:	b570      	push	{r4, r5, r6, lr}

  /* Disable the Channel 5: Reset the CC5E Bit */
  TIMx->CCER &= (uint32_t)~TIM_CCER_CC5E; /* to be verified*/
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8004c40:	6a05      	ldr	r5, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8004c42:	6843      	ldr	r3, [r0, #4]
  
  /* Get the TIMx CCMR3 register value */
  tmpccmrx = TIMx->CCMR3;
 8004c44:	6d44      	ldr	r4, [r0, #84]	; 0x54
  tmpccmrx |= (uint32_t)(TIM_OCInitStruct->TIM_OCMode);
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC5P;
  /* Set the Output Compare Polarity */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCPolarity << 16);
 8004c46:	898e      	ldrh	r6, [r1, #12]
  
  /* Get the TIMx CCMR3 register value */
  tmpccmrx = TIMx->CCMR3;
  
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint32_t)~TIM_CCMR3_OC5M;
 8004c48:	f024 0470 	bic.w	r4, r4, #112	; 0x70
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint32_t)(TIM_OCInitStruct->TIM_OCMode);
 8004c4c:	4322      	orrs	r2, r4
  tmpccer &= (uint32_t)~TIM_CCER_CC5P;
  /* Set the Output Compare Polarity */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCPolarity << 16);

  /* Set the Output State */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputState << 16);
 8004c4e:	888c      	ldrh	r4, [r1, #4]
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint32_t)(TIM_OCInitStruct->TIM_OCMode);
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC5P;
 8004c50:	f425 3500 	bic.w	r5, r5, #131072	; 0x20000
  /* Set the Output Compare Polarity */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCPolarity << 16);
 8004c54:	4334      	orrs	r4, r6

  /* Set the Output State */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputState << 16);
 8004c56:	ea45 4404 	orr.w	r4, r5, r4, lsl #16
  
  if((TIMx == TIM1) || (TIMx == TIM8))
 8004c5a:	4d09      	ldr	r5, [pc, #36]	; (8004c80 <TIM_OC5Init+0x4c>)
 8004c5c:	42a8      	cmp	r0, r5
 8004c5e:	d003      	beq.n	8004c68 <TIM_OC5Init+0x34>
 8004c60:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 8004c64:	42a8      	cmp	r0, r5
 8004c66:	d104      	bne.n	8004c72 <TIM_OC5Init+0x3e>
  {
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    /* Reset the Output Compare IDLE State */
    tmpcr2 &=(uint32_t) ~TIM_CR2_OIS5;
    /* Set the Output Idle state */
    tmpcr2 |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCIdleState << 16);
 8004c68:	8a0d      	ldrh	r5, [r1, #16]
  
  if((TIMx == TIM1) || (TIMx == TIM8))
  {
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    /* Reset the Output Compare IDLE State */
    tmpcr2 &=(uint32_t) ~TIM_CR2_OIS5;
 8004c6a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
    /* Set the Output Idle state */
    tmpcr2 |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCIdleState << 16);
 8004c6e:	ea43 4305 	orr.w	r3, r3, r5, lsl #16
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8004c72:	6043      	str	r3, [r0, #4]
  
  /* Write to TIMx CCMR2 */  
  TIMx->CCMR3 = tmpccmrx;
    
  /* Set the Capture Compare Register value */
  TIMx->CCR5 = TIM_OCInitStruct->TIM_Pulse;
 8004c74:	688b      	ldr	r3, [r1, #8]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
  
  /* Write to TIMx CCMR2 */  
  TIMx->CCMR3 = tmpccmrx;
 8004c76:	6542      	str	r2, [r0, #84]	; 0x54
    
  /* Set the Capture Compare Register value */
  TIMx->CCR5 = TIM_OCInitStruct->TIM_Pulse;
 8004c78:	6583      	str	r3, [r0, #88]	; 0x58
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8004c7a:	6204      	str	r4, [r0, #32]
 8004c7c:	bd70      	pop	{r4, r5, r6, pc}
 8004c7e:	bf00      	nop
 8004c80:	40012c00 	.word	0x40012c00

08004c84 <TIM_OC6Init>:
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 5: Reset the CC5E Bit */
  TIMx->CCER &= (uint32_t)~TIM_CCER_CC6E; /* to be verified*/
 8004c84:	6a03      	ldr	r3, [r0, #32]
  
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint32_t)~TIM_CCMR3_OC6M;
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint32_t)(TIM_OCInitStruct->TIM_OCMode << 8);
 8004c86:	680a      	ldr	r2, [r1, #0]
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 5: Reset the CC5E Bit */
  TIMx->CCER &= (uint32_t)~TIM_CCER_CC6E; /* to be verified*/
 8004c88:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
 8004c8c:	6203      	str	r3, [r0, #32]
  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_OC6Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 8004c8e:	b570      	push	{r4, r5, r6, lr}

  /* Disable the Channel 5: Reset the CC5E Bit */
  TIMx->CCER &= (uint32_t)~TIM_CCER_CC6E; /* to be verified*/
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8004c90:	6a05      	ldr	r5, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8004c92:	6843      	ldr	r3, [r0, #4]
  
  /* Get the TIMx CCMR3 register value */
  tmpccmrx = TIMx->CCMR3;
 8004c94:	6d44      	ldr	r4, [r0, #84]	; 0x54
  tmpccmrx |= (uint32_t)(TIM_OCInitStruct->TIM_OCMode << 8);
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC6P;
  /* Set the Output Compare Polarity */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCPolarity << 20);
 8004c96:	898e      	ldrh	r6, [r1, #12]
  
  /* Get the TIMx CCMR3 register value */
  tmpccmrx = TIMx->CCMR3;
  
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint32_t)~TIM_CCMR3_OC6M;
 8004c98:	f424 44e0 	bic.w	r4, r4, #28672	; 0x7000
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint32_t)(TIM_OCInitStruct->TIM_OCMode << 8);
 8004c9c:	ea44 2202 	orr.w	r2, r4, r2, lsl #8
  tmpccer &= (uint32_t)~TIM_CCER_CC6P;
  /* Set the Output Compare Polarity */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCPolarity << 20);

  /* Set the Output State */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputState << 20);
 8004ca0:	888c      	ldrh	r4, [r1, #4]
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint32_t)(TIM_OCInitStruct->TIM_OCMode << 8);
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC6P;
 8004ca2:	f425 1500 	bic.w	r5, r5, #2097152	; 0x200000
  /* Set the Output Compare Polarity */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCPolarity << 20);
 8004ca6:	4334      	orrs	r4, r6

  /* Set the Output State */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputState << 20);
 8004ca8:	ea45 5404 	orr.w	r4, r5, r4, lsl #20
  
  if((TIMx == TIM1) || (TIMx == TIM8))
 8004cac:	4d07      	ldr	r5, [pc, #28]	; (8004ccc <TIM_OC6Init+0x48>)
 8004cae:	42a8      	cmp	r0, r5
 8004cb0:	d003      	beq.n	8004cba <TIM_OC6Init+0x36>
 8004cb2:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 8004cb6:	42a8      	cmp	r0, r5
 8004cb8:	d101      	bne.n	8004cbe <TIM_OC6Init+0x3a>
  {
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    /* Reset the Output Compare IDLE State */
    tmpcr2 &=(uint32_t) ~TIM_CR2_OIS6;
 8004cba:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
    /* Set the Output Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 18);
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8004cbe:	6043      	str	r3, [r0, #4]
  
  /* Write to TIMx CCMR2 */  
  TIMx->CCMR3 = tmpccmrx;
    
  /* Set the Capture Compare Register value */
  TIMx->CCR6 = TIM_OCInitStruct->TIM_Pulse;
 8004cc0:	688b      	ldr	r3, [r1, #8]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
  
  /* Write to TIMx CCMR2 */  
  TIMx->CCMR3 = tmpccmrx;
 8004cc2:	6542      	str	r2, [r0, #84]	; 0x54
    
  /* Set the Capture Compare Register value */
  TIMx->CCR6 = TIM_OCInitStruct->TIM_Pulse;
 8004cc4:	65c3      	str	r3, [r0, #92]	; 0x5c
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8004cc6:	6204      	str	r4, [r0, #32]
 8004cc8:	bd70      	pop	{r4, r5, r6, pc}
 8004cca:	bf00      	nop
 8004ccc:	40012c00 	.word	0x40012c00

08004cd0 <TIM_SelectGC5C1>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Set the GC5C1 Bit */
    TIMx->CCR5 |= TIM_CCR5_GC5C1;
 8004cd0:	6d83      	ldr	r3, [r0, #88]	; 0x58
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8004cd2:	b111      	cbz	r1, 8004cda <TIM_SelectGC5C1+0xa>
  {
    /* Set the GC5C1 Bit */
    TIMx->CCR5 |= TIM_CCR5_GC5C1;
 8004cd4:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8004cd8:	e001      	b.n	8004cde <TIM_SelectGC5C1+0xe>
  }
  else
  {
    /* Reset the GC5C1 Bit */
    TIMx->CCR5 &= (uint32_t)~TIM_CCR5_GC5C1;
 8004cda:	f023 5300 	bic.w	r3, r3, #536870912	; 0x20000000
 8004cde:	6583      	str	r3, [r0, #88]	; 0x58
 8004ce0:	4770      	bx	lr

08004ce2 <TIM_SelectGC5C2>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Set the GC5C2 Bit */
    TIMx->CCR5 |= TIM_CCR5_GC5C2;
 8004ce2:	6d83      	ldr	r3, [r0, #88]	; 0x58
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8004ce4:	b111      	cbz	r1, 8004cec <TIM_SelectGC5C2+0xa>
  {
    /* Set the GC5C2 Bit */
    TIMx->CCR5 |= TIM_CCR5_GC5C2;
 8004ce6:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8004cea:	e001      	b.n	8004cf0 <TIM_SelectGC5C2+0xe>
  }
  else
  {
    /* Reset the GC5C2 Bit */
    TIMx->CCR5 &= (uint32_t)~TIM_CCR5_GC5C2;
 8004cec:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 8004cf0:	6583      	str	r3, [r0, #88]	; 0x58
 8004cf2:	4770      	bx	lr

08004cf4 <TIM_SelectGC5C3>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Set the GC5C3 Bit */
    TIMx->CCR5 |= TIM_CCR5_GC5C3;
 8004cf4:	6d83      	ldr	r3, [r0, #88]	; 0x58
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8004cf6:	b111      	cbz	r1, 8004cfe <TIM_SelectGC5C3+0xa>
  {
    /* Set the GC5C3 Bit */
    TIMx->CCR5 |= TIM_CCR5_GC5C3;
 8004cf8:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8004cfc:	e001      	b.n	8004d02 <TIM_SelectGC5C3+0xe>
  }
  else
  {
    /* Reset the GC5C3 Bit */
    TIMx->CCR5 &= (uint32_t)~TIM_CCR5_GC5C3;
 8004cfe:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8004d02:	6583      	str	r3, [r0, #88]	; 0x58
 8004d04:	4770      	bx	lr

08004d06 <TIM_OCStructInit>:
  * @retval None
  */
void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
{
  /* Set the default configuration */
  TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
 8004d06:	2300      	movs	r3, #0
 8004d08:	6003      	str	r3, [r0, #0]
  TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
 8004d0a:	8083      	strh	r3, [r0, #4]
  TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
 8004d0c:	80c3      	strh	r3, [r0, #6]
  TIM_OCInitStruct->TIM_Pulse = 0x00000000;
 8004d0e:	6083      	str	r3, [r0, #8]
  TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
 8004d10:	8183      	strh	r3, [r0, #12]
  TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
 8004d12:	81c3      	strh	r3, [r0, #14]
  TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
 8004d14:	8203      	strh	r3, [r0, #16]
  TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
 8004d16:	8243      	strh	r3, [r0, #18]
 8004d18:	4770      	bx	lr

08004d1a <TIM_SelectOCxM>:
  *            @arg TIM_OCMode_Asymmetric_PWM1
  *            @arg TIM_OCMode_Asymmetric_PWM2            
  * @retval None
  */
void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint32_t TIM_OCMode) /* to be updated*/
{
 8004d1a:	b530      	push	{r4, r5, lr}
  assert_param(IS_TIM_OCM(TIM_OCMode));

  tmp = (uint32_t) TIMx;
  tmp += CCMR_OFFSET;

  tmp1 = CCER_CCE_SET << (uint16_t)TIM_Channel;
 8004d1c:	2401      	movs	r4, #1
 8004d1e:	408c      	lsls	r4, r1

  /* Disable the Channel: Reset the CCxE Bit */
  TIMx->CCER &= (uint16_t) ~tmp1;
 8004d20:	6a05      	ldr	r5, [r0, #32]
 8004d22:	43e4      	mvns	r4, r4
 8004d24:	b2a4      	uxth	r4, r4
 8004d26:	402c      	ands	r4, r5
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_CHANNEL(TIM_Channel));
  assert_param(IS_TIM_OCM(TIM_OCMode));

  tmp = (uint32_t) TIMx;
  tmp += CCMR_OFFSET;
 8004d28:	f100 0318 	add.w	r3, r0, #24

  tmp1 = CCER_CCE_SET << (uint16_t)TIM_Channel;

  /* Disable the Channel: Reset the CCxE Bit */
  TIMx->CCER &= (uint16_t) ~tmp1;
 8004d2c:	6204      	str	r4, [r0, #32]

  if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
 8004d2e:	f021 0008 	bic.w	r0, r1, #8
 8004d32:	b940      	cbnz	r0, 8004d46 <TIM_SelectOCxM+0x2c>
  {
    tmp += (TIM_Channel>>1);
 8004d34:	0849      	lsrs	r1, r1, #1

    /* Reset the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp &= CCMR_OC13M_MASK;
 8004d36:	5858      	ldr	r0, [r3, r1]
 8004d38:	f420 3080 	bic.w	r0, r0, #65536	; 0x10000
 8004d3c:	f020 0070 	bic.w	r0, r0, #112	; 0x70
 8004d40:	5058      	str	r0, [r3, r1]
   
    /* Configure the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp |= TIM_OCMode;
 8004d42:	5858      	ldr	r0, [r3, r1]
 8004d44:	e00a      	b.n	8004d5c <TIM_SelectOCxM+0x42>
  }
  else
  {
    tmp += (uint32_t)(TIM_Channel - (uint32_t)4)>> (uint32_t)1;
 8004d46:	3904      	subs	r1, #4
 8004d48:	0849      	lsrs	r1, r1, #1

    /* Reset the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp &= CCMR_OC24M_MASK;
    
    /* Configure the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);
 8004d4a:	0212      	lsls	r2, r2, #8
  else
  {
    tmp += (uint32_t)(TIM_Channel - (uint32_t)4)>> (uint32_t)1;

    /* Reset the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp &= CCMR_OC24M_MASK;
 8004d4c:	58c8      	ldr	r0, [r1, r3]
 8004d4e:	f020 7080 	bic.w	r0, r0, #16777216	; 0x1000000
 8004d52:	f420 40e0 	bic.w	r0, r0, #28672	; 0x7000
 8004d56:	50c8      	str	r0, [r1, r3]
    
    /* Configure the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);
 8004d58:	58c8      	ldr	r0, [r1, r3]
 8004d5a:	b292      	uxth	r2, r2
 8004d5c:	4302      	orrs	r2, r0
 8004d5e:	50ca      	str	r2, [r1, r3]
 8004d60:	bd30      	pop	{r4, r5, pc}

08004d62 <TIM_SetCompare1>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));

  /* Set the Capture Compare1 Register value */
  TIMx->CCR1 = Compare1;
 8004d62:	6341      	str	r1, [r0, #52]	; 0x34
 8004d64:	4770      	bx	lr

08004d66 <TIM_SetCompare2>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));

  /* Set the Capture Compare2 Register value */
  TIMx->CCR2 = Compare2;
 8004d66:	6381      	str	r1, [r0, #56]	; 0x38
 8004d68:	4770      	bx	lr

08004d6a <TIM_SetCompare3>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));

  /* Set the Capture Compare3 Register value */
  TIMx->CCR3 = Compare3;
 8004d6a:	63c1      	str	r1, [r0, #60]	; 0x3c
 8004d6c:	4770      	bx	lr

08004d6e <TIM_SetCompare4>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));

  /* Set the Capture Compare4 Register value */
  TIMx->CCR4 = Compare4;
 8004d6e:	6401      	str	r1, [r0, #64]	; 0x40
 8004d70:	4770      	bx	lr

08004d72 <TIM_SetCompare5>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));

  /* Set the Capture Compare5 Register value */
  TIMx->CCR5 = Compare5;
 8004d72:	6581      	str	r1, [r0, #88]	; 0x58
 8004d74:	4770      	bx	lr

08004d76 <TIM_SetCompare6>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));

  /* Set the Capture Compare6 Register value */
  TIMx->CCR6 = Compare6;
 8004d76:	65c1      	str	r1, [r0, #92]	; 0x5c
 8004d78:	4770      	bx	lr

08004d7a <TIM_ForcedOC1Config>:
  uint32_t tmpccmr1 = 0;

  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
  tmpccmr1 = TIMx->CCMR1;
 8004d7a:	6983      	ldr	r3, [r0, #24]

  /* Reset the OC1M Bits */
  tmpccmr1 &= (uint32_t)~TIM_CCMR1_OC1M;
 8004d7c:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8004d80:	f023 0370 	bic.w	r3, r3, #112	; 0x70

  /* Configure The Forced output Mode */
  tmpccmr1 |= TIM_ForcedAction;
 8004d84:	4319      	orrs	r1, r3

  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 8004d86:	6181      	str	r1, [r0, #24]
 8004d88:	4770      	bx	lr

08004d8a <TIM_ForcedOC2Config>:
  uint32_t tmpccmr1 = 0;

  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
  tmpccmr1 = TIMx->CCMR1;
 8004d8a:	6983      	ldr	r3, [r0, #24]

  /* Reset the OC2M Bits */
  tmpccmr1 &= (uint32_t)~TIM_CCMR1_OC2M;
 8004d8c:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8004d90:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000

  /* Configure The Forced output Mode */
  tmpccmr1 |= ((uint32_t)TIM_ForcedAction << 8);
 8004d94:	ea43 2101 	orr.w	r1, r3, r1, lsl #8

  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 8004d98:	6181      	str	r1, [r0, #24]
 8004d9a:	4770      	bx	lr

08004d9c <TIM_ForcedOC3Config>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));

  tmpccmr2 = TIMx->CCMR2;
 8004d9c:	69c3      	ldr	r3, [r0, #28]

  /* Reset the OC1M Bits */
  tmpccmr2 &= (uint32_t)~TIM_CCMR2_OC3M;
 8004d9e:	f023 0370 	bic.w	r3, r3, #112	; 0x70

  /* Configure The Forced output Mode */
  tmpccmr2 |= TIM_ForcedAction;
 8004da2:	4319      	orrs	r1, r3

  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 8004da4:	61c1      	str	r1, [r0, #28]
 8004da6:	4770      	bx	lr

08004da8 <TIM_ForcedOC4Config>:
  uint32_t tmpccmr2 = 0;

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
  tmpccmr2 = TIMx->CCMR2;
 8004da8:	69c3      	ldr	r3, [r0, #28]

  /* Reset the OC2M Bits */
  tmpccmr2 &= (uint32_t)~TIM_CCMR2_OC4M;
 8004daa:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000

  /* Configure The Forced output Mode */
  tmpccmr2 |= ((uint32_t)TIM_ForcedAction << 8);
 8004dae:	ea43 2101 	orr.w	r1, r3, r1, lsl #8

  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 8004db2:	61c1      	str	r1, [r0, #28]
 8004db4:	4770      	bx	lr

08004db6 <TIM_ForcedOC5Config>:
  uint32_t tmpccmr3 = 0;

  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
  tmpccmr3 = TIMx->CCMR3;
 8004db6:	6d43      	ldr	r3, [r0, #84]	; 0x54

  /* Reset the OC5M Bits */
  tmpccmr3 &= (uint32_t)~TIM_CCMR3_OC5M;
 8004db8:	f023 0370 	bic.w	r3, r3, #112	; 0x70

  /* Configure The Forced output Mode */
  tmpccmr3 |= (uint32_t)(TIM_ForcedAction);
 8004dbc:	4319      	orrs	r1, r3

  /* Write to TIMx CCMR3 register */
  TIMx->CCMR3 = tmpccmr3;
 8004dbe:	6541      	str	r1, [r0, #84]	; 0x54
 8004dc0:	4770      	bx	lr

08004dc2 <TIM_ForcedOC6Config>:
  uint32_t tmpccmr3 = 0;

  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
  tmpccmr3 = TIMx->CCMR3;
 8004dc2:	6d43      	ldr	r3, [r0, #84]	; 0x54

  /* Reset the OC6M Bits */
  tmpccmr3 &= (uint32_t)~TIM_CCMR3_OC6M;
 8004dc4:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000

  /* Configure The Forced output Mode */
  tmpccmr3 |= ((uint32_t)TIM_ForcedAction << 8);
 8004dc8:	ea43 2101 	orr.w	r1, r3, r1, lsl #8

  /* Write to TIMx CCMR3 register */
  TIMx->CCMR3 = tmpccmr3;
 8004dcc:	6541      	str	r1, [r0, #84]	; 0x54
 8004dce:	4770      	bx	lr

08004dd0 <TIM_OC1PreloadConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));

  tmpccmr1 = TIMx->CCMR1;
 8004dd0:	6983      	ldr	r3, [r0, #24]

  /* Reset the OC1PE Bit */
  tmpccmr1 &= (uint32_t)(~TIM_CCMR1_OC1PE);
 8004dd2:	f023 0308 	bic.w	r3, r3, #8

  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr1 |= TIM_OCPreload;
 8004dd6:	4319      	orrs	r1, r3

  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 8004dd8:	6181      	str	r1, [r0, #24]
 8004dda:	4770      	bx	lr

08004ddc <TIM_OC2PreloadConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));

  tmpccmr1 = TIMx->CCMR1;
 8004ddc:	6983      	ldr	r3, [r0, #24]

  /* Reset the OC2PE Bit */
  tmpccmr1 &= (uint32_t)(~TIM_CCMR1_OC2PE);
 8004dde:	f423 6300 	bic.w	r3, r3, #2048	; 0x800

  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr1 |= ((uint32_t)TIM_OCPreload << 8);
 8004de2:	ea43 2101 	orr.w	r1, r3, r1, lsl #8

  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 8004de6:	6181      	str	r1, [r0, #24]
 8004de8:	4770      	bx	lr

08004dea <TIM_OC3PreloadConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));

  tmpccmr2 = TIMx->CCMR2;
 8004dea:	69c3      	ldr	r3, [r0, #28]

  /* Reset the OC3PE Bit */
  tmpccmr2 &= (uint32_t)(~TIM_CCMR2_OC3PE);
 8004dec:	f023 0308 	bic.w	r3, r3, #8

  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr2 |= TIM_OCPreload;
 8004df0:	4319      	orrs	r1, r3

  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 8004df2:	61c1      	str	r1, [r0, #28]
 8004df4:	4770      	bx	lr

08004df6 <TIM_OC4PreloadConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));

  tmpccmr2 = TIMx->CCMR2;
 8004df6:	69c3      	ldr	r3, [r0, #28]

  /* Reset the OC4PE Bit */
  tmpccmr2 &= (uint32_t)(~TIM_CCMR2_OC4PE);
 8004df8:	f423 6300 	bic.w	r3, r3, #2048	; 0x800

  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr2 |= ((uint32_t)TIM_OCPreload << 8);
 8004dfc:	ea43 2101 	orr.w	r1, r3, r1, lsl #8

  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 8004e00:	61c1      	str	r1, [r0, #28]
 8004e02:	4770      	bx	lr

08004e04 <TIM_OC5PreloadConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));

  tmpccmr3 = TIMx->CCMR3;
 8004e04:	6d43      	ldr	r3, [r0, #84]	; 0x54

  /* Reset the OC5PE Bit */
  tmpccmr3 &= (uint32_t)(~TIM_CCMR3_OC5PE);
 8004e06:	f023 0308 	bic.w	r3, r3, #8

  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr3 |= (uint32_t)(TIM_OCPreload);
 8004e0a:	4319      	orrs	r1, r3

  /* Write to TIMx CCMR3 register */
  TIMx->CCMR3 = tmpccmr3;
 8004e0c:	6541      	str	r1, [r0, #84]	; 0x54
 8004e0e:	4770      	bx	lr

08004e10 <TIM_OC6PreloadConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));

  tmpccmr3 = TIMx->CCMR3;
 8004e10:	6d43      	ldr	r3, [r0, #84]	; 0x54

  /* Reset the OC5PE Bit */
  tmpccmr3 &= (uint32_t)(~TIM_CCMR3_OC6PE);
 8004e12:	f423 6300 	bic.w	r3, r3, #2048	; 0x800

  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr3 |= ((uint32_t)TIM_OCPreload << 8);
 8004e16:	ea43 2101 	orr.w	r1, r3, r1, lsl #8

  /* Write to TIMx CCMR3 register */
  TIMx->CCMR3 = tmpccmr3;
 8004e1a:	6541      	str	r1, [r0, #84]	; 0x54
 8004e1c:	4770      	bx	lr

08004e1e <TIM_OC1FastConfig>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));

  /* Get the TIMx CCMR1 register value */
  tmpccmr1 = TIMx->CCMR1;
 8004e1e:	6983      	ldr	r3, [r0, #24]

  /* Reset the OC1FE Bit */
  tmpccmr1 &= (uint32_t)~TIM_CCMR1_OC1FE;
 8004e20:	f023 0304 	bic.w	r3, r3, #4

  /* Enable or Disable the Output Compare Fast Bit */
  tmpccmr1 |= TIM_OCFast;
 8004e24:	4319      	orrs	r1, r3

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmr1;
 8004e26:	6181      	str	r1, [r0, #24]
 8004e28:	4770      	bx	lr

08004e2a <TIM_OC2FastConfig>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));

  /* Get the TIMx CCMR1 register value */
  tmpccmr1 = TIMx->CCMR1;
 8004e2a:	6983      	ldr	r3, [r0, #24]

  /* Reset the OC2FE Bit */
  tmpccmr1 &= (uint32_t)(~TIM_CCMR1_OC2FE);
 8004e2c:	f423 6380 	bic.w	r3, r3, #1024	; 0x400

  /* Enable or Disable the Output Compare Fast Bit */
  tmpccmr1 |= ((uint32_t)TIM_OCFast << 8);
 8004e30:	ea43 2101 	orr.w	r1, r3, r1, lsl #8

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmr1;
 8004e34:	6181      	str	r1, [r0, #24]
 8004e36:	4770      	bx	lr

08004e38 <TIM_OC3FastConfig>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));

  /* Get the TIMx CCMR2 register value */
  tmpccmr2 = TIMx->CCMR2;
 8004e38:	69c3      	ldr	r3, [r0, #28]

  /* Reset the OC3FE Bit */
  tmpccmr2 &= (uint32_t)~TIM_CCMR2_OC3FE;
 8004e3a:	f023 0304 	bic.w	r3, r3, #4

  /* Enable or Disable the Output Compare Fast Bit */
  tmpccmr2 |= TIM_OCFast;
 8004e3e:	4319      	orrs	r1, r3

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmr2;
 8004e40:	61c1      	str	r1, [r0, #28]
 8004e42:	4770      	bx	lr

08004e44 <TIM_OC4FastConfig>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));

  /* Get the TIMx CCMR2 register value */
  tmpccmr2 = TIMx->CCMR2;
 8004e44:	69c3      	ldr	r3, [r0, #28]

  /* Reset the OC4FE Bit */
  tmpccmr2 &= (uint32_t)(~TIM_CCMR2_OC4FE);
 8004e46:	f423 6380 	bic.w	r3, r3, #1024	; 0x400

  /* Enable or Disable the Output Compare Fast Bit */
  tmpccmr2 |= ((uint32_t)TIM_OCFast << 8);
 8004e4a:	ea43 2101 	orr.w	r1, r3, r1, lsl #8

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmr2;
 8004e4e:	61c1      	str	r1, [r0, #28]
 8004e50:	4770      	bx	lr

08004e52 <TIM_ClearOC1Ref>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));

  tmpccmr1 = TIMx->CCMR1;
 8004e52:	6983      	ldr	r3, [r0, #24]

  /* Reset the OC1CE Bit */
  tmpccmr1 &= (uint32_t)~TIM_CCMR1_OC1CE;
 8004e54:	f023 0380 	bic.w	r3, r3, #128	; 0x80

  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr1 |= TIM_OCClear;
 8004e58:	4319      	orrs	r1, r3

  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 8004e5a:	6181      	str	r1, [r0, #24]
 8004e5c:	4770      	bx	lr

08004e5e <TIM_ClearOC2Ref>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));

  tmpccmr1 = TIMx->CCMR1;
 8004e5e:	6983      	ldr	r3, [r0, #24]

  /* Reset the OC2CE Bit */
  tmpccmr1 &= (uint32_t)~TIM_CCMR1_OC2CE;
 8004e60:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000

  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr1 |= ((uint32_t)TIM_OCClear << 8);
 8004e64:	ea43 2101 	orr.w	r1, r3, r1, lsl #8

  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 8004e68:	6181      	str	r1, [r0, #24]
 8004e6a:	4770      	bx	lr

08004e6c <TIM_ClearOC3Ref>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));

  tmpccmr2 = TIMx->CCMR2;
 8004e6c:	69c3      	ldr	r3, [r0, #28]

  /* Reset the OC3CE Bit */
  tmpccmr2 &= (uint32_t)~TIM_CCMR2_OC3CE;
 8004e6e:	f023 0380 	bic.w	r3, r3, #128	; 0x80

  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr2 |= TIM_OCClear;
 8004e72:	4319      	orrs	r1, r3

  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 8004e74:	61c1      	str	r1, [r0, #28]
 8004e76:	4770      	bx	lr

08004e78 <TIM_ClearOC4Ref>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));

  tmpccmr2 = TIMx->CCMR2;
 8004e78:	69c3      	ldr	r3, [r0, #28]

  /* Reset the OC4CE Bit */
  tmpccmr2 &= (uint32_t)~TIM_CCMR2_OC4CE;
 8004e7a:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000

  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr2 |= ((uint32_t)TIM_OCClear << 8);
 8004e7e:	ea43 2101 	orr.w	r1, r3, r1, lsl #8

  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 8004e82:	61c1      	str	r1, [r0, #28]
 8004e84:	4770      	bx	lr

08004e86 <TIM_ClearOC5Ref>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));

  tmpccmr3 = TIMx->CCMR3;
 8004e86:	6d43      	ldr	r3, [r0, #84]	; 0x54

  /* Reset the OC5CE Bit */
  tmpccmr3 &= (uint32_t)~TIM_CCMR3_OC5CE;
 8004e88:	f023 0380 	bic.w	r3, r3, #128	; 0x80

  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr3 |= (uint32_t)(TIM_OCClear);
 8004e8c:	4319      	orrs	r1, r3

  /* Write to TIMx CCMR3 register */
  TIMx->CCMR3 = tmpccmr3;
 8004e8e:	6541      	str	r1, [r0, #84]	; 0x54
 8004e90:	4770      	bx	lr

08004e92 <TIM_ClearOC6Ref>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));

  tmpccmr3 = TIMx->CCMR3;
 8004e92:	6d43      	ldr	r3, [r0, #84]	; 0x54

  /* Reset the OC5CE Bit */
  tmpccmr3 &= (uint32_t)~TIM_CCMR3_OC6CE;
 8004e94:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000

  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr3 |= ((uint32_t)TIM_OCClear << 8);
 8004e98:	ea43 2101 	orr.w	r1, r3, r1, lsl #8

  /* Write to TIMx CCMR3 register */
  TIMx->CCMR3 = tmpccmr3;
 8004e9c:	6541      	str	r1, [r0, #84]	; 0x54
 8004e9e:	4770      	bx	lr

08004ea0 <TIM_SelectOCREFClear>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(TIM_OCREFERENCECECLEAR_SOURCE(TIM_OCReferenceClear));

  /* Set the TIM_OCReferenceClear source */
  TIMx->SMCR &=  (uint16_t)~((uint16_t)TIM_SMCR_OCCS);
 8004ea0:	6883      	ldr	r3, [r0, #8]
 8004ea2:	f023 0308 	bic.w	r3, r3, #8
 8004ea6:	041b      	lsls	r3, r3, #16
 8004ea8:	0c1b      	lsrs	r3, r3, #16
 8004eaa:	6083      	str	r3, [r0, #8]
  TIMx->SMCR |=  TIM_OCReferenceClear;
 8004eac:	6883      	ldr	r3, [r0, #8]
 8004eae:	4319      	orrs	r1, r3
 8004eb0:	6081      	str	r1, [r0, #8]
 8004eb2:	4770      	bx	lr

08004eb4 <TIM_OC1PolarityConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));

  tmpccer = TIMx->CCER;
 8004eb4:	6a03      	ldr	r3, [r0, #32]

  /* Set or Reset the CC1P Bit */
  tmpccer &= (uint32_t)(~TIM_CCER_CC1P);
 8004eb6:	f023 0302 	bic.w	r3, r3, #2
  tmpccer |= TIM_OCPolarity;
 8004eba:	4319      	orrs	r1, r3

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 8004ebc:	6201      	str	r1, [r0, #32]
 8004ebe:	4770      	bx	lr

08004ec0 <TIM_OC1NPolarityConfig>:
  uint32_t tmpccer = 0;
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
   
  tmpccer = TIMx->CCER;
 8004ec0:	6a03      	ldr	r3, [r0, #32]

  /* Set or Reset the CC1NP Bit */
  tmpccer &= (uint32_t)~TIM_CCER_CC1NP;
 8004ec2:	f023 0308 	bic.w	r3, r3, #8
  tmpccer |= TIM_OCNPolarity;
 8004ec6:	4319      	orrs	r1, r3

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 8004ec8:	6201      	str	r1, [r0, #32]
 8004eca:	4770      	bx	lr

08004ecc <TIM_OC2PolarityConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));

  tmpccer = TIMx->CCER;
 8004ecc:	6a03      	ldr	r3, [r0, #32]

  /* Set or Reset the CC2P Bit */
  tmpccer &= (uint32_t)(~TIM_CCER_CC2P);
 8004ece:	f023 0320 	bic.w	r3, r3, #32
  tmpccer |= ((uint32_t)TIM_OCPolarity << 4);
 8004ed2:	ea43 1101 	orr.w	r1, r3, r1, lsl #4

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 8004ed6:	6201      	str	r1, [r0, #32]
 8004ed8:	4770      	bx	lr

08004eda <TIM_OC2NPolarityConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
  
  tmpccer = TIMx->CCER;
 8004eda:	6a03      	ldr	r3, [r0, #32]

  /* Set or Reset the CC2NP Bit */
  tmpccer &= (uint32_t)~TIM_CCER_CC2NP;
 8004edc:	f023 0380 	bic.w	r3, r3, #128	; 0x80
  tmpccer |= ((uint32_t)TIM_OCNPolarity << 4);
 8004ee0:	ea43 1101 	orr.w	r1, r3, r1, lsl #4

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 8004ee4:	6201      	str	r1, [r0, #32]
 8004ee6:	4770      	bx	lr

08004ee8 <TIM_OC3PolarityConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));

  tmpccer = TIMx->CCER;
 8004ee8:	6a03      	ldr	r3, [r0, #32]

  /* Set or Reset the CC3P Bit */
  tmpccer &= (uint32_t)~TIM_CCER_CC3P;
 8004eea:	f423 7300 	bic.w	r3, r3, #512	; 0x200
  tmpccer |= ((uint32_t)TIM_OCPolarity << 8);
 8004eee:	ea43 2101 	orr.w	r1, r3, r1, lsl #8

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 8004ef2:	6201      	str	r1, [r0, #32]
 8004ef4:	4770      	bx	lr

08004ef6 <TIM_OC3NPolarityConfig>:
 
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
    
  tmpccer = TIMx->CCER;
 8004ef6:	6a03      	ldr	r3, [r0, #32]

  /* Set or Reset the CC3NP Bit */
  tmpccer &= (uint32_t)~TIM_CCER_CC3NP;
 8004ef8:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
  tmpccer |= ((uint32_t)TIM_OCNPolarity << 8);
 8004efc:	ea43 2101 	orr.w	r1, r3, r1, lsl #8

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 8004f00:	6201      	str	r1, [r0, #32]
 8004f02:	4770      	bx	lr

08004f04 <TIM_OC4PolarityConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));

  tmpccer = TIMx->CCER;
 8004f04:	6a03      	ldr	r3, [r0, #32]

  /* Set or Reset the CC4P Bit */
  tmpccer &= (uint32_t)~TIM_CCER_CC4P;
 8004f06:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
  tmpccer |= ((uint32_t)TIM_OCPolarity << 12);
 8004f0a:	ea43 3101 	orr.w	r1, r3, r1, lsl #12

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 8004f0e:	6201      	str	r1, [r0, #32]
 8004f10:	4770      	bx	lr

08004f12 <TIM_OC5PolarityConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));

  tmpccer = TIMx->CCER;
 8004f12:	6a03      	ldr	r3, [r0, #32]

  /* Set or Reset the CC5P Bit */
  tmpccer &= (uint32_t)~TIM_CCER_CC5P;
 8004f14:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
  tmpccer |= ((uint32_t)TIM_OCPolarity << 16);
 8004f18:	ea43 4101 	orr.w	r1, r3, r1, lsl #16

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 8004f1c:	6201      	str	r1, [r0, #32]
 8004f1e:	4770      	bx	lr

08004f20 <TIM_OC6PolarityConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));

  tmpccer = TIMx->CCER;
 8004f20:	6a03      	ldr	r3, [r0, #32]

  /* Set or Reset the CC6P Bit */
  tmpccer &= (uint32_t)~TIM_CCER_CC6P;
 8004f22:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
  tmpccer |= ((uint32_t)TIM_OCPolarity << 20);
 8004f26:	ea43 5101 	orr.w	r1, r3, r1, lsl #20

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 8004f2a:	6201      	str	r1, [r0, #32]
 8004f2c:	4770      	bx	lr

08004f2e <TIM_CCxCmd>:
  * @param  TIM_CCx: specifies the TIM Channel CCxE bit new state.
  *          This parameter can be: TIM_CCx_Enable or TIM_CCx_Disable. 
  * @retval None
  */
void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx)
{
 8004f2e:	b510      	push	{r4, lr}
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
  assert_param(IS_TIM_CHANNEL(TIM_Channel));
  assert_param(IS_TIM_CCX(TIM_CCx));

  tmp = (uint32_t)CCER_CCE_SET << (uint32_t)TIM_Channel;
 8004f30:	2301      	movs	r3, #1

  /* Reset the CCxE Bit */
  TIMx->CCER &= (uint32_t)(~tmp);
 8004f32:	6a04      	ldr	r4, [r0, #32]
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
  assert_param(IS_TIM_CHANNEL(TIM_Channel));
  assert_param(IS_TIM_CCX(TIM_CCx));

  tmp = (uint32_t)CCER_CCE_SET << (uint32_t)TIM_Channel;
 8004f34:	408b      	lsls	r3, r1

  /* Reset the CCxE Bit */
  TIMx->CCER &= (uint32_t)(~tmp);
 8004f36:	ea24 0303 	bic.w	r3, r4, r3
 8004f3a:	6203      	str	r3, [r0, #32]

  /* Set or reset the CCxE Bit */ 
  TIMx->CCER |=  ((uint32_t)TIM_CCx << (uint32_t)TIM_Channel);
 8004f3c:	6a03      	ldr	r3, [r0, #32]
 8004f3e:	408a      	lsls	r2, r1
 8004f40:	4313      	orrs	r3, r2
 8004f42:	6203      	str	r3, [r0, #32]
 8004f44:	bd10      	pop	{r4, pc}

08004f46 <TIM_CCxNCmd>:
  * @param  TIM_CCxN: specifies the TIM Channel CCxNE bit new state.
  *          This parameter can be: TIM_CCxN_Enable or TIM_CCxN_Disable. 
  * @retval None
  */
void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN)
{
 8004f46:	b510      	push	{r4, lr}
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
  assert_param(IS_TIM_CCXN(TIM_CCxN));

  tmp = (uint32_t)CCER_CCNE_SET << (uint32_t)TIM_Channel;
 8004f48:	2304      	movs	r3, #4

  /* Reset the CCxNE Bit */
  TIMx->CCER &= (uint32_t) ~tmp;
 8004f4a:	6a04      	ldr	r4, [r0, #32]
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
  assert_param(IS_TIM_CCXN(TIM_CCxN));

  tmp = (uint32_t)CCER_CCNE_SET << (uint32_t)TIM_Channel;
 8004f4c:	408b      	lsls	r3, r1

  /* Reset the CCxNE Bit */
  TIMx->CCER &= (uint32_t) ~tmp;
 8004f4e:	ea24 0303 	bic.w	r3, r4, r3
 8004f52:	6203      	str	r3, [r0, #32]

  /* Set or reset the CCxNE Bit */ 
  TIMx->CCER |=  ((uint32_t)TIM_CCxN << (uint32_t)TIM_Channel);
 8004f54:	6a03      	ldr	r3, [r0, #32]
 8004f56:	408a      	lsls	r2, r1
 8004f58:	4313      	orrs	r3, r2
 8004f5a:	6203      	str	r3, [r0, #32]
 8004f5c:	bd10      	pop	{r4, pc}

08004f5e <TIM_ICStructInit>:
  * @retval None
  */
void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
{
  /* Set the default configuration */
  TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
 8004f5e:	2300      	movs	r3, #0
  TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
  TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
 8004f60:	2201      	movs	r2, #1
  * @retval None
  */
void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
{
  /* Set the default configuration */
  TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
 8004f62:	8003      	strh	r3, [r0, #0]
  TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
 8004f64:	8043      	strh	r3, [r0, #2]
  TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
 8004f66:	8082      	strh	r2, [r0, #4]
  TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
 8004f68:	80c3      	strh	r3, [r0, #6]
  TIM_ICInitStruct->TIM_ICFilter = 0x00;
 8004f6a:	8103      	strh	r3, [r0, #8]
 8004f6c:	4770      	bx	lr

08004f6e <TIM_GetCapture1>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));

  /* Get the Capture 1 Register value */
  return TIMx->CCR1;
 8004f6e:	6b40      	ldr	r0, [r0, #52]	; 0x34
}
 8004f70:	4770      	bx	lr

08004f72 <TIM_GetCapture2>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));

  /* Get the Capture 2 Register value */
  return TIMx->CCR2;
 8004f72:	6b80      	ldr	r0, [r0, #56]	; 0x38
}
 8004f74:	4770      	bx	lr

08004f76 <TIM_GetCapture3>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 

  /* Get the Capture 3 Register value */
  return TIMx->CCR3;
 8004f76:	6bc0      	ldr	r0, [r0, #60]	; 0x3c
}
 8004f78:	4770      	bx	lr

08004f7a <TIM_GetCapture4>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));

  /* Get the Capture 4 Register value */
  return TIMx->CCR4;
 8004f7a:	6c00      	ldr	r0, [r0, #64]	; 0x40
}
 8004f7c:	4770      	bx	lr

08004f7e <TIM_SetIC1Prescaler>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));

  /* Reset the IC1PSC Bits */
  TIMx->CCMR1 &= (uint32_t)~TIM_CCMR1_IC1PSC;
 8004f7e:	6983      	ldr	r3, [r0, #24]
 8004f80:	f023 030c 	bic.w	r3, r3, #12
 8004f84:	6183      	str	r3, [r0, #24]

  /* Set the IC1PSC value */
  TIMx->CCMR1 |= TIM_ICPSC;
 8004f86:	6983      	ldr	r3, [r0, #24]
 8004f88:	4319      	orrs	r1, r3
 8004f8a:	6181      	str	r1, [r0, #24]
 8004f8c:	4770      	bx	lr

08004f8e <TIM_SetIC2Prescaler>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));

  /* Reset the IC2PSC Bits */
  TIMx->CCMR1 &= (uint32_t)~TIM_CCMR1_IC2PSC;
 8004f8e:	6983      	ldr	r3, [r0, #24]
 8004f90:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
 8004f94:	6183      	str	r3, [r0, #24]

  /* Set the IC2PSC value */
  TIMx->CCMR1 |= (uint32_t)((uint32_t)TIM_ICPSC << 8);
 8004f96:	6983      	ldr	r3, [r0, #24]
 8004f98:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
 8004f9c:	6181      	str	r1, [r0, #24]
 8004f9e:	4770      	bx	lr

08004fa0 <TIM_PWMIConfig>:
  * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
{
 8004fa0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004fa2:	460c      	mov	r4, r1

  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));

  /* Select the Opposite Input Polarity */
  if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
 8004fa4:	8849      	ldrh	r1, [r1, #2]
  else
  {
    icoppositepolarity = TIM_ICPolarity_Rising;
  }
  /* Select the Opposite Input */
  if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
 8004fa6:	88a2      	ldrh	r2, [r4, #4]
  }
  else
  {
    icoppositeselection = TIM_ICSelection_DirectTI;
  }
  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
 8004fa8:	f8b4 e000 	ldrh.w	lr, [r4]
 8004fac:	8923      	ldrh	r3, [r4, #8]

  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));

  /* Select the Opposite Input Polarity */
  if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
 8004fae:	2900      	cmp	r1, #0
  {
    icoppositepolarity = TIM_ICPolarity_Falling;
 8004fb0:	bf14      	ite	ne
 8004fb2:	2700      	movne	r7, #0
 8004fb4:	2702      	moveq	r7, #2
  else
  {
    icoppositepolarity = TIM_ICPolarity_Rising;
  }
  /* Select the Opposite Input */
  if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
 8004fb6:	2a01      	cmp	r2, #1
  * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
{
 8004fb8:	4605      	mov	r5, r0
    icoppositepolarity = TIM_ICPolarity_Rising;
  }
  /* Select the Opposite Input */
  if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
  {
    icoppositeselection = TIM_ICSelection_IndirectTI;
 8004fba:	bf14      	ite	ne
 8004fbc:	2601      	movne	r6, #1
 8004fbe:	2602      	moveq	r6, #2
  }
  else
  {
    icoppositeselection = TIM_ICSelection_DirectTI;
  }
  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
 8004fc0:	f1be 0f00 	cmp.w	lr, #0
 8004fc4:	d111      	bne.n	8004fea <TIM_PWMIConfig+0x4a>
  {
    /* TI1 Configuration */
    TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
 8004fc6:	f7ff fc01 	bl	80047cc <TI1_Config>
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 8004fca:	4628      	mov	r0, r5
 8004fcc:	88e1      	ldrh	r1, [r4, #6]
 8004fce:	f7ff ffd6 	bl	8004f7e <TIM_SetIC1Prescaler>
    /* TI2 Configuration */
    TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
 8004fd2:	4628      	mov	r0, r5
 8004fd4:	4639      	mov	r1, r7
 8004fd6:	4632      	mov	r2, r6
 8004fd8:	8923      	ldrh	r3, [r4, #8]
 8004fda:	f7ff fc0b 	bl	80047f4 <TI2_Config>
    /* Set the Input Capture Prescaler value */
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 8004fde:	4628      	mov	r0, r5
 8004fe0:	88e1      	ldrh	r1, [r4, #6]
    /* TI1 Configuration */
    TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
  }
}
 8004fe2:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
    /* TI2 Configuration */
    TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 8004fe6:	f7ff bfd2 	b.w	8004f8e <TIM_SetIC2Prescaler>
  }
  else
  { 
    /* TI2 Configuration */
    TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
 8004fea:	f7ff fc03 	bl	80047f4 <TI2_Config>
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 8004fee:	4628      	mov	r0, r5
 8004ff0:	88e1      	ldrh	r1, [r4, #6]
 8004ff2:	f7ff ffcc 	bl	8004f8e <TIM_SetIC2Prescaler>
    /* TI1 Configuration */
    TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
 8004ff6:	4628      	mov	r0, r5
 8004ff8:	4639      	mov	r1, r7
 8004ffa:	4632      	mov	r2, r6
 8004ffc:	8923      	ldrh	r3, [r4, #8]
 8004ffe:	f7ff fbe5 	bl	80047cc <TI1_Config>
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 8005002:	4628      	mov	r0, r5
 8005004:	88e1      	ldrh	r1, [r4, #6]
  }
}
 8005006:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    /* Set the Input Capture Prescaler value */
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
    /* TI1 Configuration */
    TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 800500a:	f7ff bfb8 	b.w	8004f7e <TIM_SetIC1Prescaler>

0800500e <TIM_SetIC3Prescaler>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));

  /* Reset the IC3PSC Bits */
  TIMx->CCMR2 &= (uint16_t)~TIM_CCMR2_IC3PSC;
 800500e:	69c3      	ldr	r3, [r0, #28]
 8005010:	f023 030c 	bic.w	r3, r3, #12
 8005014:	041b      	lsls	r3, r3, #16
 8005016:	0c1b      	lsrs	r3, r3, #16
 8005018:	61c3      	str	r3, [r0, #28]

  /* Set the IC3PSC value */
  TIMx->CCMR2 |= TIM_ICPSC;
 800501a:	69c3      	ldr	r3, [r0, #28]
 800501c:	4319      	orrs	r1, r3
 800501e:	61c1      	str	r1, [r0, #28]
 8005020:	4770      	bx	lr

08005022 <TIM_SetIC4Prescaler>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));

  /* Reset the IC4PSC Bits */
  TIMx->CCMR2 &= (uint16_t)~TIM_CCMR2_IC4PSC;
 8005022:	69c3      	ldr	r3, [r0, #28]
 8005024:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
 8005028:	041b      	lsls	r3, r3, #16
 800502a:	0c1b      	lsrs	r3, r3, #16
 800502c:	61c3      	str	r3, [r0, #28]

  /* Set the IC4PSC value */
  TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
 800502e:	69c3      	ldr	r3, [r0, #28]
 8005030:	0209      	lsls	r1, r1, #8
 8005032:	b289      	uxth	r1, r1
 8005034:	430b      	orrs	r3, r1
 8005036:	61c3      	str	r3, [r0, #28]
 8005038:	4770      	bx	lr

0800503a <TIM_ICInit>:
  * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
{
 800503a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800503c:	460d      	mov	r5, r1
  assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
  assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
  assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
  
  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
 800503e:	880e      	ldrh	r6, [r1, #0]
 8005040:	88aa      	ldrh	r2, [r5, #4]
 8005042:	8849      	ldrh	r1, [r1, #2]
 8005044:	892b      	ldrh	r3, [r5, #8]
  * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
{
 8005046:	4604      	mov	r4, r0
  assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
  assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
  assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
  
  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
 8005048:	b93e      	cbnz	r6, 800505a <TIM_ICInit+0x20>
  {
    /* TI1 Configuration */
    TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
 800504a:	f7ff fbbf 	bl	80047cc <TI1_Config>
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 800504e:	4620      	mov	r0, r4
 8005050:	88e9      	ldrh	r1, [r5, #6]
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
  }
}
 8005052:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    /* TI1 Configuration */
    TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 8005056:	f7ff bf92 	b.w	8004f7e <TIM_SetIC1Prescaler>
  }
  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
 800505a:	2e04      	cmp	r6, #4
 800505c:	d107      	bne.n	800506e <TIM_ICInit+0x34>
  {
    /* TI2 Configuration */
    TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
 800505e:	f7ff fbc9 	bl	80047f4 <TI2_Config>
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 8005062:	4620      	mov	r0, r4
 8005064:	88e9      	ldrh	r1, [r5, #6]
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
  }
}
 8005066:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    /* TI2 Configuration */
    TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 800506a:	f7ff bf90 	b.w	8004f8e <TIM_SetIC2Prescaler>
  }
  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
 800506e:	2e08      	cmp	r6, #8
 8005070:	88ef      	ldrh	r7, [r5, #6]
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;

  /* Disable the Channel 3: Reset the CC3E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC3E;
 8005072:	6a06      	ldr	r6, [r0, #32]
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
  }
  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
 8005074:	d11d      	bne.n	80050b2 <TIM_ICInit+0x78>
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;

  /* Disable the Channel 3: Reset the CC3E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC3E;
 8005076:	f64f 65ff 	movw	r5, #65279	; 0xfeff
 800507a:	4035      	ands	r5, r6
 800507c:	6205      	str	r5, [r0, #32]
  tmpccmr2 = TIMx->CCMR2;
 800507e:	69c5      	ldr	r5, [r0, #28]
  tmpccer = TIMx->CCER;
 8005080:	f8d0 c020 	ldr.w	ip, [r0, #32]
  tmp = (uint16_t)(TIM_ICPolarity << 8);

  /* Select the Input and set the filter */
  tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR2_IC3F);
 8005084:	f64f 760c 	movw	r6, #65292	; 0xff0c
 8005088:	402e      	ands	r6, r5
  tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));

  /* Select the Polarity and set the CC3E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
 800508a:	f24f 55ff 	movw	r5, #62975	; 0xf5ff
 800508e:	ea0c 0505 	and.w	r5, ip, r5
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 8);

  /* Select the Input and set the filter */
  tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR2_IC3F);
  tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
 8005092:	ea42 1303 	orr.w	r3, r2, r3, lsl #4

  /* Select the Polarity and set the CC3E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC3E);
 8005096:	ea45 2101 	orr.w	r1, r5, r1, lsl #8
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 8);

  /* Select the Input and set the filter */
  tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR2_IC3F);
  tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
 800509a:	431e      	orrs	r6, r3

  /* Select the Polarity and set the CC3E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC3E);
 800509c:	f441 7180 	orr.w	r1, r1, #256	; 0x100

  /* Write to TIMx CCMR2 and CCER registers */
  TIMx->CCMR2 = tmpccmr2;
 80050a0:	b2b6      	uxth	r6, r6
  TIMx->CCER = tmpccer;
 80050a2:	b289      	uxth	r1, r1
  /* Select the Polarity and set the CC3E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC3E);

  /* Write to TIMx CCMR2 and CCER registers */
  TIMx->CCMR2 = tmpccmr2;
 80050a4:	61c6      	str	r6, [r0, #28]
  TIMx->CCER = tmpccer;
 80050a6:	6201      	str	r1, [r0, #32]
    /* TI3 Configuration */
    TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 80050a8:	4639      	mov	r1, r7
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
  }
}
 80050aa:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    /* TI3 Configuration */
    TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 80050ae:	f7ff bfae 	b.w	800500e <TIM_SetIC3Prescaler>
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC4E;
 80050b2:	f64e 75ff 	movw	r5, #61439	; 0xefff
 80050b6:	4035      	ands	r5, r6
 80050b8:	6205      	str	r5, [r0, #32]
  tmpccmr2 = TIMx->CCMR2;
 80050ba:	69c5      	ldr	r5, [r0, #28]
  tmpccer = TIMx->CCER;
 80050bc:	f8d0 c020 	ldr.w	ip, [r0, #32]
  tmp = (uint16_t)(TIM_ICPolarity << 12);

  /* Select the Input and set the filter */
  tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
 80050c0:	f640 46ff 	movw	r6, #3327	; 0xcff
 80050c4:	402e      	ands	r6, r5
  tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
  tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);

  /* Select the Polarity and set the CC4E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
 80050c6:	f645 75ff 	movw	r5, #24575	; 0x5fff
 80050ca:	ea0c 0505 	and.w	r5, ip, r5
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 12);

  /* Select the Input and set the filter */
  tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
  tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
 80050ce:	0212      	lsls	r2, r2, #8
  tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);

  /* Select the Polarity and set the CC4E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC4E);
 80050d0:	ea45 3101 	orr.w	r1, r5, r1, lsl #12
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 12);

  /* Select the Input and set the filter */
  tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
  tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
 80050d4:	ea42 3303 	orr.w	r3, r2, r3, lsl #12
 80050d8:	b29b      	uxth	r3, r3
  tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);

  /* Select the Polarity and set the CC4E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC4E);
 80050da:	f441 5180 	orr.w	r1, r1, #4096	; 0x1000

  /* Write to TIMx CCMR2 and CCER registers */
  TIMx->CCMR2 = tmpccmr2;
 80050de:	431e      	orrs	r6, r3
  TIMx->CCER = tmpccer ;
 80050e0:	b289      	uxth	r1, r1
  /* Select the Polarity and set the CC4E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC4E);

  /* Write to TIMx CCMR2 and CCER registers */
  TIMx->CCMR2 = tmpccmr2;
 80050e2:	61c6      	str	r6, [r0, #28]
  TIMx->CCER = tmpccer ;
 80050e4:	6201      	str	r1, [r0, #32]
    /* TI4 Configuration */
    TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 80050e6:	4639      	mov	r1, r7
  }
}
 80050e8:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    /* TI4 Configuration */
    TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 80050ec:	f7ff bf99 	b.w	8005022 <TIM_SetIC4Prescaler>

080050f0 <TIM_BDTRConfig>:

  /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
     the OSSI State, the dead time value and the Automatic Output Enable Bit */
  TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
             TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
             TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
 80050f0:	884a      	ldrh	r2, [r1, #2]
 80050f2:	880b      	ldrh	r3, [r1, #0]
 80050f4:	4313      	orrs	r3, r2
 80050f6:	888a      	ldrh	r2, [r1, #4]
 80050f8:	4313      	orrs	r3, r2
 80050fa:	88ca      	ldrh	r2, [r1, #6]
 80050fc:	4313      	orrs	r3, r2
 80050fe:	890a      	ldrh	r2, [r1, #8]
 8005100:	4313      	orrs	r3, r2
 8005102:	894a      	ldrh	r2, [r1, #10]
 8005104:	4313      	orrs	r3, r2
 8005106:	898a      	ldrh	r2, [r1, #12]
 8005108:	4313      	orrs	r3, r2
 800510a:	b29b      	uxth	r3, r3
  assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));

  /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
     the OSSI State, the dead time value and the Automatic Output Enable Bit */
  TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
 800510c:	6443      	str	r3, [r0, #68]	; 0x44
 800510e:	4770      	bx	lr

08005110 <TIM_Break1Config>:
{   /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_BREAK1_FILTER(TIM_Break1Filter));

  /* Reset the BKP and BKF Bits */
  TIMx->BDTR &= (uint32_t)~ (TIM_BDTR_BKP | TIM_BDTR_BKF);
 8005110:	6c43      	ldr	r3, [r0, #68]	; 0x44
 8005112:	f423 2372 	bic.w	r3, r3, #991232	; 0xf2000
 8005116:	6443      	str	r3, [r0, #68]	; 0x44
  /* Configure the Break1 polarity and filter */
  TIMx->BDTR |=	TIM_Break1Polarity |((uint32_t)TIM_Break1Filter << 16);
 8005118:	6c43      	ldr	r3, [r0, #68]	; 0x44
 800511a:	4319      	orrs	r1, r3
 800511c:	ea41 4202 	orr.w	r2, r1, r2, lsl #16
 8005120:	6442      	str	r2, [r0, #68]	; 0x44
 8005122:	4770      	bx	lr

08005124 <TIM_Break2Config>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_BREAK2_FILTER(TIM_Break2Filter));

  /* Reset the BKP and BKF Bits */
  TIMx->BDTR &= (uint32_t)~ (TIM_BDTR_BK2P | TIM_BDTR_BK2F);
 8005124:	6c43      	ldr	r3, [r0, #68]	; 0x44
 8005126:	f023 733c 	bic.w	r3, r3, #49283072	; 0x2f00000
 800512a:	6443      	str	r3, [r0, #68]	; 0x44

  /* Configure the Break1 polarity and filter */
  TIMx->BDTR |=	TIM_Break2Polarity |((uint32_t)TIM_Break2Filter << 20);
 800512c:	6c43      	ldr	r3, [r0, #68]	; 0x44
 800512e:	4319      	orrs	r1, r3
 8005130:	ea41 5202 	orr.w	r2, r1, r2, lsl #20
 8005134:	6442      	str	r2, [r0, #68]	; 0x44
 8005136:	4770      	bx	lr

08005138 <TIM_Break1Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the Break1 */
    TIMx->BDTR |= TIM_BDTR_BKE;
 8005138:	6c43      	ldr	r3, [r0, #68]	; 0x44
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800513a:	b111      	cbz	r1, 8005142 <TIM_Break1Cmd+0xa>
  {
    /* Enable the Break1 */
    TIMx->BDTR |= TIM_BDTR_BKE;
 800513c:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8005140:	e001      	b.n	8005146 <TIM_Break1Cmd+0xe>
  }
  else
  {
    /* Disable the Break1 */
    TIMx->BDTR &= (uint32_t)~TIM_BDTR_BKE;
 8005142:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8005146:	6443      	str	r3, [r0, #68]	; 0x44
 8005148:	4770      	bx	lr

0800514a <TIM_Break2Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the Break1 */
    TIMx->BDTR |= TIM_BDTR_BK2E;
 800514a:	6c43      	ldr	r3, [r0, #68]	; 0x44
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800514c:	b111      	cbz	r1, 8005154 <TIM_Break2Cmd+0xa>
  {
    /* Enable the Break1 */
    TIMx->BDTR |= TIM_BDTR_BK2E;
 800514e:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8005152:	e001      	b.n	8005158 <TIM_Break2Cmd+0xe>
  }
  else
  {
    /* Disable the Break1 */
    TIMx->BDTR &= (uint32_t)~TIM_BDTR_BK2E;
 8005154:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8005158:	6443      	str	r3, [r0, #68]	; 0x44
 800515a:	4770      	bx	lr

0800515c <TIM_BDTRStructInit>:
  * @retval None
  */
void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
{
  /* Set the default configuration */
  TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
 800515c:	2300      	movs	r3, #0
 800515e:	8003      	strh	r3, [r0, #0]
  TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
 8005160:	8043      	strh	r3, [r0, #2]
  TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
 8005162:	8083      	strh	r3, [r0, #4]
  TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
 8005164:	80c3      	strh	r3, [r0, #6]
  TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
 8005166:	8103      	strh	r3, [r0, #8]
  TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
 8005168:	8143      	strh	r3, [r0, #10]
  TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
 800516a:	8183      	strh	r3, [r0, #12]
 800516c:	4770      	bx	lr

0800516e <TIM_CtrlPWMOutputs>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the TIM Main Output */
    TIMx->BDTR |= TIM_BDTR_MOE;
 800516e:	6c43      	ldr	r3, [r0, #68]	; 0x44
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8005170:	b111      	cbz	r1, 8005178 <TIM_CtrlPWMOutputs+0xa>
  {
    /* Enable the TIM Main Output */
    TIMx->BDTR |= TIM_BDTR_MOE;
 8005172:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8005176:	e001      	b.n	800517c <TIM_CtrlPWMOutputs+0xe>
  }
  else
  {
    /* Disable the TIM Main Output */
    TIMx->BDTR &= (uint16_t)~TIM_BDTR_MOE;
 8005178:	f3c3 030e 	ubfx	r3, r3, #0, #15
 800517c:	6443      	str	r3, [r0, #68]	; 0x44
 800517e:	4770      	bx	lr

08005180 <TIM_SelectCOM>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8005180:	b119      	cbz	r1, 800518a <TIM_SelectCOM+0xa>
  {
    /* Set the COM Bit */
    TIMx->CR2 |= TIM_CR2_CCUS;
 8005182:	6843      	ldr	r3, [r0, #4]
 8005184:	f043 0304 	orr.w	r3, r3, #4
 8005188:	e003      	b.n	8005192 <TIM_SelectCOM+0x12>
  }
  else
  {
    /* Reset the COM Bit */
    TIMx->CR2 &= (uint16_t)~TIM_CR2_CCUS;
 800518a:	6842      	ldr	r2, [r0, #4]
 800518c:	f64f 73fb 	movw	r3, #65531	; 0xfffb
 8005190:	4013      	ands	r3, r2
 8005192:	6043      	str	r3, [r0, #4]
 8005194:	4770      	bx	lr

08005196 <TIM_CCPreloadControl>:
void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
{ 
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8005196:	b119      	cbz	r1, 80051a0 <TIM_CCPreloadControl+0xa>
  {
    /* Set the CCPC Bit */
    TIMx->CR2 |= TIM_CR2_CCPC;
 8005198:	6843      	ldr	r3, [r0, #4]
 800519a:	f043 0301 	orr.w	r3, r3, #1
 800519e:	e003      	b.n	80051a8 <TIM_CCPreloadControl+0x12>
  }
  else
  {
    /* Reset the CCPC Bit */
    TIMx->CR2 &= (uint16_t)~TIM_CR2_CCPC;
 80051a0:	6842      	ldr	r2, [r0, #4]
 80051a2:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 80051a6:	4013      	ands	r3, r2
 80051a8:	6043      	str	r3, [r0, #4]
 80051aa:	4770      	bx	lr

080051ac <TIM_ITConfig>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the Interrupt sources */
    TIMx->DIER |= TIM_IT;
 80051ac:	68c3      	ldr	r3, [r0, #12]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_IT(TIM_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80051ae:	b10a      	cbz	r2, 80051b4 <TIM_ITConfig+0x8>
  {
    /* Enable the Interrupt sources */
    TIMx->DIER |= TIM_IT;
 80051b0:	4319      	orrs	r1, r3
 80051b2:	e002      	b.n	80051ba <TIM_ITConfig+0xe>
  }
  else
  {
    /* Disable the Interrupt sources */
    TIMx->DIER &= (uint16_t)~TIM_IT;
 80051b4:	43c9      	mvns	r1, r1
 80051b6:	b289      	uxth	r1, r1
 80051b8:	4019      	ands	r1, r3
 80051ba:	60c1      	str	r1, [r0, #12]
 80051bc:	4770      	bx	lr

080051be <TIM_GenerateEvent>:
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));
 
  /* Set the event sources */
  TIMx->EGR = TIM_EventSource;
 80051be:	6141      	str	r1, [r0, #20]
 80051c0:	4770      	bx	lr

080051c2 <TIM_GetFlagStatus>:
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_GET_FLAG(TIM_FLAG));

  
  if ((TIMx->SR & TIM_FLAG) != RESET)
 80051c2:	6903      	ldr	r3, [r0, #16]
 80051c4:	4219      	tst	r1, r3
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 80051c6:	bf0c      	ite	eq
 80051c8:	2000      	moveq	r0, #0
 80051ca:	2001      	movne	r0, #1
 80051cc:	4770      	bx	lr

080051ce <TIM_ClearFlag>:
{  
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
   
  /* Clear the flags */
  TIMx->SR = (uint16_t)~TIM_FLAG;
 80051ce:	43c9      	mvns	r1, r1
 80051d0:	b289      	uxth	r1, r1
 80051d2:	6101      	str	r1, [r0, #16]
 80051d4:	4770      	bx	lr

080051d6 <TIM_GetITStatus>:
  uint16_t itstatus = 0x0, itenable = 0x0;
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_GET_IT(TIM_IT));
   
  itstatus = TIMx->SR & TIM_IT;
 80051d6:	6903      	ldr	r3, [r0, #16]
  
  itenable = TIMx->DIER & TIM_IT;
 80051d8:	68c2      	ldr	r2, [r0, #12]
  if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
 80051da:	ea11 0003 	ands.w	r0, r1, r3
 80051de:	d003      	beq.n	80051e8 <TIM_GetITStatus+0x12>
 80051e0:	4211      	tst	r1, r2
  {
    bitstatus = SET;
 80051e2:	bf0c      	ite	eq
 80051e4:	2000      	moveq	r0, #0
 80051e6:	2001      	movne	r0, #1
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 80051e8:	4770      	bx	lr

080051ea <TIM_ClearITPendingBit>:
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));

  /* Clear the IT pending Bit */
  TIMx->SR = (uint16_t)~TIM_IT;
 80051ea:	43c9      	mvns	r1, r1
 80051ec:	b289      	uxth	r1, r1
 80051ee:	6101      	str	r1, [r0, #16]
 80051f0:	4770      	bx	lr

080051f2 <TIM_DMAConfig>:
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_DMA_BASE(TIM_DMABase)); 
  assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));

  /* Set the DMA Base and the DMA Burst Length */
  TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
 80051f2:	430a      	orrs	r2, r1
 80051f4:	f8a0 2048 	strh.w	r2, [r0, #72]	; 0x48
 80051f8:	4770      	bx	lr

080051fa <TIM_DMACmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the DMA sources */
    TIMx->DIER |= TIM_DMASource; 
 80051fa:	68c3      	ldr	r3, [r0, #12]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80051fc:	b10a      	cbz	r2, 8005202 <TIM_DMACmd+0x8>
  {
    /* Enable the DMA sources */
    TIMx->DIER |= TIM_DMASource; 
 80051fe:	4319      	orrs	r1, r3
 8005200:	e002      	b.n	8005208 <TIM_DMACmd+0xe>
  }
  else
  {
    /* Disable the DMA sources */
    TIMx->DIER &= (uint16_t)~TIM_DMASource;
 8005202:	43c9      	mvns	r1, r1
 8005204:	b289      	uxth	r1, r1
 8005206:	4019      	ands	r1, r3
 8005208:	60c1      	str	r1, [r0, #12]
 800520a:	4770      	bx	lr

0800520c <TIM_SelectCCDMA>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800520c:	b119      	cbz	r1, 8005216 <TIM_SelectCCDMA+0xa>
  {
    /* Set the CCDS Bit */
    TIMx->CR2 |= TIM_CR2_CCDS;
 800520e:	6843      	ldr	r3, [r0, #4]
 8005210:	f043 0308 	orr.w	r3, r3, #8
 8005214:	e003      	b.n	800521e <TIM_SelectCCDMA+0x12>
  }
  else
  {
    /* Reset the CCDS Bit */
    TIMx->CR2 &= (uint16_t)~TIM_CR2_CCDS;
 8005216:	6842      	ldr	r2, [r0, #4]
 8005218:	f64f 73f7 	movw	r3, #65527	; 0xfff7
 800521c:	4013      	ands	r3, r2
 800521e:	6043      	str	r3, [r0, #4]
 8005220:	4770      	bx	lr

08005222 <TIM_InternalClockConfig>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));

  /* Disable slave mode to clock the prescaler directly with the internal clock */
  TIMx->SMCR &=  (uint16_t)~TIM_SMCR_SMS;
 8005222:	6883      	ldr	r3, [r0, #8]
 8005224:	f023 0307 	bic.w	r3, r3, #7
 8005228:	041b      	lsls	r3, r3, #16
 800522a:	0c1b      	lsrs	r3, r3, #16
 800522c:	6083      	str	r3, [r0, #8]
 800522e:	4770      	bx	lr

08005230 <TIM_ITRxExternalClockConfig>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx)); 
  assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 8005230:	6882      	ldr	r2, [r0, #8]

  /* Reset the TS Bits */
  tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
 8005232:	f64f 738f 	movw	r3, #65423	; 0xff8f
 8005236:	4013      	ands	r3, r2

  /* Set the Input Trigger source */
  tmpsmcr |= TIM_InputTriggerSource;

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 8005238:	4319      	orrs	r1, r3
 800523a:	6081      	str	r1, [r0, #8]

  /* Select the Internal Trigger */
  TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);

  /* Select the External clock mode1 */
  TIMx->SMCR |= TIM_SlaveMode_External1;
 800523c:	6883      	ldr	r3, [r0, #8]
 800523e:	f043 0307 	orr.w	r3, r3, #7
 8005242:	6083      	str	r3, [r0, #8]
 8005244:	4770      	bx	lr

08005246 <TIM_TIxExternalClockConfig>:
  *          This parameter must be a value between 0x0 and 0xF.
  * @retval None
  */
void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
                                uint16_t TIM_ICPolarity, uint16_t ICFilter)
{
 8005246:	b538      	push	{r3, r4, r5, lr}
 8005248:	460d      	mov	r5, r1
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
  assert_param(IS_TIM_IC_FILTER(ICFilter));

  /* Configure the Timer Input Clock Source */
  if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
 800524a:	2d60      	cmp	r5, #96	; 0x60
  *          This parameter must be a value between 0x0 and 0xF.
  * @retval None
  */
void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
                                uint16_t TIM_ICPolarity, uint16_t ICFilter)
{
 800524c:	4611      	mov	r1, r2
 800524e:	4604      	mov	r4, r0
  assert_param(IS_TIM_IC_FILTER(ICFilter));

  /* Configure the Timer Input Clock Source */
  if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
  {
    TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
 8005250:	f04f 0201 	mov.w	r2, #1
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
  assert_param(IS_TIM_IC_FILTER(ICFilter));

  /* Configure the Timer Input Clock Source */
  if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
 8005254:	d102      	bne.n	800525c <TIM_TIxExternalClockConfig+0x16>
  {
    TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
 8005256:	f7ff facd 	bl	80047f4 <TI2_Config>
 800525a:	e001      	b.n	8005260 <TIM_TIxExternalClockConfig+0x1a>
  }
  else
  {
    TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
 800525c:	f7ff fab6 	bl	80047cc <TI1_Config>
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx)); 
  assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 8005260:	68a2      	ldr	r2, [r4, #8]

  /* Reset the TS Bits */
  tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
 8005262:	f64f 738f 	movw	r3, #65423	; 0xff8f
 8005266:	4013      	ands	r3, r2

  /* Set the Input Trigger source */
  tmpsmcr |= TIM_InputTriggerSource;

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 8005268:	432b      	orrs	r3, r5
 800526a:	60a3      	str	r3, [r4, #8]
    TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
  }
  /* Select the Trigger source */
  TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
  /* Select the External clock mode1 */
  TIMx->SMCR |= TIM_SlaveMode_External1;
 800526c:	68a3      	ldr	r3, [r4, #8]
 800526e:	f043 0307 	orr.w	r3, r3, #7
 8005272:	60a3      	str	r3, [r4, #8]
 8005274:	bd38      	pop	{r3, r4, r5, pc}

08005276 <TIM_SelectInputTrigger>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx)); 
  assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 8005276:	6882      	ldr	r2, [r0, #8]

  /* Reset the TS Bits */
  tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
 8005278:	f64f 738f 	movw	r3, #65423	; 0xff8f
 800527c:	4013      	ands	r3, r2

  /* Set the Input Trigger source */
  tmpsmcr |= TIM_InputTriggerSource;

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 800527e:	4319      	orrs	r1, r3
 8005280:	6081      	str	r1, [r0, #8]
 8005282:	4770      	bx	lr

08005284 <TIM_SelectOutputTrigger>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST7_PERIPH(TIMx));
  assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));

  /* Reset the MMS Bits */
  TIMx->CR2 &= (uint16_t)~TIM_CR2_MMS;
 8005284:	6843      	ldr	r3, [r0, #4]
 8005286:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800528a:	041b      	lsls	r3, r3, #16
 800528c:	0c1b      	lsrs	r3, r3, #16
 800528e:	6043      	str	r3, [r0, #4]
  /* Select the TRGO source */
  TIMx->CR2 |=  TIM_TRGOSource;
 8005290:	6843      	ldr	r3, [r0, #4]
 8005292:	4319      	orrs	r1, r3
 8005294:	6041      	str	r1, [r0, #4]
 8005296:	4770      	bx	lr

08005298 <TIM_SelectOutputTrigger2>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_TRGO2_SOURCE(TIM_TRGO2Source));

  /* Reset the MMS Bits */
  TIMx->CR2 &= (uint32_t)~TIM_CR2_MMS2;
 8005298:	6843      	ldr	r3, [r0, #4]
 800529a:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
 800529e:	6043      	str	r3, [r0, #4]
  /* Select the TRGO source */
  TIMx->CR2 |=  TIM_TRGO2Source;
 80052a0:	6843      	ldr	r3, [r0, #4]
 80052a2:	4319      	orrs	r1, r3
 80052a4:	6041      	str	r1, [r0, #4]
 80052a6:	4770      	bx	lr

080052a8 <TIM_SelectSlaveMode>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));

  /* Reset the SMS Bits */
  TIMx->SMCR &= (uint32_t)~TIM_SMCR_SMS;
 80052a8:	6883      	ldr	r3, [r0, #8]
 80052aa:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80052ae:	f023 0307 	bic.w	r3, r3, #7
 80052b2:	6083      	str	r3, [r0, #8]

  /* Select the Slave Mode */
  TIMx->SMCR |= (uint32_t)TIM_SlaveMode;
 80052b4:	6883      	ldr	r3, [r0, #8]
 80052b6:	4319      	orrs	r1, r3
 80052b8:	6081      	str	r1, [r0, #8]
 80052ba:	4770      	bx	lr

080052bc <TIM_SelectMasterSlaveMode>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));

  /* Reset the MSM Bit */
  TIMx->SMCR &= (uint16_t)~TIM_SMCR_MSM;
 80052bc:	6883      	ldr	r3, [r0, #8]
 80052be:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 80052c2:	041b      	lsls	r3, r3, #16
 80052c4:	0c1b      	lsrs	r3, r3, #16
 80052c6:	6083      	str	r3, [r0, #8]
  
  /* Set or Reset the MSM Bit */
  TIMx->SMCR |= TIM_MasterSlaveMode;
 80052c8:	6883      	ldr	r3, [r0, #8]
 80052ca:	4319      	orrs	r1, r3
 80052cc:	6081      	str	r1, [r0, #8]
 80052ce:	4770      	bx	lr

080052d0 <TIM_ETRConfig>:
  *          This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */
void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler,
                   uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
{
 80052d0:	b510      	push	{r4, lr}
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));

  tmpsmcr = TIMx->SMCR;
 80052d2:	6884      	ldr	r4, [r0, #8]

  /* Reset the ETR Bits */
  tmpsmcr &= SMCR_ETR_MASK;
 80052d4:	b2e4      	uxtb	r4, r4

  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
 80052d6:	4321      	orrs	r1, r4
 80052d8:	430a      	orrs	r2, r1
 80052da:	ea42 2303 	orr.w	r3, r2, r3, lsl #8

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 80052de:	b29c      	uxth	r4, r3
 80052e0:	6084      	str	r4, [r0, #8]
 80052e2:	bd10      	pop	{r4, pc}

080052e4 <TIM_ETRClockMode1Config>:
  *          This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */
void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler,
                            uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
{
 80052e4:	b510      	push	{r4, lr}
 80052e6:	4604      	mov	r4, r0
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
  /* Configure the ETR Clock source */
  TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
 80052e8:	f7ff fff2 	bl	80052d0 <TIM_ETRConfig>
  
  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 80052ec:	68a3      	ldr	r3, [r4, #8]

  /* Select the External clock mode1 */
  tmpsmcr |= TIM_SlaveMode_External1;

  /* Select the Trigger selection : ETRF */
  tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
 80052ee:	f023 0377 	bic.w	r3, r3, #119	; 0x77
 80052f2:	b29b      	uxth	r3, r3
  tmpsmcr |= TIM_TS_ETRF;

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 80052f4:	f043 0377 	orr.w	r3, r3, #119	; 0x77
 80052f8:	60a3      	str	r3, [r4, #8]
 80052fa:	bd10      	pop	{r4, pc}

080052fc <TIM_ETRClockMode2Config>:
  *          This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */
void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
                             uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
{
 80052fc:	b510      	push	{r4, lr}
 80052fe:	4604      	mov	r4, r0
  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));

  /* Configure the ETR Clock source */
  TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
 8005300:	f7ff ffe6 	bl	80052d0 <TIM_ETRConfig>

  /* Enable the External clock mode2 */
  TIMx->SMCR |= TIM_SMCR_ECE;
 8005304:	68a3      	ldr	r3, [r4, #8]
 8005306:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800530a:	60a3      	str	r3, [r4, #8]
 800530c:	bd10      	pop	{r4, pc}

0800530e <TIM_EncoderInterfaceConfig>:
  *            @arg TIM_ICPolarity_Rising: IC Rising edge.
  * @retval None
  */
void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
                                uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity)
{
 800530e:	b5f0      	push	{r4, r5, r6, r7, lr}
  assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
  assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
  assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 8005310:	6884      	ldr	r4, [r0, #8]

  /* Get the TIMx CCMR1 register value */
  tmpccmr1 = TIMx->CCMR1;
 8005312:	6987      	ldr	r7, [r0, #24]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8005314:	6a06      	ldr	r6, [r0, #32]

  /* Set the encoder Mode */
  tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
 8005316:	f64f 75f8 	movw	r5, #65528	; 0xfff8

  /* Get the TIMx CCMR1 register value */
  tmpccmr1 = TIMx->CCMR1;

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 800531a:	b2b6      	uxth	r6, r6

  /* Set the encoder Mode */
  tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
 800531c:	4025      	ands	r5, r4
  /* Select the Capture Compare 1 and the Capture Compare 2 as input */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_CC2S);
  tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;

  /* Set the TI1 and the TI2 Polarities */
  tmpccer &= ((uint16_t)~TIM_CCER_CC1P) & ((uint16_t)~TIM_CCER_CC2P);
 800531e:	f026 0622 	bic.w	r6, r6, #34	; 0x22
  /* Set the encoder Mode */
  tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
  tmpsmcr |= TIM_EncoderMode;

  /* Select the Capture Compare 1 and the Capture Compare 2 as input */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_CC2S);
 8005322:	f64f 44fc 	movw	r4, #64764	; 0xfcfc
  tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;

  /* Set the TI1 and the TI2 Polarities */
  tmpccer &= ((uint16_t)~TIM_CCER_CC1P) & ((uint16_t)~TIM_CCER_CC2P);
  tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));
 8005326:	4332      	orrs	r2, r6
  /* Set the encoder Mode */
  tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
  tmpsmcr |= TIM_EncoderMode;

  /* Select the Capture Compare 1 and the Capture Compare 2 as input */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_CC2S);
 8005328:	403c      	ands	r4, r7

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmr1;
 800532a:	f444 7480 	orr.w	r4, r4, #256	; 0x100
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_CC2S);
  tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;

  /* Set the TI1 and the TI2 Polarities */
  tmpccer &= ((uint16_t)~TIM_CCER_CC1P) & ((uint16_t)~TIM_CCER_CC2P);
  tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));
 800532e:	ea42 1303 	orr.w	r3, r2, r3, lsl #4

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 8005332:	4329      	orrs	r1, r5

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmr1;
 8005334:	f044 0401 	orr.w	r4, r4, #1

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8005338:	b29e      	uxth	r6, r3
  /* Set the TI1 and the TI2 Polarities */
  tmpccer &= ((uint16_t)~TIM_CCER_CC1P) & ((uint16_t)~TIM_CCER_CC2P);
  tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 800533a:	6081      	str	r1, [r0, #8]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmr1;
 800533c:	6184      	str	r4, [r0, #24]

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800533e:	6206      	str	r6, [r0, #32]
 8005340:	bdf0      	pop	{r4, r5, r6, r7, pc}

08005342 <TIM_SelectHallSensor>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8005342:	b119      	cbz	r1, 800534c <TIM_SelectHallSensor+0xa>
  {
    /* Set the TI1S Bit */
    TIMx->CR2 |= TIM_CR2_TI1S;
 8005344:	6843      	ldr	r3, [r0, #4]
 8005346:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800534a:	e003      	b.n	8005354 <TIM_SelectHallSensor+0x12>
  }
  else
  {
    /* Reset the TI1S Bit */
    TIMx->CR2 &= (uint16_t)~TIM_CR2_TI1S;
 800534c:	6842      	ldr	r2, [r0, #4]
 800534e:	f64f 737f 	movw	r3, #65407	; 0xff7f
 8005352:	4013      	ands	r3, r2
 8005354:	6043      	str	r3, [r0, #4]
 8005356:	4770      	bx	lr

08005358 <TIM_RemapConfig>:
 /* Check the parameters */
  assert_param(IS_TIM_LIST8_PERIPH(TIMx));
  assert_param(IS_TIM_REMAP(TIM_Remap));

  /* Set the Timer remapping configuration */
  TIMx->OR =  TIM_Remap;
 8005358:	f8a0 1050 	strh.w	r1, [r0, #80]	; 0x50
 800535c:	4770      	bx	lr
 800535e:	bf00      	nop

08005360 <USART_DeInit>:
  * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
  *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
  * @retval None
  */
void USART_DeInit(USART_TypeDef* USARTx)
{
 8005360:	b508      	push	{r3, lr}
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));

  if (USARTx == USART1)
 8005362:	4b20      	ldr	r3, [pc, #128]	; (80053e4 <USART_DeInit+0x84>)
 8005364:	4298      	cmp	r0, r3
 8005366:	d10b      	bne.n	8005380 <USART_DeInit+0x20>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
 8005368:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 800536c:	2101      	movs	r1, #1
 800536e:	f7fe ffd5 	bl	800431c <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
 8005372:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8005376:	2100      	movs	r1, #0
    {
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
    }
  }
}
 8005378:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  assert_param(IS_USART_ALL_PERIPH(USARTx));

  if (USARTx == USART1)
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
 800537c:	f7fe bfce 	b.w	800431c <RCC_APB2PeriphResetCmd>
  }
  else if (USARTx == USART2)
 8005380:	4b19      	ldr	r3, [pc, #100]	; (80053e8 <USART_DeInit+0x88>)
 8005382:	4298      	cmp	r0, r3
 8005384:	d107      	bne.n	8005396 <USART_DeInit+0x36>
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
 8005386:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 800538a:	2101      	movs	r1, #1
 800538c:	f7fe ffd2 	bl	8004334 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
 8005390:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 8005394:	e01f      	b.n	80053d6 <USART_DeInit+0x76>
  }
  else if (USARTx == USART3)
 8005396:	4b15      	ldr	r3, [pc, #84]	; (80053ec <USART_DeInit+0x8c>)
 8005398:	4298      	cmp	r0, r3
 800539a:	d107      	bne.n	80053ac <USART_DeInit+0x4c>
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
 800539c:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 80053a0:	2101      	movs	r1, #1
 80053a2:	f7fe ffc7 	bl	8004334 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
 80053a6:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 80053aa:	e014      	b.n	80053d6 <USART_DeInit+0x76>
  }
  else if (USARTx == UART4)
 80053ac:	4b10      	ldr	r3, [pc, #64]	; (80053f0 <USART_DeInit+0x90>)
 80053ae:	4298      	cmp	r0, r3
 80053b0:	d107      	bne.n	80053c2 <USART_DeInit+0x62>
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
 80053b2:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 80053b6:	2101      	movs	r1, #1
 80053b8:	f7fe ffbc 	bl	8004334 <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
 80053bc:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 80053c0:	e009      	b.n	80053d6 <USART_DeInit+0x76>
  }
  else
  {
    if  (USARTx == UART5)
 80053c2:	4b0c      	ldr	r3, [pc, #48]	; (80053f4 <USART_DeInit+0x94>)
 80053c4:	4298      	cmp	r0, r3
 80053c6:	d10b      	bne.n	80053e0 <USART_DeInit+0x80>
    {
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
 80053c8:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 80053cc:	2101      	movs	r1, #1
 80053ce:	f7fe ffb1 	bl	8004334 <RCC_APB1PeriphResetCmd>
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
 80053d2:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 80053d6:	2100      	movs	r1, #0
    }
  }
}
 80053d8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  else
  {
    if  (USARTx == UART5)
    {
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
 80053dc:	f7fe bfaa 	b.w	8004334 <RCC_APB1PeriphResetCmd>
 80053e0:	bd08      	pop	{r3, pc}
 80053e2:	bf00      	nop
 80053e4:	40013800 	.word	0x40013800
 80053e8:	40004400 	.word	0x40004400
 80053ec:	40004800 	.word	0x40004800
 80053f0:	40004c00 	.word	0x40004c00
 80053f4:	40005000 	.word	0x40005000

080053f8 <USART_Init>:
  assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
  assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
  assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
  
  /* Disable USART */
  USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_UE);
 80053f8:	6803      	ldr	r3, [r0, #0]
 80053fa:	f023 0301 	bic.w	r3, r3, #1
  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure
  *         that contains the configuration information for the specified USART peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 80053fe:	b530      	push	{r4, r5, lr}
  assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
  assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
  assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
  
  /* Disable USART */
  USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_UE);
 8005400:	6003      	str	r3, [r0, #0]
  
  /*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
 8005402:	6842      	ldr	r2, [r0, #4]
  /* Clear STOP[13:12] bits */
  tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
  
  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
  /* Set STOP[13:12] bits according to USART_StopBits value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
 8005404:	688b      	ldr	r3, [r1, #8]
  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure
  *         that contains the configuration information for the specified USART peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 8005406:	460d      	mov	r5, r1
  USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_UE);
  
  /*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
  /* Clear STOP[13:12] bits */
  tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
 8005408:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
  
  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
  /* Set STOP[13:12] bits according to USART_StopBits value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
 800540c:	4313      	orrs	r3, r2
  
  /* Write to USART CR2 */
  USARTx->CR2 = tmpreg;
 800540e:	6043      	str	r3, [r0, #4]
  
  /* Configure the USART Word Length, Parity and mode ----------------------- */
  /* Set the M bits according to USART_WordLength value */
  /* Set PCE and PS bits according to USART_Parity value */
  /* Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 8005410:	686a      	ldr	r2, [r5, #4]
 8005412:	68c9      	ldr	r1, [r1, #12]
  
  /* Write to USART CR2 */
  USARTx->CR2 = tmpreg;
  
  /*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
 8005414:	6803      	ldr	r3, [r0, #0]
  
  /* Configure the USART Word Length, Parity and mode ----------------------- */
  /* Set the M bits according to USART_WordLength value */
  /* Set PCE and PS bits according to USART_Parity value */
  /* Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 8005416:	4311      	orrs	r1, r2
 8005418:	692a      	ldr	r2, [r5, #16]
  USARTx->CR2 = tmpreg;
  
  /*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= (uint32_t)~((uint32_t)CR1_CLEAR_MASK);
 800541a:	f423 53b0 	bic.w	r3, r3, #5632	; 0x1600
  
  /* Configure the USART Word Length, Parity and mode ----------------------- */
  /* Set the M bits according to USART_WordLength value */
  /* Set PCE and PS bits according to USART_Parity value */
  /* Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 800541e:	430a      	orrs	r2, r1
  USARTx->CR2 = tmpreg;
  
  /*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= (uint32_t)~((uint32_t)CR1_CLEAR_MASK);
 8005420:	f023 030c 	bic.w	r3, r3, #12
  
  /* Configure the USART Word Length, Parity and mode ----------------------- */
  /* Set the M bits according to USART_WordLength value */
  /* Set PCE and PS bits according to USART_Parity value */
  /* Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 8005424:	4313      	orrs	r3, r2
    USART_InitStruct->USART_Mode;
  
  /* Write to USART CR1 */
  USARTx->CR1 = tmpreg;
 8005426:	6003      	str	r3, [r0, #0]
  
  /*---------------------------- USART CR3 Configuration -----------------------*/
  tmpreg = USARTx->CR3;
 8005428:	6882      	ldr	r2, [r0, #8]
  /* Clear CTSE and RTSE bits */
  tmpreg &= (uint32_t)~((uint32_t)CR3_CLEAR_MASK);
  
  /* Configure the USART HFC -------------------------------------------------*/
  /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
 800542a:	696b      	ldr	r3, [r5, #20]
  USARTx->CR1 = tmpreg;
  
  /*---------------------------- USART CR3 Configuration -----------------------*/
  tmpreg = USARTx->CR3;
  /* Clear CTSE and RTSE bits */
  tmpreg &= (uint32_t)~((uint32_t)CR3_CLEAR_MASK);
 800542c:	f422 7240 	bic.w	r2, r2, #768	; 0x300
  
  /* Configure the USART HFC -------------------------------------------------*/
  /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
 8005430:	4313      	orrs	r3, r2
  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure
  *         that contains the configuration information for the specified USART peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 8005432:	b091      	sub	sp, #68	; 0x44
  /* Configure the USART HFC -------------------------------------------------*/
  /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
  
  /* Write to USART CR3 */
  USARTx->CR3 = tmpreg;
 8005434:	6083      	str	r3, [r0, #8]
  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure
  *         that contains the configuration information for the specified USART peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 8005436:	4604      	mov	r4, r0
  /* Write to USART CR3 */
  USARTx->CR3 = tmpreg;
  
  /*---------------------------- USART BRR Configuration -----------------------*/
  /* Configure the USART Baud Rate -------------------------------------------*/
  RCC_GetClocksFreq(&RCC_ClocksStatus);
 8005438:	a801      	add	r0, sp, #4
 800543a:	f7fe fd9d 	bl	8003f78 <RCC_GetClocksFreq>
  
  if (USARTx == USART1)
 800543e:	4b18      	ldr	r3, [pc, #96]	; (80054a0 <USART_Init+0xa8>)
 8005440:	429c      	cmp	r4, r3
 8005442:	d101      	bne.n	8005448 <USART_Init+0x50>
  {
    apbclock = RCC_ClocksStatus.USART1CLK_Frequency;
 8005444:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8005446:	e00e      	b.n	8005466 <USART_Init+0x6e>
  }
  else if (USARTx == USART2)
 8005448:	4b16      	ldr	r3, [pc, #88]	; (80054a4 <USART_Init+0xac>)
 800544a:	429c      	cmp	r4, r3
 800544c:	d101      	bne.n	8005452 <USART_Init+0x5a>
  {
    apbclock = RCC_ClocksStatus.USART2CLK_Frequency;
 800544e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8005450:	e009      	b.n	8005466 <USART_Init+0x6e>
  }
  else if (USARTx == USART3)
 8005452:	4b15      	ldr	r3, [pc, #84]	; (80054a8 <USART_Init+0xb0>)
 8005454:	429c      	cmp	r4, r3
 8005456:	d101      	bne.n	800545c <USART_Init+0x64>
  {
    apbclock = RCC_ClocksStatus.USART3CLK_Frequency;
 8005458:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 800545a:	e004      	b.n	8005466 <USART_Init+0x6e>
  }
  else if (USARTx == UART4)
 800545c:	4b13      	ldr	r3, [pc, #76]	; (80054ac <USART_Init+0xb4>)
 800545e:	429c      	cmp	r4, r3
  {
    apbclock = RCC_ClocksStatus.UART4CLK_Frequency;
 8005460:	bf0c      	ite	eq
 8005462:	9a0e      	ldreq	r2, [sp, #56]	; 0x38
  }
  else 
  {
    apbclock = RCC_ClocksStatus.UART5CLK_Frequency;
 8005464:	9a0f      	ldrne	r2, [sp, #60]	; 0x3c
  }  
  
  /* Determine the integer part */
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 8005466:	6823      	ldr	r3, [r4, #0]
 8005468:	6829      	ldr	r1, [r5, #0]
 800546a:	f413 4f00 	tst.w	r3, #32768	; 0x8000
  {
    /* (divider * 10) computing in case Oversampling mode is 8 Samples */
    divider = (uint32_t)((2 * apbclock) / (USART_InitStruct->USART_BaudRate));
 800546e:	bf18      	it	ne
 8005470:	0052      	lslne	r2, r2, #1
    tmpreg  = (uint32_t)((2 * apbclock) % (USART_InitStruct->USART_BaudRate));
  }
  else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
  {
    /* (divider * 10) computing in case Oversampling mode is 16 Samples */
    divider = (uint32_t)((apbclock) / (USART_InitStruct->USART_BaudRate));
 8005472:	fbb2 f3f1 	udiv	r3, r2, r1
    tmpreg  = (uint32_t)((apbclock) % (USART_InitStruct->USART_BaudRate));
 8005476:	fb01 2213 	mls	r2, r1, r3, r2
  }
  
  /* round the divider : if fractional part i greater than 0.5 increment divider */
  if (tmpreg >=  (USART_InitStruct->USART_BaudRate) / 2)
 800547a:	ebb2 0f51 	cmp.w	r2, r1, lsr #1
  {
    divider++;
  } 
  
  /* Implement the divider in case Oversampling mode is 8 Samples */
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 800547e:	6822      	ldr	r2, [r4, #0]
  }
  
  /* round the divider : if fractional part i greater than 0.5 increment divider */
  if (tmpreg >=  (USART_InitStruct->USART_BaudRate) / 2)
  {
    divider++;
 8005480:	bf28      	it	cs
 8005482:	3301      	addcs	r3, #1
  } 
  
  /* Implement the divider in case Oversampling mode is 8 Samples */
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 8005484:	0412      	lsls	r2, r2, #16
 8005486:	d506      	bpl.n	8005496 <USART_Init+0x9e>
  {
    /* get the LSB of divider and shift it to the right by 1 bit */
    tmpreg = (divider & (uint16_t)0x000F) >> 1;
    
    /* update the divider value */
    divider = (divider & (uint16_t)0xFFF0) | tmpreg;
 8005488:	f64f 72f0 	movw	r2, #65520	; 0xfff0
  
  /* Implement the divider in case Oversampling mode is 8 Samples */
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
  {
    /* get the LSB of divider and shift it to the right by 1 bit */
    tmpreg = (divider & (uint16_t)0x000F) >> 1;
 800548c:	f3c3 0142 	ubfx	r1, r3, #1, #3
    
    /* update the divider value */
    divider = (divider & (uint16_t)0xFFF0) | tmpreg;
 8005490:	401a      	ands	r2, r3
 8005492:	ea41 0302 	orr.w	r3, r1, r2
  }
  
  /* Write to USART BRR */
  USARTx->BRR = (uint16_t)divider;
 8005496:	b29b      	uxth	r3, r3
 8005498:	81a3      	strh	r3, [r4, #12]
}
 800549a:	b011      	add	sp, #68	; 0x44
 800549c:	bd30      	pop	{r4, r5, pc}
 800549e:	bf00      	nop
 80054a0:	40013800 	.word	0x40013800
 80054a4:	40004400 	.word	0x40004400
 80054a8:	40004800 	.word	0x40004800
 80054ac:	40004c00 	.word	0x40004c00

080054b0 <USART_StructInit>:
  * @retval None
  */
void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
{
  /* USART_InitStruct members default value */
  USART_InitStruct->USART_BaudRate = 9600;
 80054b0:	f44f 5316 	mov.w	r3, #9600	; 0x2580
 80054b4:	6003      	str	r3, [r0, #0]
  USART_InitStruct->USART_WordLength = USART_WordLength_8b;
  USART_InitStruct->USART_StopBits = USART_StopBits_1;
  USART_InitStruct->USART_Parity = USART_Parity_No ;
  USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 80054b6:	220c      	movs	r2, #12
  */
void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
{
  /* USART_InitStruct members default value */
  USART_InitStruct->USART_BaudRate = 9600;
  USART_InitStruct->USART_WordLength = USART_WordLength_8b;
 80054b8:	2300      	movs	r3, #0
 80054ba:	6043      	str	r3, [r0, #4]
  USART_InitStruct->USART_StopBits = USART_StopBits_1;
 80054bc:	6083      	str	r3, [r0, #8]
  USART_InitStruct->USART_Parity = USART_Parity_No ;
 80054be:	60c3      	str	r3, [r0, #12]
  USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 80054c0:	6102      	str	r2, [r0, #16]
  USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;
 80054c2:	6143      	str	r3, [r0, #20]
 80054c4:	4770      	bx	lr

080054c6 <USART_ClockInit>:
  /* Configure the USART Clock, CPOL, CPHA, LastBit and SSM ------------*/
  /* Set CLKEN bit according to USART_Clock value */
  /* Set CPOL bit according to USART_CPOL value */
  /* Set CPHA bit according to USART_CPHA value */
  /* Set LBCL bit according to USART_LastBit value */
  tmpreg |= (uint32_t)(USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
 80054c6:	e891 000c 	ldmia.w	r1, {r2, r3}
  *         structure that contains the configuration information for the specified
  *         USART peripheral.
  * @retval None
  */
void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
{
 80054ca:	b510      	push	{r4, lr}
  /* Configure the USART Clock, CPOL, CPHA, LastBit and SSM ------------*/
  /* Set CLKEN bit according to USART_Clock value */
  /* Set CPOL bit according to USART_CPOL value */
  /* Set CPHA bit according to USART_CPHA value */
  /* Set LBCL bit according to USART_LastBit value */
  tmpreg |= (uint32_t)(USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
 80054cc:	431a      	orrs	r2, r3
 80054ce:	688b      	ldr	r3, [r1, #8]
  assert_param(IS_USART_CLOCK(USART_ClockInitStruct->USART_Clock));
  assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
  assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
  assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
 80054d0:	6844      	ldr	r4, [r0, #4]
  /* Configure the USART Clock, CPOL, CPHA, LastBit and SSM ------------*/
  /* Set CLKEN bit according to USART_Clock value */
  /* Set CPOL bit according to USART_CPOL value */
  /* Set CPHA bit according to USART_CPHA value */
  /* Set LBCL bit according to USART_LastBit value */
  tmpreg |= (uint32_t)(USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
 80054d2:	68c9      	ldr	r1, [r1, #12]
 80054d4:	4313      	orrs	r3, r2
  assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
  assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
  /* Clear CLKEN, CPOL, CPHA, LBCL and SSM bits */
  tmpreg &= (uint32_t)~((uint32_t)CR2_CLOCK_CLEAR_MASK);
 80054d6:	f424 6470 	bic.w	r4, r4, #3840	; 0xf00
  /* Configure the USART Clock, CPOL, CPHA, LastBit and SSM ------------*/
  /* Set CLKEN bit according to USART_Clock value */
  /* Set CPOL bit according to USART_CPOL value */
  /* Set CPHA bit according to USART_CPHA value */
  /* Set LBCL bit according to USART_LastBit value */
  tmpreg |= (uint32_t)(USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
 80054da:	430b      	orrs	r3, r1
 80054dc:	4323      	orrs	r3, r4
                       USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit);
  /* Write to USART CR2 */
  USARTx->CR2 = tmpreg;
 80054de:	6043      	str	r3, [r0, #4]
 80054e0:	bd10      	pop	{r4, pc}

080054e2 <USART_ClockStructInit>:
  * @retval None
  */
void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
{
  /* USART_ClockInitStruct members default value */
  USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
 80054e2:	2300      	movs	r3, #0
 80054e4:	6003      	str	r3, [r0, #0]
  USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
 80054e6:	6043      	str	r3, [r0, #4]
  USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
 80054e8:	6083      	str	r3, [r0, #8]
  USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
 80054ea:	60c3      	str	r3, [r0, #12]
 80054ec:	4770      	bx	lr

080054ee <USART_Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the selected USART by setting the UE bit in the CR1 register */
    USARTx->CR1 |= USART_CR1_UE;
 80054ee:	6803      	ldr	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80054f0:	b111      	cbz	r1, 80054f8 <USART_Cmd+0xa>
  {
    /* Enable the selected USART by setting the UE bit in the CR1 register */
    USARTx->CR1 |= USART_CR1_UE;
 80054f2:	f043 0301 	orr.w	r3, r3, #1
 80054f6:	e001      	b.n	80054fc <USART_Cmd+0xe>
  }
  else
  {
    /* Disable the selected USART by clearing the UE bit in the CR1 register */
    USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_UE);
 80054f8:	f023 0301 	bic.w	r3, r3, #1
 80054fc:	6003      	str	r3, [r0, #0]
 80054fe:	4770      	bx	lr

08005500 <USART_DirectionModeCmd>:

  if (NewState != DISABLE)
  {
    /* Enable the USART's transfer interface by setting the TE and/or RE bits 
       in the USART CR1 register */
    USARTx->CR1 |= USART_DirectionMode;
 8005500:	6803      	ldr	r3, [r0, #0]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_MODE(USART_DirectionMode));
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 

  if (NewState != DISABLE)
 8005502:	b10a      	cbz	r2, 8005508 <USART_DirectionModeCmd+0x8>
  {
    /* Enable the USART's transfer interface by setting the TE and/or RE bits 
       in the USART CR1 register */
    USARTx->CR1 |= USART_DirectionMode;
 8005504:	4319      	orrs	r1, r3
 8005506:	e001      	b.n	800550c <USART_DirectionModeCmd+0xc>
  }
  else
  {
    /* Disable the USART's transfer interface by clearing the TE and/or RE bits
       in the USART CR3 register */
    USARTx->CR1 &= (uint32_t)~USART_DirectionMode;
 8005508:	ea23 0101 	bic.w	r1, r3, r1
 800550c:	6001      	str	r1, [r0, #0]
 800550e:	4770      	bx	lr

08005510 <USART_OverSampling8Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */
    USARTx->CR1 |= USART_CR1_OVER8;
 8005510:	6803      	ldr	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8005512:	b111      	cbz	r1, 800551a <USART_OverSampling8Cmd+0xa>
  {
    /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */
    USARTx->CR1 |= USART_CR1_OVER8;
 8005514:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8005518:	e001      	b.n	800551e <USART_OverSampling8Cmd+0xe>
  }
  else
  {
    /* Disable the 8x Oversampling mode by clearing the OVER8 bit in the CR1 register */
    USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_OVER8);
 800551a:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 800551e:	6003      	str	r3, [r0, #0]
 8005520:	4770      	bx	lr

08005522 <USART_OneBitMethodCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_ONEBIT;
 8005522:	6883      	ldr	r3, [r0, #8]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8005524:	b111      	cbz	r1, 800552c <USART_OneBitMethodCmd+0xa>
  {
    /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_ONEBIT;
 8005526:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 800552a:	e001      	b.n	8005530 <USART_OneBitMethodCmd+0xe>
  }
  else
  {
    /* Disable the one bit method by clearing the ONEBITE bit in the CR3 register */
    USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_ONEBIT);
 800552c:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8005530:	6083      	str	r3, [r0, #8]
 8005532:	4770      	bx	lr

08005534 <USART_MSBFirstCmd>:

  if (NewState != DISABLE)
  {
    /* Enable the most significant bit first transmitted/received following the
       start bit by setting the MSBFIRST bit in the CR2 register */
    USARTx->CR2 |= USART_CR2_MSBFIRST;
 8005534:	6843      	ldr	r3, [r0, #4]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8005536:	b111      	cbz	r1, 800553e <USART_MSBFirstCmd+0xa>
  {
    /* Enable the most significant bit first transmitted/received following the
       start bit by setting the MSBFIRST bit in the CR2 register */
    USARTx->CR2 |= USART_CR2_MSBFIRST;
 8005538:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 800553c:	e001      	b.n	8005542 <USART_MSBFirstCmd+0xe>
  }
  else
  {
    /* Disable the most significant bit first transmitted/received following the
       start bit by clearing the MSBFIRST bit in the CR2 register */
    USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_MSBFIRST);
 800553e:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 8005542:	6043      	str	r3, [r0, #4]
 8005544:	4770      	bx	lr

08005546 <USART_DataInvCmd>:

  if (NewState != DISABLE)
  {
    /* Enable the binary data inversion feature by setting the DATAINV bit in
       the CR2 register */
    USARTx->CR2 |= USART_CR2_DATAINV;
 8005546:	6843      	ldr	r3, [r0, #4]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8005548:	b111      	cbz	r1, 8005550 <USART_DataInvCmd+0xa>
  {
    /* Enable the binary data inversion feature by setting the DATAINV bit in
       the CR2 register */
    USARTx->CR2 |= USART_CR2_DATAINV;
 800554a:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 800554e:	e001      	b.n	8005554 <USART_DataInvCmd+0xe>
  }
  else
  {
    /* Disable the binary data inversion feature by clearing the DATAINV bit in
       the CR2 register */
    USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_DATAINV);
 8005550:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8005554:	6043      	str	r3, [r0, #4]
 8005556:	4770      	bx	lr

08005558 <USART_InvPinCmd>:

  if (NewState != DISABLE)
  {
    /* Enable the active level inversion for selected pins by setting the TXINV 
       and/or RXINV bits in the USART CR2 register */
    USARTx->CR2 |= USART_InvPin;
 8005558:	6843      	ldr	r3, [r0, #4]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_INVERSTION_PIN(USART_InvPin));
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 

  if (NewState != DISABLE)
 800555a:	b10a      	cbz	r2, 8005560 <USART_InvPinCmd+0x8>
  {
    /* Enable the active level inversion for selected pins by setting the TXINV 
       and/or RXINV bits in the USART CR2 register */
    USARTx->CR2 |= USART_InvPin;
 800555c:	4319      	orrs	r1, r3
 800555e:	e001      	b.n	8005564 <USART_InvPinCmd+0xc>
  }
  else
  {
    /* Disable the active level inversion for selected requests by clearing the 
       TXINV and/or RXINV bits in the USART CR2 register */
    USARTx->CR2 &= (uint32_t)~USART_InvPin;
 8005560:	ea23 0101 	bic.w	r1, r3, r1
 8005564:	6041      	str	r1, [r0, #4]
 8005566:	4770      	bx	lr

08005568 <USART_SWAPPinCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the SWAP feature by setting the SWAP bit in the CR2 register */
    USARTx->CR2 |= USART_CR2_SWAP;
 8005568:	6843      	ldr	r3, [r0, #4]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800556a:	b111      	cbz	r1, 8005572 <USART_SWAPPinCmd+0xa>
  {
    /* Enable the SWAP feature by setting the SWAP bit in the CR2 register */
    USARTx->CR2 |= USART_CR2_SWAP;
 800556c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8005570:	e001      	b.n	8005576 <USART_SWAPPinCmd+0xe>
  }
  else
  {
    /* Disable the SWAP feature by clearing the SWAP bit in the CR2 register */
    USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_SWAP);
 8005572:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8005576:	6043      	str	r3, [r0, #4]
 8005578:	4770      	bx	lr

0800557a <USART_ReceiverTimeOutCmd>:

  if (NewState != DISABLE)
  {
    /* Enable the receiver time out feature by setting the RTOEN bit in the CR2 
       register */
    USARTx->CR2 |= USART_CR2_RTOEN;
 800557a:	6843      	ldr	r3, [r0, #4]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800557c:	b111      	cbz	r1, 8005584 <USART_ReceiverTimeOutCmd+0xa>
  {
    /* Enable the receiver time out feature by setting the RTOEN bit in the CR2 
       register */
    USARTx->CR2 |= USART_CR2_RTOEN;
 800557e:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8005582:	e001      	b.n	8005588 <USART_ReceiverTimeOutCmd+0xe>
  }
  else
  {
    /* Disable the receiver time out feature by clearing the RTOEN bit in the CR2 
       register */
    USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_RTOEN);
 8005584:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
 8005588:	6043      	str	r3, [r0, #4]
 800558a:	4770      	bx	lr

0800558c <USART_SetReceiverTimeOut>:
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_TIMEOUT(USART_ReceiverTimeOut));

  /* Clear the receiver Time Out value by clearing the RTO[23:0] bits in the RTOR
     register  */
  USARTx->RTOR &= (uint32_t)~((uint32_t)USART_RTOR_RTO);
 800558c:	6943      	ldr	r3, [r0, #20]
 800558e:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
 8005592:	6143      	str	r3, [r0, #20]
  /* Set the receiver Time Out value by setting the RTO[23:0] bits in the RTOR
     register  */
  USARTx->RTOR |= USART_ReceiverTimeOut;
 8005594:	6943      	ldr	r3, [r0, #20]
 8005596:	4319      	orrs	r1, r3
 8005598:	6141      	str	r1, [r0, #20]
 800559a:	4770      	bx	lr

0800559c <USART_SetPrescaler>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));

  /* Clear the USART prescaler */
  USARTx->GTPR &= USART_GTPR_GT;
 800559c:	8a03      	ldrh	r3, [r0, #16]
 800559e:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 80055a2:	8203      	strh	r3, [r0, #16]
  /* Set the USART prescaler */
  USARTx->GTPR |= USART_Prescaler;
 80055a4:	8a03      	ldrh	r3, [r0, #16]
 80055a6:	b29b      	uxth	r3, r3
 80055a8:	4319      	orrs	r1, r3
 80055aa:	8201      	strh	r1, [r0, #16]
 80055ac:	4770      	bx	lr

080055ae <USART_STOPModeCmd>:
  
  if (NewState != DISABLE)
  {
    /* Enable the selected USART in STOP mode by setting the UESM bit in the CR1
       register */
    USARTx->CR1 |= USART_CR1_UESM;
 80055ae:	6803      	ldr	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80055b0:	b111      	cbz	r1, 80055b8 <USART_STOPModeCmd+0xa>
  {
    /* Enable the selected USART in STOP mode by setting the UESM bit in the CR1
       register */
    USARTx->CR1 |= USART_CR1_UESM;
 80055b2:	f043 0302 	orr.w	r3, r3, #2
 80055b6:	e001      	b.n	80055bc <USART_STOPModeCmd+0xe>
  }
  else
  {
    /* Disable the selected USART in STOP mode by clearing the UE bit in the CR1
       register */
    USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_UESM);
 80055b8:	f023 0302 	bic.w	r3, r3, #2
 80055bc:	6003      	str	r3, [r0, #0]
 80055be:	4770      	bx	lr

080055c0 <USART_StopModeWakeUpSourceConfig>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_STOPMODE_WAKEUPSOURCE(USART_WakeUpSource));

  USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_WUS);
 80055c0:	6883      	ldr	r3, [r0, #8]
 80055c2:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 80055c6:	6083      	str	r3, [r0, #8]
  USARTx->CR3 |= USART_WakeUpSource;
 80055c8:	6883      	ldr	r3, [r0, #8]
 80055ca:	4319      	orrs	r1, r3
 80055cc:	6081      	str	r1, [r0, #8]
 80055ce:	4770      	bx	lr

080055d0 <USART_AutoBaudRateCmd>:

  if (NewState != DISABLE)
  {
    /* Enable the auto baud rate feature by setting the ABREN bit in the CR2 
       register */
    USARTx->CR2 |= USART_CR2_ABREN;
 80055d0:	6843      	ldr	r3, [r0, #4]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80055d2:	b111      	cbz	r1, 80055da <USART_AutoBaudRateCmd+0xa>
  {
    /* Enable the auto baud rate feature by setting the ABREN bit in the CR2 
       register */
    USARTx->CR2 |= USART_CR2_ABREN;
 80055d4:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 80055d8:	e001      	b.n	80055de <USART_AutoBaudRateCmd+0xe>
  }
  else
  {
    /* Disable the auto baud rate feature by clearing the ABREN bit in the CR2 
       register */
    USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_ABREN);
 80055da:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
 80055de:	6043      	str	r3, [r0, #4]
 80055e0:	4770      	bx	lr

080055e2 <USART_AutoBaudRateConfig>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_AUTOBAUDRATE_MODE(USART_AutoBaudRate));

  USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_ABRMODE);
 80055e2:	6843      	ldr	r3, [r0, #4]
 80055e4:	f423 03c0 	bic.w	r3, r3, #6291456	; 0x600000
 80055e8:	6043      	str	r3, [r0, #4]
  USARTx->CR2 |= USART_AutoBaudRate;
 80055ea:	6843      	ldr	r3, [r0, #4]
 80055ec:	4319      	orrs	r1, r3
 80055ee:	6041      	str	r1, [r0, #4]
 80055f0:	4770      	bx	lr

080055f2 <USART_SendData>:
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_DATA(Data)); 

  /* Transmit Data */
  USARTx->TDR = (Data & (uint16_t)0x01FF);
 80055f2:	f3c1 0108 	ubfx	r1, r1, #0, #9
 80055f6:	8501      	strh	r1, [r0, #40]	; 0x28
 80055f8:	4770      	bx	lr

080055fa <USART_ReceiveData>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));

  /* Receive Data */
  return (uint16_t)(USARTx->RDR & (uint16_t)0x01FF);
 80055fa:	8c80      	ldrh	r0, [r0, #36]	; 0x24
}
 80055fc:	f3c0 0008 	ubfx	r0, r0, #0, #9
 8005600:	4770      	bx	lr

08005602 <USART_SetAddress>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));

  /* Clear the USART address */
  USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_ADD);
 8005602:	6843      	ldr	r3, [r0, #4]
 8005604:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8005608:	6043      	str	r3, [r0, #4]
  /* Set the USART address node */
  USARTx->CR2 |=((uint32_t)USART_Address << (uint32_t)0x18);
 800560a:	6843      	ldr	r3, [r0, #4]
 800560c:	ea43 6101 	orr.w	r1, r3, r1, lsl #24
 8005610:	6041      	str	r1, [r0, #4]
 8005612:	4770      	bx	lr

08005614 <USART_MuteModeCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 

  if (NewState != DISABLE)
  {
    /* Enable the USART mute mode by setting the MME bit in the CR1 register */
    USARTx->CR1 |= USART_CR1_MME;
 8005614:	6803      	ldr	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 

  if (NewState != DISABLE)
 8005616:	b111      	cbz	r1, 800561e <USART_MuteModeCmd+0xa>
  {
    /* Enable the USART mute mode by setting the MME bit in the CR1 register */
    USARTx->CR1 |= USART_CR1_MME;
 8005618:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 800561c:	e001      	b.n	8005622 <USART_MuteModeCmd+0xe>
  }
  else
  {
    /* Disable the USART mute mode by clearing the MME bit in the CR1 register */
    USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_MME);
 800561e:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8005622:	6003      	str	r3, [r0, #0]
 8005624:	4770      	bx	lr

08005626 <USART_MuteModeWakeUpConfig>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_MUTEMODE_WAKEUP(USART_WakeUp));

  USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_WAKE);
 8005626:	6803      	ldr	r3, [r0, #0]
 8005628:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 800562c:	6003      	str	r3, [r0, #0]
  USARTx->CR1 |= USART_WakeUp;
 800562e:	6803      	ldr	r3, [r0, #0]
 8005630:	4319      	orrs	r1, r3
 8005632:	6001      	str	r1, [r0, #0]
 8005634:	4770      	bx	lr

08005636 <USART_AddressDetectionConfig>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_ADDRESS_DETECTION(USART_AddressLength));

  USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_ADDM7);
 8005636:	6843      	ldr	r3, [r0, #4]
 8005638:	f023 0310 	bic.w	r3, r3, #16
 800563c:	6043      	str	r3, [r0, #4]
  USARTx->CR2 |= USART_AddressLength;
 800563e:	6843      	ldr	r3, [r0, #4]
 8005640:	4319      	orrs	r1, r3
 8005642:	6041      	str	r1, [r0, #4]
 8005644:	4770      	bx	lr

08005646 <USART_LINBreakDetectLengthConfig>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));

  USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_LBDL);
 8005646:	6843      	ldr	r3, [r0, #4]
 8005648:	f023 0320 	bic.w	r3, r3, #32
 800564c:	6043      	str	r3, [r0, #4]
  USARTx->CR2 |= USART_LINBreakDetectLength;  
 800564e:	6843      	ldr	r3, [r0, #4]
 8005650:	4319      	orrs	r1, r3
 8005652:	6041      	str	r1, [r0, #4]
 8005654:	4770      	bx	lr

08005656 <USART_LINCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
    USARTx->CR2 |= USART_CR2_LINEN;
 8005656:	6843      	ldr	r3, [r0, #4]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8005658:	b111      	cbz	r1, 8005660 <USART_LINCmd+0xa>
  {
    /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
    USARTx->CR2 |= USART_CR2_LINEN;
 800565a:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800565e:	e001      	b.n	8005664 <USART_LINCmd+0xe>
  }
  else
  {
    /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
    USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_LINEN);
 8005660:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8005664:	6043      	str	r3, [r0, #4]
 8005666:	4770      	bx	lr

08005668 <USART_HalfDuplexCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_HDSEL;
 8005668:	6883      	ldr	r3, [r0, #8]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 800566a:	b111      	cbz	r1, 8005672 <USART_HalfDuplexCmd+0xa>
  {
    /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_HDSEL;
 800566c:	f043 0308 	orr.w	r3, r3, #8
 8005670:	e001      	b.n	8005676 <USART_HalfDuplexCmd+0xe>
  }
  else
  {
    /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
    USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_HDSEL);
 8005672:	f023 0308 	bic.w	r3, r3, #8
 8005676:	6083      	str	r3, [r0, #8]
 8005678:	4770      	bx	lr

0800567a <USART_SetGuardTime>:
{    
  /* Check the parameters */
  assert_param(IS_USART_123_PERIPH(USARTx));

  /* Clear the USART Guard time */
  USARTx->GTPR &= USART_GTPR_PSC;
 800567a:	8a03      	ldrh	r3, [r0, #16]
 800567c:	b2db      	uxtb	r3, r3
 800567e:	8203      	strh	r3, [r0, #16]
  /* Set the USART guard time */
  USARTx->GTPR |= (uint16_t)((uint16_t)USART_GuardTime << 0x08);
 8005680:	8a03      	ldrh	r3, [r0, #16]
 8005682:	b29b      	uxth	r3, r3
 8005684:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
 8005688:	8201      	strh	r1, [r0, #16]
 800568a:	4770      	bx	lr

0800568c <USART_SmartCardCmd>:
  assert_param(IS_USART_123_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the SC mode by setting the SCEN bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_SCEN;
 800568c:	6883      	ldr	r3, [r0, #8]
void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_USART_123_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800568e:	b111      	cbz	r1, 8005696 <USART_SmartCardCmd+0xa>
  {
    /* Enable the SC mode by setting the SCEN bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_SCEN;
 8005690:	f043 0320 	orr.w	r3, r3, #32
 8005694:	e001      	b.n	800569a <USART_SmartCardCmd+0xe>
  }
  else
  {
    /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
    USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_SCEN);
 8005696:	f023 0320 	bic.w	r3, r3, #32
 800569a:	6083      	str	r3, [r0, #8]
 800569c:	4770      	bx	lr

0800569e <USART_SmartCardNACKCmd>:
  assert_param(IS_USART_123_PERIPH(USARTx)); 
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_NACK;
 800569e:	6883      	ldr	r3, [r0, #8]
void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_USART_123_PERIPH(USARTx)); 
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80056a0:	b111      	cbz	r1, 80056a8 <USART_SmartCardNACKCmd+0xa>
  {
    /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_NACK;
 80056a2:	f043 0310 	orr.w	r3, r3, #16
 80056a6:	e001      	b.n	80056ac <USART_SmartCardNACKCmd+0xe>
  }
  else
  {
    /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
    USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_NACK);
 80056a8:	f023 0310 	bic.w	r3, r3, #16
 80056ac:	6083      	str	r3, [r0, #8]
 80056ae:	4770      	bx	lr

080056b0 <USART_SetAutoRetryCount>:
{    
  /* Check the parameters */
  assert_param(IS_USART_123_PERIPH(USARTx));
  assert_param(IS_USART_AUTO_RETRY_COUNTER(USART_AutoCount));
  /* Clear the USART auto retry count */
  USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_SCARCNT);
 80056b0:	6883      	ldr	r3, [r0, #8]
 80056b2:	f423 2360 	bic.w	r3, r3, #917504	; 0xe0000
 80056b6:	6083      	str	r3, [r0, #8]
  /* Set the USART auto retry count*/
  USARTx->CR3 |= (uint32_t)((uint32_t)USART_AutoCount << 0x11);
 80056b8:	6883      	ldr	r3, [r0, #8]
 80056ba:	ea43 4141 	orr.w	r1, r3, r1, lsl #17
 80056be:	6081      	str	r1, [r0, #8]
 80056c0:	4770      	bx	lr

080056c2 <USART_SetBlockLength>:
{    
  /* Check the parameters */
  assert_param(IS_USART_123_PERIPH(USARTx));

  /* Clear the Smart card block length */
  USARTx->RTOR &= (uint32_t)~((uint32_t)USART_RTOR_BLEN);
 80056c2:	6943      	ldr	r3, [r0, #20]
 80056c4:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 80056c8:	6143      	str	r3, [r0, #20]
  /* Set the Smart Card block length */
  USARTx->RTOR |= (uint32_t)((uint32_t)USART_BlockLength << 0x18);
 80056ca:	6943      	ldr	r3, [r0, #20]
 80056cc:	ea43 6101 	orr.w	r1, r3, r1, lsl #24
 80056d0:	6141      	str	r1, [r0, #20]
 80056d2:	4770      	bx	lr

080056d4 <USART_IrDAConfig>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));

  USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_IRLP);
 80056d4:	6883      	ldr	r3, [r0, #8]
 80056d6:	f023 0304 	bic.w	r3, r3, #4
 80056da:	6083      	str	r3, [r0, #8]
  USARTx->CR3 |= USART_IrDAMode;
 80056dc:	6883      	ldr	r3, [r0, #8]
 80056de:	4319      	orrs	r1, r3
 80056e0:	6081      	str	r1, [r0, #8]
 80056e2:	4770      	bx	lr

080056e4 <USART_IrDACmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_IREN;
 80056e4:	6883      	ldr	r3, [r0, #8]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80056e6:	b111      	cbz	r1, 80056ee <USART_IrDACmd+0xa>
  {
    /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_IREN;
 80056e8:	f043 0302 	orr.w	r3, r3, #2
 80056ec:	e001      	b.n	80056f2 <USART_IrDACmd+0xe>
  }
  else
  {
    /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
    USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_IREN);
 80056ee:	f023 0302 	bic.w	r3, r3, #2
 80056f2:	6083      	str	r3, [r0, #8]
 80056f4:	4770      	bx	lr

080056f6 <USART_DECmd>:
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the DE functionality by setting the DEM bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_DEM;
 80056f6:	6883      	ldr	r3, [r0, #8]
void USART_DECmd(USART_TypeDef* USARTx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80056f8:	b111      	cbz	r1, 8005700 <USART_DECmd+0xa>
  {
    /* Enable the DE functionality by setting the DEM bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_DEM;
 80056fa:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80056fe:	e001      	b.n	8005704 <USART_DECmd+0xe>
  }
  else
  {
    /* Disable the DE functionality by clearing the DEM bit in the CR3 register */
    USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_DEM);
 8005700:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8005704:	6083      	str	r3, [r0, #8]
 8005706:	4770      	bx	lr

08005708 <USART_DEPolarityConfig>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_DE_POLARITY(USART_DEPolarity));

  USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_DEP);
 8005708:	6883      	ldr	r3, [r0, #8]
 800570a:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 800570e:	6083      	str	r3, [r0, #8]
  USARTx->CR3 |= USART_DEPolarity;
 8005710:	6883      	ldr	r3, [r0, #8]
 8005712:	4319      	orrs	r1, r3
 8005714:	6081      	str	r1, [r0, #8]
 8005716:	4770      	bx	lr

08005718 <USART_SetDEAssertionTime>:
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_DE_ASSERTION_DEASSERTION_TIME(USART_DEAssertionTime)); 

  /* Clear the DE assertion time */
  USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_DEAT);
 8005718:	6803      	ldr	r3, [r0, #0]
 800571a:	f023 7378 	bic.w	r3, r3, #65011712	; 0x3e00000
 800571e:	6003      	str	r3, [r0, #0]
  /* Set the new value for the DE assertion time */
  USARTx->CR1 |=((uint32_t)USART_DEAssertionTime << (uint32_t)0x15);
 8005720:	6803      	ldr	r3, [r0, #0]
 8005722:	ea43 5141 	orr.w	r1, r3, r1, lsl #21
 8005726:	6001      	str	r1, [r0, #0]
 8005728:	4770      	bx	lr

0800572a <USART_SetDEDeassertionTime>:
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_DE_ASSERTION_DEASSERTION_TIME(USART_DEDeassertionTime)); 

  /* Clear the DE deassertion time */
  USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_DEDT);
 800572a:	6803      	ldr	r3, [r0, #0]
 800572c:	f423 13f8 	bic.w	r3, r3, #2031616	; 0x1f0000
 8005730:	6003      	str	r3, [r0, #0]
  /* Set the new value for the DE deassertion time */
  USARTx->CR1 |=((uint32_t)USART_DEDeassertionTime << (uint32_t)0x10);
 8005732:	6803      	ldr	r3, [r0, #0]
 8005734:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 8005738:	6001      	str	r1, [r0, #0]
 800573a:	4770      	bx	lr

0800573c <USART_DMACmd>:

  if (NewState != DISABLE)
  {
    /* Enable the DMA transfer for selected requests by setting the DMAT and/or
       DMAR bits in the USART CR3 register */
    USARTx->CR3 |= USART_DMAReq;
 800573c:	6883      	ldr	r3, [r0, #8]
  /* Check the parameters */
  assert_param(IS_USART_1234_PERIPH(USARTx));
  assert_param(IS_USART_DMAREQ(USART_DMAReq));  
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 

  if (NewState != DISABLE)
 800573e:	b10a      	cbz	r2, 8005744 <USART_DMACmd+0x8>
  {
    /* Enable the DMA transfer for selected requests by setting the DMAT and/or
       DMAR bits in the USART CR3 register */
    USARTx->CR3 |= USART_DMAReq;
 8005740:	4319      	orrs	r1, r3
 8005742:	e001      	b.n	8005748 <USART_DMACmd+0xc>
  }
  else
  {
    /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
       DMAR bits in the USART CR3 register */
    USARTx->CR3 &= (uint32_t)~USART_DMAReq;
 8005744:	ea23 0101 	bic.w	r1, r3, r1
 8005748:	6081      	str	r1, [r0, #8]
 800574a:	4770      	bx	lr

0800574c <USART_DMAReceptionErrorConfig>:
  /* Check the parameters */
  assert_param(IS_USART_1234_PERIPH(USARTx));
  assert_param(IS_USART_DMAONERROR(USART_DMAOnError)); 
  
  /* Clear the DMA Reception error detection bit */
  USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_DDRE);
 800574c:	6883      	ldr	r3, [r0, #8]
 800574e:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8005752:	6083      	str	r3, [r0, #8]
  /* Set the new value for the DMA Reception error detection bit */
  USARTx->CR3 |= USART_DMAOnError;
 8005754:	6883      	ldr	r3, [r0, #8]
 8005756:	4319      	orrs	r1, r3
 8005758:	6081      	str	r1, [r0, #8]
 800575a:	4770      	bx	lr

0800575c <USART_ITConfig>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  usartxbase = (uint32_t)USARTx;

  /* Get the USART register index */
  usartreg = (((uint16_t)USART_IT) >> 0x08);
 800575c:	f3c1 2307 	ubfx	r3, r1, #8, #8
  * @param  NewState: new state of the specified USARTx interrupts.
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void USART_ITConfig(USART_TypeDef* USARTx, uint32_t USART_IT, FunctionalState NewState)
{
 8005760:	b510      	push	{r4, lr}

  /* Get the USART register index */
  usartreg = (((uint16_t)USART_IT) >> 0x08);

  /* Get the interrupt position */
  itpos = USART_IT & IT_MASK;
 8005762:	b2c9      	uxtb	r1, r1
  itmask = (((uint32_t)0x01) << itpos);
 8005764:	2401      	movs	r4, #1

  if (usartreg == 0x02) /* The IT is in CR2 register */
 8005766:	2b02      	cmp	r3, #2
  /* Get the USART register index */
  usartreg = (((uint16_t)USART_IT) >> 0x08);

  /* Get the interrupt position */
  itpos = USART_IT & IT_MASK;
  itmask = (((uint32_t)0x01) << itpos);
 8005768:	fa04 f101 	lsl.w	r1, r4, r1

  if (usartreg == 0x02) /* The IT is in CR2 register */
 800576c:	d101      	bne.n	8005772 <USART_ITConfig+0x16>
  {
    usartxbase += 0x04;
 800576e:	3004      	adds	r0, #4
 8005770:	e002      	b.n	8005778 <USART_ITConfig+0x1c>
  }
  else if (usartreg == 0x03) /* The IT is in CR3 register */
 8005772:	2b03      	cmp	r3, #3
  {
    usartxbase += 0x08;
 8005774:	bf08      	it	eq
 8005776:	3008      	addeq	r0, #8
  else /* The IT is in CR1 register */
  {
  }
  if (NewState != DISABLE)
  {
    *(__IO uint32_t*)usartxbase  |= itmask;
 8005778:	6803      	ldr	r3, [r0, #0]
    usartxbase += 0x08;
  }
  else /* The IT is in CR1 register */
  {
  }
  if (NewState != DISABLE)
 800577a:	b10a      	cbz	r2, 8005780 <USART_ITConfig+0x24>
  {
    *(__IO uint32_t*)usartxbase  |= itmask;
 800577c:	4319      	orrs	r1, r3
 800577e:	e001      	b.n	8005784 <USART_ITConfig+0x28>
  }
  else
  {
    *(__IO uint32_t*)usartxbase &= ~itmask;
 8005780:	ea23 0101 	bic.w	r1, r3, r1
 8005784:	6001      	str	r1, [r0, #0]
 8005786:	bd10      	pop	{r4, pc}

08005788 <USART_RequestCmd>:

  if (NewState != DISABLE)
  {
    /* Enable the USART ReQuest by setting the dedicated request bit in the RQR
       register.*/
    USARTx->RQR |= USART_Request;
 8005788:	8b03      	ldrh	r3, [r0, #24]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_REQUEST(USART_Request));
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 

  if (NewState != DISABLE)
 800578a:	b112      	cbz	r2, 8005792 <USART_RequestCmd+0xa>
  {
    /* Enable the USART ReQuest by setting the dedicated request bit in the RQR
       register.*/
    USARTx->RQR |= USART_Request;
 800578c:	4319      	orrs	r1, r3
 800578e:	b289      	uxth	r1, r1
 8005790:	e002      	b.n	8005798 <USART_RequestCmd+0x10>
  }
  else
  {
    /* Disable the USART ReQuest by clearing the dedicated request bit in the RQR
       register.*/
    USARTx->RQR &= (uint32_t)~USART_Request;
 8005792:	b29b      	uxth	r3, r3
 8005794:	ea23 0101 	bic.w	r1, r3, r1
 8005798:	8301      	strh	r1, [r0, #24]
 800579a:	4770      	bx	lr

0800579c <USART_OverrunDetectionConfig>:
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_OVRDETECTION(USART_OVRDetection));
  
  /* Clear the OVR detection bit */
  USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_OVRDIS);
 800579c:	6883      	ldr	r3, [r0, #8]
 800579e:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 80057a2:	6083      	str	r3, [r0, #8]
  /* Set the new value for the OVR detection bit */
  USARTx->CR3 |= USART_OVRDetection;
 80057a4:	6883      	ldr	r3, [r0, #8]
 80057a6:	4319      	orrs	r1, r3
 80057a8:	6081      	str	r1, [r0, #8]
 80057aa:	4770      	bx	lr

080057ac <USART_GetFlagStatus>:
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_FLAG(USART_FLAG));
  
  if ((USARTx->ISR & USART_FLAG) != (uint16_t)RESET)
 80057ac:	69c3      	ldr	r3, [r0, #28]
 80057ae:	4219      	tst	r1, r3
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 80057b0:	bf0c      	ite	eq
 80057b2:	2000      	moveq	r0, #0
 80057b4:	2001      	movne	r0, #1
 80057b6:	4770      	bx	lr

080057b8 <USART_ClearFlag>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
     
  USARTx->ICR = USART_FLAG;
 80057b8:	6201      	str	r1, [r0, #32]
 80057ba:	4770      	bx	lr

080057bc <USART_GetITStatus>:
  *         @arg USART_IT_FE:  Framing Error interrupt.
  *         @arg USART_IT_PE:  Parity Error interrupt.
  * @retval The new state of USART_IT (SET or RESET).
  */
ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint32_t USART_IT)
{
 80057bc:	b510      	push	{r4, lr}
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_GET_IT(USART_IT)); 
  
  /* Get the USART register index */
  usartreg = (((uint16_t)USART_IT) >> 0x08);
 80057be:	f3c1 2207 	ubfx	r2, r1, #8, #8
  /* Get the interrupt position */
  itmask = USART_IT & IT_MASK;
  itmask = (uint32_t)0x01 << itmask;
 80057c2:	2401      	movs	r4, #1
  assert_param(IS_USART_GET_IT(USART_IT)); 
  
  /* Get the USART register index */
  usartreg = (((uint16_t)USART_IT) >> 0x08);
  /* Get the interrupt position */
  itmask = USART_IT & IT_MASK;
 80057c4:	b2cb      	uxtb	r3, r1
  itmask = (uint32_t)0x01 << itmask;
  
  if (usartreg == 0x01) /* The IT  is in CR1 register */
 80057c6:	42a2      	cmp	r2, r4
  
  /* Get the USART register index */
  usartreg = (((uint16_t)USART_IT) >> 0x08);
  /* Get the interrupt position */
  itmask = USART_IT & IT_MASK;
  itmask = (uint32_t)0x01 << itmask;
 80057c8:	fa04 f303 	lsl.w	r3, r4, r3
  
  if (usartreg == 0x01) /* The IT  is in CR1 register */
 80057cc:	d101      	bne.n	80057d2 <USART_GetITStatus+0x16>
  {
    itmask &= USARTx->CR1;
 80057ce:	6802      	ldr	r2, [r0, #0]
 80057d0:	e003      	b.n	80057da <USART_GetITStatus+0x1e>
  }
  else if (usartreg == 0x02) /* The IT  is in CR2 register */
 80057d2:	2a02      	cmp	r2, #2
  {
    itmask &= USARTx->CR2;
 80057d4:	bf0c      	ite	eq
 80057d6:	6842      	ldreq	r2, [r0, #4]
  }
  else /* The IT  is in CR3 register */
  {
    itmask &= USARTx->CR3;
 80057d8:	6882      	ldrne	r2, [r0, #8]
 80057da:	4013      	ands	r3, r2
  }
  
  bitpos = USART_IT >> 0x10;
  bitpos = (uint32_t)0x01 << bitpos;
  bitpos &= USARTx->ISR;
 80057dc:	69c2      	ldr	r2, [r0, #28]
  if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
 80057de:	b143      	cbz	r3, 80057f2 <USART_GetITStatus+0x36>
  {
    itmask &= USARTx->CR3;
  }
  
  bitpos = USART_IT >> 0x10;
  bitpos = (uint32_t)0x01 << bitpos;
 80057e0:	2301      	movs	r3, #1
  else /* The IT  is in CR3 register */
  {
    itmask &= USARTx->CR3;
  }
  
  bitpos = USART_IT >> 0x10;
 80057e2:	0c09      	lsrs	r1, r1, #16
  bitpos = (uint32_t)0x01 << bitpos;
 80057e4:	fa03 f101 	lsl.w	r1, r3, r1
  bitpos &= USARTx->ISR;
  if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
 80057e8:	4211      	tst	r1, r2
  {
    bitstatus = SET;
 80057ea:	bf0c      	ite	eq
 80057ec:	2000      	moveq	r0, #0
 80057ee:	2001      	movne	r0, #1
 80057f0:	bd10      	pop	{r4, pc}
  }
  else
  {
    bitstatus = RESET;
 80057f2:	4618      	mov	r0, r3
  }
  
  return bitstatus;  
}
 80057f4:	bd10      	pop	{r4, pc}

080057f6 <USART_ClearITPendingBit>:
  uint32_t bitpos = 0, itmask = 0;
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_CLEAR_IT(USART_IT)); 
  
  bitpos = USART_IT >> 0x10;
 80057f6:	0c09      	lsrs	r1, r1, #16
  itmask = ((uint32_t)0x01 << (uint32_t)bitpos);
 80057f8:	2301      	movs	r3, #1
 80057fa:	fa03 f101 	lsl.w	r1, r3, r1
  USARTx->ICR = (uint32_t)itmask;
 80057fe:	6201      	str	r1, [r0, #32]
 8005800:	4770      	bx	lr
 8005802:	bf00      	nop

08005804 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 8005804:	b538      	push	{r3, r4, r5, lr}
void *pvReturn = NULL;
static unsigned char *pucAlignedHeap = NULL;

	/* Ensure that blocks are always aligned to the required number of bytes. */
	#if portBYTE_ALIGNMENT != 1
		if( xWantedSize & portBYTE_ALIGNMENT_MASK )
 8005806:	0743      	lsls	r3, r0, #29
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 8005808:	4605      	mov	r5, r0
	/* Ensure that blocks are always aligned to the required number of bytes. */
	#if portBYTE_ALIGNMENT != 1
		if( xWantedSize & portBYTE_ALIGNMENT_MASK )
		{
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 800580a:	bf1c      	itt	ne
 800580c:	f020 0507 	bicne.w	r5, r0, #7
 8005810:	3508      	addne	r5, #8
		}
	#endif

	vTaskSuspendAll();
 8005812:	f001 f897 	bl	8006944 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
 8005816:	4a0f      	ldr	r2, [pc, #60]	; (8005854 <pvPortMalloc+0x50>)
 8005818:	6813      	ldr	r3, [r2, #0]
 800581a:	b923      	cbnz	r3, 8005826 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( unsigned char * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
 800581c:	f102 030c 	add.w	r3, r2, #12
 8005820:	f023 0307 	bic.w	r3, r3, #7
 8005824:	6013      	str	r3, [r2, #0]
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
 8005826:	490c      	ldr	r1, [pc, #48]	; (8005858 <pvPortMalloc+0x54>)
 8005828:	f8d1 3614 	ldr.w	r3, [r1, #1556]	; 0x614
 800582c:	f242 70f7 	movw	r0, #10231	; 0x27f7
 8005830:	441d      	add	r5, r3
 8005832:	4285      	cmp	r5, r0
 8005834:	d806      	bhi.n	8005844 <pvPortMalloc+0x40>
 8005836:	429d      	cmp	r5, r3
 8005838:	d904      	bls.n	8005844 <pvPortMalloc+0x40>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
 800583a:	6814      	ldr	r4, [r2, #0]
			xNextFreeByte += xWantedSize;
 800583c:	f8c1 5614 	str.w	r5, [r1, #1556]	; 0x614
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
 8005840:	441c      	add	r4, r3
 8005842:	e000      	b.n	8005846 <pvPortMalloc+0x42>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
 8005844:	2400      	movs	r4, #0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}	
	xTaskResumeAll();
 8005846:	f001 f925 	bl	8006a94 <xTaskResumeAll>

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
 800584a:	b90c      	cbnz	r4, 8005850 <pvPortMalloc+0x4c>
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
 800584c:	f7fc fbc0 	bl	8001fd0 <vApplicationMallocFailedHook>
		}
	}
	#endif

	return pvReturn;
}
 8005850:	4620      	mov	r0, r4
 8005852:	bd38      	pop	{r3, r4, r5, pc}
 8005854:	20000534 	.word	0x20000534
 8005858:	20002724 	.word	0x20002724

0800585c <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 800585c:	b508      	push	{r3, lr}
	heap_4.c for alternative implementations, and the memory management pages of
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
 800585e:	b110      	cbz	r0, 8005866 <vPortFree+0xa>
 8005860:	f000 f84e 	bl	8005900 <ulPortSetInterruptMask>
 8005864:	e7fe      	b.n	8005864 <vPortFree+0x8>
 8005866:	bd08      	pop	{r3, pc}

08005868 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
 8005868:	4b02      	ldr	r3, [pc, #8]	; (8005874 <vPortInitialiseBlocks+0xc>)
 800586a:	2200      	movs	r2, #0
 800586c:	f8c3 2614 	str.w	r2, [r3, #1556]	; 0x614
 8005870:	4770      	bx	lr
 8005872:	bf00      	nop
 8005874:	20002724 	.word	0x20002724

08005878 <xPortGetFreeHeapSize>:
}
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
 8005878:	4b03      	ldr	r3, [pc, #12]	; (8005888 <xPortGetFreeHeapSize+0x10>)
 800587a:	f8d3 0614 	ldr.w	r0, [r3, #1556]	; 0x614
}
 800587e:	f5c0 501f 	rsb	r0, r0, #10176	; 0x27c0
 8005882:	3038      	adds	r0, #56	; 0x38
 8005884:	4770      	bx	lr
 8005886:	bf00      	nop
 8005888:	20002724 	.word	0x20002724

0800588c <prvPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

static void prvPortStartFirstTask( void )
{
	__asm volatile(
 800588c:	488f      	ldr	r0, [pc, #572]	; (8005acc <vPortValidateInterruptPriority+0x40>)
 800588e:	6800      	ldr	r0, [r0, #0]
 8005890:	6800      	ldr	r0, [r0, #0]
 8005892:	f380 8808 	msr	MSP, r0
 8005896:	b662      	cpsie	i
 8005898:	df00      	svc	0
 800589a:	bf00      	nop

0800589c <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
 800589c:	f8df 0230 	ldr.w	r0, [pc, #560]	; 8005ad0 <vPortValidateInterruptPriority+0x44>
 80058a0:	6801      	ldr	r1, [r0, #0]
 80058a2:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80058a6:	6001      	str	r1, [r0, #0]
 80058a8:	4770      	bx	lr

080058aa <pxPortInitialiseStack>:

	/* Offset added to account for the way the MCU uses the stack on entry/exit
	of interrupts, and to ensure alignment. */
	pxTopOfStack--;

	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 80058aa:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) pxCode;	/* PC */
 80058ae:	e900 000a 	stmdb	r0, {r1, r3}
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) portTASK_RETURN_ADDRESS;	/* LR */
 80058b2:	4b05      	ldr	r3, [pc, #20]	; (80058c8 <pxPortInitialiseStack+0x1e>)
 80058b4:	f840 3c0c 	str.w	r3, [r0, #-12]
	*pxTopOfStack = ( portSTACK_TYPE ) pvParameters;	/* R0 */

	/* A save method is being used that requires each task to maintain its
	own exec return value. */
	pxTopOfStack--;
	*pxTopOfStack = portINITIAL_EXEC_RETURN;
 80058b8:	f06f 0302 	mvn.w	r3, #2
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) portTASK_RETURN_ADDRESS;	/* LR */

	/* Save code space by skipping register initialisation. */
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
	*pxTopOfStack = ( portSTACK_TYPE ) pvParameters;	/* R0 */
 80058bc:	f840 2c20 	str.w	r2, [r0, #-32]

	/* A save method is being used that requires each task to maintain its
	own exec return value. */
	pxTopOfStack--;
	*pxTopOfStack = portINITIAL_EXEC_RETURN;
 80058c0:	f840 3c24 	str.w	r3, [r0, #-36]

	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */

	return pxTopOfStack;
}
 80058c4:	3844      	subs	r0, #68	; 0x44
 80058c6:	4770      	bx	lr
 80058c8:	08005911 	.word	0x08005911

080058cc <SVC_Handler>:
}
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
 80058cc:	4b05      	ldr	r3, [pc, #20]	; (80058e4 <pxCurrentTCBConst2>)
 80058ce:	6819      	ldr	r1, [r3, #0]
 80058d0:	6808      	ldr	r0, [r1, #0]
 80058d2:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80058d6:	f380 8809 	msr	PSP, r0
 80058da:	f04f 0000 	mov.w	r0, #0
 80058de:	f380 8811 	msr	BASEPRI, r0
 80058e2:	4770      	bx	lr

080058e4 <pxCurrentTCBConst2>:
 80058e4:	20002dc4 	.word	0x20002dc4

080058e8 <vPortEndScheduler>:
	return 0;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
 80058e8:	4770      	bx	lr

080058ea <vPortYield>:
/*-----------------------------------------------------------*/

void vPortYield( void )
{
	/* Set a PendSV to request a context switch. */
	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 80058ea:	4b04      	ldr	r3, [pc, #16]	; (80058fc <vPortYield+0x12>)
 80058ec:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80058f0:	601a      	str	r2, [r3, #0]

	/* Barriers are normally not required but do ensure the code is completely
	within the specified behaviour for the architecture. */
	__asm volatile( "dsb" );
 80058f2:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
 80058f6:	f3bf 8f6f 	isb	sy
 80058fa:	4770      	bx	lr
 80058fc:	e000ed04 	.word	0xe000ed04

08005900 <ulPortSetInterruptMask>:
}
/*-----------------------------------------------------------*/

__attribute__(( naked )) unsigned long ulPortSetInterruptMask( void )
{
	__asm volatile														\
 8005900:	f3ef 8011 	mrs	r0, BASEPRI
 8005904:	f04f 0150 	mov.w	r1, #80	; 0x50
 8005908:	f381 8811 	msr	BASEPRI, r1
 800590c:	4770      	bx	lr
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return 0;
}
 800590e:	2000      	movs	r0, #0

08005910 <prvTaskExitError>:
	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
 8005910:	b508      	push	{r3, lr}
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
 8005912:	4b05      	ldr	r3, [pc, #20]	; (8005928 <prvTaskExitError+0x18>)
 8005914:	681b      	ldr	r3, [r3, #0]
 8005916:	3301      	adds	r3, #1
 8005918:	d002      	beq.n	8005920 <prvTaskExitError+0x10>
 800591a:	f7ff fff1 	bl	8005900 <ulPortSetInterruptMask>
 800591e:	e7fe      	b.n	800591e <prvTaskExitError+0xe>
	portDISABLE_INTERRUPTS();
 8005920:	f7ff ffee 	bl	8005900 <ulPortSetInterruptMask>
 8005924:	e7fe      	b.n	8005924 <prvTaskExitError+0x14>
 8005926:	bf00      	nop
 8005928:	2000002c 	.word	0x2000002c

0800592c <vPortEnterCritical>:
	__asm volatile( "isb" );
}
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
 800592c:	b508      	push	{r3, lr}
	portDISABLE_INTERRUPTS();
 800592e:	f7ff ffe7 	bl	8005900 <ulPortSetInterruptMask>
	uxCriticalNesting++;
 8005932:	4b04      	ldr	r3, [pc, #16]	; (8005944 <vPortEnterCritical+0x18>)
 8005934:	681a      	ldr	r2, [r3, #0]
 8005936:	3201      	adds	r2, #1
 8005938:	601a      	str	r2, [r3, #0]
	__asm volatile( "dsb" );
 800593a:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
 800593e:	f3bf 8f6f 	isb	sy
 8005942:	bd08      	pop	{r3, pc}
 8005944:	2000002c 	.word	0x2000002c

08005948 <vPortClearInterruptMask>:
}
/*-----------------------------------------------------------*/

__attribute__(( naked )) void vPortClearInterruptMask( unsigned long ulNewMaskValue )
{
	__asm volatile													\
 8005948:	f380 8811 	msr	BASEPRI, r0
 800594c:	4770      	bx	lr

0800594e <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
	uxCriticalNesting--;
 800594e:	4b04      	ldr	r3, [pc, #16]	; (8005960 <vPortExitCritical+0x12>)
 8005950:	6818      	ldr	r0, [r3, #0]
 8005952:	3801      	subs	r0, #1
 8005954:	6018      	str	r0, [r3, #0]
	if( uxCriticalNesting == 0 )
 8005956:	b908      	cbnz	r0, 800595c <vPortExitCritical+0xe>
	{
		portENABLE_INTERRUPTS();
 8005958:	f7ff bff6 	b.w	8005948 <vPortClearInterruptMask>
 800595c:	4770      	bx	lr
 800595e:	bf00      	nop
 8005960:	2000002c 	.word	0x2000002c

08005964 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
 8005964:	f3ef 8009 	mrs	r0, PSP
 8005968:	4b11      	ldr	r3, [pc, #68]	; (80059b0 <pxCurrentTCBConst>)
 800596a:	681a      	ldr	r2, [r3, #0]
 800596c:	f01e 0f10 	tst.w	lr, #16
 8005970:	bf08      	it	eq
 8005972:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
 8005976:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800597a:	6010      	str	r0, [r2, #0]
 800597c:	e92d 4008 	stmdb	sp!, {r3, lr}
 8005980:	f04f 0050 	mov.w	r0, #80	; 0x50
 8005984:	f380 8811 	msr	BASEPRI, r0
 8005988:	f001 f962 	bl	8006c50 <vTaskSwitchContext>
 800598c:	f04f 0000 	mov.w	r0, #0
 8005990:	f380 8811 	msr	BASEPRI, r0
 8005994:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8005998:	6819      	ldr	r1, [r3, #0]
 800599a:	6808      	ldr	r0, [r1, #0]
 800599c:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80059a0:	f01e 0f10 	tst.w	lr, #16
 80059a4:	bf08      	it	eq
 80059a6:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
 80059aa:	f380 8809 	msr	PSP, r0
 80059ae:	4770      	bx	lr

080059b0 <pxCurrentTCBConst>:
 80059b0:	20002dc4 	.word	0x20002dc4

080059b4 <SysTick_Handler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 80059b4:	b508      	push	{r3, lr}
	/* The SysTick runs at the lowest interrupt priority, so when this interrupt
	executes all interrupts must be unmasked.  There is therefore no need to
	save and then restore the interrupt mask value as its value is already
	known. */
	( void ) portSET_INTERRUPT_MASK_FROM_ISR();
 80059b6:	f7ff ffa3 	bl	8005900 <ulPortSetInterruptMask>
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
 80059ba:	f000 ffed 	bl	8006998 <xTaskIncrementTick>
 80059be:	b118      	cbz	r0, 80059c8 <SysTick_Handler+0x14>
		{
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 80059c0:	4b04      	ldr	r3, [pc, #16]	; (80059d4 <SysTick_Handler+0x20>)
 80059c2:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80059c6:	601a      	str	r2, [r3, #0]
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( 0 );
 80059c8:	2000      	movs	r0, #0
}
 80059ca:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( 0 );
 80059ce:	f7ff bfbb 	b.w	8005948 <vPortClearInterruptMask>
 80059d2:	bf00      	nop
 80059d4:	e000ed04 	.word	0xe000ed04

080059d8 <vPortSetupTimerInterrupt>:
		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
	}
	#endif /* configUSE_TICKLESS_IDLE */

	/* Configure SysTick to interrupt at the requested rate. */
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;;
 80059d8:	4b03      	ldr	r3, [pc, #12]	; (80059e8 <vPortSetupTimerInterrupt+0x10>)
 80059da:	4a04      	ldr	r2, [pc, #16]	; (80059ec <vPortSetupTimerInterrupt+0x14>)
 80059dc:	601a      	str	r2, [r3, #0]
	portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT;
 80059de:	2207      	movs	r2, #7
 80059e0:	f843 2c04 	str.w	r2, [r3, #-4]
 80059e4:	4770      	bx	lr
 80059e6:	bf00      	nop
 80059e8:	e000e014 	.word	0xe000e014
 80059ec:	0001193f 	.word	0x0001193f

080059f0 <xPortStartScheduler>:

/*
 * See header file for description.
 */
portBASE_TYPE xPortStartScheduler( void )
{
 80059f0:	b513      	push	{r0, r1, r4, lr}
		functions can be called.  ISR safe functions are those that end in
		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
		ensure interrupt entry is as fast and simple as possible.

		Save the interrupt priority value that is about to be clobbered. */
		ulOriginalPriority = *pcFirstUserPriorityRegister;
 80059f2:	4b22      	ldr	r3, [pc, #136]	; (8005a7c <xPortStartScheduler+0x8c>)
 80059f4:	781a      	ldrb	r2, [r3, #0]
 80059f6:	b2d2      	uxtb	r2, r2
 80059f8:	9201      	str	r2, [sp, #4]

		/* Determine the number of priority bits available.  First write to all
		possible bits. */
		*pcFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 80059fa:	22ff      	movs	r2, #255	; 0xff
 80059fc:	701a      	strb	r2, [r3, #0]

		/* Read the value back to see how many bits stuck. */
		ucMaxPriorityValue = *pcFirstUserPriorityRegister;
 80059fe:	781b      	ldrb	r3, [r3, #0]

		/* Use the same mask on the maximum system call priority. */
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 8005a00:	4a1f      	ldr	r2, [pc, #124]	; (8005a80 <xPortStartScheduler+0x90>)
		/* Determine the number of priority bits available.  First write to all
		possible bits. */
		*pcFirstUserPriorityRegister = portMAX_8_BIT_VALUE;

		/* Read the value back to see how many bits stuck. */
		ucMaxPriorityValue = *pcFirstUserPriorityRegister;
 8005a02:	b2db      	uxtb	r3, r3
 8005a04:	f88d 3003 	strb.w	r3, [sp, #3]

		/* Use the same mask on the maximum system call priority. */
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 8005a08:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8005a0c:	f003 0350 	and.w	r3, r3, #80	; 0x50
 8005a10:	7013      	strb	r3, [r2, #0]

		/* Calculate the maximum acceptable priority group value for the number
		of bits read back. */
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 8005a12:	2307      	movs	r3, #7
 8005a14:	6053      	str	r3, [r2, #4]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 8005a16:	f89d 1003 	ldrb.w	r1, [sp, #3]
 8005a1a:	0609      	lsls	r1, r1, #24
 8005a1c:	f103 30ff 	add.w	r0, r3, #4294967295
 8005a20:	d507      	bpl.n	8005a32 <xPortStartScheduler+0x42>
		{
			ulMaxPRIGROUPValue--;
			ucMaxPriorityValue <<= ( unsigned char ) 0x01;
 8005a22:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8005a26:	005b      	lsls	r3, r3, #1
 8005a28:	b2db      	uxtb	r3, r3
 8005a2a:	f88d 3003 	strb.w	r3, [sp, #3]
 8005a2e:	4603      	mov	r3, r0
 8005a30:	e7f1      	b.n	8005a16 <xPortStartScheduler+0x26>
		}

		/* Shift the priority group value back to its position within the AIRCR
		register. */
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
 8005a32:	021b      	lsls	r3, r3, #8
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 8005a34:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8005a38:	6053      	str	r3, [r2, #4]

		/* Restore the clobbered interrupt priority register to its original
		value. */
		*pcFirstUserPriorityRegister = ulOriginalPriority;
 8005a3a:	9a01      	ldr	r2, [sp, #4]
 8005a3c:	4b0f      	ldr	r3, [pc, #60]	; (8005a7c <xPortStartScheduler+0x8c>)
 8005a3e:	b2d2      	uxtb	r2, r2
 8005a40:	701a      	strb	r2, [r3, #0]
	}
	#endif /* conifgASSERT_DEFINED */

	/* Make PendSV and SysTick the lowest priority interrupts. */
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 8005a42:	f8d3 2920 	ldr.w	r2, [r3, #2336]	; 0x920
 8005a46:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 8005a4a:	f8c3 2920 	str.w	r2, [r3, #2336]	; 0x920
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 8005a4e:	f8d3 2920 	ldr.w	r2, [r3, #2336]	; 0x920
 8005a52:	f042 4270 	orr.w	r2, r2, #4026531840	; 0xf0000000
 8005a56:	f8c3 2920 	str.w	r2, [r3, #2336]	; 0x920

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	vPortSetupTimerInterrupt();
 8005a5a:	f7ff ffbd 	bl	80059d8 <vPortSetupTimerInterrupt>

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
 8005a5e:	4b09      	ldr	r3, [pc, #36]	; (8005a84 <xPortStartScheduler+0x94>)
 8005a60:	2400      	movs	r4, #0
 8005a62:	601c      	str	r4, [r3, #0]

	/* Ensure the VFP is enabled - it should be anyway. */
	vPortEnableVFP();
 8005a64:	f7ff ff1a 	bl	800589c <vPortEnableVFP>

	/* Lazy save always. */
	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
 8005a68:	4b07      	ldr	r3, [pc, #28]	; (8005a88 <xPortStartScheduler+0x98>)
 8005a6a:	681a      	ldr	r2, [r3, #0]
 8005a6c:	f042 4240 	orr.w	r2, r2, #3221225472	; 0xc0000000
 8005a70:	601a      	str	r2, [r3, #0]

	/* Start the first task. */
	prvPortStartFirstTask();
 8005a72:	f7ff ff0b 	bl	800588c <prvPortStartFirstTask>

	/* Should not get here! */
	return 0;
}
 8005a76:	4620      	mov	r0, r4
 8005a78:	b002      	add	sp, #8
 8005a7a:	bd10      	pop	{r4, pc}
 8005a7c:	e000e400 	.word	0xe000e400
 8005a80:	20002d3c 	.word	0x20002d3c
 8005a84:	2000002c 	.word	0x2000002c
 8005a88:	e000ef34 	.word	0xe000ef34

08005a8c <vPortValidateInterruptPriority>:
/*-----------------------------------------------------------*/

#if( configASSERT_DEFINED == 1 )

	void vPortValidateInterruptPriority( void )
	{
 8005a8c:	b508      	push	{r3, lr}
	unsigned long ulCurrentInterrupt;
	unsigned char ucCurrentPriority;

		/* Obtain the number of the currently executing interrupt. */
		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) );
 8005a8e:	f3ef 8205 	mrs	r2, IPSR

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
 8005a92:	2a0f      	cmp	r2, #15
 8005a94:	4b0a      	ldr	r3, [pc, #40]	; (8005ac0 <vPortValidateInterruptPriority+0x34>)
 8005a96:	d907      	bls.n	8005aa8 <vPortValidateInterruptPriority+0x1c>
		{
			/* Look up the interrupt's priority. */
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
 8005a98:	490a      	ldr	r1, [pc, #40]	; (8005ac4 <vPortValidateInterruptPriority+0x38>)
 8005a9a:	5c52      	ldrb	r2, [r2, r1]
			interrupt entry is as fast and simple as possible.

			The following links provide detailed information:
			http://www.freertos.org/RTOS-Cortex-M3-M4.html
			http://www.freertos.org/FAQHelp.html */
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
 8005a9c:	7819      	ldrb	r1, [r3, #0]
 8005a9e:	4291      	cmp	r1, r2
 8005aa0:	d902      	bls.n	8005aa8 <vPortValidateInterruptPriority+0x1c>
 8005aa2:	f7ff ff2d 	bl	8005900 <ulPortSetInterruptMask>
 8005aa6:	e7fe      	b.n	8005aa6 <vPortValidateInterruptPriority+0x1a>
		configuration then the correct setting can be achieved on all Cortex-M
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredicable behaviour. */
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
 8005aa8:	4a07      	ldr	r2, [pc, #28]	; (8005ac8 <vPortValidateInterruptPriority+0x3c>)
 8005aaa:	685b      	ldr	r3, [r3, #4]
 8005aac:	6812      	ldr	r2, [r2, #0]
 8005aae:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 8005ab2:	429a      	cmp	r2, r3
 8005ab4:	d902      	bls.n	8005abc <vPortValidateInterruptPriority+0x30>
 8005ab6:	f7ff ff23 	bl	8005900 <ulPortSetInterruptMask>
 8005aba:	e7fe      	b.n	8005aba <vPortValidateInterruptPriority+0x2e>
 8005abc:	bd08      	pop	{r3, pc}
 8005abe:	bf00      	nop
 8005ac0:	20002d3c 	.word	0x20002d3c
 8005ac4:	e000e3f0 	.word	0xe000e3f0
 8005ac8:	e000ed0c 	.word	0xe000ed0c
 8005acc:	e000ed08 	.word	0xe000ed08
 8005ad0:	e000ed88 	.word	0xe000ed88

08005ad4 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
 8005ad4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005ad8:	4682      	mov	sl, r0
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
 8005ada:	2038      	movs	r0, #56	; 0x38
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
 8005adc:	4688      	mov	r8, r1
 8005ade:	4693      	mov	fp, r2
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
 8005ae0:	f7ff fe90 	bl	8005804 <pvPortMalloc>
	if( pxCoRoutine )
 8005ae4:	4604      	mov	r4, r0
 8005ae6:	2800      	cmp	r0, #0
 8005ae8:	d047      	beq.n	8005b7a <xCoRoutineCreate+0xa6>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
 8005aea:	4d26      	ldr	r5, [pc, #152]	; (8005b84 <xCoRoutineCreate+0xb0>)
 8005aec:	682b      	ldr	r3, [r5, #0]
 8005aee:	1d2f      	adds	r7, r5, #4
 8005af0:	b9c3      	cbnz	r3, 8005b24 <xCoRoutineCreate+0x50>
		{
			pxCurrentCoRoutine = pxCoRoutine;
 8005af2:	6028      	str	r0, [r5, #0]
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
 8005af4:	4638      	mov	r0, r7
 8005af6:	f000 f903 	bl	8005d00 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
 8005afa:	f105 092c 	add.w	r9, r5, #44	; 0x2c
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
 8005afe:	f105 0018 	add.w	r0, r5, #24
 8005b02:	f000 f8fd 	bl	8005d00 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
 8005b06:	f105 0640 	add.w	r6, r5, #64	; 0x40
	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
 8005b0a:	4648      	mov	r0, r9
 8005b0c:	f000 f8f8 	bl	8005d00 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
 8005b10:	4630      	mov	r0, r6
 8005b12:	f000 f8f5 	bl	8005d00 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
 8005b16:	f105 0054 	add.w	r0, r5, #84	; 0x54
 8005b1a:	f000 f8f1 	bl	8005d00 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
 8005b1e:	f8c5 9068 	str.w	r9, [r5, #104]	; 0x68
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
 8005b22:	66ee      	str	r6, [r5, #108]	; 0x6c

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
		pxCoRoutine->uxPriority = uxPriority;
		pxCoRoutine->uxIndex = uxIndex;
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
 8005b24:	4626      	mov	r6, r4
 8005b26:	f1b8 0f01 	cmp.w	r8, #1
 8005b2a:	bf28      	it	cs
 8005b2c:	f04f 0801 	movcs.w	r8, #1
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
 8005b30:	2300      	movs	r3, #0
 8005b32:	86a3      	strh	r3, [r4, #52]	; 0x34
		pxCoRoutine->uxPriority = uxPriority;
 8005b34:	f8c4 802c 	str.w	r8, [r4, #44]	; 0x2c
		pxCoRoutine->uxIndex = uxIndex;
 8005b38:	f8c4 b030 	str.w	fp, [r4, #48]	; 0x30
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
 8005b3c:	f846 ab04 	str.w	sl, [r6], #4

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
 8005b40:	4630      	mov	r0, r6
 8005b42:	f000 f8e8 	bl	8005d16 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
 8005b46:	f104 0018 	add.w	r0, r4, #24
 8005b4a:	f000 f8e4 	bl	8005d16 <vListInitialiseItem>
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
 8005b4e:	f1c8 0305 	rsb	r3, r8, #5

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
 8005b52:	6f2a      	ldr	r2, [r5, #112]	; 0x70
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
 8005b54:	61a3      	str	r3, [r4, #24]

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
 8005b56:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
 8005b58:	6124      	str	r4, [r4, #16]
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
 8005b5a:	4293      	cmp	r3, r2
 8005b5c:	bf88      	it	hi
 8005b5e:	4a09      	ldrhi	r2, [pc, #36]	; (8005b84 <xCoRoutineCreate+0xb0>)

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
 8005b60:	6264      	str	r4, [r4, #36]	; 0x24
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
 8005b62:	f04f 0014 	mov.w	r0, #20
 8005b66:	fb00 7003 	mla	r0, r0, r3, r7
 8005b6a:	4631      	mov	r1, r6
 8005b6c:	bf88      	it	hi
 8005b6e:	6713      	strhi	r3, [r2, #112]	; 0x70
 8005b70:	f000 f8d4 	bl	8005d1c <vListInsertEnd>

		xReturn = pdPASS;
 8005b74:	2001      	movs	r0, #1
 8005b76:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 8005b7a:	f04f 30ff 	mov.w	r0, #4294967295
	}

	return xReturn;
}
 8005b7e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8005b82:	bf00      	nop
 8005b84:	20002d44 	.word	0x20002d44

08005b88 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
 8005b88:	b570      	push	{r4, r5, r6, lr}
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
 8005b8a:	4c0d      	ldr	r4, [pc, #52]	; (8005bc0 <vCoRoutineAddToDelayedList+0x38>)
 8005b8c:	6f66      	ldr	r6, [r4, #116]	; 0x74
 8005b8e:	4406      	add	r6, r0

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	( void ) uxListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
 8005b90:	6820      	ldr	r0, [r4, #0]
 8005b92:	3004      	adds	r0, #4
	return xReturn;
}
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
 8005b94:	460d      	mov	r5, r1
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	( void ) uxListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
 8005b96:	f000 f8e5 	bl	8005d64 <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xCoRoutineTickCount )
 8005b9a:	6f63      	ldr	r3, [r4, #116]	; 0x74
	ourselves to the blocked list as the same list item is used for
	both lists. */
	( void ) uxListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
 8005b9c:	6821      	ldr	r1, [r4, #0]

	if( xTimeToWake < xCoRoutineTickCount )
 8005b9e:	429e      	cmp	r6, r3
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
 8005ba0:	bf34      	ite	cc
 8005ba2:	6ee0      	ldrcc	r0, [r4, #108]	; 0x6c
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
 8005ba4:	6ea0      	ldrcs	r0, [r4, #104]	; 0x68
	ourselves to the blocked list as the same list item is used for
	both lists. */
	( void ) uxListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
 8005ba6:	f841 6f04 	str.w	r6, [r1, #4]!
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
 8005baa:	f000 f8c3 	bl	8005d34 <vListInsert>
	}

	if( pxEventList )
 8005bae:	b135      	cbz	r5, 8005bbe <vCoRoutineAddToDelayedList+0x36>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
 8005bb0:	6821      	ldr	r1, [r4, #0]
 8005bb2:	4628      	mov	r0, r5
 8005bb4:	3118      	adds	r1, #24
	}
}
 8005bb6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}

	if( pxEventList )
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
 8005bba:	f000 b8bb 	b.w	8005d34 <vListInsert>
 8005bbe:	bd70      	pop	{r4, r5, r6, pc}
 8005bc0:	20002d44 	.word	0x20002d44

08005bc4 <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
 8005bc4:	b570      	push	{r4, r5, r6, lr}
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
 8005bc6:	4d40      	ldr	r5, [pc, #256]	; (8005cc8 <vCoRoutineSchedule+0x104>)
 8005bc8:	6d6b      	ldr	r3, [r5, #84]	; 0x54
 8005bca:	462c      	mov	r4, r5
 8005bcc:	b1db      	cbz	r3, 8005c06 <vCoRoutineSchedule+0x42>
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
 8005bce:	f7ff fe97 	bl	8005900 <ulPortSetInterruptMask>
		{
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
 8005bd2:	6e2b      	ldr	r3, [r5, #96]	; 0x60
 8005bd4:	68dc      	ldr	r4, [r3, #12]
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
 8005bd6:	f104 0018 	add.w	r0, r4, #24
 8005bda:	f000 f8c3 	bl	8005d64 <uxListRemove>
		}
		portENABLE_INTERRUPTS();

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
 8005bde:	1d26      	adds	r6, r4, #4
		portDISABLE_INTERRUPTS();
		{
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();
 8005be0:	2000      	movs	r0, #0
 8005be2:	f7ff feb1 	bl	8005948 <vPortClearInterruptMask>

		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
 8005be6:	4630      	mov	r0, r6
 8005be8:	f000 f8bc 	bl	8005d64 <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
 8005bec:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8005bee:	6f2a      	ldr	r2, [r5, #112]	; 0x70
 8005bf0:	4293      	cmp	r3, r2
 8005bf2:	4a36      	ldr	r2, [pc, #216]	; (8005ccc <vCoRoutineSchedule+0x108>)
 8005bf4:	bf88      	it	hi
 8005bf6:	672b      	strhi	r3, [r5, #112]	; 0x70
 8005bf8:	2014      	movs	r0, #20
 8005bfa:	fb00 2003 	mla	r0, r0, r3, r2
 8005bfe:	4631      	mov	r1, r6
 8005c00:	f000 f88c 	bl	8005d1c <vListInsertEnd>
 8005c04:	e7df      	b.n	8005bc6 <vCoRoutineSchedule+0x2>

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
 8005c06:	f000 fea7 	bl	8006958 <xTaskGetTickCount>
 8005c0a:	6feb      	ldr	r3, [r5, #124]	; 0x7c
 8005c0c:	1ac0      	subs	r0, r0, r3
 8005c0e:	67a8      	str	r0, [r5, #120]	; 0x78
	while( xPassedTicks )
 8005c10:	6fa2      	ldr	r2, [r4, #120]	; 0x78
 8005c12:	4b2d      	ldr	r3, [pc, #180]	; (8005cc8 <vCoRoutineSchedule+0x104>)
 8005c14:	2a00      	cmp	r2, #0
 8005c16:	d032      	beq.n	8005c7e <vCoRoutineSchedule+0xba>
	{
		xCoRoutineTickCount++;
 8005c18:	6f59      	ldr	r1, [r3, #116]	; 0x74
		xPassedTicks--;
 8005c1a:	3a01      	subs	r2, #1
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
 8005c1c:	3101      	adds	r1, #1
 8005c1e:	6759      	str	r1, [r3, #116]	; 0x74
		xPassedTicks--;
 8005c20:	679a      	str	r2, [r3, #120]	; 0x78

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
 8005c22:	bb39      	cbnz	r1, 8005c74 <vCoRoutineSchedule+0xb0>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
 8005c24:	6e99      	ldr	r1, [r3, #104]	; 0x68
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
 8005c26:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 8005c28:	669a      	str	r2, [r3, #104]	; 0x68
			pxOverflowDelayedCoRoutineList = pxTemp;
 8005c2a:	66d9      	str	r1, [r3, #108]	; 0x6c
 8005c2c:	e022      	b.n	8005c74 <vCoRoutineSchedule+0xb0>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
 8005c2e:	68db      	ldr	r3, [r3, #12]
 8005c30:	68dd      	ldr	r5, [r3, #12]

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
 8005c32:	4b25      	ldr	r3, [pc, #148]	; (8005cc8 <vCoRoutineSchedule+0x104>)
 8005c34:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 8005c36:	686b      	ldr	r3, [r5, #4]
 8005c38:	429a      	cmp	r2, r3
 8005c3a:	d3e9      	bcc.n	8005c10 <vCoRoutineSchedule+0x4c>
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				uxListRemove( &( pxCRCB->xGenericListItem ) );
 8005c3c:	1d2e      	adds	r6, r5, #4
			{
				/* Timeout not yet expired. */
				break;
			}

			portDISABLE_INTERRUPTS();
 8005c3e:	f7ff fe5f 	bl	8005900 <ulPortSetInterruptMask>
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				uxListRemove( &( pxCRCB->xGenericListItem ) );
 8005c42:	4630      	mov	r0, r6
 8005c44:	f000 f88e 	bl	8005d64 <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pvContainer )
 8005c48:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8005c4a:	b11b      	cbz	r3, 8005c54 <vCoRoutineSchedule+0x90>
				{
					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
 8005c4c:	f105 0018 	add.w	r0, r5, #24
 8005c50:	f000 f888 	bl	8005d64 <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
 8005c54:	2000      	movs	r0, #0
 8005c56:	f7ff fe77 	bl	8005948 <vPortClearInterruptMask>

			prvAddCoRoutineToReadyQueue( pxCRCB );
 8005c5a:	6f22      	ldr	r2, [r4, #112]	; 0x70
 8005c5c:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8005c5e:	4293      	cmp	r3, r2
 8005c60:	bf84      	itt	hi
 8005c62:	4a19      	ldrhi	r2, [pc, #100]	; (8005cc8 <vCoRoutineSchedule+0x104>)
 8005c64:	6713      	strhi	r3, [r2, #112]	; 0x70
 8005c66:	4a19      	ldr	r2, [pc, #100]	; (8005ccc <vCoRoutineSchedule+0x108>)
 8005c68:	2014      	movs	r0, #20
 8005c6a:	fb00 2003 	mla	r0, r0, r3, r2
 8005c6e:	4631      	mov	r1, r6
 8005c70:	f000 f854 	bl	8005d1c <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
 8005c74:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 8005c76:	681a      	ldr	r2, [r3, #0]
 8005c78:	2a00      	cmp	r2, #0
 8005c7a:	d1d8      	bne.n	8005c2e <vCoRoutineSchedule+0x6a>
 8005c7c:	e7c8      	b.n	8005c10 <vCoRoutineSchedule+0x4c>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
 8005c7e:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 8005c80:	67da      	str	r2, [r3, #124]	; 0x7c
 8005c82:	6f1a      	ldr	r2, [r3, #112]	; 0x70

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
 8005c84:	2114      	movs	r1, #20
 8005c86:	fb01 3002 	mla	r0, r1, r2, r3
 8005c8a:	6840      	ldr	r0, [r0, #4]
 8005c8c:	b938      	cbnz	r0, 8005c9e <vCoRoutineSchedule+0xda>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
 8005c8e:	b122      	cbz	r2, 8005c9a <vCoRoutineSchedule+0xd6>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
 8005c90:	3a01      	subs	r2, #1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
 8005c92:	fb01 3302 	mla	r3, r1, r2, r3
 8005c96:	685b      	ldr	r3, [r3, #4]
 8005c98:	b90b      	cbnz	r3, 8005c9e <vCoRoutineSchedule+0xda>
 8005c9a:	6722      	str	r2, [r4, #112]	; 0x70
 8005c9c:	bd70      	pop	{r4, r5, r6, pc}
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
 8005c9e:	4b0b      	ldr	r3, [pc, #44]	; (8005ccc <vCoRoutineSchedule+0x108>)
 8005ca0:	6722      	str	r2, [r4, #112]	; 0x70
 8005ca2:	2114      	movs	r1, #20
 8005ca4:	fb01 3202 	mla	r2, r1, r2, r3
 8005ca8:	f102 0108 	add.w	r1, r2, #8
 8005cac:	6853      	ldr	r3, [r2, #4]
 8005cae:	685b      	ldr	r3, [r3, #4]
 8005cb0:	6053      	str	r3, [r2, #4]
 8005cb2:	428b      	cmp	r3, r1
 8005cb4:	bf04      	itt	eq
 8005cb6:	685b      	ldreq	r3, [r3, #4]
 8005cb8:	6053      	streq	r3, [r2, #4]
 8005cba:	6853      	ldr	r3, [r2, #4]
 8005cbc:	68d8      	ldr	r0, [r3, #12]
 8005cbe:	6020      	str	r0, [r4, #0]

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
 8005cc0:	6803      	ldr	r3, [r0, #0]
 8005cc2:	6b01      	ldr	r1, [r0, #48]	; 0x30
 8005cc4:	4798      	blx	r3
 8005cc6:	bd70      	pop	{r4, r5, r6, pc}
 8005cc8:	20002d44 	.word	0x20002d44
 8005ccc:	20002d48 	.word	0x20002d48

08005cd0 <xCoRoutineRemoveFromEventList>:
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 8005cd0:	68c3      	ldr	r3, [r0, #12]
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
 8005cd2:	b570      	push	{r4, r5, r6, lr}
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 8005cd4:	68dc      	ldr	r4, [r3, #12]
	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
 8005cd6:	4d09      	ldr	r5, [pc, #36]	; (8005cfc <xCoRoutineRemoveFromEventList+0x2c>)

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
 8005cd8:	f104 0618 	add.w	r6, r4, #24
 8005cdc:	4630      	mov	r0, r6
 8005cde:	f000 f841 	bl	8005d64 <uxListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
 8005ce2:	f105 0054 	add.w	r0, r5, #84	; 0x54
 8005ce6:	4631      	mov	r1, r6
 8005ce8:	f000 f818 	bl	8005d1c <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
 8005cec:	682b      	ldr	r3, [r5, #0]
 8005cee:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8005cf0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
 8005cf2:	4298      	cmp	r0, r3
 8005cf4:	bf34      	ite	cc
 8005cf6:	2000      	movcc	r0, #0
 8005cf8:	2001      	movcs	r0, #1
 8005cfa:	bd70      	pop	{r4, r5, r6, pc}
 8005cfc:	20002d44 	.word	0x20002d44

08005d00 <vListInitialise>:
void vListInitialise( xList * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8005d00:	f100 0308 	add.w	r3, r0, #8
 8005d04:	6043      	str	r3, [r0, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8005d06:	f04f 32ff 	mov.w	r2, #4294967295

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8005d0a:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8005d0c:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
 8005d0e:	2300      	movs	r3, #0
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8005d10:	6082      	str	r2, [r0, #8]
	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
 8005d12:	6003      	str	r3, [r0, #0]
 8005d14:	4770      	bx	lr

08005d16 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 8005d16:	2300      	movs	r3, #0
 8005d18:	6103      	str	r3, [r0, #16]
 8005d1a:	4770      	bx	lr

08005d1c <vListInsertEnd>:
xListItem * pxIndex;

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry. */
	pxIndex = pxList->pxIndex;
 8005d1c:	6843      	ldr	r3, [r0, #4]

	pxNewListItem->pxNext = pxIndex;
 8005d1e:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 8005d20:	689a      	ldr	r2, [r3, #8]
 8005d22:	608a      	str	r2, [r1, #8]
	pxIndex->pxPrevious->pxNext = pxNewListItem;
 8005d24:	689a      	ldr	r2, [r3, #8]
 8005d26:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
 8005d28:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8005d2a:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
	pxIndex->pxPrevious->pxNext = pxNewListItem;
	pxIndex->pxPrevious = pxNewListItem;

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 8005d2c:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
 8005d2e:	3301      	adds	r3, #1
 8005d30:	6003      	str	r3, [r0, #0]
 8005d32:	4770      	bx	lr

08005d34 <vListInsert>:
}
/*-----------------------------------------------------------*/

void vListInsert( xList * const pxList, xListItem * const pxNewListItem )
{
 8005d34:	b530      	push	{r4, r5, lr}
xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
 8005d36:	680c      	ldr	r4, [r1, #0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 8005d38:	1c63      	adds	r3, r4, #1
 8005d3a:	d101      	bne.n	8005d40 <vListInsert+0xc>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 8005d3c:	6903      	ldr	r3, [r0, #16]
 8005d3e:	e007      	b.n	8005d50 <vListInsert+0x1c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8005d40:	f100 0308 	add.w	r3, r0, #8
 8005d44:	685a      	ldr	r2, [r3, #4]
 8005d46:	6815      	ldr	r5, [r2, #0]
 8005d48:	42a5      	cmp	r5, r4
 8005d4a:	d801      	bhi.n	8005d50 <vListInsert+0x1c>
 8005d4c:	4613      	mov	r3, r2
 8005d4e:	e7f9      	b.n	8005d44 <vListInsert+0x10>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 8005d50:	685a      	ldr	r2, [r3, #4]
 8005d52:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 8005d54:	6091      	str	r1, [r2, #8]
	pxNewListItem->pxPrevious = pxIterator;
 8005d56:	608b      	str	r3, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
 8005d58:	6059      	str	r1, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8005d5a:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pxPrevious = pxIterator;
	pxIterator->pxNext = pxNewListItem;

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 8005d5c:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
 8005d5e:	3301      	adds	r3, #1
 8005d60:	6003      	str	r3, [r0, #0]
 8005d62:	bd30      	pop	{r4, r5, pc}

08005d64 <uxListRemove>:

unsigned portBASE_TYPE uxListRemove( xListItem * const pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8005d64:	6843      	ldr	r3, [r0, #4]
 8005d66:	6882      	ldr	r2, [r0, #8]
 8005d68:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 8005d6a:	6882      	ldr	r2, [r0, #8]
 8005d6c:	6053      	str	r3, [r2, #4]

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
 8005d6e:	6903      	ldr	r3, [r0, #16]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 8005d70:	6859      	ldr	r1, [r3, #4]
 8005d72:	4281      	cmp	r1, r0
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 8005d74:	bf08      	it	eq
 8005d76:	605a      	streq	r2, [r3, #4]
	}

	pxItemToRemove->pvContainer = NULL;
 8005d78:	2200      	movs	r2, #0
 8005d7a:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
 8005d7c:	6818      	ldr	r0, [r3, #0]
 8005d7e:	3801      	subs	r0, #1
 8005d80:	6018      	str	r0, [r3, #0]

	return pxList->uxNumberOfItems;
}
 8005d82:	4770      	bx	lr

08005d84 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
 8005d84:	b538      	push	{r3, r4, r5, lr}
 8005d86:	4615      	mov	r5, r2
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
 8005d88:	6c02      	ldr	r2, [r0, #64]	; 0x40

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
 8005d8a:	4604      	mov	r4, r0
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
 8005d8c:	b932      	cbnz	r2, 8005d9c <prvCopyDataToQueue+0x18>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8005d8e:	6805      	ldr	r5, [r0, #0]
 8005d90:	bb3d      	cbnz	r5, 8005de2 <prvCopyDataToQueue+0x5e>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 8005d92:	6840      	ldr	r0, [r0, #4]
 8005d94:	f001 f8d6 	bl	8006f44 <vTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
 8005d98:	6065      	str	r5, [r4, #4]
 8005d9a:	e022      	b.n	8005de2 <prvCopyDataToQueue+0x5e>
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
 8005d9c:	b965      	cbnz	r5, 8005db8 <prvCopyDataToQueue+0x34>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
 8005d9e:	6880      	ldr	r0, [r0, #8]
 8005da0:	f001 fd58 	bl	8007854 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 8005da4:	68a2      	ldr	r2, [r4, #8]
 8005da6:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8005da8:	4413      	add	r3, r2
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8005daa:	6862      	ldr	r2, [r4, #4]
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 8005dac:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8005dae:	4293      	cmp	r3, r2
 8005db0:	d317      	bcc.n	8005de2 <prvCopyDataToQueue+0x5e>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
 8005db2:	6823      	ldr	r3, [r4, #0]
 8005db4:	60a3      	str	r3, [r4, #8]
 8005db6:	e014      	b.n	8005de2 <prvCopyDataToQueue+0x5e>
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8005db8:	68c0      	ldr	r0, [r0, #12]
 8005dba:	f001 fd4b 	bl	8007854 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 8005dbe:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8005dc0:	68e2      	ldr	r2, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8005dc2:	6821      	ldr	r1, [r4, #0]
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 8005dc4:	425b      	negs	r3, r3
 8005dc6:	441a      	add	r2, r3
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8005dc8:	428a      	cmp	r2, r1
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 8005dca:	60e2      	str	r2, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8005dcc:	d202      	bcs.n	8005dd4 <prvCopyDataToQueue+0x50>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 8005dce:	6862      	ldr	r2, [r4, #4]
 8005dd0:	4413      	add	r3, r2
 8005dd2:	60e3      	str	r3, [r4, #12]
		}

		if( xPosition == queueOVERWRITE )
 8005dd4:	2d02      	cmp	r5, #2
 8005dd6:	d104      	bne.n	8005de2 <prvCopyDataToQueue+0x5e>
		{
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 8005dd8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8005dda:	b113      	cbz	r3, 8005de2 <prvCopyDataToQueue+0x5e>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
 8005ddc:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8005dde:	3b01      	subs	r3, #1
 8005de0:	63a3      	str	r3, [r4, #56]	; 0x38
			}
		}
	}

	++( pxQueue->uxMessagesWaiting );
 8005de2:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8005de4:	3301      	adds	r3, #1
 8005de6:	63a3      	str	r3, [r4, #56]	; 0x38
 8005de8:	bd38      	pop	{r3, r4, r5, pc}

08005dea <prvCopyDataFromQueue>:
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void * const pvBuffer )
{
 8005dea:	b570      	push	{r4, r5, r6, lr}
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
 8005dec:	6804      	ldr	r4, [r0, #0]
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void * const pvBuffer )
{
 8005dee:	4603      	mov	r3, r0
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
 8005df0:	b16c      	cbz	r4, 8005e0e <prvCopyDataFromQueue+0x24>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 8005df2:	68c5      	ldr	r5, [r0, #12]
 8005df4:	6c02      	ldr	r2, [r0, #64]	; 0x40
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 8005df6:	6846      	ldr	r6, [r0, #4]

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void * const pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 8005df8:	4415      	add	r5, r2
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 8005dfa:	42b5      	cmp	r5, r6

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void * const pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 8005dfc:	60c5      	str	r5, [r0, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
 8005dfe:	bf28      	it	cs
 8005e00:	60c4      	strcs	r4, [r0, #12]
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
	}
}
 8005e02:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
 8005e06:	4608      	mov	r0, r1
 8005e08:	68d9      	ldr	r1, [r3, #12]
 8005e0a:	f001 bd23 	b.w	8007854 <memcpy>
 8005e0e:	bd70      	pop	{r4, r5, r6, pc}

08005e10 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQUEUE *pxQueue )
{
 8005e10:	b510      	push	{r4, lr}
 8005e12:	4604      	mov	r4, r0

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
 8005e14:	f7ff fd8a 	bl	800592c <vPortEnterCritical>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 8005e18:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8005e1a:	2b00      	cmp	r3, #0
 8005e1c:	dd0c      	ble.n	8005e38 <prvUnlockQueue+0x28>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8005e1e:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8005e20:	b153      	cbz	r3, 8005e38 <prvUnlockQueue+0x28>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8005e22:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8005e26:	f000 ffcf 	bl	8006dc8 <xTaskRemoveFromEventList>
 8005e2a:	b108      	cbz	r0, 8005e30 <prvUnlockQueue+0x20>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
 8005e2c:	f001 f83c 	bl	8006ea8 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
 8005e30:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8005e32:	3b01      	subs	r3, #1
 8005e34:	64a3      	str	r3, [r4, #72]	; 0x48
 8005e36:	e7ef      	b.n	8005e18 <prvUnlockQueue+0x8>
		}

		pxQueue->xTxLock = queueUNLOCKED;
 8005e38:	f04f 33ff 	mov.w	r3, #4294967295
 8005e3c:	64a3      	str	r3, [r4, #72]	; 0x48
	}
	taskEXIT_CRITICAL();
 8005e3e:	f7ff fd86 	bl	800594e <vPortExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
 8005e42:	f7ff fd73 	bl	800592c <vPortEnterCritical>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 8005e46:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8005e48:	2b00      	cmp	r3, #0
 8005e4a:	dd0c      	ble.n	8005e66 <prvUnlockQueue+0x56>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8005e4c:	6923      	ldr	r3, [r4, #16]
 8005e4e:	b153      	cbz	r3, 8005e66 <prvUnlockQueue+0x56>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8005e50:	f104 0010 	add.w	r0, r4, #16
 8005e54:	f000 ffb8 	bl	8006dc8 <xTaskRemoveFromEventList>
 8005e58:	b108      	cbz	r0, 8005e5e <prvUnlockQueue+0x4e>
				{
					vTaskMissedYield();
 8005e5a:	f001 f825 	bl	8006ea8 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
 8005e5e:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8005e60:	3b01      	subs	r3, #1
 8005e62:	6463      	str	r3, [r4, #68]	; 0x44
 8005e64:	e7ef      	b.n	8005e46 <prvUnlockQueue+0x36>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
 8005e66:	f04f 33ff 	mov.w	r3, #4294967295
 8005e6a:	6463      	str	r3, [r4, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
}
 8005e6c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
	}
	taskEXIT_CRITICAL();
 8005e70:	f7ff bd6d 	b.w	800594e <vPortExitCritical>

08005e74 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

portBASE_TYPE xQueueGenericReset( xQueueHandle xQueue, portBASE_TYPE xNewQueue )
{
 8005e74:	b538      	push	{r3, r4, r5, lr}
 8005e76:	460d      	mov	r5, r1
xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;

	configASSERT( pxQueue );
 8005e78:	4604      	mov	r4, r0
 8005e7a:	b910      	cbnz	r0, 8005e82 <xQueueGenericReset+0xe>
 8005e7c:	f7ff fd40 	bl	8005900 <ulPortSetInterruptMask>
 8005e80:	e7fe      	b.n	8005e80 <xQueueGenericReset+0xc>

	taskENTER_CRITICAL();
 8005e82:	f7ff fd53 	bl	800592c <vPortEnterCritical>
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 8005e86:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8005e88:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 8005e8a:	6823      	ldr	r3, [r4, #0]
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
		pxQueue->pcWriteTo = pxQueue->pcHead;
 8005e8c:	60a3      	str	r3, [r4, #8]

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 8005e8e:	4350      	muls	r0, r2
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
 8005e90:	1a82      	subs	r2, r0, r2

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 8005e92:	1819      	adds	r1, r3, r0
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
 8005e94:	4413      	add	r3, r2

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 8005e96:	6061      	str	r1, [r4, #4]
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
 8005e98:	60e3      	str	r3, [r4, #12]
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
 8005e9a:	2100      	movs	r1, #0
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
		pxQueue->xRxLock = queueUNLOCKED;
 8005e9c:	f04f 33ff 	mov.w	r3, #4294967295
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
 8005ea0:	63a1      	str	r1, [r4, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
		pxQueue->xRxLock = queueUNLOCKED;
 8005ea2:	6463      	str	r3, [r4, #68]	; 0x44
		pxQueue->xTxLock = queueUNLOCKED;
 8005ea4:	64a3      	str	r3, [r4, #72]	; 0x48

		if( xNewQueue == pdFALSE )
 8005ea6:	b955      	cbnz	r5, 8005ebe <xQueueGenericReset+0x4a>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to	write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8005ea8:	6923      	ldr	r3, [r4, #16]
 8005eaa:	b183      	cbz	r3, 8005ece <xQueueGenericReset+0x5a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 8005eac:	f104 0010 	add.w	r0, r4, #16
 8005eb0:	f000 ff8a 	bl	8006dc8 <xTaskRemoveFromEventList>
 8005eb4:	2801      	cmp	r0, #1
 8005eb6:	d10a      	bne.n	8005ece <xQueueGenericReset+0x5a>
				{
					portYIELD_WITHIN_API();
 8005eb8:	f7ff fd17 	bl	80058ea <vPortYield>
 8005ebc:	e007      	b.n	8005ece <xQueueGenericReset+0x5a>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 8005ebe:	f104 0010 	add.w	r0, r4, #16
 8005ec2:	f7ff ff1d 	bl	8005d00 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 8005ec6:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8005eca:	f7ff ff19 	bl	8005d00 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
 8005ece:	f7ff fd3e 	bl	800594e <vPortExitCritical>

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
 8005ed2:	2001      	movs	r0, #1
 8005ed4:	bd38      	pop	{r3, r4, r5, pc}

08005ed6 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
 8005ed6:	b570      	push	{r4, r5, r6, lr}
 8005ed8:	460e      	mov	r6, r1
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
 8005eda:	4605      	mov	r5, r0
 8005edc:	b170      	cbz	r0, 8005efc <xQueueGenericCreate+0x26>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
 8005ede:	204c      	movs	r0, #76	; 0x4c
 8005ee0:	f7ff fc90 	bl	8005804 <pvPortMalloc>
		if( pxNewQueue != NULL )
 8005ee4:	4604      	mov	r4, r0
 8005ee6:	b148      	cbz	r0, 8005efc <xQueueGenericCreate+0x26>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8005ee8:	fb06 f005 	mul.w	r0, r6, r5

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
 8005eec:	3001      	adds	r0, #1
 8005eee:	f7ff fc89 	bl	8005804 <pvPortMalloc>
 8005ef2:	6020      	str	r0, [r4, #0]
			if( pxNewQueue->pcHead != NULL )
 8005ef4:	b928      	cbnz	r0, 8005f02 <xQueueGenericCreate+0x2c>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
 8005ef6:	4620      	mov	r0, r4
 8005ef8:	f7ff fcb0 	bl	800585c <vPortFree>
			}
		}
	}

	configASSERT( xReturn );
 8005efc:	f7ff fd00 	bl	8005900 <ulPortSetInterruptMask>
 8005f00:	e7fe      	b.n	8005f00 <xQueueGenericCreate+0x2a>
			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
			if( pxNewQueue->pcHead != NULL )
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
 8005f02:	63e5      	str	r5, [r4, #60]	; 0x3c
				pxNewQueue->uxItemSize = uxItemSize;
 8005f04:	6426      	str	r6, [r4, #64]	; 0x40
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 8005f06:	4620      	mov	r0, r4
 8005f08:	2101      	movs	r1, #1
 8005f0a:	f7ff ffb3 	bl	8005e74 <xQueueGenericReset>
	}

	configASSERT( xReturn );

	return xReturn;
}
 8005f0e:	4620      	mov	r0, r4
 8005f10:	bd70      	pop	{r4, r5, r6, pc}

08005f12 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
 8005f12:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 8005f16:	460e      	mov	r6, r1
 8005f18:	9201      	str	r2, [sp, #4]
 8005f1a:	461d      	mov	r5, r3
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
xTimeOutType xTimeOut;
xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;

	configASSERT( pxQueue );
 8005f1c:	4604      	mov	r4, r0
 8005f1e:	b910      	cbnz	r0, 8005f26 <xQueueGenericSend+0x14>
 8005f20:	f7ff fcee 	bl	8005900 <ulPortSetInterruptMask>
 8005f24:	e7fe      	b.n	8005f24 <xQueueGenericSend+0x12>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
 8005f26:	b921      	cbnz	r1, 8005f32 <xQueueGenericSend+0x20>
 8005f28:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8005f2a:	b113      	cbz	r3, 8005f32 <xQueueGenericSend+0x20>
 8005f2c:	f7ff fce8 	bl	8005900 <ulPortSetInterruptMask>
 8005f30:	e7fe      	b.n	8005f30 <xQueueGenericSend+0x1e>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 8005f32:	2d02      	cmp	r5, #2
 8005f34:	d102      	bne.n	8005f3c <xQueueGenericSend+0x2a>
 8005f36:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8005f38:	2b01      	cmp	r3, #1
 8005f3a:	d164      	bne.n	8006006 <xQueueGenericSend+0xf4>

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
 8005f3c:	2700      	movs	r7, #0
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
 8005f3e:	f7ff fcf5 	bl	800592c <vPortEnterCritical>
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 8005f42:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8005f44:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8005f46:	429a      	cmp	r2, r3
 8005f48:	d301      	bcc.n	8005f4e <xQueueGenericSend+0x3c>
 8005f4a:	2d02      	cmp	r5, #2
 8005f4c:	d112      	bne.n	8005f74 <xQueueGenericSend+0x62>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 8005f4e:	4620      	mov	r0, r4
 8005f50:	4631      	mov	r1, r6
 8005f52:	462a      	mov	r2, r5
 8005f54:	f7ff ff16 	bl	8005d84 <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8005f58:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8005f5a:	b13b      	cbz	r3, 8005f6c <xQueueGenericSend+0x5a>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 8005f5c:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8005f60:	f000 ff32 	bl	8006dc8 <xTaskRemoveFromEventList>
 8005f64:	2801      	cmp	r0, #1
 8005f66:	d101      	bne.n	8005f6c <xQueueGenericSend+0x5a>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							portYIELD_WITHIN_API();
 8005f68:	f7ff fcbf 	bl	80058ea <vPortYield>
						}
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
 8005f6c:	f7ff fcef 	bl	800594e <vPortExitCritical>

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
 8005f70:	2001      	movs	r0, #1
 8005f72:	e04b      	b.n	800600c <xQueueGenericSend+0xfa>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
 8005f74:	f8dd 8004 	ldr.w	r8, [sp, #4]
 8005f78:	f1b8 0f00 	cmp.w	r8, #0
 8005f7c:	d102      	bne.n	8005f84 <xQueueGenericSend+0x72>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 8005f7e:	f7ff fce6 	bl	800594e <vPortExitCritical>
 8005f82:	e03e      	b.n	8006002 <xQueueGenericSend+0xf0>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
 8005f84:	b917      	cbnz	r7, 8005f8c <xQueueGenericSend+0x7a>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
 8005f86:	a802      	add	r0, sp, #8
 8005f88:	f000 ff54 	bl	8006e34 <vTaskSetTimeOutState>
				{
					/* Entry time was already set. */
				}
			}
		}
		taskEXIT_CRITICAL();
 8005f8c:	f7ff fcdf 	bl	800594e <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 8005f90:	f000 fcd8 	bl	8006944 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 8005f94:	f7ff fcca 	bl	800592c <vPortEnterCritical>
 8005f98:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8005f9a:	3301      	adds	r3, #1
 8005f9c:	bf04      	itt	eq
 8005f9e:	2300      	moveq	r3, #0
 8005fa0:	6463      	streq	r3, [r4, #68]	; 0x44
 8005fa2:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8005fa4:	3301      	adds	r3, #1
 8005fa6:	bf04      	itt	eq
 8005fa8:	2300      	moveq	r3, #0
 8005faa:	64a3      	streq	r3, [r4, #72]	; 0x48
 8005fac:	f7ff fccf 	bl	800594e <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8005fb0:	a802      	add	r0, sp, #8
 8005fb2:	a901      	add	r1, sp, #4
 8005fb4:	f000 ff4c 	bl	8006e50 <xTaskCheckForTimeOut>
 8005fb8:	b9f0      	cbnz	r0, 8005ff8 <xQueueGenericSend+0xe6>

static signed portBASE_TYPE prvIsQueueFull( const xQUEUE *pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
 8005fba:	f7ff fcb7 	bl	800592c <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 8005fbe:	f8d4 8038 	ldr.w	r8, [r4, #56]	; 0x38
 8005fc2:	6be7      	ldr	r7, [r4, #60]	; 0x3c
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 8005fc4:	f7ff fcc3 	bl	800594e <vPortExitCritical>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 8005fc8:	45b8      	cmp	r8, r7
 8005fca:	d10f      	bne.n	8005fec <xQueueGenericSend+0xda>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 8005fcc:	f104 0010 	add.w	r0, r4, #16
 8005fd0:	9901      	ldr	r1, [sp, #4]
 8005fd2:	f000 febf 	bl	8006d54 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
 8005fd6:	4620      	mov	r0, r4
 8005fd8:	f7ff ff1a 	bl	8005e10 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
 8005fdc:	f000 fd5a 	bl	8006a94 <xTaskResumeAll>
 8005fe0:	b108      	cbz	r0, 8005fe6 <xQueueGenericSend+0xd4>
 8005fe2:	2701      	movs	r7, #1
 8005fe4:	e7ab      	b.n	8005f3e <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
 8005fe6:	f7ff fc80 	bl	80058ea <vPortYield>
 8005fea:	e7fa      	b.n	8005fe2 <xQueueGenericSend+0xd0>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
 8005fec:	4620      	mov	r0, r4
 8005fee:	f7ff ff0f 	bl	8005e10 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 8005ff2:	f000 fd4f 	bl	8006a94 <xTaskResumeAll>
 8005ff6:	e7f4      	b.n	8005fe2 <xQueueGenericSend+0xd0>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
 8005ff8:	4620      	mov	r0, r4
 8005ffa:	f7ff ff09 	bl	8005e10 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 8005ffe:	f000 fd49 	bl	8006a94 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
 8006002:	2000      	movs	r0, #0
 8006004:	e002      	b.n	800600c <xQueueGenericSend+0xfa>
xTimeOutType xTimeOut;
xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;

	configASSERT( pxQueue );
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 8006006:	f7ff fc7b 	bl	8005900 <ulPortSetInterruptMask>
 800600a:	e7fe      	b.n	800600a <xQueueGenericSend+0xf8>
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
 800600c:	b004      	add	sp, #16
 800600e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08006012 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( unsigned char ucQueueType )
	{
 8006012:	b538      	push	{r3, r4, r5, lr}
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
 8006014:	204c      	movs	r0, #76	; 0x4c
 8006016:	f7ff fbf5 	bl	8005804 <pvPortMalloc>
		if( pxNewQueue != NULL )
 800601a:	4604      	mov	r4, r0
 800601c:	b910      	cbnz	r0, 8006024 <xQueueCreateMutex+0x12>
		else
		{
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
 800601e:	f7ff fc6f 	bl	8005900 <ulPortSetInterruptMask>
 8006022:	e7fe      	b.n	8006022 <xQueueCreateMutex+0x10>

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
 8006024:	2301      	movs	r3, #1
		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
		if( pxNewQueue != NULL )
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
 8006026:	2500      	movs	r5, #0

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
 8006028:	63c3      	str	r3, [r0, #60]	; 0x3c
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
			pxNewQueue->xRxLock = queueUNLOCKED;
 800602a:	f04f 33ff 	mov.w	r3, #4294967295
			pxNewQueue->u.pcReadFrom = NULL;

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
 800602e:	6385      	str	r5, [r0, #56]	; 0x38
		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
		if( pxNewQueue != NULL )
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
 8006030:	6045      	str	r5, [r0, #4]
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
			pxNewQueue->xRxLock = queueUNLOCKED;
 8006032:	6443      	str	r3, [r0, #68]	; 0x44
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
		if( pxNewQueue != NULL )
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 8006034:	6005      	str	r5, [r0, #0]
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
			pxNewQueue->xRxLock = queueUNLOCKED;
			pxNewQueue->xTxLock = queueUNLOCKED;
 8006036:	6483      	str	r3, [r0, #72]	; 0x48
			pxNewQueue->pxMutexHolder = NULL;
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
 8006038:	6085      	str	r5, [r0, #8]
			pxNewQueue->u.pcReadFrom = NULL;
 800603a:	60c5      	str	r5, [r0, #12]
			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
 800603c:	6405      	str	r5, [r0, #64]	; 0x40
				pxNewQueue->pxQueueSetContainer = NULL;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 800603e:	3010      	adds	r0, #16
 8006040:	f7ff fe5e 	bl	8005d00 <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 8006044:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8006048:	f7ff fe5a 	bl	8005d00 <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
 800604c:	4620      	mov	r0, r4
 800604e:	4629      	mov	r1, r5
 8006050:	462a      	mov	r2, r5
 8006052:	462b      	mov	r3, r5
 8006054:	f7ff ff5d 	bl	8005f12 <xQueueGenericSend>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
 8006058:	4620      	mov	r0, r4
 800605a:	bd38      	pop	{r3, r4, r5, pc}

0800605c <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle xQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
 800605c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8006060:	460f      	mov	r7, r1
 8006062:	4616      	mov	r6, r2
 8006064:	461d      	mov	r5, r3
signed portBASE_TYPE xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;
xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;

	configASSERT( pxQueue );
 8006066:	4604      	mov	r4, r0
 8006068:	b910      	cbnz	r0, 8006070 <xQueueGenericSendFromISR+0x14>
 800606a:	f7ff fc49 	bl	8005900 <ulPortSetInterruptMask>
 800606e:	e7fe      	b.n	800606e <xQueueGenericSendFromISR+0x12>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
 8006070:	b921      	cbnz	r1, 800607c <xQueueGenericSendFromISR+0x20>
 8006072:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8006074:	b113      	cbz	r3, 800607c <xQueueGenericSendFromISR+0x20>
 8006076:	f7ff fc43 	bl	8005900 <ulPortSetInterruptMask>
 800607a:	e7fe      	b.n	800607a <xQueueGenericSendFromISR+0x1e>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 800607c:	2d02      	cmp	r5, #2
 800607e:	d105      	bne.n	800608c <xQueueGenericSendFromISR+0x30>
 8006080:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8006082:	2b01      	cmp	r3, #1
 8006084:	d002      	beq.n	800608c <xQueueGenericSendFromISR+0x30>
 8006086:	f7ff fc3b 	bl	8005900 <ulPortSetInterruptMask>
 800608a:	e7fe      	b.n	800608a <xQueueGenericSendFromISR+0x2e>
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 800608c:	f7ff fcfe 	bl	8005a8c <vPortValidateInterruptPriority>
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 8006090:	f7ff fc36 	bl	8005900 <ulPortSetInterruptMask>
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 8006094:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8006096:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8006098:	429a      	cmp	r2, r3
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 800609a:	4680      	mov	r8, r0
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 800609c:	d301      	bcc.n	80060a2 <xQueueGenericSendFromISR+0x46>
 800609e:	2d02      	cmp	r5, #2
 80060a0:	d117      	bne.n	80060d2 <xQueueGenericSendFromISR+0x76>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 80060a2:	4620      	mov	r0, r4
 80060a4:	4639      	mov	r1, r7
 80060a6:	462a      	mov	r2, r5
 80060a8:	f7ff fe6c 	bl	8005d84 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
 80060ac:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 80060ae:	3301      	adds	r3, #1
 80060b0:	d10a      	bne.n	80060c8 <xQueueGenericSendFromISR+0x6c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 80060b2:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80060b4:	b15b      	cbz	r3, 80060ce <xQueueGenericSendFromISR+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80060b6:	f104 0024 	add.w	r0, r4, #36	; 0x24
 80060ba:	f000 fe85 	bl	8006dc8 <xTaskRemoveFromEventList>
 80060be:	b130      	cbz	r0, 80060ce <xQueueGenericSendFromISR+0x72>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
 80060c0:	b12e      	cbz	r6, 80060ce <xQueueGenericSendFromISR+0x72>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
 80060c2:	2401      	movs	r4, #1
 80060c4:	6034      	str	r4, [r6, #0]
 80060c6:	e005      	b.n	80060d4 <xQueueGenericSendFromISR+0x78>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
 80060c8:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 80060ca:	3301      	adds	r3, #1
 80060cc:	64a3      	str	r3, [r4, #72]	; 0x48
			}

			xReturn = pdPASS;
 80060ce:	2401      	movs	r4, #1
 80060d0:	e000      	b.n	80060d4 <xQueueGenericSendFromISR+0x78>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
 80060d2:	2400      	movs	r4, #0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 80060d4:	4640      	mov	r0, r8
 80060d6:	f7ff fc37 	bl	8005948 <vPortClearInterruptMask>

	return xReturn;
}
 80060da:	4620      	mov	r0, r4
 80060dc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

080060e0 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle xQueue, const void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
 80060e0:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 80060e4:	460d      	mov	r5, r1
 80060e6:	9201      	str	r2, [sp, #4]
 80060e8:	4698      	mov	r8, r3
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
xTimeOutType xTimeOut;
signed char *pcOriginalReadPosition;
xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;

	configASSERT( pxQueue );
 80060ea:	4604      	mov	r4, r0
 80060ec:	b910      	cbnz	r0, 80060f4 <xQueueGenericReceive+0x14>
 80060ee:	f7ff fc07 	bl	8005900 <ulPortSetInterruptMask>
 80060f2:	e7fe      	b.n	80060f2 <xQueueGenericReceive+0x12>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
 80060f4:	b911      	cbnz	r1, 80060fc <xQueueGenericReceive+0x1c>
 80060f6:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80060f8:	2b00      	cmp	r3, #0
 80060fa:	d178      	bne.n	80061ee <xQueueGenericReceive+0x10e>
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle xQueue, const void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
 80060fc:	2600      	movs	r6, #0
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
 80060fe:	f7ff fc15 	bl	800592c <vPortEnterCritical>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 8006102:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8006104:	b33b      	cbz	r3, 8006156 <xQueueGenericReceive+0x76>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );
 8006106:	4620      	mov	r0, r4
 8006108:	4629      	mov	r1, r5
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 800610a:	68e6      	ldr	r6, [r4, #12]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
 800610c:	f7ff fe6d 	bl	8005dea <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
 8006110:	f1b8 0f00 	cmp.w	r8, #0
 8006114:	d112      	bne.n	800613c <xQueueGenericReceive+0x5c>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
 8006116:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8006118:	3b01      	subs	r3, #1
 800611a:	63a3      	str	r3, [r4, #56]	; 0x38

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 800611c:	6823      	ldr	r3, [r4, #0]
 800611e:	b913      	cbnz	r3, 8006126 <xQueueGenericReceive+0x46>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( signed char * ) xTaskGetCurrentTaskHandle(); /*lint !e961 Cast is not redundant as xTaskHandle is a typedef. */
 8006120:	f000 feca 	bl	8006eb8 <xTaskGetCurrentTaskHandle>
 8006124:	6060      	str	r0, [r4, #4]
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8006126:	6923      	ldr	r3, [r4, #16]
 8006128:	b18b      	cbz	r3, 800614e <xQueueGenericReceive+0x6e>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 800612a:	f104 0010 	add.w	r0, r4, #16
 800612e:	f000 fe4b 	bl	8006dc8 <xTaskRemoveFromEventList>
 8006132:	2801      	cmp	r0, #1
 8006134:	d10b      	bne.n	800614e <xQueueGenericReceive+0x6e>
						{
							portYIELD_WITHIN_API();
 8006136:	f7ff fbd8 	bl	80058ea <vPortYield>
 800613a:	e008      	b.n	800614e <xQueueGenericReceive+0x6e>
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800613c:	6a63      	ldr	r3, [r4, #36]	; 0x24
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 800613e:	60e6      	str	r6, [r4, #12]

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8006140:	b12b      	cbz	r3, 800614e <xQueueGenericReceive+0x6e>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8006142:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8006146:	f000 fe3f 	bl	8006dc8 <xTaskRemoveFromEventList>
 800614a:	2800      	cmp	r0, #0
 800614c:	d1f3      	bne.n	8006136 <xQueueGenericReceive+0x56>
							portYIELD_WITHIN_API();
						}
					}
				}

				taskEXIT_CRITICAL();
 800614e:	f7ff fbfe 	bl	800594e <vPortExitCritical>
				return pdPASS;
 8006152:	2001      	movs	r0, #1
 8006154:	e04e      	b.n	80061f4 <xQueueGenericReceive+0x114>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
 8006156:	9f01      	ldr	r7, [sp, #4]
 8006158:	b917      	cbnz	r7, 8006160 <xQueueGenericReceive+0x80>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 800615a:	f7ff fbf8 	bl	800594e <vPortExitCritical>
 800615e:	e044      	b.n	80061ea <xQueueGenericReceive+0x10a>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
 8006160:	b916      	cbnz	r6, 8006168 <xQueueGenericReceive+0x88>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
 8006162:	a802      	add	r0, sp, #8
 8006164:	f000 fe66 	bl	8006e34 <vTaskSetTimeOutState>
				{
					/* Entry time was already set. */
				}
			}
		}
		taskEXIT_CRITICAL();
 8006168:	f7ff fbf1 	bl	800594e <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 800616c:	f000 fbea 	bl	8006944 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 8006170:	f7ff fbdc 	bl	800592c <vPortEnterCritical>
 8006174:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8006176:	3301      	adds	r3, #1
 8006178:	bf04      	itt	eq
 800617a:	2300      	moveq	r3, #0
 800617c:	6463      	streq	r3, [r4, #68]	; 0x44
 800617e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8006180:	3301      	adds	r3, #1
 8006182:	bf04      	itt	eq
 8006184:	2300      	moveq	r3, #0
 8006186:	64a3      	streq	r3, [r4, #72]	; 0x48
 8006188:	f7ff fbe1 	bl	800594e <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 800618c:	a802      	add	r0, sp, #8
 800618e:	a901      	add	r1, sp, #4
 8006190:	f000 fe5e 	bl	8006e50 <xTaskCheckForTimeOut>
 8006194:	bb20      	cbnz	r0, 80061e0 <xQueueGenericReceive+0x100>

static signed portBASE_TYPE prvIsQueueEmpty( const xQUEUE *pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
 8006196:	f7ff fbc9 	bl	800592c <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE )  0 )
 800619a:	6ba6      	ldr	r6, [r4, #56]	; 0x38
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 800619c:	f7ff fbd7 	bl	800594e <vPortExitCritical>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 80061a0:	b9c6      	cbnz	r6, 80061d4 <xQueueGenericReceive+0xf4>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 80061a2:	6823      	ldr	r3, [r4, #0]
 80061a4:	b933      	cbnz	r3, 80061b4 <xQueueGenericReceive+0xd4>
					{
						portENTER_CRITICAL();
 80061a6:	f7ff fbc1 	bl	800592c <vPortEnterCritical>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 80061aa:	6860      	ldr	r0, [r4, #4]
 80061ac:	f000 fe98 	bl	8006ee0 <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
 80061b0:	f7ff fbcd 	bl	800594e <vPortExitCritical>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 80061b4:	f104 0024 	add.w	r0, r4, #36	; 0x24
 80061b8:	9901      	ldr	r1, [sp, #4]
 80061ba:	f000 fdcb 	bl	8006d54 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 80061be:	4620      	mov	r0, r4
 80061c0:	f7ff fe26 	bl	8005e10 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 80061c4:	f000 fc66 	bl	8006a94 <xTaskResumeAll>
 80061c8:	b108      	cbz	r0, 80061ce <xQueueGenericReceive+0xee>
 80061ca:	2601      	movs	r6, #1
 80061cc:	e797      	b.n	80060fe <xQueueGenericReceive+0x1e>
				{
					portYIELD_WITHIN_API();
 80061ce:	f7ff fb8c 	bl	80058ea <vPortYield>
 80061d2:	e7fa      	b.n	80061ca <xQueueGenericReceive+0xea>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
 80061d4:	4620      	mov	r0, r4
 80061d6:	f7ff fe1b 	bl	8005e10 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 80061da:	f000 fc5b 	bl	8006a94 <xTaskResumeAll>
 80061de:	e7f4      	b.n	80061ca <xQueueGenericReceive+0xea>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
 80061e0:	4620      	mov	r0, r4
 80061e2:	f7ff fe15 	bl	8005e10 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 80061e6:	f000 fc55 	bl	8006a94 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
 80061ea:	2000      	movs	r0, #0
 80061ec:	e002      	b.n	80061f4 <xQueueGenericReceive+0x114>
xTimeOutType xTimeOut;
signed char *pcOriginalReadPosition;
xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;

	configASSERT( pxQueue );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
 80061ee:	f7ff fb87 	bl	8005900 <ulPortSetInterruptMask>
 80061f2:	e7fe      	b.n	80061f2 <xQueueGenericReceive+0x112>
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
 80061f4:	b004      	add	sp, #16
 80061f6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

080061fa <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle xQueue, const void * const pvBuffer, signed portBASE_TYPE *pxHigherPriorityTaskWoken )
{
 80061fa:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80061fc:	460e      	mov	r6, r1
 80061fe:	4615      	mov	r5, r2
signed portBASE_TYPE xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;
xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;

	configASSERT( pxQueue );
 8006200:	4604      	mov	r4, r0
 8006202:	b910      	cbnz	r0, 800620a <xQueueReceiveFromISR+0x10>
 8006204:	f7ff fb7c 	bl	8005900 <ulPortSetInterruptMask>
 8006208:	e7fe      	b.n	8006208 <xQueueReceiveFromISR+0xe>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
 800620a:	b921      	cbnz	r1, 8006216 <xQueueReceiveFromISR+0x1c>
 800620c:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800620e:	b113      	cbz	r3, 8006216 <xQueueReceiveFromISR+0x1c>
 8006210:	f7ff fb76 	bl	8005900 <ulPortSetInterruptMask>
 8006214:	e7fe      	b.n	8006214 <xQueueReceiveFromISR+0x1a>
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8006216:	f7ff fc39 	bl	8005a8c <vPortValidateInterruptPriority>

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 800621a:	f7ff fb71 	bl	8005900 <ulPortSetInterruptMask>
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 800621e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 8006220:	4607      	mov	r7, r0
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 8006222:	b1cb      	cbz	r3, 8006258 <xQueueReceiveFromISR+0x5e>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
 8006224:	4620      	mov	r0, r4
 8006226:	4631      	mov	r1, r6
 8006228:	f7ff fddf 	bl	8005dea <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
 800622c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800622e:	3b01      	subs	r3, #1
 8006230:	63a3      	str	r3, [r4, #56]	; 0x38

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
 8006232:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8006234:	3301      	adds	r3, #1
 8006236:	d10a      	bne.n	800624e <xQueueReceiveFromISR+0x54>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8006238:	6923      	ldr	r3, [r4, #16]
 800623a:	b15b      	cbz	r3, 8006254 <xQueueReceiveFromISR+0x5a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 800623c:	f104 0010 	add.w	r0, r4, #16
 8006240:	f000 fdc2 	bl	8006dc8 <xTaskRemoveFromEventList>
 8006244:	b130      	cbz	r0, 8006254 <xQueueReceiveFromISR+0x5a>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
 8006246:	b12d      	cbz	r5, 8006254 <xQueueReceiveFromISR+0x5a>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
 8006248:	2401      	movs	r4, #1
 800624a:	602c      	str	r4, [r5, #0]
 800624c:	e005      	b.n	800625a <xQueueReceiveFromISR+0x60>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
 800624e:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8006250:	3301      	adds	r3, #1
 8006252:	6463      	str	r3, [r4, #68]	; 0x44
			}

			xReturn = pdPASS;
 8006254:	2401      	movs	r4, #1
 8006256:	e000      	b.n	800625a <xQueueReceiveFromISR+0x60>
		}
		else
		{
			xReturn = pdFAIL;
 8006258:	461c      	mov	r4, r3
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 800625a:	4638      	mov	r0, r7
 800625c:	f7ff fb74 	bl	8005948 <vPortClearInterruptMask>

	return xReturn;
}
 8006260:	4620      	mov	r0, r4
 8006262:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08006264 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueuePeekFromISR( xQueueHandle xQueue, const void * const pvBuffer )
{
 8006264:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8006266:	460d      	mov	r5, r1
signed portBASE_TYPE xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;
signed char *pcOriginalReadPosition;
xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;

	configASSERT( pxQueue );
 8006268:	4604      	mov	r4, r0
 800626a:	b910      	cbnz	r0, 8006272 <xQueuePeekFromISR+0xe>
 800626c:	f7ff fb48 	bl	8005900 <ulPortSetInterruptMask>
 8006270:	e7fe      	b.n	8006270 <xQueuePeekFromISR+0xc>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
 8006272:	b921      	cbnz	r1, 800627e <xQueuePeekFromISR+0x1a>
 8006274:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8006276:	b113      	cbz	r3, 800627e <xQueuePeekFromISR+0x1a>
 8006278:	f7ff fb42 	bl	8005900 <ulPortSetInterruptMask>
 800627c:	e7fe      	b.n	800627c <xQueuePeekFromISR+0x18>
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 800627e:	f7ff fc05 	bl	8005a8c <vPortValidateInterruptPriority>

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 8006282:	f7ff fb3d 	bl	8005900 <ulPortSetInterruptMask>
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 8006286:	6ba3      	ldr	r3, [r4, #56]	; 0x38
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 8006288:	4607      	mov	r7, r0
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 800628a:	b13b      	cbz	r3, 800629c <xQueuePeekFromISR+0x38>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 800628c:	68e6      	ldr	r6, [r4, #12]
			prvCopyDataFromQueue( pxQueue, pvBuffer );
 800628e:	4620      	mov	r0, r4
 8006290:	4629      	mov	r1, r5
 8006292:	f7ff fdaa 	bl	8005dea <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 8006296:	60e6      	str	r6, [r4, #12]

			xReturn = pdPASS;
 8006298:	2401      	movs	r4, #1
 800629a:	e000      	b.n	800629e <xQueuePeekFromISR+0x3a>
		}
		else
		{
			xReturn = pdFAIL;
 800629c:	461c      	mov	r4, r3
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 800629e:	4638      	mov	r0, r7
 80062a0:	f7ff fb52 	bl	8005948 <vPortClearInterruptMask>

	return xReturn;
}
 80062a4:	4620      	mov	r0, r4
 80062a6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080062a8 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle xQueue )
{
 80062a8:	b510      	push	{r4, lr}
unsigned portBASE_TYPE uxReturn;

	configASSERT( xQueue );
 80062aa:	4604      	mov	r4, r0
 80062ac:	b910      	cbnz	r0, 80062b4 <uxQueueMessagesWaiting+0xc>
 80062ae:	f7ff fb27 	bl	8005900 <ulPortSetInterruptMask>
 80062b2:	e7fe      	b.n	80062b2 <uxQueueMessagesWaiting+0xa>

	taskENTER_CRITICAL();
 80062b4:	f7ff fb3a 	bl	800592c <vPortEnterCritical>
		uxReturn = ( ( xQUEUE * ) xQueue )->uxMessagesWaiting;
 80062b8:	6ba4      	ldr	r4, [r4, #56]	; 0x38
	taskEXIT_CRITICAL();
 80062ba:	f7ff fb48 	bl	800594e <vPortExitCritical>

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 80062be:	4620      	mov	r0, r4
 80062c0:	bd10      	pop	{r4, pc}

080062c2 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueSpacesAvailable( const xQueueHandle xQueue )
{
 80062c2:	b510      	push	{r4, lr}
unsigned portBASE_TYPE uxReturn;
xQUEUE *pxQueue;

	pxQueue = ( xQUEUE * ) xQueue;
	configASSERT( pxQueue );
 80062c4:	4604      	mov	r4, r0
 80062c6:	b910      	cbnz	r0, 80062ce <uxQueueSpacesAvailable+0xc>
 80062c8:	f7ff fb1a 	bl	8005900 <ulPortSetInterruptMask>
 80062cc:	e7fe      	b.n	80062cc <uxQueueSpacesAvailable+0xa>

	taskENTER_CRITICAL();
 80062ce:	f7ff fb2d 	bl	800592c <vPortEnterCritical>
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
 80062d2:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80062d4:	6be4      	ldr	r4, [r4, #60]	; 0x3c
 80062d6:	1ae4      	subs	r4, r4, r3
	taskEXIT_CRITICAL();
 80062d8:	f7ff fb39 	bl	800594e <vPortExitCritical>

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 80062dc:	4620      	mov	r0, r4
 80062de:	bd10      	pop	{r4, pc}

080062e0 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle xQueue )
{
 80062e0:	b508      	push	{r3, lr}
unsigned portBASE_TYPE uxReturn;

	configASSERT( xQueue );
 80062e2:	b910      	cbnz	r0, 80062ea <uxQueueMessagesWaitingFromISR+0xa>
 80062e4:	f7ff fb0c 	bl	8005900 <ulPortSetInterruptMask>
 80062e8:	e7fe      	b.n	80062e8 <uxQueueMessagesWaitingFromISR+0x8>

	uxReturn = ( ( xQUEUE * ) xQueue )->uxMessagesWaiting;
 80062ea:	6b80      	ldr	r0, [r0, #56]	; 0x38

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 80062ec:	bd08      	pop	{r3, pc}

080062ee <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle xQueue )
{
 80062ee:	b510      	push	{r4, lr}
xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;

	configASSERT( pxQueue );
 80062f0:	4604      	mov	r4, r0
 80062f2:	b910      	cbnz	r0, 80062fa <vQueueDelete+0xc>
 80062f4:	f7ff fb04 	bl	8005900 <ulPortSetInterruptMask>
 80062f8:	e7fe      	b.n	80062f8 <vQueueDelete+0xa>
	#if ( configQUEUE_REGISTRY_SIZE > 0 )
	{
		vQueueUnregisterQueue( pxQueue );
	}
	#endif
	vPortFree( pxQueue->pcHead );
 80062fa:	6800      	ldr	r0, [r0, #0]
 80062fc:	f7ff faae 	bl	800585c <vPortFree>
	vPortFree( pxQueue );
 8006300:	4620      	mov	r0, r4
}
 8006302:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	{
		vQueueUnregisterQueue( pxQueue );
	}
	#endif
	vPortFree( pxQueue->pcHead );
	vPortFree( pxQueue );
 8006306:	f7ff baa9 	b.w	800585c <vPortFree>

0800630a <xQueueIsQueueEmptyFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle xQueue )
{
 800630a:	b508      	push	{r3, lr}
signed portBASE_TYPE xReturn;

	configASSERT( xQueue );
 800630c:	b910      	cbnz	r0, 8006314 <xQueueIsQueueEmptyFromISR+0xa>
 800630e:	f7ff faf7 	bl	8005900 <ulPortSetInterruptMask>
 8006312:	e7fe      	b.n	8006312 <xQueueIsQueueEmptyFromISR+0x8>
	if( ( ( xQUEUE * ) xQueue )->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 )
 8006314:	6b80      	ldr	r0, [r0, #56]	; 0x38
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 8006316:	f1d0 0001 	rsbs	r0, r0, #1
 800631a:	bf38      	it	cc
 800631c:	2000      	movcc	r0, #0
 800631e:	bd08      	pop	{r3, pc}

08006320 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle xQueue )
{
 8006320:	b508      	push	{r3, lr}
signed portBASE_TYPE xReturn;

	configASSERT( xQueue );
 8006322:	b910      	cbnz	r0, 800632a <xQueueIsQueueFullFromISR+0xa>
 8006324:	f7ff faec 	bl	8005900 <ulPortSetInterruptMask>
 8006328:	e7fe      	b.n	8006328 <xQueueIsQueueFullFromISR+0x8>
	if( ( ( xQUEUE * ) xQueue )->uxMessagesWaiting == ( ( xQUEUE * ) xQueue )->uxLength )
 800632a:	6b82      	ldr	r2, [r0, #56]	; 0x38
 800632c:	6bc0      	ldr	r0, [r0, #60]	; 0x3c
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 800632e:	1a13      	subs	r3, r2, r0
 8006330:	4258      	negs	r0, r3
 8006332:	4158      	adcs	r0, r3
 8006334:	bd08      	pop	{r3, pc}

08006336 <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	signed portBASE_TYPE xQueueCRSend( xQueueHandle xQueue, const void *pvItemToQueue, portTickType xTicksToWait )
	{
 8006336:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800633a:	4604      	mov	r4, r0
 800633c:	460e      	mov	r6, r1
 800633e:	4615      	mov	r5, r2
	xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;

		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
 8006340:	f7ff fade 	bl	8005900 <ulPortSetInterruptMask>

static signed portBASE_TYPE prvIsQueueFull( const xQUEUE *pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
 8006344:	f7ff faf2 	bl	800592c <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 8006348:	f8d4 8038 	ldr.w	r8, [r4, #56]	; 0x38
 800634c:	6be7      	ldr	r7, [r4, #60]	; 0x3c
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 800634e:	f7ff fafe 	bl	800594e <vPortExitCritical>
		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 8006352:	45b8      	cmp	r8, r7
 8006354:	d10c      	bne.n	8006370 <xQueueCRSend+0x3a>
				posting? */
				if( xTicksToWait > ( portTickType ) 0 )
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
 8006356:	4628      	mov	r0, r5
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				/* The queue is full - do we want to block or just leave without
				posting? */
				if( xTicksToWait > ( portTickType ) 0 )
 8006358:	b33d      	cbz	r5, 80063aa <xQueueCRSend+0x74>
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
 800635a:	f104 0110 	add.w	r1, r4, #16
 800635e:	f7ff fc13 	bl	8005b88 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
 8006362:	2000      	movs	r0, #0
 8006364:	f7ff faf0 	bl	8005948 <vPortClearInterruptMask>
					return errQUEUE_BLOCKED;
 8006368:	f06f 0003 	mvn.w	r0, #3
 800636c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
					portENABLE_INTERRUPTS();
					return errQUEUE_FULL;
				}
			}
		}
		portENABLE_INTERRUPTS();
 8006370:	2000      	movs	r0, #0
 8006372:	f7ff fae9 	bl	8005948 <vPortClearInterruptMask>

		portDISABLE_INTERRUPTS();
 8006376:	f7ff fac3 	bl	8005900 <ulPortSetInterruptMask>
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 800637a:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 800637c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800637e:	429a      	cmp	r2, r3
 8006380:	d211      	bcs.n	80063a6 <xQueueCRSend+0x70>
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
 8006382:	4620      	mov	r0, r4
 8006384:	4631      	mov	r1, r6
 8006386:	2200      	movs	r2, #0
 8006388:	f7ff fcfc 	bl	8005d84 <prvCopyDataToQueue>
				xReturn = pdPASS;

				/* Were any co-routines waiting for data to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800638c:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800638e:	b90b      	cbnz	r3, 8006394 <xQueueCRSend+0x5e>
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
				xReturn = pdPASS;
 8006390:	2501      	movs	r5, #1
 8006392:	e009      	b.n	80063a8 <xQueueCRSend+0x72>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8006394:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8006398:	f7ff fc9a 	bl	8005cd0 <xCoRoutineRemoveFromEventList>
 800639c:	2800      	cmp	r0, #0
 800639e:	d0f7      	beq.n	8006390 <xQueueCRSend+0x5a>
					{
						/* The co-routine waiting has a higher priority so record
						that a yield might be appropriate. */
						xReturn = errQUEUE_YIELD;
 80063a0:	f06f 0504 	mvn.w	r5, #4
 80063a4:	e000      	b.n	80063a8 <xQueueCRSend+0x72>
					}
				}
			}
			else
			{
				xReturn = errQUEUE_FULL;
 80063a6:	2500      	movs	r5, #0
			}
		}
		portENABLE_INTERRUPTS();
 80063a8:	2000      	movs	r0, #0
 80063aa:	f7ff facd 	bl	8005948 <vPortClearInterruptMask>

		return xReturn;
 80063ae:	4628      	mov	r0, r5
	}
 80063b0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

080063b4 <xQueueCRReceive>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	signed portBASE_TYPE xQueueCRReceive( xQueueHandle xQueue, void *pvBuffer, portTickType xTicksToWait )
	{
 80063b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80063b6:	4604      	mov	r4, r0
 80063b8:	460f      	mov	r7, r1
 80063ba:	4615      	mov	r5, r2
	xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;

		/* If the queue is already empty we may have to block.  A critical section
		is required to prevent an interrupt adding something to the queue
		between the check to see if the queue is empty and blocking on the queue. */
		portDISABLE_INTERRUPTS();
 80063bc:	f7ff faa0 	bl	8005900 <ulPortSetInterruptMask>
		{
			if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 )
 80063c0:	6ba6      	ldr	r6, [r4, #56]	; 0x38
 80063c2:	b95e      	cbnz	r6, 80063dc <xQueueCRReceive+0x28>
				leave with nothing? */
				if( xTicksToWait > ( portTickType ) 0 )
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
 80063c4:	4628      	mov	r0, r5
		{
			if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 )
			{
				/* There are no messages in the queue, do we want to block or just
				leave with nothing? */
				if( xTicksToWait > ( portTickType ) 0 )
 80063c6:	b36d      	cbz	r5, 8006424 <xQueueCRReceive+0x70>
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
 80063c8:	f104 0124 	add.w	r1, r4, #36	; 0x24
 80063cc:	f7ff fbdc 	bl	8005b88 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
 80063d0:	4630      	mov	r0, r6
 80063d2:	f7ff fab9 	bl	8005948 <vPortClearInterruptMask>
					return errQUEUE_BLOCKED;
 80063d6:	f06f 0003 	mvn.w	r0, #3
 80063da:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
					portENABLE_INTERRUPTS();
					return errQUEUE_FULL;
				}
			}
		}
		portENABLE_INTERRUPTS();
 80063dc:	2000      	movs	r0, #0
 80063de:	f7ff fab3 	bl	8005948 <vPortClearInterruptMask>

		portDISABLE_INTERRUPTS();
 80063e2:	f7ff fa8d 	bl	8005900 <ulPortSetInterruptMask>
		{
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 80063e6:	6ba5      	ldr	r5, [r4, #56]	; 0x38
 80063e8:	b1dd      	cbz	r5, 8006422 <xQueueCRReceive+0x6e>
			{
				/* Data is available from the queue. */
				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 80063ea:	68e3      	ldr	r3, [r4, #12]
 80063ec:	6c22      	ldr	r2, [r4, #64]	; 0x40
				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
 80063ee:	6861      	ldr	r1, [r4, #4]
		portDISABLE_INTERRUPTS();
		{
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
			{
				/* Data is available from the queue. */
				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 80063f0:	4413      	add	r3, r2
				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
 80063f2:	428b      	cmp	r3, r1
		portDISABLE_INTERRUPTS();
		{
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
			{
				/* Data is available from the queue. */
				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 80063f4:	60e3      	str	r3, [r4, #12]
				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
				{
					pxQueue->u.pcReadFrom = pxQueue->pcHead;
 80063f6:	bf24      	itt	cs
 80063f8:	6823      	ldrcs	r3, [r4, #0]
 80063fa:	60e3      	strcs	r3, [r4, #12]
				}
				--( pxQueue->uxMessagesWaiting );
 80063fc:	6ba3      	ldr	r3, [r4, #56]	; 0x38
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
 80063fe:	68e1      	ldr	r1, [r4, #12]
				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
				{
					pxQueue->u.pcReadFrom = pxQueue->pcHead;
				}
				--( pxQueue->uxMessagesWaiting );
 8006400:	3b01      	subs	r3, #1
 8006402:	63a3      	str	r3, [r4, #56]	; 0x38
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
 8006404:	4638      	mov	r0, r7
 8006406:	f001 fa25 	bl	8007854 <memcpy>

				xReturn = pdPASS;

				/* Were any co-routines waiting for space to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800640a:	6923      	ldr	r3, [r4, #16]
 800640c:	b90b      	cbnz	r3, 8006412 <xQueueCRReceive+0x5e>
					pxQueue->u.pcReadFrom = pxQueue->pcHead;
				}
				--( pxQueue->uxMessagesWaiting );
				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

				xReturn = pdPASS;
 800640e:	2501      	movs	r5, #1
 8006410:	e007      	b.n	8006422 <xQueueCRReceive+0x6e>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8006412:	f104 0010 	add.w	r0, r4, #16
 8006416:	f7ff fc5b 	bl	8005cd0 <xCoRoutineRemoveFromEventList>
 800641a:	2800      	cmp	r0, #0
 800641c:	d0f7      	beq.n	800640e <xQueueCRReceive+0x5a>
					{
						xReturn = errQUEUE_YIELD;
 800641e:	f06f 0504 	mvn.w	r5, #4
			else
			{
				xReturn = pdFAIL;
			}
		}
		portENABLE_INTERRUPTS();
 8006422:	2000      	movs	r0, #0
 8006424:	f7ff fa90 	bl	8005948 <vPortClearInterruptMask>

		return xReturn;
 8006428:	4628      	mov	r0, r5
	}
 800642a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0800642c <xQueueCRSendFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	signed portBASE_TYPE xQueueCRSendFromISR( xQueueHandle xQueue, const void *pvItemToQueue, signed portBASE_TYPE xCoRoutinePreviouslyWoken )
	{
 800642c:	b538      	push	{r3, r4, r5, lr}
 800642e:	4615      	mov	r5, r2
	xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;

		/* Cannot block within an ISR so if there is no space on the queue then
		exit without doing anything. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 8006430:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 8006432:	6b82      	ldr	r2, [r0, #56]	; 0x38
 8006434:	429a      	cmp	r2, r3
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	signed portBASE_TYPE xQueueCRSendFromISR( xQueueHandle xQueue, const void *pvItemToQueue, signed portBASE_TYPE xCoRoutinePreviouslyWoken )
	{
 8006436:	4604      	mov	r4, r0
	xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;

		/* Cannot block within an ISR so if there is no space on the queue then
		exit without doing anything. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 8006438:	d301      	bcc.n	800643e <xQueueCRSendFromISR+0x12>
 800643a:	4628      	mov	r0, r5
 800643c:	bd38      	pop	{r3, r4, r5, pc}
		{
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
 800643e:	2200      	movs	r2, #0
 8006440:	f7ff fca0 	bl	8005d84 <prvCopyDataToQueue>

			/* We only want to wake one co-routine per ISR, so check that a
			co-routine has not already been woken. */
			if( xCoRoutinePreviouslyWoken == pdFALSE )
 8006444:	2d00      	cmp	r5, #0
 8006446:	d1f8      	bne.n	800643a <xQueueCRSendFromISR+0xe>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8006448:	6a60      	ldr	r0, [r4, #36]	; 0x24
 800644a:	b130      	cbz	r0, 800645a <xQueueCRSendFromISR+0x2e>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800644c:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8006450:	f7ff fc3e 	bl	8005cd0 <xCoRoutineRemoveFromEventList>
 8006454:	3000      	adds	r0, #0
 8006456:	bf18      	it	ne
 8006458:	2001      	movne	r0, #1
				}
			}
		}

		return xCoRoutinePreviouslyWoken;
	}
 800645a:	bd38      	pop	{r3, r4, r5, pc}

0800645c <xQueueCRReceiveFromISR>:
	signed portBASE_TYPE xReturn;
	xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;

		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 800645c:	6b83      	ldr	r3, [r0, #56]	; 0x38
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	signed portBASE_TYPE xQueueCRReceiveFromISR( xQueueHandle xQueue, void *pvBuffer, signed portBASE_TYPE *pxCoRoutineWoken )
	{
 800645e:	b570      	push	{r4, r5, r6, lr}
 8006460:	4604      	mov	r4, r0
 8006462:	4615      	mov	r5, r2
	signed portBASE_TYPE xReturn;
	xQUEUE * const pxQueue = ( xQUEUE * ) xQueue;

		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 8006464:	b1fb      	cbz	r3, 80064a6 <xQueueCRReceiveFromISR+0x4a>
		{
			/* Copy the data from the queue. */
			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 8006466:	68c3      	ldr	r3, [r0, #12]
 8006468:	6c02      	ldr	r2, [r0, #64]	; 0x40
			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
 800646a:	6846      	ldr	r6, [r0, #4]
		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
		{
			/* Copy the data from the queue. */
			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 800646c:	4413      	add	r3, r2
			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
 800646e:	42b3      	cmp	r3, r6
		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
		{
			/* Copy the data from the queue. */
			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 8006470:	60c3      	str	r3, [r0, #12]
			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
			{
				pxQueue->u.pcReadFrom = pxQueue->pcHead;
 8006472:	bf24      	itt	cs
 8006474:	6803      	ldrcs	r3, [r0, #0]
 8006476:	60c3      	strcs	r3, [r0, #12]
			}
			--( pxQueue->uxMessagesWaiting );
 8006478:	6b83      	ldr	r3, [r0, #56]	; 0x38
 800647a:	3b01      	subs	r3, #1
 800647c:	6383      	str	r3, [r0, #56]	; 0x38
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
 800647e:	4608      	mov	r0, r1
 8006480:	68e1      	ldr	r1, [r4, #12]
 8006482:	f001 f9e7 	bl	8007854 <memcpy>

			if( ( *pxCoRoutineWoken ) == pdFALSE )
 8006486:	682b      	ldr	r3, [r5, #0]
 8006488:	b10b      	cbz	r3, 800648e <xQueueCRReceiveFromISR+0x32>
						*pxCoRoutineWoken = pdTRUE;
					}
				}
			}

			xReturn = pdPASS;
 800648a:	2001      	movs	r0, #1
 800648c:	bd70      	pop	{r4, r5, r6, pc}
			--( pxQueue->uxMessagesWaiting );
			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

			if( ( *pxCoRoutineWoken ) == pdFALSE )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800648e:	6923      	ldr	r3, [r4, #16]
 8006490:	2b00      	cmp	r3, #0
 8006492:	d0fa      	beq.n	800648a <xQueueCRReceiveFromISR+0x2e>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8006494:	f104 0010 	add.w	r0, r4, #16
 8006498:	f7ff fc1a 	bl	8005cd0 <xCoRoutineRemoveFromEventList>
 800649c:	2800      	cmp	r0, #0
 800649e:	d0f4      	beq.n	800648a <xQueueCRReceiveFromISR+0x2e>
					{
						*pxCoRoutineWoken = pdTRUE;
 80064a0:	2001      	movs	r0, #1
 80064a2:	6028      	str	r0, [r5, #0]
 80064a4:	bd70      	pop	{r4, r5, r6, pc}

			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
 80064a6:	4618      	mov	r0, r3
		}

		return xReturn;
	}
 80064a8:	bd70      	pop	{r4, r5, r6, pc}

080064aa <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( xQueueHandle xQueue, portTickType xTicksToWait )
	{
 80064aa:	b538      	push	{r3, r4, r5, lr}
 80064ac:	4604      	mov	r4, r0
 80064ae:	460d      	mov	r5, r1
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
 80064b0:	f7ff fa3c 	bl	800592c <vPortEnterCritical>
 80064b4:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80064b6:	3301      	adds	r3, #1
 80064b8:	bf04      	itt	eq
 80064ba:	2300      	moveq	r3, #0
 80064bc:	6463      	streq	r3, [r4, #68]	; 0x44
 80064be:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 80064c0:	3301      	adds	r3, #1
 80064c2:	bf04      	itt	eq
 80064c4:	2300      	moveq	r3, #0
 80064c6:	64a3      	streq	r3, [r4, #72]	; 0x48
 80064c8:	f7ff fa41 	bl	800594e <vPortExitCritical>
		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0U )
 80064cc:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80064ce:	b923      	cbnz	r3, 80064da <vQueueWaitForMessageRestricted+0x30>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 80064d0:	f104 0024 	add.w	r0, r4, #36	; 0x24
 80064d4:	4629      	mov	r1, r5
 80064d6:	f000 fc5f 	bl	8006d98 <vTaskPlaceOnEventListRestricted>
		}
		prvUnlockQueue( pxQueue );
 80064da:	4620      	mov	r0, r4
	}
 80064dc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0U )
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
		}
		prvUnlockQueue( pxQueue );
 80064e0:	f7ff bc96 	b.w	8005e10 <prvUnlockQueue>

080064e4 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 80064e4:	4b0c      	ldr	r3, [pc, #48]	; (8006518 <prvAddCurrentTaskToDelayedList+0x34>)
 80064e6:	681a      	ldr	r2, [r3, #0]
	#endif /* vTaskDelete */
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
 80064e8:	b510      	push	{r4, lr}
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 80064ea:	6050      	str	r0, [r2, #4]

	if( xTimeToWake < xTickCount )
 80064ec:	685a      	ldr	r2, [r3, #4]
 80064ee:	4290      	cmp	r0, r2
	#endif /* vTaskDelete */
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
 80064f0:	4604      	mov	r4, r0
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
 80064f2:	d206      	bcs.n	8006502 <prvAddCurrentTaskToDelayedList+0x1e>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 80064f4:	6898      	ldr	r0, [r3, #8]
 80064f6:	6819      	ldr	r1, [r3, #0]
		if( xTimeToWake < xNextTaskUnblockTime )
		{
			xNextTaskUnblockTime = xTimeToWake;
		}
	}
}
 80064f8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 80064fc:	3104      	adds	r1, #4
 80064fe:	f7ff bc19 	b.w	8005d34 <vListInsert>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 8006502:	68d8      	ldr	r0, [r3, #12]
 8006504:	6819      	ldr	r1, [r3, #0]
 8006506:	3104      	adds	r1, #4
 8006508:	f7ff fc14 	bl	8005d34 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
 800650c:	4b03      	ldr	r3, [pc, #12]	; (800651c <prvAddCurrentTaskToDelayedList+0x38>)
 800650e:	681a      	ldr	r2, [r3, #0]
 8006510:	4294      	cmp	r4, r2
		{
			xNextTaskUnblockTime = xTimeToWake;
 8006512:	bf38      	it	cc
 8006514:	601c      	strcc	r4, [r3, #0]
 8006516:	bd10      	pop	{r4, pc}
 8006518:	20002dc4 	.word	0x20002dc4
 800651c:	20000030 	.word	0x20000030

08006520 <xTaskGenericCreate>:
	static portTickType prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;

#endif

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
 8006520:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006524:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 8006526:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 8006528:	f8dd b030 	ldr.w	fp, [sp, #48]	; 0x30
 800652c:	4689      	mov	r9, r1
 800652e:	4615      	mov	r5, r2
 8006530:	469a      	mov	sl, r3
signed portBASE_TYPE xReturn;
tskTCB * pxNewTCB;

	configASSERT( pxTaskCode );
 8006532:	4680      	mov	r8, r0
 8006534:	b910      	cbnz	r0, 800653c <xTaskGenericCreate+0x1c>
 8006536:	f7ff f9e3 	bl	8005900 <ulPortSetInterruptMask>
 800653a:	e7fe      	b.n	800653a <xTaskGenericCreate+0x1a>
	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
 800653c:	2f04      	cmp	r7, #4
 800653e:	d902      	bls.n	8006546 <xTaskGenericCreate+0x26>
 8006540:	f7ff f9de 	bl	8005900 <ulPortSetInterruptMask>
 8006544:	e7fe      	b.n	8006544 <xTaskGenericCreate+0x24>
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 8006546:	2044      	movs	r0, #68	; 0x44
 8006548:	f7ff f95c 	bl	8005804 <pvPortMalloc>

	if( pxNewTCB != NULL )
 800654c:	4604      	mov	r4, r0
 800654e:	2800      	cmp	r0, #0
 8006550:	f000 809e 	beq.w	8006690 <xTaskGenericCreate+0x170>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8006554:	4658      	mov	r0, fp
 8006556:	f1bb 0f00 	cmp.w	fp, #0
 800655a:	d102      	bne.n	8006562 <xTaskGenericCreate+0x42>
 800655c:	00a8      	lsls	r0, r5, #2
 800655e:	f7ff f951 	bl	8005804 <pvPortMalloc>
 8006562:	6320      	str	r0, [r4, #48]	; 0x30

		if( pxNewTCB->pxStack == NULL )
 8006564:	b918      	cbnz	r0, 800656e <xTaskGenericCreate+0x4e>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
 8006566:	4620      	mov	r0, r4
 8006568:	f7ff f978 	bl	800585c <vPortFree>
 800656c:	e090      	b.n	8006690 <xTaskGenericCreate+0x170>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
 800656e:	00ad      	lsls	r5, r5, #2
 8006570:	462a      	mov	r2, r5
 8006572:	21a5      	movs	r1, #165	; 0xa5
 8006574:	f001 fd5a 	bl	800802c <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
 8006578:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800657a:	3d04      	subs	r5, #4
 800657c:	442b      	add	r3, r5
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK  ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 800657e:	f023 0b07 	bic.w	fp, r3, #7
static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
unsigned portBASE_TYPE x;

	/* Store the task name in the TCB. */
	for( x = ( unsigned portBASE_TYPE ) 0; x < ( unsigned portBASE_TYPE ) configMAX_TASK_NAME_LEN; x++ )
 8006582:	2500      	movs	r5, #0
 8006584:	1963      	adds	r3, r4, r5
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
 8006586:	f819 2005 	ldrb.w	r2, [r9, r5]
 800658a:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
 800658e:	f919 3005 	ldrsb.w	r3, [r9, r5]
 8006592:	b113      	cbz	r3, 800659a <xTaskGenericCreate+0x7a>
static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
unsigned portBASE_TYPE x;

	/* Store the task name in the TCB. */
	for( x = ( unsigned portBASE_TYPE ) 0; x < ( unsigned portBASE_TYPE ) configMAX_TASK_NAME_LEN; x++ )
 8006594:	3501      	adds	r5, #1
 8006596:	2d0a      	cmp	r5, #10
 8006598:	d1f4      	bne.n	8006584 <xTaskGenericCreate+0x64>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = ( signed char ) '\0';
 800659a:	2300      	movs	r3, #0
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 800659c:	f104 0904 	add.w	r9, r4, #4
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = ( signed char ) '\0';
 80065a0:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 80065a4:	4648      	mov	r0, r9
	if( uxPriority >= ( unsigned portBASE_TYPE ) configMAX_PRIORITIES )
	{
		uxPriority = ( unsigned portBASE_TYPE ) configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
 80065a6:	62e7      	str	r7, [r4, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
 80065a8:	6427      	str	r7, [r4, #64]	; 0x40
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 80065aa:	f7ff fbb4 	bl	8005d16 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 80065ae:	f104 0018 	add.w	r0, r4, #24
 80065b2:	f7ff fbb0 	bl	8005d16 <vListInitialiseItem>
	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( portTickType ) configMAX_PRIORITIES - ( portTickType ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80065b6:	f1c7 0305 	rsb	r3, r7, #5
	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
	vListInitialiseItem( &( pxTCB->xEventListItem ) );

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 80065ba:	6124      	str	r4, [r4, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( portTickType ) configMAX_PRIORITIES - ( portTickType ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80065bc:	61a3      	str	r3, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 80065be:	6264      	str	r4, [r4, #36]	; 0x24
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 80065c0:	4658      	mov	r0, fp
 80065c2:	4641      	mov	r1, r8
 80065c4:	4652      	mov	r2, sl
 80065c6:	f7ff f970 	bl	80058aa <pxPortInitialiseStack>
 80065ca:	6020      	str	r0, [r4, #0]
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
 80065cc:	b106      	cbz	r6, 80065d0 <xTaskGenericCreate+0xb0>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 80065ce:	6034      	str	r4, [r6, #0]

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
		{
			uxCurrentNumberOfTasks++;
 80065d0:	4d31      	ldr	r5, [pc, #196]	; (8006698 <xTaskGenericCreate+0x178>)
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
 80065d2:	f7ff f9ab 	bl	800592c <vPortEnterCritical>
		{
			uxCurrentNumberOfTasks++;
 80065d6:	692b      	ldr	r3, [r5, #16]
 80065d8:	3301      	adds	r3, #1
 80065da:	612b      	str	r3, [r5, #16]
			if( pxCurrentTCB == NULL )
 80065dc:	682b      	ldr	r3, [r5, #0]
 80065de:	f105 0a14 	add.w	sl, r5, #20
 80065e2:	bb4b      	cbnz	r3, 8006638 <xTaskGenericCreate+0x118>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
 80065e4:	602c      	str	r4, [r5, #0]

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 80065e6:	692a      	ldr	r2, [r5, #16]
 80065e8:	2a01      	cmp	r2, #1
 80065ea:	d12d      	bne.n	8006648 <xTaskGenericCreate+0x128>
 80065ec:	4698      	mov	r8, r3
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < ( unsigned portBASE_TYPE ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 80065ee:	eb0a 0008 	add.w	r0, sl, r8
 80065f2:	f108 0814 	add.w	r8, r8, #20
 80065f6:	f7ff fb83 	bl	8005d00 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < ( unsigned portBASE_TYPE ) configMAX_PRIORITIES; uxPriority++ )
 80065fa:	f1b8 0f64 	cmp.w	r8, #100	; 0x64
 80065fe:	4e26      	ldr	r6, [pc, #152]	; (8006698 <xTaskGenericCreate+0x178>)
 8006600:	d1f5      	bne.n	80065ee <xTaskGenericCreate+0xce>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
 8006602:	f106 0b78 	add.w	fp, r6, #120	; 0x78
 8006606:	4658      	mov	r0, fp
	vListInitialise( &xDelayedTaskList2 );
 8006608:	f106 088c 	add.w	r8, r6, #140	; 0x8c
	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < ( unsigned portBASE_TYPE ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
 800660c:	f7ff fb78 	bl	8005d00 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 8006610:	4640      	mov	r0, r8
 8006612:	f7ff fb75 	bl	8005d00 <vListInitialise>
	vListInitialise( &xPendingReadyList );
 8006616:	f106 00a0 	add.w	r0, r6, #160	; 0xa0
 800661a:	f7ff fb71 	bl	8005d00 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
 800661e:	f106 00b4 	add.w	r0, r6, #180	; 0xb4
 8006622:	f7ff fb6d 	bl	8005d00 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
 8006626:	f106 00c8 	add.w	r0, r6, #200	; 0xc8
 800662a:	f7ff fb69 	bl	8005d00 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 800662e:	f8c6 b00c 	str.w	fp, [r6, #12]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 8006632:	f8c6 8008 	str.w	r8, [r6, #8]
 8006636:	e007      	b.n	8006648 <xTaskGenericCreate+0x128>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
 8006638:	f8d5 30dc 	ldr.w	r3, [r5, #220]	; 0xdc
 800663c:	b923      	cbnz	r3, 8006648 <xTaskGenericCreate+0x128>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
 800663e:	682b      	ldr	r3, [r5, #0]
 8006640:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006642:	42bb      	cmp	r3, r7
					{
						pxCurrentTCB = pxNewTCB;
 8006644:	bf98      	it	ls
 8006646:	602c      	strls	r4, [r5, #0]
					}
				}
			}

			uxTaskNumber++;
 8006648:	f8d5 30e0 	ldr.w	r3, [r5, #224]	; 0xe0
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
 800664c:	f8d5 20e4 	ldr.w	r2, [r5, #228]	; 0xe4
						pxCurrentTCB = pxNewTCB;
					}
				}
			}

			uxTaskNumber++;
 8006650:	3301      	adds	r3, #1
 8006652:	f8c5 30e0 	str.w	r3, [r5, #224]	; 0xe0
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
 8006656:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8006658:	4293      	cmp	r3, r2
 800665a:	bf88      	it	hi
 800665c:	4a0e      	ldrhi	r2, [pc, #56]	; (8006698 <xTaskGenericCreate+0x178>)
 800665e:	f04f 0014 	mov.w	r0, #20
 8006662:	fb00 a003 	mla	r0, r0, r3, sl
 8006666:	4649      	mov	r1, r9
 8006668:	bf88      	it	hi
 800666a:	f8c2 30e4 	strhi.w	r3, [r2, #228]	; 0xe4
 800666e:	f7ff fb55 	bl	8005d1c <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
 8006672:	f7ff f96c 	bl	800594e <vPortExitCritical>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
 8006676:	f8d5 30dc 	ldr.w	r3, [r5, #220]	; 0xdc
 800667a:	b133      	cbz	r3, 800668a <xTaskGenericCreate+0x16a>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
 800667c:	4b06      	ldr	r3, [pc, #24]	; (8006698 <xTaskGenericCreate+0x178>)
 800667e:	681b      	ldr	r3, [r3, #0]
 8006680:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006682:	42bb      	cmp	r3, r7
 8006684:	d201      	bcs.n	800668a <xTaskGenericCreate+0x16a>
			{
				portYIELD_WITHIN_API();
 8006686:	f7ff f930 	bl	80058ea <vPortYield>
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );

			xReturn = pdPASS;
 800668a:	2001      	movs	r0, #1
 800668c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 8006690:	f04f 30ff 	mov.w	r0, #4294967295
			}
		}
	}

	return xReturn;
}
 8006694:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8006698:	20002dc4 	.word	0x20002dc4

0800669c <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle xTaskToDelete )
	{
 800669c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800669e:	4604      	mov	r4, r0
 80066a0:	4d15      	ldr	r5, [pc, #84]	; (80066f8 <vTaskDelete+0x5c>)
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
 80066a2:	f7ff f943 	bl	800592c <vPortEnterCritical>
		{
			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 80066a6:	b904      	cbnz	r4, 80066aa <vTaskDelete+0xe>
 80066a8:	682c      	ldr	r4, [r5, #0]

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
 80066aa:	1d26      	adds	r6, r4, #4
 80066ac:	4630      	mov	r0, r6
 80066ae:	f7ff fb59 	bl	8005d64 <uxListRemove>
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 80066b2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80066b4:	b11b      	cbz	r3, 80066be <vTaskDelete+0x22>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 80066b6:	f104 0018 	add.w	r0, r4, #24
 80066ba:	f7ff fb53 	bl	8005d64 <uxListRemove>
			}

			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
 80066be:	4f0e      	ldr	r7, [pc, #56]	; (80066f8 <vTaskDelete+0x5c>)
 80066c0:	4631      	mov	r1, r6
 80066c2:	f107 00b4 	add.w	r0, r7, #180	; 0xb4
 80066c6:	f7ff fb29 	bl	8005d1c <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
 80066ca:	f8d5 30e8 	ldr.w	r3, [r5, #232]	; 0xe8
 80066ce:	3301      	adds	r3, #1
 80066d0:	f8c5 30e8 	str.w	r3, [r5, #232]	; 0xe8

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
 80066d4:	f8d5 30e0 	ldr.w	r3, [r5, #224]	; 0xe0
 80066d8:	3301      	adds	r3, #1
 80066da:	f8c5 30e0 	str.w	r3, [r5, #224]	; 0xe0

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
 80066de:	f7ff f936 	bl	800594e <vPortExitCritical>

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
 80066e2:	f8d5 30dc 	ldr.w	r3, [r5, #220]	; 0xdc
 80066e6:	b133      	cbz	r3, 80066f6 <vTaskDelete+0x5a>
		{
			if( pxTCB == pxCurrentTCB )
 80066e8:	683b      	ldr	r3, [r7, #0]
 80066ea:	429c      	cmp	r4, r3
 80066ec:	d103      	bne.n	80066f6 <vTaskDelete+0x5a>
			{
				portYIELD_WITHIN_API();
			}
		}
	}
 80066ee:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
		{
			if( pxTCB == pxCurrentTCB )
			{
				portYIELD_WITHIN_API();
 80066f2:	f7ff b8fa 	b.w	80058ea <vPortYield>
 80066f6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80066f8:	20002dc4 	.word	0x20002dc4

080066fc <uxTaskPriorityGet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle xTask )
	{
 80066fc:	b510      	push	{r4, lr}
 80066fe:	4604      	mov	r4, r0
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxReturn;

		taskENTER_CRITICAL();
 8006700:	f7ff f914 	bl	800592c <vPortEnterCritical>
		{
			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( xTask );
 8006704:	b90c      	cbnz	r4, 800670a <uxTaskPriorityGet+0xe>
 8006706:	4b03      	ldr	r3, [pc, #12]	; (8006714 <uxTaskPriorityGet+0x18>)
 8006708:	681c      	ldr	r4, [r3, #0]
			uxReturn = pxTCB->uxPriority;
 800670a:	6ae4      	ldr	r4, [r4, #44]	; 0x2c
		}
		taskEXIT_CRITICAL();
 800670c:	f7ff f91f 	bl	800594e <vPortExitCritical>

		return uxReturn;
	}
 8006710:	4620      	mov	r0, r4
 8006712:	bd10      	pop	{r4, pc}
 8006714:	20002dc4 	.word	0x20002dc4

08006718 <vTaskPrioritySet>:
	{
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxCurrentBasePriority, uxPriorityUsedOnEntry;
	portBASE_TYPE xYieldRequired = pdFALSE;

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
 8006718:	2904      	cmp	r1, #4
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( xTaskHandle xTask, unsigned portBASE_TYPE uxNewPriority )
	{
 800671a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800671e:	4604      	mov	r4, r0
 8006720:	460d      	mov	r5, r1
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxCurrentBasePriority, uxPriorityUsedOnEntry;
	portBASE_TYPE xYieldRequired = pdFALSE;

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
 8006722:	d902      	bls.n	800672a <vTaskPrioritySet+0x12>
 8006724:	f7ff f8ec 	bl	8005900 <ulPortSetInterruptMask>
 8006728:	e7fe      	b.n	8006728 <vTaskPrioritySet+0x10>
		if( uxNewPriority >= ( unsigned portBASE_TYPE ) configMAX_PRIORITIES )
		{
			uxNewPriority = ( unsigned portBASE_TYPE ) configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
		}

		taskENTER_CRITICAL();
 800672a:	f7ff f8ff 	bl	800592c <vPortEnterCritical>
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being changed. */
			pxTCB = prvGetTCBFromHandle( xTask );
 800672e:	b90c      	cbnz	r4, 8006734 <vTaskPrioritySet+0x1c>
 8006730:	4b20      	ldr	r3, [pc, #128]	; (80067b4 <vTaskPrioritySet+0x9c>)
 8006732:	681c      	ldr	r4, [r3, #0]

			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

			#if ( configUSE_MUTEXES == 1 )
			{
				uxCurrentBasePriority = pxTCB->uxBasePriority;
 8006734:	6c23      	ldr	r3, [r4, #64]	; 0x40
			{
				uxCurrentBasePriority = pxTCB->uxPriority;
			}
			#endif

			if( uxCurrentBasePriority != uxNewPriority )
 8006736:	42ab      	cmp	r3, r5
 8006738:	d038      	beq.n	80067ac <vTaskPrioritySet+0x94>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
 800673a:	429d      	cmp	r5, r3
 800673c:	4a1d      	ldr	r2, [pc, #116]	; (80067b4 <vTaskPrioritySet+0x9c>)
 800673e:	d909      	bls.n	8006754 <vTaskPrioritySet+0x3c>
				{
					if( pxTCB != pxCurrentTCB )
 8006740:	6811      	ldr	r1, [r2, #0]
 8006742:	428c      	cmp	r4, r1
 8006744:	d00b      	beq.n	800675e <vTaskPrioritySet+0x46>
					{
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
 8006746:	6812      	ldr	r2, [r2, #0]
 8006748:	6ad6      	ldr	r6, [r2, #44]	; 0x2c
 800674a:	42b5      	cmp	r5, r6
 800674c:	bf34      	ite	cc
 800674e:	2600      	movcc	r6, #0
 8006750:	2601      	movcs	r6, #1
 8006752:	e005      	b.n	8006760 <vTaskPrioritySet+0x48>
						/* The priority of the running task is being raised,
						but the running task must already be the highest
						priority task able to run so no yield is required. */
					}
				}
				else if( pxTCB == pxCurrentTCB )
 8006754:	6816      	ldr	r6, [r2, #0]
 8006756:	1ba2      	subs	r2, r4, r6
 8006758:	4256      	negs	r6, r2
 800675a:	4156      	adcs	r6, r2
 800675c:	e000      	b.n	8006760 <vTaskPrioritySet+0x48>

	void vTaskPrioritySet( xTaskHandle xTask, unsigned portBASE_TYPE uxNewPriority )
	{
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxCurrentBasePriority, uxPriorityUsedOnEntry;
	portBASE_TYPE xYieldRequired = pdFALSE;
 800675e:	2600      	movs	r6, #0
				}

				/* Remember the ready list the task might be referenced from
				before its uxPriority member is changed so the
				taskRESET_READY_PRIORITY() macro can function correctly. */
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
 8006760:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
					{
						pxTCB->uxPriority = uxNewPriority;
					}

					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
 8006762:	6425      	str	r5, [r4, #64]	; 0x40

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 8006764:	4293      	cmp	r3, r2
					{
						pxTCB->uxPriority = uxNewPriority;
 8006766:	bf08      	it	eq
 8006768:	62e5      	streq	r5, [r4, #44]	; 0x2c
				{
					pxTCB->uxPriority = uxNewPriority;
				}
				#endif

				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( portTickType ) configMAX_PRIORITIES - ( portTickType ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800676a:	f1c5 0505 	rsb	r5, r5, #5
 800676e:	61a5      	str	r5, [r4, #24]

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
 8006770:	4d10      	ldr	r5, [pc, #64]	; (80067b4 <vTaskPrioritySet+0x9c>)
 8006772:	2314      	movs	r3, #20
 8006774:	f105 0014 	add.w	r0, r5, #20
 8006778:	fb03 0202 	mla	r2, r3, r2, r0
 800677c:	6963      	ldr	r3, [r4, #20]
 800677e:	4293      	cmp	r3, r2
 8006780:	4680      	mov	r8, r0
 8006782:	d110      	bne.n	80067a6 <vTaskPrioritySet+0x8e>
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
 8006784:	1d27      	adds	r7, r4, #4
 8006786:	4638      	mov	r0, r7
 8006788:	f7ff faec 	bl	8005d64 <uxListRemove>
						/* It is known that the task is in its ready list so
						there is no need to check again and the port level
						reset macro can be called directly. */
						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
					}
					prvAddTaskToReadyList( pxTCB );
 800678c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800678e:	f8d5 20e4 	ldr.w	r2, [r5, #228]	; 0xe4
 8006792:	4293      	cmp	r3, r2
 8006794:	d901      	bls.n	800679a <vTaskPrioritySet+0x82>
 8006796:	f8c5 30e4 	str.w	r3, [r5, #228]	; 0xe4
 800679a:	2014      	movs	r0, #20
 800679c:	fb00 8003 	mla	r0, r0, r3, r8
 80067a0:	4639      	mov	r1, r7
 80067a2:	f7ff fabb 	bl	8005d1c <vListInsertEnd>
				}

				if( xYieldRequired == pdTRUE )
 80067a6:	b10e      	cbz	r6, 80067ac <vTaskPrioritySet+0x94>
				{
					portYIELD_WITHIN_API();
 80067a8:	f7ff f89f 	bl	80058ea <vPortYield>
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
	}
 80067ac:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
				/* Remove compiler warning about unused variables when the port
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
 80067b0:	f7ff b8cd 	b.w	800594e <vPortExitCritical>
 80067b4:	20002dc4 	.word	0x20002dc4

080067b8 <xTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
 80067b8:	b508      	push	{r3, lr}
	portBASE_TYPE xReturn = pdFALSE;
	const tskTCB * const pxTCB = ( tskTCB * ) xTask;

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );
 80067ba:	b910      	cbnz	r0, 80067c2 <xTaskIsTaskSuspended+0xa>
 80067bc:	f7ff f8a0 	bl	8005900 <ulPortSetInterruptMask>
 80067c0:	e7fe      	b.n	80067c0 <xTaskIsTaskSuspended+0x8>

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
 80067c2:	6943      	ldr	r3, [r0, #20]
 80067c4:	4a06      	ldr	r2, [pc, #24]	; (80067e0 <xTaskIsTaskSuspended+0x28>)
 80067c6:	4293      	cmp	r3, r2
 80067c8:	d108      	bne.n	80067dc <xTaskIsTaskSuspended+0x24>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
 80067ca:	6a80      	ldr	r0, [r0, #40]	; 0x28
 80067cc:	3b28      	subs	r3, #40	; 0x28
 80067ce:	4298      	cmp	r0, r3
 80067d0:	d004      	beq.n	80067dc <xTaskIsTaskSuspended+0x24>
			{
				/* Is it in the suspended list because it is in the
				Suspended state?  It is possible to be in the suspended
				list because it is blocked on a task with no timeout
				specified. */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
 80067d2:	f1d0 0001 	rsbs	r0, r0, #1
 80067d6:	bf38      	it	cc
 80067d8:	2000      	movcc	r0, #0
 80067da:	bd08      	pop	{r3, pc}

#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
	portBASE_TYPE xReturn = pdFALSE;
 80067dc:	2000      	movs	r0, #0
				}
			}
		}

		return xReturn;
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
 80067de:	bd08      	pop	{r3, pc}
 80067e0:	20002e8c 	.word	0x20002e8c

080067e4 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( xTaskHandle xTaskToResume )
	{
 80067e4:	b570      	push	{r4, r5, r6, lr}
	tskTCB * const pxTCB = ( tskTCB * ) xTaskToResume;

		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );
 80067e6:	4604      	mov	r4, r0
 80067e8:	b910      	cbnz	r0, 80067f0 <vTaskResume+0xc>
 80067ea:	f7ff f889 	bl	8005900 <ulPortSetInterruptMask>
 80067ee:	e7fe      	b.n	80067ee <vTaskResume+0xa>

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 80067f0:	4d14      	ldr	r5, [pc, #80]	; (8006844 <vTaskResume+0x60>)
 80067f2:	682b      	ldr	r3, [r5, #0]
 80067f4:	4298      	cmp	r0, r3
 80067f6:	d023      	beq.n	8006840 <vTaskResume+0x5c>
		{
			taskENTER_CRITICAL();
 80067f8:	f7ff f898 	bl	800592c <vPortEnterCritical>
			{
				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 80067fc:	4620      	mov	r0, r4
 80067fe:	f7ff ffdb 	bl	80067b8 <xTaskIsTaskSuspended>
 8006802:	2801      	cmp	r0, #1
 8006804:	d118      	bne.n	8006838 <vTaskResume+0x54>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
 8006806:	1d26      	adds	r6, r4, #4
 8006808:	4630      	mov	r0, r6
 800680a:	f7ff faab 	bl	8005d64 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 800680e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8006810:	f8d5 20e4 	ldr.w	r2, [r5, #228]	; 0xe4
 8006814:	4293      	cmp	r3, r2
 8006816:	4a0c      	ldr	r2, [pc, #48]	; (8006848 <vTaskResume+0x64>)
 8006818:	bf88      	it	hi
 800681a:	f8c5 30e4 	strhi.w	r3, [r5, #228]	; 0xe4
 800681e:	2014      	movs	r0, #20
 8006820:	fb00 2003 	mla	r0, r0, r3, r2
 8006824:	4631      	mov	r1, r6
 8006826:	f7ff fa79 	bl	8005d1c <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 800682a:	682b      	ldr	r3, [r5, #0]
 800682c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800682e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006830:	429a      	cmp	r2, r3
 8006832:	d301      	bcc.n	8006838 <vTaskResume+0x54>
					{
						/* This yield may not cause the task just resumed to run, but
						will leave the lists in the correct state for the next yield. */
						portYIELD_WITHIN_API();
 8006834:	f7ff f859 	bl	80058ea <vPortYield>
					}
				}
			}
			taskEXIT_CRITICAL();
		}
	}
 8006838:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
						will leave the lists in the correct state for the next yield. */
						portYIELD_WITHIN_API();
					}
				}
			}
			taskEXIT_CRITICAL();
 800683c:	f7ff b887 	b.w	800594e <vPortExitCritical>
 8006840:	bd70      	pop	{r4, r5, r6, pc}
 8006842:	bf00      	nop
 8006844:	20002dc4 	.word	0x20002dc4
 8006848:	20002dd8 	.word	0x20002dd8

0800684c <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle xTaskToResume )
	{
 800684c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	portBASE_TYPE xYieldRequired = pdFALSE;
	tskTCB * const pxTCB = ( tskTCB * ) xTaskToResume;
	unsigned portBASE_TYPE uxSavedInterruptStatus;

		configASSERT( xTaskToResume );
 8006850:	4604      	mov	r4, r0
 8006852:	b910      	cbnz	r0, 800685a <xTaskResumeFromISR+0xe>
 8006854:	f7ff f854 	bl	8005900 <ulPortSetInterruptMask>
 8006858:	e7fe      	b.n	8006858 <xTaskResumeFromISR+0xc>
		below the maximum system call interrupt priority.  FreeRTOS maintains a
		separate interrupt safe API to ensure interrupt entry is as fast and as
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 800685a:	f7ff f917 	bl	8005a8c <vPortValidateInterruptPriority>

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 800685e:	f7ff f84f 	bl	8005900 <ulPortSetInterruptMask>
 8006862:	4680      	mov	r8, r0
		{
			if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 8006864:	4620      	mov	r0, r4
 8006866:	f7ff ffa7 	bl	80067b8 <xTaskIsTaskSuspended>
 800686a:	2801      	cmp	r0, #1
 800686c:	d123      	bne.n	80068b6 <xTaskResumeFromISR+0x6a>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 800686e:	4d15      	ldr	r5, [pc, #84]	; (80068c4 <xTaskResumeFromISR+0x78>)
 8006870:	f8d5 30ec 	ldr.w	r3, [r5, #236]	; 0xec
 8006874:	b9cb      	cbnz	r3, 80068aa <xTaskResumeFromISR+0x5e>
				{
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8006876:	682a      	ldr	r2, [r5, #0]
 8006878:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800687a:	6ad6      	ldr	r6, [r2, #44]	; 0x2c
					{
						xYieldRequired = pdTRUE;
					}

					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
 800687c:	1d27      	adds	r7, r4, #4
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
				{
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 800687e:	42b3      	cmp	r3, r6
					{
						xYieldRequired = pdTRUE;
					}

					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
 8006880:	4638      	mov	r0, r7
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
				{
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8006882:	bf34      	ite	cc
 8006884:	2600      	movcc	r6, #0
 8006886:	2601      	movcs	r6, #1
					{
						xYieldRequired = pdTRUE;
					}

					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
 8006888:	f7ff fa6c 	bl	8005d64 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 800688c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800688e:	f8d5 20e4 	ldr.w	r2, [r5, #228]	; 0xe4
 8006892:	4293      	cmp	r3, r2
 8006894:	4a0c      	ldr	r2, [pc, #48]	; (80068c8 <xTaskResumeFromISR+0x7c>)
 8006896:	bf88      	it	hi
 8006898:	f8c5 30e4 	strhi.w	r3, [r5, #228]	; 0xe4
 800689c:	2014      	movs	r0, #20
 800689e:	fb00 2003 	mla	r0, r0, r3, r2
 80068a2:	4639      	mov	r1, r7
 80068a4:	f7ff fa3a 	bl	8005d1c <vListInsertEnd>
 80068a8:	e006      	b.n	80068b8 <xTaskResumeFromISR+0x6c>
				else
				{
					/* We cannot access the delayed or ready lists, so will hold this
					task pending until the scheduler is resumed, at which point a
					yield will be performed if necessary. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 80068aa:	f105 00a0 	add.w	r0, r5, #160	; 0xa0
 80068ae:	f104 0118 	add.w	r1, r4, #24
 80068b2:	f7ff fa33 	bl	8005d1c <vListInsertEnd>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle xTaskToResume )
	{
	portBASE_TYPE xYieldRequired = pdFALSE;
 80068b6:	2600      	movs	r6, #0
					yield will be performed if necessary. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 80068b8:	4640      	mov	r0, r8
 80068ba:	f7ff f845 	bl	8005948 <vPortClearInterruptMask>

		return xYieldRequired;
	}
 80068be:	4630      	mov	r0, r6
 80068c0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80068c4:	20002dc4 	.word	0x20002dc4
 80068c8:	20002dd8 	.word	0x20002dd8

080068cc <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
 80068cc:	b530      	push	{r4, r5, lr}
 80068ce:	b085      	sub	sp, #20
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
 80068d0:	2400      	movs	r4, #0
 80068d2:	9400      	str	r4, [sp, #0]
 80068d4:	9401      	str	r4, [sp, #4]
 80068d6:	9402      	str	r4, [sp, #8]
 80068d8:	9403      	str	r4, [sp, #12]
 80068da:	4810      	ldr	r0, [pc, #64]	; (800691c <vTaskStartScheduler+0x50>)
 80068dc:	4910      	ldr	r1, [pc, #64]	; (8006920 <vTaskStartScheduler+0x54>)
 80068de:	f44f 72a0 	mov.w	r2, #320	; 0x140
 80068e2:	4623      	mov	r3, r4
 80068e4:	f7ff fe1c 	bl	8006520 <xTaskGenericCreate>
	}
	#endif /* INCLUDE_xTaskGetIdleTaskHandle */

	#if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
 80068e8:	2801      	cmp	r0, #1
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
 80068ea:	4605      	mov	r5, r0
	}
	#endif /* INCLUDE_xTaskGetIdleTaskHandle */

	#if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
 80068ec:	d10f      	bne.n	800690e <vTaskStartScheduler+0x42>
		{
			xReturn = xTimerCreateTimerTask();
 80068ee:	f000 fb89 	bl	8007004 <xTimerCreateTimerTask>
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
 80068f2:	2801      	cmp	r0, #1

	#if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
		{
			xReturn = xTimerCreateTimerTask();
 80068f4:	4605      	mov	r5, r0
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
 80068f6:	d10a      	bne.n	800690e <vTaskStartScheduler+0x42>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
 80068f8:	f7ff f802 	bl	8005900 <ulPortSetInterruptMask>
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xSchedulerRunning = pdTRUE;
 80068fc:	4b09      	ldr	r3, [pc, #36]	; (8006924 <vTaskStartScheduler+0x58>)
 80068fe:	f8c3 50dc 	str.w	r5, [r3, #220]	; 0xdc
		xTickCount = ( portTickType ) 0U;
 8006902:	605c      	str	r4, [r3, #4]
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
 8006904:	b005      	add	sp, #20
 8006906:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
 800690a:	f7ff b871 	b.w	80059f0 <xPortStartScheduler>
	else
	{
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
 800690e:	b915      	cbnz	r5, 8006916 <vTaskStartScheduler+0x4a>
 8006910:	f7fe fff6 	bl	8005900 <ulPortSetInterruptMask>
 8006914:	e7fe      	b.n	8006914 <vTaskStartScheduler+0x48>
	}
}
 8006916:	b005      	add	sp, #20
 8006918:	bd30      	pop	{r4, r5, pc}
 800691a:	bf00      	nop
 800691c:	08006bf1 	.word	0x08006bf1
 8006920:	08009d3d 	.word	0x08009d3d
 8006924:	20002dc4 	.word	0x20002dc4

08006928 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
 8006928:	b508      	push	{r3, lr}
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
 800692a:	f7fe ffe9 	bl	8005900 <ulPortSetInterruptMask>
	xSchedulerRunning = pdFALSE;
 800692e:	4b04      	ldr	r3, [pc, #16]	; (8006940 <vTaskEndScheduler+0x18>)
 8006930:	2200      	movs	r2, #0
 8006932:	f8c3 20dc 	str.w	r2, [r3, #220]	; 0xdc
	vPortEndScheduler();
}
 8006936:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
	xSchedulerRunning = pdFALSE;
	vPortEndScheduler();
 800693a:	f7fe bfd5 	b.w	80058e8 <vPortEndScheduler>
 800693e:	bf00      	nop
 8006940:	20002dc4 	.word	0x20002dc4

08006944 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
 8006944:	4b03      	ldr	r3, [pc, #12]	; (8006954 <vTaskSuspendAll+0x10>)
 8006946:	f8d3 20ec 	ldr.w	r2, [r3, #236]	; 0xec
 800694a:	3201      	adds	r2, #1
 800694c:	f8c3 20ec 	str.w	r2, [r3, #236]	; 0xec
 8006950:	4770      	bx	lr
 8006952:	bf00      	nop
 8006954:	20002dc4 	.word	0x20002dc4

08006958 <xTaskGetTickCount>:
	return xAlreadyYielded;
}
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCount( void )
{
 8006958:	b510      	push	{r4, lr}
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
 800695a:	f7fe ffe7 	bl	800592c <vPortEnterCritical>
	{
		xTicks = xTickCount;
 800695e:	4b03      	ldr	r3, [pc, #12]	; (800696c <xTaskGetTickCount+0x14>)
 8006960:	685c      	ldr	r4, [r3, #4]
	}
	taskEXIT_CRITICAL();
 8006962:	f7fe fff4 	bl	800594e <vPortExitCritical>

	return xTicks;
}
 8006966:	4620      	mov	r0, r4
 8006968:	bd10      	pop	{r4, pc}
 800696a:	bf00      	nop
 800696c:	20002dc4 	.word	0x20002dc4

08006970 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
 8006970:	b510      	push	{r4, lr}
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 8006972:	f7ff f88b 	bl	8005a8c <vPortValidateInterruptPriority>

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 8006976:	f7fe ffc3 	bl	8005900 <ulPortSetInterruptMask>
	xReturn = xTickCount;
 800697a:	4b03      	ldr	r3, [pc, #12]	; (8006988 <xTaskGetTickCountFromISR+0x18>)
 800697c:	685c      	ldr	r4, [r3, #4]
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 800697e:	f7fe ffe3 	bl	8005948 <vPortClearInterruptMask>

	return xReturn;
}
 8006982:	4620      	mov	r0, r4
 8006984:	bd10      	pop	{r4, pc}
 8006986:	bf00      	nop
 8006988:	20002dc4 	.word	0x20002dc4

0800698c <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
 800698c:	4b01      	ldr	r3, [pc, #4]	; (8006994 <uxTaskGetNumberOfTasks+0x8>)
 800698e:	6918      	ldr	r0, [r3, #16]
}
 8006990:	4770      	bx	lr
 8006992:	bf00      	nop
 8006994:	20002dc4 	.word	0x20002dc4

08006998 <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

portBASE_TYPE xTaskIncrementTick( void )
{
 8006998:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 800699c:	4b3a      	ldr	r3, [pc, #232]	; (8006a88 <xTaskIncrementTick+0xf0>)
 800699e:	f8d3 20ec 	ldr.w	r2, [r3, #236]	; 0xec
 80069a2:	461c      	mov	r4, r3
 80069a4:	2a00      	cmp	r2, #0
 80069a6:	d13f      	bne.n	8006a28 <xTaskIncrementTick+0x90>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
 80069a8:	685a      	ldr	r2, [r3, #4]
 80069aa:	3201      	adds	r2, #1
 80069ac:	605a      	str	r2, [r3, #4]

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const portTickType xConstTickCount = xTickCount;
 80069ae:	685f      	ldr	r7, [r3, #4]

			if( xConstTickCount == ( portTickType ) 0U )
 80069b0:	b9d7      	cbnz	r7, 80069e8 <xTaskIncrementTick+0x50>
			{
				taskSWITCH_DELAYED_LISTS();
 80069b2:	68db      	ldr	r3, [r3, #12]
 80069b4:	681b      	ldr	r3, [r3, #0]
 80069b6:	b113      	cbz	r3, 80069be <xTaskIncrementTick+0x26>
 80069b8:	f7fe ffa2 	bl	8005900 <ulPortSetInterruptMask>
 80069bc:	e7fe      	b.n	80069bc <xTaskIncrementTick+0x24>
 80069be:	68e3      	ldr	r3, [r4, #12]
 80069c0:	68a2      	ldr	r2, [r4, #8]
 80069c2:	60e2      	str	r2, [r4, #12]
 80069c4:	60a3      	str	r3, [r4, #8]
 80069c6:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
 80069ca:	3301      	adds	r3, #1
 80069cc:	f8c4 30f0 	str.w	r3, [r4, #240]	; 0xf0
 80069d0:	68e3      	ldr	r3, [r4, #12]
 80069d2:	681a      	ldr	r2, [r3, #0]
 80069d4:	4b2d      	ldr	r3, [pc, #180]	; (8006a8c <xTaskIncrementTick+0xf4>)
 80069d6:	b912      	cbnz	r2, 80069de <xTaskIncrementTick+0x46>
 80069d8:	f04f 32ff 	mov.w	r2, #4294967295
 80069dc:	e003      	b.n	80069e6 <xTaskIncrementTick+0x4e>
 80069de:	68e2      	ldr	r2, [r4, #12]
 80069e0:	68d2      	ldr	r2, [r2, #12]
 80069e2:	68d2      	ldr	r2, [r2, #12]
 80069e4:	6852      	ldr	r2, [r2, #4]
 80069e6:	601a      	str	r2, [r3, #0]

			/* See if this tick has made a timeout expire.  Tasks are stored in the
			queue in the order of their wake time - meaning once one tasks has been
			found whose block time has not expired there is no need not look any
			further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
 80069e8:	4b28      	ldr	r3, [pc, #160]	; (8006a8c <xTaskIncrementTick+0xf4>)
 80069ea:	681a      	ldr	r2, [r3, #0]
 80069ec:	4297      	cmp	r7, r2
 80069ee:	f04f 0500 	mov.w	r5, #0
 80069f2:	4698      	mov	r8, r3
 80069f4:	d30e      	bcc.n	8006a14 <xTaskIncrementTick+0x7c>
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 80069f6:	68e3      	ldr	r3, [r4, #12]
 80069f8:	681b      	ldr	r3, [r3, #0]
 80069fa:	b913      	cbnz	r3, 8006a02 <xTaskIncrementTick+0x6a>
					{
						/* The delayed list is empty.  Set xNextTaskUnblockTime to
						the	maximum possible value so it is extremely unlikely that
						the if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
 80069fc:	f04f 33ff 	mov.w	r3, #4294967295
 8006a00:	e006      	b.n	8006a10 <xTaskIncrementTick+0x78>
					{
						/* The delayed list is not empty, get the value of the item
						at the head of the delayed list.  This is the time at which
						the task at the head of the delayed list must be removed
						from the Blocked state. */
						pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8006a02:	4b21      	ldr	r3, [pc, #132]	; (8006a88 <xTaskIncrementTick+0xf0>)
 8006a04:	68db      	ldr	r3, [r3, #12]
 8006a06:	68db      	ldr	r3, [r3, #12]
 8006a08:	68de      	ldr	r6, [r3, #12]
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 8006a0a:	6873      	ldr	r3, [r6, #4]

						if( xConstTickCount < xItemValue )
 8006a0c:	429f      	cmp	r7, r3
 8006a0e:	d212      	bcs.n	8006a36 <xTaskIncrementTick+0x9e>
					{
						/* The delayed list is empty.  Set xNextTaskUnblockTime to
						the	maximum possible value so it is extremely unlikely that
						the if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
 8006a10:	f8c8 3000 	str.w	r3, [r8]
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( unsigned portBASE_TYPE ) 1 )
 8006a14:	6823      	ldr	r3, [r4, #0]
 8006a16:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006a18:	2214      	movs	r2, #20
 8006a1a:	fb02 4303 	mla	r3, r2, r3, r4
 8006a1e:	695b      	ldr	r3, [r3, #20]
			{
				xSwitchRequired = pdTRUE;
 8006a20:	2b02      	cmp	r3, #2
 8006a22:	bf28      	it	cs
 8006a24:	2501      	movcs	r5, #1
 8006a26:	e027      	b.n	8006a78 <xTaskIncrementTick+0xe0>
		}
		#endif /* configUSE_TICK_HOOK */		
	}
	else
	{
		++uxPendedTicks;
 8006a28:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 8006a2c:	3301      	adds	r3, #1
 8006a2e:	f8c4 30f4 	str.w	r3, [r4, #244]	; 0xf4

portBASE_TYPE xTaskIncrementTick( void )
{
tskTCB * pxTCB;
portTickType xItemValue;
portBASE_TYPE xSwitchRequired = pdFALSE;
 8006a32:	2500      	movs	r5, #0
 8006a34:	e020      	b.n	8006a78 <xTaskIncrementTick+0xe0>
							xNextTaskUnblockTime = xItemValue;
							break;
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 8006a36:	f106 0904 	add.w	r9, r6, #4
 8006a3a:	4648      	mov	r0, r9
 8006a3c:	f7ff f992 	bl	8005d64 <uxListRemove>

						/* Is the task waiting on an event also?  If so remove it
						from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8006a40:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 8006a42:	b11b      	cbz	r3, 8006a4c <xTaskIncrementTick+0xb4>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8006a44:	f106 0018 	add.w	r0, r6, #24
 8006a48:	f7ff f98c 	bl	8005d64 <uxListRemove>
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
 8006a4c:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 8006a4e:	f8d4 20e4 	ldr.w	r2, [r4, #228]	; 0xe4
 8006a52:	4293      	cmp	r3, r2
 8006a54:	bf84      	itt	hi
 8006a56:	4a0c      	ldrhi	r2, [pc, #48]	; (8006a88 <xTaskIncrementTick+0xf0>)
 8006a58:	f8c2 30e4 	strhi.w	r3, [r2, #228]	; 0xe4
 8006a5c:	4a0c      	ldr	r2, [pc, #48]	; (8006a90 <xTaskIncrementTick+0xf8>)
 8006a5e:	2014      	movs	r0, #20
 8006a60:	fb00 2003 	mla	r0, r0, r3, r2
 8006a64:	4649      	mov	r1, r9
 8006a66:	f7ff f959 	bl	8005d1c <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should only
							be performed if the unblocked task has a priority that
							is equal to or higher than the currently executing
							task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8006a6a:	6823      	ldr	r3, [r4, #0]
 8006a6c:	6af2      	ldr	r2, [r6, #44]	; 0x2c
 8006a6e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
							{
								xSwitchRequired = pdTRUE;
 8006a70:	429a      	cmp	r2, r3
 8006a72:	bf28      	it	cs
 8006a74:	2501      	movcs	r5, #1
 8006a76:	e7be      	b.n	80069f6 <xTaskIncrementTick+0x5e>
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
 8006a78:	f8d4 30f8 	ldr.w	r3, [r4, #248]	; 0xf8
		{
			xSwitchRequired = pdTRUE;
 8006a7c:	2b00      	cmp	r3, #0
 8006a7e:	bf18      	it	ne
 8006a80:	2501      	movne	r5, #1
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
 8006a82:	4628      	mov	r0, r5
 8006a84:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8006a88:	20002dc4 	.word	0x20002dc4
 8006a8c:	20000030 	.word	0x20000030
 8006a90:	20002dd8 	.word	0x20002dd8

08006a94 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
 8006a94:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
tskTCB *pxTCB;
portBASE_TYPE xAlreadyYielded = pdFALSE;

	/* If uxSchedulerSuspended is zero then this function does not match a
	previous call to vTaskSuspendAll(). */
	configASSERT( uxSchedulerSuspended );
 8006a96:	4c2e      	ldr	r4, [pc, #184]	; (8006b50 <xTaskResumeAll+0xbc>)
 8006a98:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
 8006a9c:	b913      	cbnz	r3, 8006aa4 <xTaskResumeAll+0x10>
 8006a9e:	f7fe ff2f 	bl	8005900 <ulPortSetInterruptMask>
 8006aa2:	e7fe      	b.n	8006aa2 <xTaskResumeAll+0xe>
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
 8006aa4:	f7fe ff42 	bl	800592c <vPortEnterCritical>
	{
		--uxSchedulerSuspended;
 8006aa8:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
 8006aac:	3b01      	subs	r3, #1
 8006aae:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 8006ab2:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
 8006ab6:	b10b      	cbz	r3, 8006abc <xTaskResumeAll+0x28>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
tskTCB *pxTCB;
portBASE_TYPE xAlreadyYielded = pdFALSE;
 8006ab8:	2400      	movs	r4, #0
 8006aba:	e045      	b.n	8006b48 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
 8006abc:	6923      	ldr	r3, [r4, #16]
 8006abe:	2b00      	cmp	r3, #0
 8006ac0:	d0fa      	beq.n	8006ab8 <xTaskResumeAll+0x24>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8006ac2:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
 8006ac6:	4e22      	ldr	r6, [pc, #136]	; (8006b50 <xTaskResumeAll+0xbc>)
 8006ac8:	b31b      	cbz	r3, 8006b12 <xTaskResumeAll+0x7e>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 8006aca:	f8d6 30ac 	ldr.w	r3, [r6, #172]	; 0xac
 8006ace:	68dd      	ldr	r5, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 8006ad0:	1d2f      	adds	r7, r5, #4
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8006ad2:	f105 0018 	add.w	r0, r5, #24
 8006ad6:	f7ff f945 	bl	8005d64 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 8006ada:	4638      	mov	r0, r7
 8006adc:	f7ff f942 	bl	8005d64 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8006ae0:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8006ae2:	f8d6 20e4 	ldr.w	r2, [r6, #228]	; 0xe4
 8006ae6:	4293      	cmp	r3, r2
 8006ae8:	bf88      	it	hi
 8006aea:	f8c6 30e4 	strhi.w	r3, [r6, #228]	; 0xe4
 8006aee:	4e18      	ldr	r6, [pc, #96]	; (8006b50 <xTaskResumeAll+0xbc>)
 8006af0:	2014      	movs	r0, #20
 8006af2:	f106 0214 	add.w	r2, r6, #20
 8006af6:	fb00 2003 	mla	r0, r0, r3, r2
 8006afa:	4639      	mov	r1, r7
 8006afc:	f7ff f90e 	bl	8005d1c <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8006b00:	6823      	ldr	r3, [r4, #0]
 8006b02:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 8006b04:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006b06:	429a      	cmp	r2, r3
					{
						xYieldPending = pdTRUE;
 8006b08:	bf24      	itt	cs
 8006b0a:	2301      	movcs	r3, #1
 8006b0c:	f8c6 30f8 	strcs.w	r3, [r6, #248]	; 0xf8
 8006b10:	e7d7      	b.n	8006ac2 <xTaskResumeAll+0x2e>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
 8006b12:	f8d6 30f4 	ldr.w	r3, [r6, #244]	; 0xf4
 8006b16:	b993      	cbnz	r3, 8006b3e <xTaskResumeAll+0xaa>
						}
						--uxPendedTicks;
					}
				}

				if( xYieldPending == pdTRUE )
 8006b18:	f8d4 40f8 	ldr.w	r4, [r4, #248]	; 0xf8
 8006b1c:	2c01      	cmp	r4, #1
 8006b1e:	d1cb      	bne.n	8006ab8 <xTaskResumeAll+0x24>
				{
					xAlreadyYielded = pdTRUE;
					portYIELD_WITHIN_API();
 8006b20:	f7fe fee3 	bl	80058ea <vPortYield>
 8006b24:	e010      	b.n	8006b48 <xTaskResumeAll+0xb4>
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
 8006b26:	f7ff ff37 	bl	8006998 <xTaskIncrementTick>
 8006b2a:	b118      	cbz	r0, 8006b34 <xTaskResumeAll+0xa0>
						{
							xYieldPending = pdTRUE;
 8006b2c:	4b08      	ldr	r3, [pc, #32]	; (8006b50 <xTaskResumeAll+0xbc>)
 8006b2e:	2201      	movs	r2, #1
 8006b30:	f8c3 20f8 	str.w	r2, [r3, #248]	; 0xf8
						}
						--uxPendedTicks;
 8006b34:	f8d4 30f4 	ldr.w	r3, [r4, #244]	; 0xf4
 8006b38:	3b01      	subs	r3, #1
 8006b3a:	f8c4 30f4 	str.w	r3, [r4, #244]	; 0xf4
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxPendedTicks > ( unsigned portBASE_TYPE ) 0U )
 8006b3e:	f8d4 30f4 	ldr.w	r3, [r4, #244]	; 0xf4
 8006b42:	2b00      	cmp	r3, #0
 8006b44:	d1ef      	bne.n	8006b26 <xTaskResumeAll+0x92>
 8006b46:	e7e7      	b.n	8006b18 <xTaskResumeAll+0x84>
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
 8006b48:	f7fe ff01 	bl	800594e <vPortExitCritical>

	return xAlreadyYielded;
}
 8006b4c:	4620      	mov	r0, r4
 8006b4e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8006b50:	20002dc4 	.word	0x20002dc4

08006b54 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
 8006b54:	b538      	push	{r3, r4, r5, lr}
 8006b56:	460c      	mov	r4, r1
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
 8006b58:	4605      	mov	r5, r0
 8006b5a:	b910      	cbnz	r0, 8006b62 <vTaskDelayUntil+0xe>
 8006b5c:	f7fe fed0 	bl	8005900 <ulPortSetInterruptMask>
 8006b60:	e7fe      	b.n	8006b60 <vTaskDelayUntil+0xc>
		configASSERT( ( xTimeIncrement > 0U ) );
 8006b62:	b911      	cbnz	r1, 8006b6a <vTaskDelayUntil+0x16>
 8006b64:	f7fe fecc 	bl	8005900 <ulPortSetInterruptMask>
 8006b68:	e7fe      	b.n	8006b68 <vTaskDelayUntil+0x14>

		vTaskSuspendAll();
 8006b6a:	f7ff feeb 	bl	8006944 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const portTickType xConstTickCount = xTickCount;
 8006b6e:	4912      	ldr	r1, [pc, #72]	; (8006bb8 <vTaskDelayUntil+0x64>)

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 8006b70:	682a      	ldr	r2, [r5, #0]

		vTaskSuspendAll();
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const portTickType xConstTickCount = xTickCount;
 8006b72:	684b      	ldr	r3, [r1, #4]

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;

			if( xConstTickCount < *pxPreviousWakeTime )
 8006b74:	4293      	cmp	r3, r2
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const portTickType xConstTickCount = xTickCount;

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 8006b76:	4414      	add	r4, r2

			if( xConstTickCount < *pxPreviousWakeTime )
 8006b78:	d202      	bcs.n	8006b80 <vTaskDelayUntil+0x2c>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 8006b7a:	4294      	cmp	r4, r2
 8006b7c:	d207      	bcs.n	8006b8e <vTaskDelayUntil+0x3a>
 8006b7e:	e001      	b.n	8006b84 <vTaskDelayUntil+0x30>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 8006b80:	4294      	cmp	r4, r2
 8006b82:	d306      	bcc.n	8006b92 <vTaskDelayUntil+0x3e>
 8006b84:	429c      	cmp	r4, r3
 8006b86:	bf94      	ite	ls
 8006b88:	2300      	movls	r3, #0
 8006b8a:	2301      	movhi	r3, #1
 8006b8c:	e002      	b.n	8006b94 <vTaskDelayUntil+0x40>
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
 8006b8e:	2300      	movs	r3, #0
 8006b90:	e000      	b.n	8006b94 <vTaskDelayUntil+0x40>
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
				{
					xShouldDelay = pdTRUE;
 8006b92:	2301      	movs	r3, #1
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
 8006b94:	602c      	str	r4, [r5, #0]

			if( xShouldDelay != pdFALSE )
 8006b96:	b133      	cbz	r3, 8006ba6 <vTaskDelayUntil+0x52>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
 8006b98:	6808      	ldr	r0, [r1, #0]
 8006b9a:	3004      	adds	r0, #4
 8006b9c:	f7ff f8e2 	bl	8005d64 <uxListRemove>
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
 8006ba0:	4620      	mov	r0, r4
 8006ba2:	f7ff fc9f 	bl	80064e4 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
 8006ba6:	f7ff ff75 	bl	8006a94 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 8006baa:	b918      	cbnz	r0, 8006bb4 <vTaskDelayUntil+0x60>
		{
			portYIELD_WITHIN_API();
		}
	}
 8006bac:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
 8006bb0:	f7fe be9b 	b.w	80058ea <vPortYield>
 8006bb4:	bd38      	pop	{r3, r4, r5, pc}
 8006bb6:	bf00      	nop
 8006bb8:	20002dc4 	.word	0x20002dc4

08006bbc <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
 8006bbc:	b510      	push	{r4, lr}
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
 8006bbe:	4604      	mov	r4, r0
 8006bc0:	b918      	cbnz	r0, 8006bca <vTaskDelay+0xe>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
 8006bc2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
 8006bc6:	f7fe be90 	b.w	80058ea <vPortYield>
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
		{
			vTaskSuspendAll();
 8006bca:	f7ff febb 	bl	8006944 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
 8006bce:	4b07      	ldr	r3, [pc, #28]	; (8006bec <vTaskDelay+0x30>)
 8006bd0:	685a      	ldr	r2, [r3, #4]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
 8006bd2:	6818      	ldr	r0, [r3, #0]
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
 8006bd4:	4414      	add	r4, r2

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
 8006bd6:	3004      	adds	r0, #4
 8006bd8:	f7ff f8c4 	bl	8005d64 <uxListRemove>
					/* The current task must be in a ready list, so there is
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
 8006bdc:	4620      	mov	r0, r4
 8006bde:	f7ff fc81 	bl	80064e4 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
 8006be2:	f7ff ff57 	bl	8006a94 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 8006be6:	2800      	cmp	r0, #0
 8006be8:	d0eb      	beq.n	8006bc2 <vTaskDelay+0x6>
		{
			portYIELD_WITHIN_API();
		}
	}
 8006bea:	bd10      	pop	{r4, pc}
 8006bec:	20002dc4 	.word	0x20002dc4

08006bf0 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
 8006bf0:	b508      	push	{r3, lr}
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
 8006bf2:	4c16      	ldr	r4, [pc, #88]	; (8006c4c <prvIdleTask+0x5c>)
 8006bf4:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 8006bf8:	b303      	cbz	r3, 8006c3c <prvIdleTask+0x4c>
		{
			vTaskSuspendAll();
 8006bfa:	f7ff fea3 	bl	8006944 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 8006bfe:	f8d4 50b4 	ldr.w	r5, [r4, #180]	; 0xb4
			( void ) xTaskResumeAll();
 8006c02:	f7ff ff47 	bl	8006a94 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
 8006c06:	2d00      	cmp	r5, #0
 8006c08:	d0f3      	beq.n	8006bf2 <prvIdleTask+0x2>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
 8006c0a:	f7fe fe8f 	bl	800592c <vPortEnterCritical>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 8006c0e:	f8d4 30c0 	ldr.w	r3, [r4, #192]	; 0xc0
 8006c12:	68dd      	ldr	r5, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 8006c14:	1d28      	adds	r0, r5, #4
 8006c16:	f7ff f8a5 	bl	8005d64 <uxListRemove>
					--uxCurrentNumberOfTasks;
 8006c1a:	6923      	ldr	r3, [r4, #16]
 8006c1c:	3b01      	subs	r3, #1
 8006c1e:	6123      	str	r3, [r4, #16]
					--uxTasksDeleted;
 8006c20:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 8006c24:	3b01      	subs	r3, #1
 8006c26:	f8c4 30e8 	str.w	r3, [r4, #232]	; 0xe8
				}
				taskEXIT_CRITICAL();
 8006c2a:	f7fe fe90 	bl	800594e <vPortExitCritical>
		want to allocate and clean RAM statically. */
		portCLEAN_UP_TCB( pxTCB );

		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
 8006c2e:	6b28      	ldr	r0, [r5, #48]	; 0x30
 8006c30:	f7fe fe14 	bl	800585c <vPortFree>
		vPortFree( pxTCB );
 8006c34:	4628      	mov	r0, r5
 8006c36:	f7fe fe11 	bl	800585c <vPortFree>
 8006c3a:	e7da      	b.n	8006bf2 <prvIdleTask+0x2>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
 8006c3c:	6963      	ldr	r3, [r4, #20]
 8006c3e:	2b01      	cmp	r3, #1
 8006c40:	d901      	bls.n	8006c46 <prvIdleTask+0x56>
			{
				taskYIELD();
 8006c42:	f7fe fe52 	bl	80058ea <vPortYield>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
 8006c46:	f7fb f9d7 	bl	8001ff8 <vApplicationIdleHook>
				}
				( void ) xTaskResumeAll();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
 8006c4a:	e7d2      	b.n	8006bf2 <prvIdleTask+0x2>
 8006c4c:	20002dc4 	.word	0x20002dc4

08006c50 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
 8006c50:	b538      	push	{r3, r4, r5, lr}
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 8006c52:	4b25      	ldr	r3, [pc, #148]	; (8006ce8 <vTaskSwitchContext+0x98>)
 8006c54:	f8d3 20ec 	ldr.w	r2, [r3, #236]	; 0xec
 8006c58:	461c      	mov	r4, r3
 8006c5a:	b11a      	cbz	r2, 8006c64 <vTaskSwitchContext+0x14>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 8006c5c:	2201      	movs	r2, #1
 8006c5e:	f8c3 20f8 	str.w	r2, [r3, #248]	; 0xf8
 8006c62:	bd38      	pop	{r3, r4, r5, pc}
	}
	else
	{
		xYieldPending = pdFALSE;
 8006c64:	f8c3 20f8 	str.w	r2, [r3, #248]	; 0xf8
				}
				ulTaskSwitchedInTime = ulTotalRunTime;
		}
		#endif /* configGENERATE_RUN_TIME_STATS */

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
 8006c68:	681a      	ldr	r2, [r3, #0]
 8006c6a:	681b      	ldr	r3, [r3, #0]
 8006c6c:	6812      	ldr	r2, [r2, #0]
 8006c6e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8006c70:	429a      	cmp	r2, r3
 8006c72:	d804      	bhi.n	8006c7e <vTaskSwitchContext+0x2e>
 8006c74:	6820      	ldr	r0, [r4, #0]
 8006c76:	6821      	ldr	r1, [r4, #0]
 8006c78:	3134      	adds	r1, #52	; 0x34
 8006c7a:	f7fb f9b3 	bl	8001fe4 <vApplicationStackOverflowHook>
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
 8006c7e:	6823      	ldr	r3, [r4, #0]
 8006c80:	491a      	ldr	r1, [pc, #104]	; (8006cec <vTaskSwitchContext+0x9c>)
 8006c82:	6b18      	ldr	r0, [r3, #48]	; 0x30
 8006c84:	4d18      	ldr	r5, [pc, #96]	; (8006ce8 <vTaskSwitchContext+0x98>)
 8006c86:	2214      	movs	r2, #20
 8006c88:	f001 f99c 	bl	8007fc4 <memcmp>
 8006c8c:	b150      	cbz	r0, 8006ca4 <vTaskSwitchContext+0x54>
 8006c8e:	6828      	ldr	r0, [r5, #0]
 8006c90:	6829      	ldr	r1, [r5, #0]
 8006c92:	3134      	adds	r1, #52	; 0x34
 8006c94:	f7fb f9a6 	bl	8001fe4 <vApplicationStackOverflowHook>
 8006c98:	e004      	b.n	8006ca4 <vTaskSwitchContext+0x54>

		taskSELECT_HIGHEST_PRIORITY_TASK();
 8006c9a:	f8d2 30e4 	ldr.w	r3, [r2, #228]	; 0xe4
 8006c9e:	3b01      	subs	r3, #1
 8006ca0:	f8c2 30e4 	str.w	r3, [r2, #228]	; 0xe4
 8006ca4:	f8d4 30e4 	ldr.w	r3, [r4, #228]	; 0xe4
 8006ca8:	4a0f      	ldr	r2, [pc, #60]	; (8006ce8 <vTaskSwitchContext+0x98>)
 8006caa:	2114      	movs	r1, #20
 8006cac:	fb01 4303 	mla	r3, r1, r3, r4
 8006cb0:	695b      	ldr	r3, [r3, #20]
 8006cb2:	b933      	cbnz	r3, 8006cc2 <vTaskSwitchContext+0x72>
 8006cb4:	f8d2 30e4 	ldr.w	r3, [r2, #228]	; 0xe4
 8006cb8:	2b00      	cmp	r3, #0
 8006cba:	d1ee      	bne.n	8006c9a <vTaskSwitchContext+0x4a>
 8006cbc:	f7fe fe20 	bl	8005900 <ulPortSetInterruptMask>
 8006cc0:	e7fe      	b.n	8006cc0 <vTaskSwitchContext+0x70>
 8006cc2:	f8d2 30e4 	ldr.w	r3, [r2, #228]	; 0xe4
 8006cc6:	440a      	add	r2, r1
 8006cc8:	fb01 2303 	mla	r3, r1, r3, r2
 8006ccc:	f103 0108 	add.w	r1, r3, #8
 8006cd0:	685a      	ldr	r2, [r3, #4]
 8006cd2:	6852      	ldr	r2, [r2, #4]
 8006cd4:	605a      	str	r2, [r3, #4]
 8006cd6:	428a      	cmp	r2, r1
 8006cd8:	bf04      	itt	eq
 8006cda:	6852      	ldreq	r2, [r2, #4]
 8006cdc:	605a      	streq	r2, [r3, #4]
 8006cde:	685b      	ldr	r3, [r3, #4]
 8006ce0:	68db      	ldr	r3, [r3, #12]
 8006ce2:	6023      	str	r3, [r4, #0]
 8006ce4:	bd38      	pop	{r3, r4, r5, pc}
 8006ce6:	bf00      	nop
 8006ce8:	20002dc4 	.word	0x20002dc4
 8006cec:	08009cfc 	.word	0x08009cfc

08006cf0 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( xTaskHandle xTaskToSuspend )
	{
 8006cf0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8006cf2:	4604      	mov	r4, r0
 8006cf4:	4e16      	ldr	r6, [pc, #88]	; (8006d50 <vTaskSuspend+0x60>)
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
 8006cf6:	f7fe fe19 	bl	800592c <vPortEnterCritical>
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 8006cfa:	b904      	cbnz	r4, 8006cfe <vTaskSuspend+0xe>
 8006cfc:	6834      	ldr	r4, [r6, #0]

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the	suspended list. */
			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
 8006cfe:	1d27      	adds	r7, r4, #4
 8006d00:	4638      	mov	r0, r7
 8006d02:	f7ff f82f 	bl	8005d64 <uxListRemove>
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8006d06:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8006d08:	b11b      	cbz	r3, 8006d12 <vTaskSuspend+0x22>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8006d0a:	f104 0018 	add.w	r0, r4, #24
 8006d0e:	f7ff f829 	bl	8005d64 <uxListRemove>
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
 8006d12:	4d0f      	ldr	r5, [pc, #60]	; (8006d50 <vTaskSuspend+0x60>)
 8006d14:	4639      	mov	r1, r7
 8006d16:	f105 00c8 	add.w	r0, r5, #200	; 0xc8
 8006d1a:	f7fe ffff 	bl	8005d1c <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
 8006d1e:	f7fe fe16 	bl	800594e <vPortExitCritical>

		if( pxTCB == pxCurrentTCB )
 8006d22:	6833      	ldr	r3, [r6, #0]
 8006d24:	429c      	cmp	r4, r3
 8006d26:	d111      	bne.n	8006d4c <vTaskSuspend+0x5c>
		{
			if( xSchedulerRunning != pdFALSE )
 8006d28:	f8d5 30dc 	ldr.w	r3, [r5, #220]	; 0xdc
 8006d2c:	b11b      	cbz	r3, 8006d36 <vTaskSuspend+0x46>
				{
					vTaskSwitchContext();
				}
			}
		}
	}
 8006d2e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		if( pxTCB == pxCurrentTCB )
		{
			if( xSchedulerRunning != pdFALSE )
			{
				/* The current task has just been suspended. */
				portYIELD_WITHIN_API();
 8006d32:	f7fe bdda 	b.w	80058ea <vPortYield>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
 8006d36:	6929      	ldr	r1, [r5, #16]
 8006d38:	f8d5 20c8 	ldr.w	r2, [r5, #200]	; 0xc8
 8006d3c:	428a      	cmp	r2, r1
 8006d3e:	d101      	bne.n	8006d44 <vTaskSuspend+0x54>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
 8006d40:	602b      	str	r3, [r5, #0]
 8006d42:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				{
					vTaskSwitchContext();
				}
			}
		}
	}
 8006d44:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
					is. */
					pxCurrentTCB = NULL;
				}
				else
				{
					vTaskSwitchContext();
 8006d48:	f7ff bf82 	b.w	8006c50 <vTaskSwitchContext>
 8006d4c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8006d4e:	bf00      	nop
 8006d50:	20002dc4 	.word	0x20002dc4

08006d54 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( xList * const pxEventList, portTickType xTicksToWait )
{
 8006d54:	b538      	push	{r3, r4, r5, lr}
 8006d56:	460d      	mov	r5, r1
portTickType xTimeToWake;

	configASSERT( pxEventList );
 8006d58:	b910      	cbnz	r0, 8006d60 <vTaskPlaceOnEventList+0xc>
 8006d5a:	f7fe fdd1 	bl	8005900 <ulPortSetInterruptMask>
 8006d5e:	e7fe      	b.n	8006d5e <vTaskPlaceOnEventList+0xa>
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 8006d60:	4c0c      	ldr	r4, [pc, #48]	; (8006d94 <vTaskPlaceOnEventList+0x40>)
 8006d62:	6821      	ldr	r1, [r4, #0]
 8006d64:	3118      	adds	r1, #24
 8006d66:	f7fe ffe5 	bl	8005d34 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
 8006d6a:	6820      	ldr	r0, [r4, #0]
 8006d6c:	3004      	adds	r0, #4
 8006d6e:	f7fe fff9 	bl	8005d64 <uxListRemove>
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
 8006d72:	1c6b      	adds	r3, r5, #1
 8006d74:	d107      	bne.n	8006d86 <vTaskPlaceOnEventList+0x32>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 8006d76:	4620      	mov	r0, r4
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 8006d78:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		if( xTicksToWait == portMAX_DELAY )
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 8006d7c:	f850 1bc8 	ldr.w	r1, [r0], #200
 8006d80:	3104      	adds	r1, #4
 8006d82:	f7fe bfcb 	b.w	8005d1c <vListInsertEnd>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
 8006d86:	6860      	ldr	r0, [r4, #4]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
 8006d88:	4428      	add	r0, r5
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 8006d8a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
 8006d8e:	f7ff bba9 	b.w	80064e4 <prvAddCurrentTaskToDelayedList>
 8006d92:	bf00      	nop
 8006d94:	20002dc4 	.word	0x20002dc4

08006d98 <vTaskPlaceOnEventListRestricted>:
/*-----------------------------------------------------------*/

#if configUSE_TIMERS == 1

	void vTaskPlaceOnEventListRestricted( xList * const pxEventList, portTickType xTicksToWait )
	{
 8006d98:	b538      	push	{r3, r4, r5, lr}
 8006d9a:	460d      	mov	r5, r1
	portTickType xTimeToWake;

		configASSERT( pxEventList );
 8006d9c:	b910      	cbnz	r0, 8006da4 <vTaskPlaceOnEventListRestricted+0xc>
 8006d9e:	f7fe fdaf 	bl	8005900 <ulPortSetInterruptMask>
 8006da2:	e7fe      	b.n	8006da2 <vTaskPlaceOnEventListRestricted+0xa>

		/* Place the event list item of the TCB in the appropriate event list.
		In this case it is assume that this is the only task that is going to
		be waiting on this event list, so the faster vListInsertEnd() function
		can be used in place of vListInsert. */
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 8006da4:	4c07      	ldr	r4, [pc, #28]	; (8006dc4 <vTaskPlaceOnEventListRestricted+0x2c>)
 8006da6:	6821      	ldr	r1, [r4, #0]
 8006da8:	3118      	adds	r1, #24
 8006daa:	f7fe ffb7 	bl	8005d1c <vListInsertEnd>

		/* We must remove this task from the ready list before adding it to the
		blocked list as the same list item is used for both lists.  This
		function is called form a critical section. */
		if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
 8006dae:	6820      	ldr	r0, [r4, #0]
 8006db0:	3004      	adds	r0, #4
 8006db2:	f7fe ffd7 	bl	8005d64 <uxListRemove>
			portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
		}

		/* Calculate the time at which the task should be woken if the event does
		not occur.  This may overflow but this doesn't matter. */
		xTimeToWake = xTickCount + xTicksToWait;
 8006db6:	6860      	ldr	r0, [r4, #4]

		traceTASK_DELAY_UNTIL();
		prvAddCurrentTaskToDelayedList( xTimeToWake );
 8006db8:	4428      	add	r0, r5
	}
 8006dba:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		/* Calculate the time at which the task should be woken if the event does
		not occur.  This may overflow but this doesn't matter. */
		xTimeToWake = xTickCount + xTicksToWait;

		traceTASK_DELAY_UNTIL();
		prvAddCurrentTaskToDelayedList( xTimeToWake );
 8006dbe:	f7ff bb91 	b.w	80064e4 <prvAddCurrentTaskToDelayedList>
 8006dc2:	bf00      	nop
 8006dc4:	20002dc4 	.word	0x20002dc4

08006dc8 <xTaskRemoveFromEventList>:
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 8006dc8:	68c3      	ldr	r3, [r0, #12]

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
 8006dca:	b570      	push	{r4, r5, r6, lr}
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 8006dcc:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
 8006dce:	b914      	cbnz	r4, 8006dd6 <xTaskRemoveFromEventList+0xe>
 8006dd0:	f7fe fd96 	bl	8005900 <ulPortSetInterruptMask>
 8006dd4:	e7fe      	b.n	8006dd4 <xTaskRemoveFromEventList+0xc>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 8006dd6:	f104 0618 	add.w	r6, r4, #24

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 8006dda:	4d14      	ldr	r5, [pc, #80]	; (8006e2c <xTaskRemoveFromEventList+0x64>)

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 8006ddc:	4630      	mov	r0, r6
 8006dde:	f7fe ffc1 	bl	8005d64 <uxListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 8006de2:	f8d5 30ec 	ldr.w	r3, [r5, #236]	; 0xec
 8006de6:	b97b      	cbnz	r3, 8006e08 <xTaskRemoveFromEventList+0x40>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 8006de8:	1d26      	adds	r6, r4, #4
 8006dea:	4630      	mov	r0, r6
 8006dec:	f7fe ffba 	bl	8005d64 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
 8006df0:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8006df2:	f8d5 20e4 	ldr.w	r2, [r5, #228]	; 0xe4
 8006df6:	4293      	cmp	r3, r2
 8006df8:	4a0d      	ldr	r2, [pc, #52]	; (8006e30 <xTaskRemoveFromEventList+0x68>)
 8006dfa:	bf88      	it	hi
 8006dfc:	f8c5 30e4 	strhi.w	r3, [r5, #228]	; 0xe4
 8006e00:	2014      	movs	r0, #20
 8006e02:	fb00 2003 	mla	r0, r0, r3, r2
 8006e06:	e001      	b.n	8006e0c <xTaskRemoveFromEventList+0x44>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 8006e08:	f105 00a0 	add.w	r0, r5, #160	; 0xa0
 8006e0c:	4631      	mov	r1, r6
 8006e0e:	f7fe ff85 	bl	8005d1c <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8006e12:	682b      	ldr	r3, [r5, #0]
 8006e14:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8006e16:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006e18:	429a      	cmp	r2, r3
 8006e1a:	d304      	bcc.n	8006e26 <xTaskRemoveFromEventList+0x5e>
		switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
 8006e1c:	4b03      	ldr	r3, [pc, #12]	; (8006e2c <xTaskRemoveFromEventList+0x64>)
 8006e1e:	2001      	movs	r0, #1
 8006e20:	f8c3 00f8 	str.w	r0, [r3, #248]	; 0xf8
 8006e24:	bd70      	pop	{r4, r5, r6, pc}
	}
	else
	{
		xReturn = pdFALSE;
 8006e26:	2000      	movs	r0, #0
	}

	return xReturn;
}
 8006e28:	bd70      	pop	{r4, r5, r6, pc}
 8006e2a:	bf00      	nop
 8006e2c:	20002dc4 	.word	0x20002dc4
 8006e30:	20002dd8 	.word	0x20002dd8

08006e34 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
 8006e34:	b508      	push	{r3, lr}
	configASSERT( pxTimeOut );
 8006e36:	b910      	cbnz	r0, 8006e3e <vTaskSetTimeOutState+0xa>
 8006e38:	f7fe fd62 	bl	8005900 <ulPortSetInterruptMask>
 8006e3c:	e7fe      	b.n	8006e3c <vTaskSetTimeOutState+0x8>
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 8006e3e:	4b03      	ldr	r3, [pc, #12]	; (8006e4c <vTaskSetTimeOutState+0x18>)
 8006e40:	f8d3 20f0 	ldr.w	r2, [r3, #240]	; 0xf0
	pxTimeOut->xTimeOnEntering = xTickCount;
 8006e44:	685b      	ldr	r3, [r3, #4]
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 8006e46:	6002      	str	r2, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 8006e48:	6043      	str	r3, [r0, #4]
 8006e4a:	bd08      	pop	{r3, pc}
 8006e4c:	20002dc4 	.word	0x20002dc4

08006e50 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
 8006e50:	b538      	push	{r3, r4, r5, lr}
 8006e52:	460d      	mov	r5, r1
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
 8006e54:	4604      	mov	r4, r0
 8006e56:	b910      	cbnz	r0, 8006e5e <xTaskCheckForTimeOut+0xe>
 8006e58:	f7fe fd52 	bl	8005900 <ulPortSetInterruptMask>
 8006e5c:	e7fe      	b.n	8006e5c <xTaskCheckForTimeOut+0xc>
	configASSERT( pxTicksToWait );
 8006e5e:	b911      	cbnz	r1, 8006e66 <xTaskCheckForTimeOut+0x16>
 8006e60:	f7fe fd4e 	bl	8005900 <ulPortSetInterruptMask>
 8006e64:	e7fe      	b.n	8006e64 <xTaskCheckForTimeOut+0x14>

	taskENTER_CRITICAL();
 8006e66:	f7fe fd61 	bl	800592c <vPortEnterCritical>

		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
 8006e6a:	682b      	ldr	r3, [r5, #0]
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const portTickType xConstTickCount = xTickCount;
 8006e6c:	490d      	ldr	r1, [pc, #52]	; (8006ea4 <xTaskCheckForTimeOut+0x54>)

		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
 8006e6e:	1c58      	adds	r0, r3, #1
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const portTickType xConstTickCount = xTickCount;
 8006e70:	684a      	ldr	r2, [r1, #4]

		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
 8006e72:	d010      	beq.n	8006e96 <xTaskCheckForTimeOut+0x46>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 8006e74:	f8d1 00f0 	ldr.w	r0, [r1, #240]	; 0xf0
 8006e78:	6821      	ldr	r1, [r4, #0]
 8006e7a:	4288      	cmp	r0, r1
 8006e7c:	6861      	ldr	r1, [r4, #4]
 8006e7e:	d001      	beq.n	8006e84 <xTaskCheckForTimeOut+0x34>
 8006e80:	428a      	cmp	r2, r1
 8006e82:	d20a      	bcs.n	8006e9a <xTaskCheckForTimeOut+0x4a>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
 8006e84:	1a50      	subs	r0, r2, r1
 8006e86:	4298      	cmp	r0, r3
 8006e88:	d207      	bcs.n	8006e9a <xTaskCheckForTimeOut+0x4a>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
 8006e8a:	1a8a      	subs	r2, r1, r2
 8006e8c:	4413      	add	r3, r2
 8006e8e:	602b      	str	r3, [r5, #0]
			vTaskSetTimeOutState( pxTimeOut );
 8006e90:	4620      	mov	r0, r4
 8006e92:	f7ff ffcf 	bl	8006e34 <vTaskSetTimeOutState>
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
			{
				xReturn = pdFALSE;
 8006e96:	2400      	movs	r4, #0
 8006e98:	e000      	b.n	8006e9c <xTaskCheckForTimeOut+0x4c>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
 8006e9a:	2401      	movs	r4, #1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
 8006e9c:	f7fe fd57 	bl	800594e <vPortExitCritical>

	return xReturn;
}
 8006ea0:	4620      	mov	r0, r4
 8006ea2:	bd38      	pop	{r3, r4, r5, pc}
 8006ea4:	20002dc4 	.word	0x20002dc4

08006ea8 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
 8006ea8:	4b02      	ldr	r3, [pc, #8]	; (8006eb4 <vTaskMissedYield+0xc>)
 8006eaa:	2201      	movs	r2, #1
 8006eac:	f8c3 20f8 	str.w	r2, [r3, #248]	; 0xf8
 8006eb0:	4770      	bx	lr
 8006eb2:	bf00      	nop
 8006eb4:	20002dc4 	.word	0x20002dc4

08006eb8 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
 8006eb8:	4b01      	ldr	r3, [pc, #4]	; (8006ec0 <xTaskGetCurrentTaskHandle+0x8>)
 8006eba:	6818      	ldr	r0, [r3, #0]

		return xReturn;
	}
 8006ebc:	4770      	bx	lr
 8006ebe:	bf00      	nop
 8006ec0:	20002dc4 	.word	0x20002dc4

08006ec4 <xTaskGetSchedulerState>:

	portBASE_TYPE xTaskGetSchedulerState( void )
	{
	portBASE_TYPE xReturn;

		if( xSchedulerRunning == pdFALSE )
 8006ec4:	4b05      	ldr	r3, [pc, #20]	; (8006edc <xTaskGetSchedulerState+0x18>)
 8006ec6:	f8d3 00dc 	ldr.w	r0, [r3, #220]	; 0xdc
 8006eca:	b128      	cbz	r0, 8006ed8 <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
		}
		else
		{
			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 8006ecc:	f8d3 30ec 	ldr.w	r3, [r3, #236]	; 0xec
 8006ed0:	2b00      	cmp	r3, #0
			{
				xReturn = taskSCHEDULER_RUNNING;
 8006ed2:	bf14      	ite	ne
 8006ed4:	2002      	movne	r0, #2
 8006ed6:	2001      	moveq	r0, #1
				xReturn = taskSCHEDULER_SUSPENDED;
			}
		}

		return xReturn;
	}
 8006ed8:	4770      	bx	lr
 8006eda:	bf00      	nop
 8006edc:	20002dc4 	.word	0x20002dc4

08006ee0 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle const pxMutexHolder )
	{
 8006ee0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
 8006ee2:	4604      	mov	r4, r0
 8006ee4:	b358      	cbz	r0, 8006f3e <vTaskPriorityInherit+0x5e>
		{
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 8006ee6:	4d16      	ldr	r5, [pc, #88]	; (8006f40 <vTaskPriorityInherit+0x60>)
 8006ee8:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8006eea:	682a      	ldr	r2, [r5, #0]
 8006eec:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8006eee:	4293      	cmp	r3, r2
 8006ef0:	d225      	bcs.n	8006f3e <vTaskPriorityInherit+0x5e>
			{
				/* Adjust the mutex holder state to account for its new priority. */
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( portTickType ) configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8006ef2:	4628      	mov	r0, r5
 8006ef4:	f850 2b14 	ldr.w	r2, [r0], #20
 8006ef8:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8006efa:	f1c2 0205 	rsb	r2, r2, #5
 8006efe:	61a2      	str	r2, [r4, #24]

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
 8006f00:	2214      	movs	r2, #20
 8006f02:	fb02 0303 	mla	r3, r2, r3, r0
 8006f06:	6962      	ldr	r2, [r4, #20]
 8006f08:	429a      	cmp	r2, r3
 8006f0a:	4607      	mov	r7, r0
 8006f0c:	d114      	bne.n	8006f38 <vTaskPriorityInherit+0x58>
				{
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
 8006f0e:	1d26      	adds	r6, r4, #4
 8006f10:	4630      	mov	r0, r6
 8006f12:	f7fe ff27 	bl	8005d64 <uxListRemove>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 8006f16:	682b      	ldr	r3, [r5, #0]
					prvAddTaskToReadyList( pxTCB );
 8006f18:	f8d5 20e4 	ldr.w	r2, [r5, #228]	; 0xe4
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 8006f1c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006f1e:	62e3      	str	r3, [r4, #44]	; 0x2c
					prvAddTaskToReadyList( pxTCB );
 8006f20:	4293      	cmp	r3, r2
 8006f22:	d901      	bls.n	8006f28 <vTaskPriorityInherit+0x48>
 8006f24:	f8c5 30e4 	str.w	r3, [r5, #228]	; 0xe4
 8006f28:	2014      	movs	r0, #20
 8006f2a:	fb00 7003 	mla	r0, r0, r3, r7
 8006f2e:	4631      	mov	r1, r6
				}

				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
			}
		}
	}
 8006f30:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
					prvAddTaskToReadyList( pxTCB );
 8006f34:	f7fe bef2 	b.w	8005d1c <vListInsertEnd>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 8006f38:	682b      	ldr	r3, [r5, #0]
 8006f3a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006f3c:	62e3      	str	r3, [r4, #44]	; 0x2c
 8006f3e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8006f40:	20002dc4 	.word	0x20002dc4

08006f44 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle const pxMutexHolder )
	{
 8006f44:	b538      	push	{r3, r4, r5, lr}
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
 8006f46:	4604      	mov	r4, r0
 8006f48:	b1e0      	cbz	r0, 8006f84 <vTaskPriorityDisinherit+0x40>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8006f4a:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 8006f4c:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8006f4e:	429a      	cmp	r2, r3
 8006f50:	d018      	beq.n	8006f84 <vTaskPriorityDisinherit+0x40>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( unsigned portBASE_TYPE ) 0 )
 8006f52:	1d05      	adds	r5, r0, #4
 8006f54:	4628      	mov	r0, r5
 8006f56:	f7fe ff05 	bl	8005d64 <uxListRemove>
				}

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
 8006f5a:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8006f5c:	62e3      	str	r3, [r4, #44]	; 0x2c
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( portTickType ) configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8006f5e:	f1c3 0205 	rsb	r2, r3, #5
 8006f62:	61a2      	str	r2, [r4, #24]
				prvAddTaskToReadyList( pxTCB );
 8006f64:	4a08      	ldr	r2, [pc, #32]	; (8006f88 <vTaskPriorityDisinherit+0x44>)
 8006f66:	f8d2 10e4 	ldr.w	r1, [r2, #228]	; 0xe4
 8006f6a:	428b      	cmp	r3, r1
 8006f6c:	bf88      	it	hi
 8006f6e:	f8c2 30e4 	strhi.w	r3, [r2, #228]	; 0xe4
 8006f72:	4a06      	ldr	r2, [pc, #24]	; (8006f8c <vTaskPriorityDisinherit+0x48>)
 8006f74:	2014      	movs	r0, #20
 8006f76:	fb00 2003 	mla	r0, r0, r3, r2
 8006f7a:	4629      	mov	r1, r5
			}
		}
	}
 8006f7c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( portTickType ) configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
				prvAddTaskToReadyList( pxTCB );
 8006f80:	f7fe becc 	b.w	8005d1c <vListInsertEnd>
 8006f84:	bd38      	pop	{r3, r4, r5, pc}
 8006f86:	bf00      	nop
 8006f88:	20002dc4 	.word	0x20002dc4
 8006f8c:	20002dd8 	.word	0x20002dd8

08006f90 <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
 8006f90:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
	{
		if( xTimerQueue == NULL )
 8006f92:	4c0d      	ldr	r4, [pc, #52]	; (8006fc8 <prvCheckForValidListAndQueue+0x38>)
static void prvCheckForValidListAndQueue( void )
{
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
 8006f94:	f7fe fcca 	bl	800592c <vPortEnterCritical>
	{
		if( xTimerQueue == NULL )
 8006f98:	6825      	ldr	r5, [r4, #0]
 8006f9a:	b985      	cbnz	r5, 8006fbe <prvCheckForValidListAndQueue+0x2e>
		{
			vListInitialise( &xActiveTimerList1 );
 8006f9c:	1d27      	adds	r7, r4, #4
 8006f9e:	4638      	mov	r0, r7
			vListInitialise( &xActiveTimerList2 );
 8006fa0:	f104 0618 	add.w	r6, r4, #24
	initialised. */
	taskENTER_CRITICAL();
	{
		if( xTimerQueue == NULL )
		{
			vListInitialise( &xActiveTimerList1 );
 8006fa4:	f7fe feac 	bl	8005d00 <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
 8006fa8:	4630      	mov	r0, r6
 8006faa:	f7fe fea9 	bl	8005d00 <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
			pxOverflowTimerList = &xActiveTimerList2;
			xTimerQueue = xQueueCreate( ( unsigned portBASE_TYPE ) configTIMER_QUEUE_LENGTH, sizeof( xTIMER_MESSAGE ) );
 8006fae:	2005      	movs	r0, #5
 8006fb0:	210c      	movs	r1, #12
 8006fb2:	462a      	mov	r2, r5
	{
		if( xTimerQueue == NULL )
		{
			vListInitialise( &xActiveTimerList1 );
			vListInitialise( &xActiveTimerList2 );
			pxCurrentTimerList = &xActiveTimerList1;
 8006fb4:	62e7      	str	r7, [r4, #44]	; 0x2c
			pxOverflowTimerList = &xActiveTimerList2;
 8006fb6:	6326      	str	r6, [r4, #48]	; 0x30
			xTimerQueue = xQueueCreate( ( unsigned portBASE_TYPE ) configTIMER_QUEUE_LENGTH, sizeof( xTIMER_MESSAGE ) );
 8006fb8:	f7fe ff8d 	bl	8005ed6 <xQueueGenericCreate>
 8006fbc:	6020      	str	r0, [r4, #0]
		}
	}
	taskEXIT_CRITICAL();
}
 8006fbe:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			pxCurrentTimerList = &xActiveTimerList1;
			pxOverflowTimerList = &xActiveTimerList2;
			xTimerQueue = xQueueCreate( ( unsigned portBASE_TYPE ) configTIMER_QUEUE_LENGTH, sizeof( xTIMER_MESSAGE ) );
		}
	}
	taskEXIT_CRITICAL();
 8006fc2:	f7fe bcc4 	b.w	800594e <vPortExitCritical>
 8006fc6:	bf00      	nop
 8006fc8:	20002ec0 	.word	0x20002ec0

08006fcc <prvInsertTimerInActiveList>:
	return xTimeNow;
}
/*-----------------------------------------------------------*/

static portBASE_TYPE prvInsertTimerInActiveList( xTIMER *pxTimer, portTickType xNextExpiryTime, portTickType xTimeNow, portTickType xCommandTime )
{
 8006fcc:	b510      	push	{r4, lr}
 8006fce:	4604      	mov	r4, r0
portBASE_TYPE xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );

	if( xNextExpiryTime <= xTimeNow )
 8006fd0:	4291      	cmp	r1, r2

static portBASE_TYPE prvInsertTimerInActiveList( xTIMER *pxTimer, portTickType xNextExpiryTime, portTickType xTimeNow, portTickType xCommandTime )
{
portBASE_TYPE xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 8006fd2:	6041      	str	r1, [r0, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 8006fd4:	6120      	str	r0, [r4, #16]

	if( xNextExpiryTime <= xTimeNow )
 8006fd6:	d806      	bhi.n	8006fe6 <prvInsertTimerInActiveList+0x1a>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( xTimeNow - xCommandTime ) >= pxTimer->xTimerPeriodInTicks )
 8006fd8:	6981      	ldr	r1, [r0, #24]
 8006fda:	1ad2      	subs	r2, r2, r3
 8006fdc:	428a      	cmp	r2, r1
 8006fde:	d20d      	bcs.n	8006ffc <prvInsertTimerInActiveList+0x30>
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 8006fe0:	4b07      	ldr	r3, [pc, #28]	; (8007000 <prvInsertTimerInActiveList+0x34>)
 8006fe2:	6b18      	ldr	r0, [r3, #48]	; 0x30
 8006fe4:	e005      	b.n	8006ff2 <prvInsertTimerInActiveList+0x26>
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 8006fe6:	429a      	cmp	r2, r3
 8006fe8:	d201      	bcs.n	8006fee <prvInsertTimerInActiveList+0x22>
 8006fea:	4299      	cmp	r1, r3
 8006fec:	d206      	bcs.n	8006ffc <prvInsertTimerInActiveList+0x30>
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 8006fee:	4b04      	ldr	r3, [pc, #16]	; (8007000 <prvInsertTimerInActiveList+0x34>)
 8006ff0:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 8006ff2:	1d21      	adds	r1, r4, #4
 8006ff4:	f7fe fe9e 	bl	8005d34 <vListInsert>
}
/*-----------------------------------------------------------*/

static portBASE_TYPE prvInsertTimerInActiveList( xTIMER *pxTimer, portTickType xNextExpiryTime, portTickType xTimeNow, portTickType xCommandTime )
{
portBASE_TYPE xProcessTimerNow = pdFALSE;
 8006ff8:	2000      	movs	r0, #0
 8006ffa:	bd10      	pop	{r4, pc}
		timer was issued, and the time the command was processed? */
		if( ( xTimeNow - xCommandTime ) >= pxTimer->xTimerPeriodInTicks )
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
 8006ffc:	2001      	movs	r0, #1
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
		}
	}

	return xProcessTimerNow;
}
 8006ffe:	bd10      	pop	{r4, pc}
 8007000:	20002ec0 	.word	0x20002ec0

08007004 <xTimerCreateTimerTask>:
static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty ) PRIVILEGED_FUNCTION;

/*-----------------------------------------------------------*/

portBASE_TYPE xTimerCreateTimerTask( void )
{
 8007004:	b51f      	push	{r0, r1, r2, r3, r4, lr}

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
 8007006:	f7ff ffc3 	bl	8006f90 <prvCheckForValidListAndQueue>

	if( xTimerQueue != NULL )
 800700a:	4b0c      	ldr	r3, [pc, #48]	; (800703c <xTimerCreateTimerTask+0x38>)
 800700c:	681b      	ldr	r3, [r3, #0]
 800700e:	b913      	cbnz	r3, 8007016 <xTimerCreateTimerTask+0x12>
			xReturn = xTaskCreate( prvTimerTask, ( const signed char * ) "Tmr Svc", ( unsigned short ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( unsigned portBASE_TYPE ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, NULL);
		}
		#endif
	}

	configASSERT( xReturn );
 8007010:	f7fe fc76 	bl	8005900 <ulPortSetInterruptMask>
 8007014:	e010      	b.n	8007038 <xTimerCreateTimerTask+0x34>
			xReturn = xTaskCreate( prvTimerTask, ( const signed char * ) "Tmr Svc", ( unsigned short ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( unsigned portBASE_TYPE ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, &xTimerTaskHandle );
		}
		#else
		{
			/* Create the timer task without storing its handle. */
			xReturn = xTaskCreate( prvTimerTask, ( const signed char * ) "Tmr Svc", ( unsigned short ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( unsigned portBASE_TYPE ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, NULL);
 8007016:	2303      	movs	r3, #3
 8007018:	9300      	str	r3, [sp, #0]
 800701a:	2300      	movs	r3, #0
 800701c:	9301      	str	r3, [sp, #4]
 800701e:	9302      	str	r3, [sp, #8]
 8007020:	9303      	str	r3, [sp, #12]
 8007022:	4807      	ldr	r0, [pc, #28]	; (8007040 <xTimerCreateTimerTask+0x3c>)
 8007024:	4907      	ldr	r1, [pc, #28]	; (8007044 <xTimerCreateTimerTask+0x40>)
 8007026:	f44f 72a0 	mov.w	r2, #320	; 0x140
 800702a:	f7ff fa79 	bl	8006520 <xTaskGenericCreate>
		}
		#endif
	}

	configASSERT( xReturn );
 800702e:	2800      	cmp	r0, #0
 8007030:	d0ee      	beq.n	8007010 <xTimerCreateTimerTask+0xc>
	return xReturn;
}
 8007032:	b005      	add	sp, #20
 8007034:	f85d fb04 	ldr.w	pc, [sp], #4
 8007038:	e7fe      	b.n	8007038 <xTimerCreateTimerTask+0x34>
 800703a:	bf00      	nop
 800703c:	20002ec0 	.word	0x20002ec0
 8007040:	0800712d 	.word	0x0800712d
 8007044:	08009d42 	.word	0x08009d42

08007048 <xTimerCreate>:
/*-----------------------------------------------------------*/

xTimerHandle xTimerCreate( const signed char * const pcTimerName, portTickType xTimerPeriodInTicks, unsigned portBASE_TYPE uxAutoReload, void *pvTimerID, tmrTIMER_CALLBACK pxCallbackFunction )
{
 8007048:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800704c:	4680      	mov	r8, r0
 800704e:	4617      	mov	r7, r2
 8007050:	461e      	mov	r6, r3
xTIMER *pxNewTimer;

	/* Allocate the timer structure. */
	if( xTimerPeriodInTicks == ( portTickType ) 0U )
 8007052:	460d      	mov	r5, r1
 8007054:	b189      	cbz	r1, 800707a <xTimerCreate+0x32>
	{
		pxNewTimer = NULL;
	}
	else
	{
		pxNewTimer = ( xTIMER * ) pvPortMalloc( sizeof( xTIMER ) );
 8007056:	2028      	movs	r0, #40	; 0x28
 8007058:	f7fe fbd4 	bl	8005804 <pvPortMalloc>
		if( pxNewTimer != NULL )
 800705c:	4604      	mov	r4, r0
 800705e:	b178      	cbz	r0, 8007080 <xTimerCreate+0x38>
		{
			/* Ensure the infrastructure used by the timer service task has been
			created/initialised. */
			prvCheckForValidListAndQueue();
 8007060:	f7ff ff96 	bl	8006f90 <prvCheckForValidListAndQueue>
			/* Initialise the timer structure members using the function parameters. */
			pxNewTimer->pcTimerName = pcTimerName;
			pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
			pxNewTimer->uxAutoReload = uxAutoReload;
			pxNewTimer->pvTimerID = pvTimerID;
			pxNewTimer->pxCallbackFunction = pxCallbackFunction;
 8007064:	9b06      	ldr	r3, [sp, #24]
			/* Ensure the infrastructure used by the timer service task has been
			created/initialised. */
			prvCheckForValidListAndQueue();

			/* Initialise the timer structure members using the function parameters. */
			pxNewTimer->pcTimerName = pcTimerName;
 8007066:	f8c4 8000 	str.w	r8, [r4]
			pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
 800706a:	61a5      	str	r5, [r4, #24]
			pxNewTimer->uxAutoReload = uxAutoReload;
 800706c:	61e7      	str	r7, [r4, #28]
			pxNewTimer->pvTimerID = pvTimerID;
 800706e:	6226      	str	r6, [r4, #32]
			pxNewTimer->pxCallbackFunction = pxCallbackFunction;
 8007070:	6263      	str	r3, [r4, #36]	; 0x24
			vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
 8007072:	1d20      	adds	r0, r4, #4
 8007074:	f7fe fe4f 	bl	8005d16 <vListInitialiseItem>
 8007078:	e002      	b.n	8007080 <xTimerCreate+0x38>
			traceTIMER_CREATE_FAILED();
		}
	}

	/* 0 is not a valid value for xTimerPeriodInTicks. */
	configASSERT( ( xTimerPeriodInTicks > 0 ) );
 800707a:	f7fe fc41 	bl	8005900 <ulPortSetInterruptMask>
 800707e:	e7fe      	b.n	800707e <xTimerCreate+0x36>

	return ( xTimerHandle ) pxNewTimer;
}
 8007080:	4620      	mov	r0, r4
 8007082:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08007086 <xTimerGenericCommand>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTimerGenericCommand( xTimerHandle xTimer, portBASE_TYPE xCommandID, portTickType xOptionalValue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portTickType xBlockTime )
{
 8007086:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
portBASE_TYPE xReturn = pdFAIL;
xTIMER_MESSAGE xMessage;

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
 8007088:	4d0f      	ldr	r5, [pc, #60]	; (80070c8 <xTimerGenericCommand+0x42>)
	return ( xTimerHandle ) pxNewTimer;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTimerGenericCommand( xTimerHandle xTimer, portBASE_TYPE xCommandID, portTickType xOptionalValue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portTickType xBlockTime )
{
 800708a:	4606      	mov	r6, r0
portBASE_TYPE xReturn = pdFAIL;
xTIMER_MESSAGE xMessage;

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
 800708c:	6828      	ldr	r0, [r5, #0]
	return ( xTimerHandle ) pxNewTimer;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTimerGenericCommand( xTimerHandle xTimer, portBASE_TYPE xCommandID, portTickType xOptionalValue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portTickType xBlockTime )
{
 800708e:	461c      	mov	r4, r3
portBASE_TYPE xReturn = pdFAIL;
xTIMER_MESSAGE xMessage;

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
 8007090:	b1b8      	cbz	r0, 80070c2 <xTimerGenericCommand+0x3c>
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
 8007092:	9101      	str	r1, [sp, #4]
		xMessage.xMessageValue = xOptionalValue;
 8007094:	9202      	str	r2, [sp, #8]
		xMessage.pxTimer = ( xTIMER * ) xTimer;
 8007096:	9603      	str	r6, [sp, #12]

		if( pxHigherPriorityTaskWoken == NULL )
 8007098:	b973      	cbnz	r3, 80070b8 <xTimerGenericCommand+0x32>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 800709a:	f7ff ff13 	bl	8006ec4 <xTaskGetSchedulerState>
 800709e:	2801      	cmp	r0, #1
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xBlockTime );
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
 80070a0:	bf18      	it	ne
 80070a2:	4622      	movne	r2, r4

		if( pxHigherPriorityTaskWoken == NULL )
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xBlockTime );
 80070a4:	6828      	ldr	r0, [r5, #0]
 80070a6:	bf08      	it	eq
 80070a8:	9a08      	ldreq	r2, [sp, #32]
 80070aa:	a901      	add	r1, sp, #4
 80070ac:	bf0c      	ite	eq
 80070ae:	4623      	moveq	r3, r4
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
 80070b0:	4613      	movne	r3, r2
 80070b2:	f7fe ff2e 	bl	8005f12 <xQueueGenericSend>
 80070b6:	e004      	b.n	80070c2 <xTimerGenericCommand+0x3c>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
 80070b8:	461a      	mov	r2, r3
 80070ba:	a901      	add	r1, sp, #4
 80070bc:	2300      	movs	r3, #0
 80070be:	f7fe ffcd 	bl	800605c <xQueueGenericSendFromISR>

		traceTIMER_COMMAND_SEND( xTimer, xCommandID, xOptionalValue, xReturn );
	}

	return xReturn;
}
 80070c2:	b004      	add	sp, #16
 80070c4:	bd70      	pop	{r4, r5, r6, pc}
 80070c6:	bf00      	nop
 80070c8:	20002ec0 	.word	0x20002ec0

080070cc <prvSwitchTimerLists.isra.1>:
		}
	}
}
/*-----------------------------------------------------------*/

static void prvSwitchTimerLists( portTickType xLastTime )
 80070cc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 80070ce:	4d16      	ldr	r5, [pc, #88]	; (8007128 <prvSwitchTimerLists.isra.1+0x5c>)
 80070d0:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 80070d2:	681a      	ldr	r2, [r3, #0]
 80070d4:	b31a      	cbz	r2, 800711e <prvSwitchTimerLists.isra.1+0x52>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 80070d6:	68db      	ldr	r3, [r3, #12]

		/* Remove the timer from the list. */
		pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
 80070d8:	68dc      	ldr	r4, [r3, #12]
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 80070da:	681e      	ldr	r6, [r3, #0]

		/* Remove the timer from the list. */
		pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 80070dc:	1d27      	adds	r7, r4, #4
 80070de:	4638      	mov	r0, r7
 80070e0:	f7fe fe40 	bl	8005d64 <uxListRemove>

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
 80070e4:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80070e6:	4620      	mov	r0, r4
 80070e8:	4798      	blx	r3

		if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
 80070ea:	69e3      	ldr	r3, [r4, #28]
 80070ec:	2b01      	cmp	r3, #1
 80070ee:	d1ee      	bne.n	80070ce <prvSwitchTimerLists.isra.1+0x2>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
 80070f0:	69a3      	ldr	r3, [r4, #24]
 80070f2:	4433      	add	r3, r6
			if( xReloadTime > xNextExpireTime )
 80070f4:	42b3      	cmp	r3, r6
 80070f6:	d906      	bls.n	8007106 <prvSwitchTimerLists.isra.1+0x3a>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
 80070f8:	6063      	str	r3, [r4, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 80070fa:	6124      	str	r4, [r4, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 80070fc:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
 80070fe:	4639      	mov	r1, r7
 8007100:	f7fe fe18 	bl	8005d34 <vListInsert>
 8007104:	e7e3      	b.n	80070ce <prvSwitchTimerLists.isra.1+0x2>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
 8007106:	2100      	movs	r1, #0
 8007108:	9100      	str	r1, [sp, #0]
 800710a:	4620      	mov	r0, r4
 800710c:	4632      	mov	r2, r6
 800710e:	460b      	mov	r3, r1
 8007110:	f7ff ffb9 	bl	8007086 <xTimerGenericCommand>
				configASSERT( xResult );
 8007114:	2800      	cmp	r0, #0
 8007116:	d1da      	bne.n	80070ce <prvSwitchTimerLists.isra.1+0x2>
 8007118:	f7fe fbf2 	bl	8005900 <ulPortSetInterruptMask>
 800711c:	e7fe      	b.n	800711c <prvSwitchTimerLists.isra.1+0x50>
			}
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
 800711e:	6b2a      	ldr	r2, [r5, #48]	; 0x30
 8007120:	62ea      	str	r2, [r5, #44]	; 0x2c
	pxOverflowTimerList = pxTemp;
 8007122:	632b      	str	r3, [r5, #48]	; 0x30
}
 8007124:	b003      	add	sp, #12
 8007126:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8007128:	20002ec0 	.word	0x20002ec0

0800712c <prvTimerTask>:
	pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
 800712c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8007130:	b086      	sub	sp, #24
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 8007132:	4c51      	ldr	r4, [pc, #324]	; (8007278 <prvTimerTask+0x14c>)
 8007134:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8007136:	681a      	ldr	r2, [r3, #0]
 8007138:	f1d2 0801 	rsbs	r8, r2, #1
 800713c:	bf38      	it	cc
 800713e:	f04f 0800 	movcc.w	r8, #0
 8007142:	4627      	mov	r7, r4
	if( *pxListWasEmpty == pdFALSE )
 8007144:	f1b8 0f00 	cmp.w	r8, #0
 8007148:	d102      	bne.n	8007150 <prvTimerTask+0x24>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 800714a:	68db      	ldr	r3, [r3, #12]
 800714c:	681d      	ldr	r5, [r3, #0]
 800714e:	e000      	b.n	8007152 <prvTimerTask+0x26>
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( portTickType ) 0U;
 8007150:	2500      	movs	r5, #0
static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty )
{
portTickType xTimeNow;
portBASE_TYPE xTimerListsWereSwitched;

	vTaskSuspendAll();
 8007152:	f7ff fbf7 	bl	8006944 <vTaskSuspendAll>
static portTickType prvSampleTimeNow( portBASE_TYPE *pxTimerListsWereSwitched )
{
portTickType xTimeNow;
PRIVILEGED_DATA static portTickType xLastTime = ( portTickType ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
 8007156:	f7ff fbff 	bl	8006958 <xTaskGetTickCount>

	if( xTimeNow < xLastTime )
 800715a:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800715c:	4298      	cmp	r0, r3
static portTickType prvSampleTimeNow( portBASE_TYPE *pxTimerListsWereSwitched )
{
portTickType xTimeNow;
PRIVILEGED_DATA static portTickType xLastTime = ( portTickType ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
 800715e:	4606      	mov	r6, r0

	if( xTimeNow < xLastTime )
 8007160:	d203      	bcs.n	800716a <prvTimerTask+0x3e>
	{
		prvSwitchTimerLists( xLastTime );
 8007162:	f7ff ffb3 	bl	80070cc <prvSwitchTimerLists.isra.1>
		*pxTimerListsWereSwitched = pdTRUE;
 8007166:	2301      	movs	r3, #1
 8007168:	e000      	b.n	800716c <prvTimerTask+0x40>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
 800716a:	2300      	movs	r3, #0
	}

	xLastTime = xTimeNow;
 800716c:	6366      	str	r6, [r4, #52]	; 0x34
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampelTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
		if( xTimerListsWereSwitched == pdFALSE )
 800716e:	2b00      	cmp	r3, #0
 8007170:	d133      	bne.n	80071da <prvTimerTask+0xae>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 8007172:	f1b8 0f00 	cmp.w	r8, #0
 8007176:	d126      	bne.n	80071c6 <prvTimerTask+0x9a>
 8007178:	42b5      	cmp	r5, r6
 800717a:	d824      	bhi.n	80071c6 <prvTimerTask+0x9a>
			{
				( void ) xTaskResumeAll();
 800717c:	f7ff fc8a 	bl	8006a94 <xTaskResumeAll>
xTIMER *pxTimer;
portBASE_TYPE xResult;

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
 8007180:	4b3d      	ldr	r3, [pc, #244]	; (8007278 <prvTimerTask+0x14c>)
 8007182:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8007184:	68db      	ldr	r3, [r3, #12]
 8007186:	68dc      	ldr	r4, [r3, #12]
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 8007188:	1d20      	adds	r0, r4, #4
 800718a:	f7fe fdeb 	bl	8005d64 <uxListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
 800718e:	69e3      	ldr	r3, [r4, #28]
 8007190:	2b01      	cmp	r3, #1
 8007192:	d114      	bne.n	80071be <prvTimerTask+0x92>
		a time relative to anything other than the current time.  It
		will therefore be inserted into the correct list relative to
		the time this task thinks it is now, even if a command to
		switch lists due to a tick count overflow is already waiting in
		the timer queue. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
 8007194:	69a1      	ldr	r1, [r4, #24]
 8007196:	4620      	mov	r0, r4
 8007198:	4429      	add	r1, r5
 800719a:	4632      	mov	r2, r6
 800719c:	462b      	mov	r3, r5
 800719e:	f7ff ff15 	bl	8006fcc <prvInsertTimerInActiveList>
 80071a2:	2801      	cmp	r0, #1
 80071a4:	d10b      	bne.n	80071be <prvTimerTask+0x92>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
 80071a6:	f8cd 8000 	str.w	r8, [sp]
 80071aa:	4620      	mov	r0, r4
 80071ac:	4641      	mov	r1, r8
 80071ae:	462a      	mov	r2, r5
 80071b0:	4643      	mov	r3, r8
 80071b2:	f7ff ff68 	bl	8007086 <xTimerGenericCommand>
			configASSERT( xResult );
 80071b6:	b910      	cbnz	r0, 80071be <prvTimerTask+0x92>
 80071b8:	f7fe fba2 	bl	8005900 <ulPortSetInterruptMask>
 80071bc:	e7fe      	b.n	80071bc <prvTimerTask+0x90>
			( void ) xResult;
		}
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
 80071be:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80071c0:	4620      	mov	r0, r4
 80071c2:	4798      	blx	r3
 80071c4:	e021      	b.n	800720a <prvTimerTask+0xde>
				time has not been reached yet.  This task should therefore
				block to wait for the next expire time or a command to be
				received - whichever comes first.  The following line cannot
				be reached unless xNextExpireTime > xTimeNow, except in the
				case when the current timer list is empty. */
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ) );
 80071c6:	6820      	ldr	r0, [r4, #0]
 80071c8:	1ba9      	subs	r1, r5, r6
 80071ca:	f7ff f96e 	bl	80064aa <vQueueWaitForMessageRestricted>

				if( xTaskResumeAll() == pdFALSE )
 80071ce:	f7ff fc61 	bl	8006a94 <xTaskResumeAll>
 80071d2:	b9d0      	cbnz	r0, 800720a <prvTimerTask+0xde>
				{
					/* Yield to wait for either a command to arrive, or the block time
					to expire.  If a command arrived between the critical section being
					exited and this yield then the yield will not cause the task
					to block. */
					portYIELD_WITHIN_API();
 80071d4:	f7fe fb89 	bl	80058ea <vPortYield>
 80071d8:	e017      	b.n	800720a <prvTimerTask+0xde>
				}
			}
		}
		else
		{
			( void ) xTaskResumeAll();
 80071da:	f7ff fc5b 	bl	8006a94 <xTaskResumeAll>
 80071de:	e014      	b.n	800720a <prvTimerTask+0xde>
portBASE_TYPE xTimerListsWereSwitched, xResult;
portTickType xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
	{
		pxTimer = xMessage.pxTimer;
 80071e0:	9c05      	ldr	r4, [sp, #20]

		if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
 80071e2:	6963      	ldr	r3, [r4, #20]
 80071e4:	b113      	cbz	r3, 80071ec <prvTimerTask+0xc0>
		{
			/* The timer is in a list, remove it. */
			( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 80071e6:	1d20      	adds	r0, r4, #4
 80071e8:	f7fe fdbc 	bl	8005d64 <uxListRemove>
static portTickType prvSampleTimeNow( portBASE_TYPE *pxTimerListsWereSwitched )
{
portTickType xTimeNow;
PRIVILEGED_DATA static portTickType xLastTime = ( portTickType ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
 80071ec:	f7ff fbb4 	bl	8006958 <xTaskGetTickCount>

	if( xTimeNow < xLastTime )
 80071f0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80071f2:	4298      	cmp	r0, r3
static portTickType prvSampleTimeNow( portBASE_TYPE *pxTimerListsWereSwitched )
{
portTickType xTimeNow;
PRIVILEGED_DATA static portTickType xLastTime = ( portTickType ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
 80071f4:	4606      	mov	r6, r0

	if( xTimeNow < xLastTime )
 80071f6:	d201      	bcs.n	80071fc <prvTimerTask+0xd0>
	{
		prvSwitchTimerLists( xLastTime );
 80071f8:	f7ff ff68 	bl	80070cc <prvSwitchTimerLists.isra.1>
		possibility of a higher priority task adding a message to the message
		queue with a time that is ahead of the timer daemon task (because it
		pre-empted the timer daemon task after the xTimeNow value was set). */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );

		switch( xMessage.xMessageID )
 80071fc:	9d03      	ldr	r5, [sp, #12]
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
	}

	xLastTime = xTimeNow;
 80071fe:	637e      	str	r6, [r7, #52]	; 0x34
		possibility of a higher priority task adding a message to the message
		queue with a time that is ahead of the timer daemon task (because it
		pre-empted the timer daemon task after the xTimeNow value was set). */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );

		switch( xMessage.xMessageID )
 8007200:	2d02      	cmp	r5, #2
 8007202:	d028      	beq.n	8007256 <prvTimerTask+0x12a>
 8007204:	2d03      	cmp	r5, #3
 8007206:	d033      	beq.n	8007270 <prvTimerTask+0x144>
 8007208:	b145      	cbz	r5, 800721c <prvTimerTask+0xf0>
xTIMER_MESSAGE xMessage;
xTIMER *pxTimer;
portBASE_TYPE xTimerListsWereSwitched, xResult;
portTickType xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
 800720a:	2200      	movs	r2, #0
 800720c:	6838      	ldr	r0, [r7, #0]
 800720e:	a903      	add	r1, sp, #12
 8007210:	4613      	mov	r3, r2
 8007212:	f7fe ff65 	bl	80060e0 <xQueueGenericReceive>
 8007216:	2800      	cmp	r0, #0
 8007218:	d1e2      	bne.n	80071e0 <prvTimerTask+0xb4>
 800721a:	e78a      	b.n	8007132 <prvTimerTask+0x6>

		switch( xMessage.xMessageID )
		{
			case tmrCOMMAND_START :
				/* Start or restart a timer. */
				if( prvInsertTimerInActiveList( pxTimer,  xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.xMessageValue ) == pdTRUE )
 800721c:	9b04      	ldr	r3, [sp, #16]
 800721e:	69a1      	ldr	r1, [r4, #24]
 8007220:	4620      	mov	r0, r4
 8007222:	4419      	add	r1, r3
 8007224:	4632      	mov	r2, r6
 8007226:	f7ff fed1 	bl	8006fcc <prvInsertTimerInActiveList>
 800722a:	2801      	cmp	r0, #1
 800722c:	d1ed      	bne.n	800720a <prvTimerTask+0xde>
				{
					/* The timer expired before it was added to the active timer
					list.  Process it now. */
					pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
 800722e:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8007230:	4620      	mov	r0, r4
 8007232:	4798      	blx	r3

					if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
 8007234:	69e3      	ldr	r3, [r4, #28]
 8007236:	2b01      	cmp	r3, #1
 8007238:	d1e7      	bne.n	800720a <prvTimerTask+0xde>
					{
						xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
 800723a:	69a2      	ldr	r2, [r4, #24]
 800723c:	9b04      	ldr	r3, [sp, #16]
 800723e:	9500      	str	r5, [sp, #0]
 8007240:	441a      	add	r2, r3
 8007242:	4620      	mov	r0, r4
 8007244:	4629      	mov	r1, r5
 8007246:	462b      	mov	r3, r5
 8007248:	f7ff ff1d 	bl	8007086 <xTimerGenericCommand>
						configASSERT( xResult );
 800724c:	2800      	cmp	r0, #0
 800724e:	d1dc      	bne.n	800720a <prvTimerTask+0xde>
 8007250:	f7fe fb56 	bl	8005900 <ulPortSetInterruptMask>
 8007254:	e7fe      	b.n	8007254 <prvTimerTask+0x128>
				/* The timer has already been removed from the active list.
				There is nothing to do here. */
				break;

			case tmrCOMMAND_CHANGE_PERIOD :
				pxTimer->xTimerPeriodInTicks = xMessage.xMessageValue;
 8007256:	9904      	ldr	r1, [sp, #16]
 8007258:	61a1      	str	r1, [r4, #24]
				configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 800725a:	b911      	cbnz	r1, 8007262 <prvTimerTask+0x136>
 800725c:	f7fe fb50 	bl	8005900 <ulPortSetInterruptMask>
 8007260:	e7fe      	b.n	8007260 <prvTimerTask+0x134>
				longer or shorter than the old one.  The command time is 
				therefore set to the current time, and as the period cannot be
				zero the next expiry time can only be in the future, meaning
				(unlike for the xTimerStart() case above) there is no fail case
				that needs to be handled here. */
				( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
 8007262:	4620      	mov	r0, r4
 8007264:	4431      	add	r1, r6
 8007266:	4632      	mov	r2, r6
 8007268:	4633      	mov	r3, r6
 800726a:	f7ff feaf 	bl	8006fcc <prvInsertTimerInActiveList>
 800726e:	e7cc      	b.n	800720a <prvTimerTask+0xde>
				break;

			case tmrCOMMAND_DELETE :
				/* The timer has already been removed from the active list,
				just free up the memory. */
				vPortFree( pxTimer );
 8007270:	4620      	mov	r0, r4
 8007272:	f7fe faf3 	bl	800585c <vPortFree>
 8007276:	e7c8      	b.n	800720a <prvTimerTask+0xde>
 8007278:	20002ec0 	.word	0x20002ec0

0800727c <xTimerIsTimerActive>:
	taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTimerIsTimerActive( xTimerHandle xTimer )
{
 800727c:	b510      	push	{r4, lr}
 800727e:	4604      	mov	r4, r0
portBASE_TYPE xTimerIsInActiveList;
xTIMER *pxTimer = ( xTIMER * ) xTimer;

	/* Is the timer in the list of active timers? */
	taskENTER_CRITICAL();
 8007280:	f7fe fb54 	bl	800592c <vPortEnterCritical>
	{
		/* Checking to see if it is in the NULL list in effect checks to see if
		it is referenced from either the current or the overflow timer lists in
		one go, but the logic has to be reversed, hence the '!'. */
		xTimerIsInActiveList = !( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) );
 8007284:	6964      	ldr	r4, [r4, #20]
 8007286:	3400      	adds	r4, #0
 8007288:	bf18      	it	ne
 800728a:	2401      	movne	r4, #1
	}
	taskEXIT_CRITICAL();
 800728c:	f7fe fb5f 	bl	800594e <vPortExitCritical>

	return xTimerIsInActiveList;
}
 8007290:	4620      	mov	r0, r4
 8007292:	bd10      	pop	{r4, pc}

08007294 <pvTimerGetTimerID>:
void *pvTimerGetTimerID( xTimerHandle xTimer )
{
xTIMER *pxTimer = ( xTIMER * ) xTimer;

	return pxTimer->pvTimerID;
}
 8007294:	6a00      	ldr	r0, [r0, #32]
 8007296:	4770      	bx	lr

08007298 <SystemInit>:
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8007298:	4b39      	ldr	r3, [pc, #228]	; (8007380 <SystemInit+0xe8>)
 800729a:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 800729e:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 80072a2:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  #endif

  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 80072a6:	4b37      	ldr	r3, [pc, #220]	; (8007384 <SystemInit+0xec>)
 80072a8:	681a      	ldr	r2, [r3, #0]
 80072aa:	f042 0201 	orr.w	r2, r2, #1
 80072ae:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR &= 0xF87FC00C;
 80072b0:	6859      	ldr	r1, [r3, #4]
 80072b2:	4a35      	ldr	r2, [pc, #212]	; (8007388 <SystemInit+0xf0>)
 80072b4:	400a      	ands	r2, r1
 80072b6:	605a      	str	r2, [r3, #4]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 80072b8:	681a      	ldr	r2, [r3, #0]
 80072ba:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 80072be:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80072c2:	601a      	str	r2, [r3, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 80072c4:	681a      	ldr	r2, [r3, #0]
 80072c6:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80072ca:	601a      	str	r2, [r3, #0]

  /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE bits */
  RCC->CFGR &= (uint32_t)0xFF80FFFF;
 80072cc:	685a      	ldr	r2, [r3, #4]
 80072ce:	f422 02fe 	bic.w	r2, r2, #8323072	; 0x7f0000
 80072d2:	605a      	str	r2, [r3, #4]

  /* Reset PREDIV1[3:0] bits */
  RCC->CFGR2 &= (uint32_t)0xFFFFFFF0;
 80072d4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80072d6:	f022 020f 	bic.w	r2, r2, #15
 80072da:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Reset USARTSW[1:0], I2CSW and TIMs bits */
  RCC->CFGR3 &= (uint32_t)0xFF00FCCC;
 80072dc:	6b19      	ldr	r1, [r3, #48]	; 0x30
 80072de:	4a2b      	ldr	r2, [pc, #172]	; (800738c <SystemInit+0xf4>)
  *         SystemFrequency variable.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 80072e0:	b082      	sub	sp, #8

  /* Reset PREDIV1[3:0] bits */
  RCC->CFGR2 &= (uint32_t)0xFFFFFFF0;

  /* Reset USARTSW[1:0], I2CSW and TIMs bits */
  RCC->CFGR3 &= (uint32_t)0xFF00FCCC;
 80072e2:	400a      	ands	r2, r1
 80072e4:	631a      	str	r2, [r3, #48]	; 0x30
  
  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 80072e6:	2200      	movs	r2, #0
 80072e8:	609a      	str	r2, [r3, #8]
  * @param  None
  * @retval None
  */
static void SetSysClock(void)
{
  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
 80072ea:	9200      	str	r2, [sp, #0]
 80072ec:	9201      	str	r2, [sp, #4]
/*            PLL (clocked by HSE) used as System clock source                */
/******************************************************************************/

  /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration -----------*/
  /* Enable HSE */
  RCC->CR |= ((uint32_t)RCC_CR_HSEON);
 80072ee:	681a      	ldr	r2, [r3, #0]
 80072f0:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 80072f4:	601a      	str	r2, [r3, #0]
 
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC->CR & RCC_CR_HSERDY;
 80072f6:	681a      	ldr	r2, [r3, #0]
 80072f8:	f402 3200 	and.w	r2, r2, #131072	; 0x20000
 80072fc:	9201      	str	r2, [sp, #4]
    StartUpCounter++;
 80072fe:	9a00      	ldr	r2, [sp, #0]
 8007300:	3201      	adds	r2, #1
 8007302:	9200      	str	r2, [sp, #0]
  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
 8007304:	9a01      	ldr	r2, [sp, #4]
 8007306:	b91a      	cbnz	r2, 8007310 <SystemInit+0x78>
 8007308:	9a00      	ldr	r2, [sp, #0]
 800730a:	f5b2 6fa0 	cmp.w	r2, #1280	; 0x500
 800730e:	d1f2      	bne.n	80072f6 <SystemInit+0x5e>

  if ((RCC->CR & RCC_CR_HSERDY) != RESET)
 8007310:	681a      	ldr	r2, [r3, #0]
 8007312:	f412 3200 	ands.w	r2, r2, #131072	; 0x20000
  {
    HSEStatus = (uint32_t)0x01;
 8007316:	bf18      	it	ne
 8007318:	2201      	movne	r2, #1
  }
  else
  {
    HSEStatus = (uint32_t)0x00;
 800731a:	9201      	str	r2, [sp, #4]
  }

  if (HSEStatus == (uint32_t)0x01)
 800731c:	9a01      	ldr	r2, [sp, #4]
 800731e:	2a01      	cmp	r2, #1
 8007320:	d005      	beq.n	800732e <SystemInit+0x96>
  SetSysClock();
  
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */
 8007322:	4b17      	ldr	r3, [pc, #92]	; (8007380 <SystemInit+0xe8>)
 8007324:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8007328:	609a      	str	r2, [r3, #8]
#endif  
}
 800732a:	b002      	add	sp, #8
 800732c:	4770      	bx	lr
  }

  if (HSEStatus == (uint32_t)0x01)
  {
    /* Enable Prefetch Buffer and set Flash Latency */
    FLASH->ACR = FLASH_ACR_PRFTBE | (uint32_t)FLASH_ACR_LATENCY_1;
 800732e:	4a18      	ldr	r2, [pc, #96]	; (8007390 <SystemInit+0xf8>)
 8007330:	2112      	movs	r1, #18
 8007332:	6011      	str	r1, [r2, #0]
 
     /* HCLK = SYSCLK / 1 */
     RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
 8007334:	685a      	ldr	r2, [r3, #4]
 8007336:	605a      	str	r2, [r3, #4]
       
     /* PCLK2 = HCLK / 1 */
     RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
 8007338:	685a      	ldr	r2, [r3, #4]
 800733a:	605a      	str	r2, [r3, #4]
     
     /* PCLK1 = HCLK / 2 */
     RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;
 800733c:	685a      	ldr	r2, [r3, #4]
 800733e:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8007342:	605a      	str	r2, [r3, #4]

    /* PLL configuration */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL));
 8007344:	685a      	ldr	r2, [r3, #4]
 8007346:	f422 127c 	bic.w	r2, r2, #4128768	; 0x3f0000
 800734a:	605a      	str	r2, [r3, #4]
    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_PREDIV1 | RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLMULL9);
 800734c:	685a      	ldr	r2, [r3, #4]
 800734e:	f442 12e8 	orr.w	r2, r2, #1900544	; 0x1d0000
 8007352:	605a      	str	r2, [r3, #4]

    /* Enable PLL */
    RCC->CR |= RCC_CR_PLLON;
 8007354:	681a      	ldr	r2, [r3, #0]
 8007356:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 800735a:	601a      	str	r2, [r3, #0]

    /* Wait till PLL is ready */
    while((RCC->CR & RCC_CR_PLLRDY) == 0)
 800735c:	6819      	ldr	r1, [r3, #0]
 800735e:	4a09      	ldr	r2, [pc, #36]	; (8007384 <SystemInit+0xec>)
 8007360:	0189      	lsls	r1, r1, #6
 8007362:	d5fb      	bpl.n	800735c <SystemInit+0xc4>
    {
    }
    
    /* Select PLL as system clock source */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
 8007364:	6851      	ldr	r1, [r2, #4]
 8007366:	f021 0103 	bic.w	r1, r1, #3
 800736a:	6051      	str	r1, [r2, #4]
    RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;
 800736c:	6851      	ldr	r1, [r2, #4]
 800736e:	f041 0102 	orr.w	r1, r1, #2
 8007372:	6051      	str	r1, [r2, #4]

    /* Wait till PLL is used as system clock source */
    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)RCC_CFGR_SWS_PLL)
 8007374:	685a      	ldr	r2, [r3, #4]
 8007376:	f002 020c 	and.w	r2, r2, #12
 800737a:	2a08      	cmp	r2, #8
 800737c:	d1fa      	bne.n	8007374 <SystemInit+0xdc>
 800737e:	e7d0      	b.n	8007322 <SystemInit+0x8a>
 8007380:	e000ed00 	.word	0xe000ed00
 8007384:	40021000 	.word	0x40021000
 8007388:	f87fc00c 	.word	0xf87fc00c
 800738c:	ff00fccc 	.word	0xff00fccc
 8007390:	40022000 	.word	0x40022000

08007394 <SystemCoreClockUpdate>:
void SystemCoreClockUpdate (void)
{
  uint32_t tmp = 0, pllmull = 0, pllsource = 0, prediv1factor = 0;

  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 8007394:	4a13      	ldr	r2, [pc, #76]	; (80073e4 <SystemCoreClockUpdate+0x50>)
 8007396:	4b14      	ldr	r3, [pc, #80]	; (80073e8 <SystemCoreClockUpdate+0x54>)
 8007398:	6851      	ldr	r1, [r2, #4]
 800739a:	f001 010c 	and.w	r1, r1, #12
  
  switch (tmp)
 800739e:	2904      	cmp	r1, #4
  *     
  * @param  None
  * @retval None
  */
void SystemCoreClockUpdate (void)
{
 80073a0:	b510      	push	{r4, lr}
  uint32_t tmp = 0, pllmull = 0, pllsource = 0, prediv1factor = 0;

  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
  
  switch (tmp)
 80073a2:	d001      	beq.n	80073a8 <SystemCoreClockUpdate+0x14>
 80073a4:	2908      	cmp	r1, #8
 80073a6:	d001      	beq.n	80073ac <SystemCoreClockUpdate+0x18>
  {
    case 0x00:  /* HSI used as system clock */
      SystemCoreClock = HSI_VALUE;
      break;
    case 0x04:  /* HSE used as system clock */
      SystemCoreClock = HSE_VALUE;
 80073a8:	4910      	ldr	r1, [pc, #64]	; (80073ec <SystemCoreClockUpdate+0x58>)
 80073aa:	e011      	b.n	80073d0 <SystemCoreClockUpdate+0x3c>
      break;
    case 0x08:  /* PLL used as system clock */
      /* Get PLL clock source and multiplication factor ----------------------*/
      pllmull = RCC->CFGR & RCC_CFGR_PLLMULL;
 80073ac:	6851      	ldr	r1, [r2, #4]
      pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
 80073ae:	6850      	ldr	r0, [r2, #4]
      pllmull = ( pllmull >> 18) + 2;
 80073b0:	f3c1 4183 	ubfx	r1, r1, #18, #4
      
      if (pllsource == 0x00)
 80073b4:	03c0      	lsls	r0, r0, #15
      break;
    case 0x08:  /* PLL used as system clock */
      /* Get PLL clock source and multiplication factor ----------------------*/
      pllmull = RCC->CFGR & RCC_CFGR_PLLMULL;
      pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
      pllmull = ( pllmull >> 18) + 2;
 80073b6:	f101 0102 	add.w	r1, r1, #2
      
      if (pllsource == 0x00)
 80073ba:	d401      	bmi.n	80073c0 <SystemCoreClockUpdate+0x2c>
      {
        /* HSI oscillator clock divided by 2 selected as PLL clock entry */
        SystemCoreClock = (HSI_VALUE >> 1) * pllmull;
 80073bc:	480c      	ldr	r0, [pc, #48]	; (80073f0 <SystemCoreClockUpdate+0x5c>)
 80073be:	e006      	b.n	80073ce <SystemCoreClockUpdate+0x3a>
      }
      else
      {
        prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
 80073c0:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
        /* HSE oscillator clock selected as PREDIV1 clock entry */
        SystemCoreClock = (HSE_VALUE / prediv1factor) * pllmull; 
 80073c2:	4c0a      	ldr	r4, [pc, #40]	; (80073ec <SystemCoreClockUpdate+0x58>)
        /* HSI oscillator clock divided by 2 selected as PLL clock entry */
        SystemCoreClock = (HSI_VALUE >> 1) * pllmull;
      }
      else
      {
        prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
 80073c4:	f000 000f 	and.w	r0, r0, #15
 80073c8:	3001      	adds	r0, #1
        /* HSE oscillator clock selected as PREDIV1 clock entry */
        SystemCoreClock = (HSE_VALUE / prediv1factor) * pllmull; 
 80073ca:	fbb4 f0f0 	udiv	r0, r4, r0
 80073ce:	4341      	muls	r1, r0
 80073d0:	6019      	str	r1, [r3, #0]
      SystemCoreClock = HSI_VALUE;
      break;
  }
  /* Compute HCLK clock frequency ----------------*/
  /* Get HCLK prescaler */
  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
 80073d2:	6852      	ldr	r2, [r2, #4]
 80073d4:	f3c2 1203 	ubfx	r2, r2, #4, #4
 80073d8:	441a      	add	r2, r3
 80073da:	7911      	ldrb	r1, [r2, #4]
  /* HCLK clock frequency */
  SystemCoreClock >>= tmp;  
 80073dc:	681a      	ldr	r2, [r3, #0]
 80073de:	40ca      	lsrs	r2, r1
 80073e0:	601a      	str	r2, [r3, #0]
 80073e2:	bd10      	pop	{r4, pc}
 80073e4:	40021000 	.word	0x40021000
 80073e8:	20000034 	.word	0x20000034
 80073ec:	007a1200 	.word	0x007a1200
 80073f0:	003d0900 	.word	0x003d0900

080073f4 <__aeabi_drsub>:
 80073f4:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 80073f8:	e002      	b.n	8007400 <__adddf3>
 80073fa:	bf00      	nop

080073fc <__aeabi_dsub>:
 80073fc:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

08007400 <__adddf3>:
 8007400:	b530      	push	{r4, r5, lr}
 8007402:	ea4f 0441 	mov.w	r4, r1, lsl #1
 8007406:	ea4f 0543 	mov.w	r5, r3, lsl #1
 800740a:	ea94 0f05 	teq	r4, r5
 800740e:	bf08      	it	eq
 8007410:	ea90 0f02 	teqeq	r0, r2
 8007414:	bf1f      	itttt	ne
 8007416:	ea54 0c00 	orrsne.w	ip, r4, r0
 800741a:	ea55 0c02 	orrsne.w	ip, r5, r2
 800741e:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 8007422:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8007426:	f000 80e2 	beq.w	80075ee <__adddf3+0x1ee>
 800742a:	ea4f 5454 	mov.w	r4, r4, lsr #21
 800742e:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 8007432:	bfb8      	it	lt
 8007434:	426d      	neglt	r5, r5
 8007436:	dd0c      	ble.n	8007452 <__adddf3+0x52>
 8007438:	442c      	add	r4, r5
 800743a:	ea80 0202 	eor.w	r2, r0, r2
 800743e:	ea81 0303 	eor.w	r3, r1, r3
 8007442:	ea82 0000 	eor.w	r0, r2, r0
 8007446:	ea83 0101 	eor.w	r1, r3, r1
 800744a:	ea80 0202 	eor.w	r2, r0, r2
 800744e:	ea81 0303 	eor.w	r3, r1, r3
 8007452:	2d36      	cmp	r5, #54	; 0x36
 8007454:	bf88      	it	hi
 8007456:	bd30      	pophi	{r4, r5, pc}
 8007458:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 800745c:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8007460:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 8007464:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 8007468:	d002      	beq.n	8007470 <__adddf3+0x70>
 800746a:	4240      	negs	r0, r0
 800746c:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8007470:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 8007474:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8007478:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 800747c:	d002      	beq.n	8007484 <__adddf3+0x84>
 800747e:	4252      	negs	r2, r2
 8007480:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8007484:	ea94 0f05 	teq	r4, r5
 8007488:	f000 80a7 	beq.w	80075da <__adddf3+0x1da>
 800748c:	f1a4 0401 	sub.w	r4, r4, #1
 8007490:	f1d5 0e20 	rsbs	lr, r5, #32
 8007494:	db0d      	blt.n	80074b2 <__adddf3+0xb2>
 8007496:	fa02 fc0e 	lsl.w	ip, r2, lr
 800749a:	fa22 f205 	lsr.w	r2, r2, r5
 800749e:	1880      	adds	r0, r0, r2
 80074a0:	f141 0100 	adc.w	r1, r1, #0
 80074a4:	fa03 f20e 	lsl.w	r2, r3, lr
 80074a8:	1880      	adds	r0, r0, r2
 80074aa:	fa43 f305 	asr.w	r3, r3, r5
 80074ae:	4159      	adcs	r1, r3
 80074b0:	e00e      	b.n	80074d0 <__adddf3+0xd0>
 80074b2:	f1a5 0520 	sub.w	r5, r5, #32
 80074b6:	f10e 0e20 	add.w	lr, lr, #32
 80074ba:	2a01      	cmp	r2, #1
 80074bc:	fa03 fc0e 	lsl.w	ip, r3, lr
 80074c0:	bf28      	it	cs
 80074c2:	f04c 0c02 	orrcs.w	ip, ip, #2
 80074c6:	fa43 f305 	asr.w	r3, r3, r5
 80074ca:	18c0      	adds	r0, r0, r3
 80074cc:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 80074d0:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80074d4:	d507      	bpl.n	80074e6 <__adddf3+0xe6>
 80074d6:	f04f 0e00 	mov.w	lr, #0
 80074da:	f1dc 0c00 	rsbs	ip, ip, #0
 80074de:	eb7e 0000 	sbcs.w	r0, lr, r0
 80074e2:	eb6e 0101 	sbc.w	r1, lr, r1
 80074e6:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 80074ea:	d31b      	bcc.n	8007524 <__adddf3+0x124>
 80074ec:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 80074f0:	d30c      	bcc.n	800750c <__adddf3+0x10c>
 80074f2:	0849      	lsrs	r1, r1, #1
 80074f4:	ea5f 0030 	movs.w	r0, r0, rrx
 80074f8:	ea4f 0c3c 	mov.w	ip, ip, rrx
 80074fc:	f104 0401 	add.w	r4, r4, #1
 8007500:	ea4f 5244 	mov.w	r2, r4, lsl #21
 8007504:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 8007508:	f080 809a 	bcs.w	8007640 <__adddf3+0x240>
 800750c:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 8007510:	bf08      	it	eq
 8007512:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8007516:	f150 0000 	adcs.w	r0, r0, #0
 800751a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800751e:	ea41 0105 	orr.w	r1, r1, r5
 8007522:	bd30      	pop	{r4, r5, pc}
 8007524:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 8007528:	4140      	adcs	r0, r0
 800752a:	eb41 0101 	adc.w	r1, r1, r1
 800752e:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8007532:	f1a4 0401 	sub.w	r4, r4, #1
 8007536:	d1e9      	bne.n	800750c <__adddf3+0x10c>
 8007538:	f091 0f00 	teq	r1, #0
 800753c:	bf04      	itt	eq
 800753e:	4601      	moveq	r1, r0
 8007540:	2000      	moveq	r0, #0
 8007542:	fab1 f381 	clz	r3, r1
 8007546:	bf08      	it	eq
 8007548:	3320      	addeq	r3, #32
 800754a:	f1a3 030b 	sub.w	r3, r3, #11
 800754e:	f1b3 0220 	subs.w	r2, r3, #32
 8007552:	da0c      	bge.n	800756e <__adddf3+0x16e>
 8007554:	320c      	adds	r2, #12
 8007556:	dd08      	ble.n	800756a <__adddf3+0x16a>
 8007558:	f102 0c14 	add.w	ip, r2, #20
 800755c:	f1c2 020c 	rsb	r2, r2, #12
 8007560:	fa01 f00c 	lsl.w	r0, r1, ip
 8007564:	fa21 f102 	lsr.w	r1, r1, r2
 8007568:	e00c      	b.n	8007584 <__adddf3+0x184>
 800756a:	f102 0214 	add.w	r2, r2, #20
 800756e:	bfd8      	it	le
 8007570:	f1c2 0c20 	rsble	ip, r2, #32
 8007574:	fa01 f102 	lsl.w	r1, r1, r2
 8007578:	fa20 fc0c 	lsr.w	ip, r0, ip
 800757c:	bfdc      	itt	le
 800757e:	ea41 010c 	orrle.w	r1, r1, ip
 8007582:	4090      	lslle	r0, r2
 8007584:	1ae4      	subs	r4, r4, r3
 8007586:	bfa2      	ittt	ge
 8007588:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 800758c:	4329      	orrge	r1, r5
 800758e:	bd30      	popge	{r4, r5, pc}
 8007590:	ea6f 0404 	mvn.w	r4, r4
 8007594:	3c1f      	subs	r4, #31
 8007596:	da1c      	bge.n	80075d2 <__adddf3+0x1d2>
 8007598:	340c      	adds	r4, #12
 800759a:	dc0e      	bgt.n	80075ba <__adddf3+0x1ba>
 800759c:	f104 0414 	add.w	r4, r4, #20
 80075a0:	f1c4 0220 	rsb	r2, r4, #32
 80075a4:	fa20 f004 	lsr.w	r0, r0, r4
 80075a8:	fa01 f302 	lsl.w	r3, r1, r2
 80075ac:	ea40 0003 	orr.w	r0, r0, r3
 80075b0:	fa21 f304 	lsr.w	r3, r1, r4
 80075b4:	ea45 0103 	orr.w	r1, r5, r3
 80075b8:	bd30      	pop	{r4, r5, pc}
 80075ba:	f1c4 040c 	rsb	r4, r4, #12
 80075be:	f1c4 0220 	rsb	r2, r4, #32
 80075c2:	fa20 f002 	lsr.w	r0, r0, r2
 80075c6:	fa01 f304 	lsl.w	r3, r1, r4
 80075ca:	ea40 0003 	orr.w	r0, r0, r3
 80075ce:	4629      	mov	r1, r5
 80075d0:	bd30      	pop	{r4, r5, pc}
 80075d2:	fa21 f004 	lsr.w	r0, r1, r4
 80075d6:	4629      	mov	r1, r5
 80075d8:	bd30      	pop	{r4, r5, pc}
 80075da:	f094 0f00 	teq	r4, #0
 80075de:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 80075e2:	bf06      	itte	eq
 80075e4:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 80075e8:	3401      	addeq	r4, #1
 80075ea:	3d01      	subne	r5, #1
 80075ec:	e74e      	b.n	800748c <__adddf3+0x8c>
 80075ee:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80075f2:	bf18      	it	ne
 80075f4:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80075f8:	d029      	beq.n	800764e <__adddf3+0x24e>
 80075fa:	ea94 0f05 	teq	r4, r5
 80075fe:	bf08      	it	eq
 8007600:	ea90 0f02 	teqeq	r0, r2
 8007604:	d005      	beq.n	8007612 <__adddf3+0x212>
 8007606:	ea54 0c00 	orrs.w	ip, r4, r0
 800760a:	bf04      	itt	eq
 800760c:	4619      	moveq	r1, r3
 800760e:	4610      	moveq	r0, r2
 8007610:	bd30      	pop	{r4, r5, pc}
 8007612:	ea91 0f03 	teq	r1, r3
 8007616:	bf1e      	ittt	ne
 8007618:	2100      	movne	r1, #0
 800761a:	2000      	movne	r0, #0
 800761c:	bd30      	popne	{r4, r5, pc}
 800761e:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 8007622:	d105      	bne.n	8007630 <__adddf3+0x230>
 8007624:	0040      	lsls	r0, r0, #1
 8007626:	4149      	adcs	r1, r1
 8007628:	bf28      	it	cs
 800762a:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 800762e:	bd30      	pop	{r4, r5, pc}
 8007630:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 8007634:	bf3c      	itt	cc
 8007636:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 800763a:	bd30      	popcc	{r4, r5, pc}
 800763c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8007640:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 8007644:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8007648:	f04f 0000 	mov.w	r0, #0
 800764c:	bd30      	pop	{r4, r5, pc}
 800764e:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 8007652:	bf1a      	itte	ne
 8007654:	4619      	movne	r1, r3
 8007656:	4610      	movne	r0, r2
 8007658:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 800765c:	bf1c      	itt	ne
 800765e:	460b      	movne	r3, r1
 8007660:	4602      	movne	r2, r0
 8007662:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8007666:	bf06      	itte	eq
 8007668:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 800766c:	ea91 0f03 	teqeq	r1, r3
 8007670:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 8007674:	bd30      	pop	{r4, r5, pc}
 8007676:	bf00      	nop

08007678 <__aeabi_ui2d>:
 8007678:	f090 0f00 	teq	r0, #0
 800767c:	bf04      	itt	eq
 800767e:	2100      	moveq	r1, #0
 8007680:	4770      	bxeq	lr
 8007682:	b530      	push	{r4, r5, lr}
 8007684:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8007688:	f104 0432 	add.w	r4, r4, #50	; 0x32
 800768c:	f04f 0500 	mov.w	r5, #0
 8007690:	f04f 0100 	mov.w	r1, #0
 8007694:	e750      	b.n	8007538 <__adddf3+0x138>
 8007696:	bf00      	nop

08007698 <__aeabi_i2d>:
 8007698:	f090 0f00 	teq	r0, #0
 800769c:	bf04      	itt	eq
 800769e:	2100      	moveq	r1, #0
 80076a0:	4770      	bxeq	lr
 80076a2:	b530      	push	{r4, r5, lr}
 80076a4:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80076a8:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80076ac:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 80076b0:	bf48      	it	mi
 80076b2:	4240      	negmi	r0, r0
 80076b4:	f04f 0100 	mov.w	r1, #0
 80076b8:	e73e      	b.n	8007538 <__adddf3+0x138>
 80076ba:	bf00      	nop

080076bc <__aeabi_f2d>:
 80076bc:	0042      	lsls	r2, r0, #1
 80076be:	ea4f 01e2 	mov.w	r1, r2, asr #3
 80076c2:	ea4f 0131 	mov.w	r1, r1, rrx
 80076c6:	ea4f 7002 	mov.w	r0, r2, lsl #28
 80076ca:	bf1f      	itttt	ne
 80076cc:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 80076d0:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80076d4:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 80076d8:	4770      	bxne	lr
 80076da:	f092 0f00 	teq	r2, #0
 80076de:	bf14      	ite	ne
 80076e0:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80076e4:	4770      	bxeq	lr
 80076e6:	b530      	push	{r4, r5, lr}
 80076e8:	f44f 7460 	mov.w	r4, #896	; 0x380
 80076ec:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80076f0:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80076f4:	e720      	b.n	8007538 <__adddf3+0x138>
 80076f6:	bf00      	nop

080076f8 <__aeabi_ul2d>:
 80076f8:	ea50 0201 	orrs.w	r2, r0, r1
 80076fc:	bf08      	it	eq
 80076fe:	4770      	bxeq	lr
 8007700:	b530      	push	{r4, r5, lr}
 8007702:	f04f 0500 	mov.w	r5, #0
 8007706:	e00a      	b.n	800771e <__aeabi_l2d+0x16>

08007708 <__aeabi_l2d>:
 8007708:	ea50 0201 	orrs.w	r2, r0, r1
 800770c:	bf08      	it	eq
 800770e:	4770      	bxeq	lr
 8007710:	b530      	push	{r4, r5, lr}
 8007712:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 8007716:	d502      	bpl.n	800771e <__aeabi_l2d+0x16>
 8007718:	4240      	negs	r0, r0
 800771a:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800771e:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8007722:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8007726:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 800772a:	f43f aedc 	beq.w	80074e6 <__adddf3+0xe6>
 800772e:	f04f 0203 	mov.w	r2, #3
 8007732:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8007736:	bf18      	it	ne
 8007738:	3203      	addne	r2, #3
 800773a:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 800773e:	bf18      	it	ne
 8007740:	3203      	addne	r2, #3
 8007742:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 8007746:	f1c2 0320 	rsb	r3, r2, #32
 800774a:	fa00 fc03 	lsl.w	ip, r0, r3
 800774e:	fa20 f002 	lsr.w	r0, r0, r2
 8007752:	fa01 fe03 	lsl.w	lr, r1, r3
 8007756:	ea40 000e 	orr.w	r0, r0, lr
 800775a:	fa21 f102 	lsr.w	r1, r1, r2
 800775e:	4414      	add	r4, r2
 8007760:	e6c1      	b.n	80074e6 <__adddf3+0xe6>
 8007762:	bf00      	nop

08007764 <__aeabi_d2iz>:
 8007764:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8007768:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 800776c:	d215      	bcs.n	800779a <__aeabi_d2iz+0x36>
 800776e:	d511      	bpl.n	8007794 <__aeabi_d2iz+0x30>
 8007770:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 8007774:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 8007778:	d912      	bls.n	80077a0 <__aeabi_d2iz+0x3c>
 800777a:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 800777e:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8007782:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 8007786:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 800778a:	fa23 f002 	lsr.w	r0, r3, r2
 800778e:	bf18      	it	ne
 8007790:	4240      	negne	r0, r0
 8007792:	4770      	bx	lr
 8007794:	f04f 0000 	mov.w	r0, #0
 8007798:	4770      	bx	lr
 800779a:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 800779e:	d105      	bne.n	80077ac <__aeabi_d2iz+0x48>
 80077a0:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
 80077a4:	bf08      	it	eq
 80077a6:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 80077aa:	4770      	bx	lr
 80077ac:	f04f 0000 	mov.w	r0, #0
 80077b0:	4770      	bx	lr
 80077b2:	bf00      	nop

080077b4 <__aeabi_d2f>:
 80077b4:	ea4f 0241 	mov.w	r2, r1, lsl #1
 80077b8:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
 80077bc:	bf24      	itt	cs
 80077be:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
 80077c2:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
 80077c6:	d90d      	bls.n	80077e4 <__aeabi_d2f+0x30>
 80077c8:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 80077cc:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 80077d0:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 80077d4:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
 80077d8:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 80077dc:	bf08      	it	eq
 80077de:	f020 0001 	biceq.w	r0, r0, #1
 80077e2:	4770      	bx	lr
 80077e4:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
 80077e8:	d121      	bne.n	800782e <__aeabi_d2f+0x7a>
 80077ea:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
 80077ee:	bfbc      	itt	lt
 80077f0:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
 80077f4:	4770      	bxlt	lr
 80077f6:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80077fa:	ea4f 5252 	mov.w	r2, r2, lsr #21
 80077fe:	f1c2 0218 	rsb	r2, r2, #24
 8007802:	f1c2 0c20 	rsb	ip, r2, #32
 8007806:	fa10 f30c 	lsls.w	r3, r0, ip
 800780a:	fa20 f002 	lsr.w	r0, r0, r2
 800780e:	bf18      	it	ne
 8007810:	f040 0001 	orrne.w	r0, r0, #1
 8007814:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8007818:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 800781c:	fa03 fc0c 	lsl.w	ip, r3, ip
 8007820:	ea40 000c 	orr.w	r0, r0, ip
 8007824:	fa23 f302 	lsr.w	r3, r3, r2
 8007828:	ea4f 0343 	mov.w	r3, r3, lsl #1
 800782c:	e7cc      	b.n	80077c8 <__aeabi_d2f+0x14>
 800782e:	ea7f 5362 	mvns.w	r3, r2, asr #21
 8007832:	d107      	bne.n	8007844 <__aeabi_d2f+0x90>
 8007834:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 8007838:	bf1e      	ittt	ne
 800783a:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
 800783e:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
 8007842:	4770      	bxne	lr
 8007844:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
 8007848:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 800784c:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8007850:	4770      	bx	lr
 8007852:	bf00      	nop

08007854 <memcpy>:
 8007854:	4684      	mov	ip, r0
 8007856:	ea41 0300 	orr.w	r3, r1, r0
 800785a:	f013 0303 	ands.w	r3, r3, #3
 800785e:	d16d      	bne.n	800793c <memcpy+0xe8>
 8007860:	3a40      	subs	r2, #64	; 0x40
 8007862:	d341      	bcc.n	80078e8 <memcpy+0x94>
 8007864:	f851 3b04 	ldr.w	r3, [r1], #4
 8007868:	f840 3b04 	str.w	r3, [r0], #4
 800786c:	f851 3b04 	ldr.w	r3, [r1], #4
 8007870:	f840 3b04 	str.w	r3, [r0], #4
 8007874:	f851 3b04 	ldr.w	r3, [r1], #4
 8007878:	f840 3b04 	str.w	r3, [r0], #4
 800787c:	f851 3b04 	ldr.w	r3, [r1], #4
 8007880:	f840 3b04 	str.w	r3, [r0], #4
 8007884:	f851 3b04 	ldr.w	r3, [r1], #4
 8007888:	f840 3b04 	str.w	r3, [r0], #4
 800788c:	f851 3b04 	ldr.w	r3, [r1], #4
 8007890:	f840 3b04 	str.w	r3, [r0], #4
 8007894:	f851 3b04 	ldr.w	r3, [r1], #4
 8007898:	f840 3b04 	str.w	r3, [r0], #4
 800789c:	f851 3b04 	ldr.w	r3, [r1], #4
 80078a0:	f840 3b04 	str.w	r3, [r0], #4
 80078a4:	f851 3b04 	ldr.w	r3, [r1], #4
 80078a8:	f840 3b04 	str.w	r3, [r0], #4
 80078ac:	f851 3b04 	ldr.w	r3, [r1], #4
 80078b0:	f840 3b04 	str.w	r3, [r0], #4
 80078b4:	f851 3b04 	ldr.w	r3, [r1], #4
 80078b8:	f840 3b04 	str.w	r3, [r0], #4
 80078bc:	f851 3b04 	ldr.w	r3, [r1], #4
 80078c0:	f840 3b04 	str.w	r3, [r0], #4
 80078c4:	f851 3b04 	ldr.w	r3, [r1], #4
 80078c8:	f840 3b04 	str.w	r3, [r0], #4
 80078cc:	f851 3b04 	ldr.w	r3, [r1], #4
 80078d0:	f840 3b04 	str.w	r3, [r0], #4
 80078d4:	f851 3b04 	ldr.w	r3, [r1], #4
 80078d8:	f840 3b04 	str.w	r3, [r0], #4
 80078dc:	f851 3b04 	ldr.w	r3, [r1], #4
 80078e0:	f840 3b04 	str.w	r3, [r0], #4
 80078e4:	3a40      	subs	r2, #64	; 0x40
 80078e6:	d2bd      	bcs.n	8007864 <memcpy+0x10>
 80078e8:	3230      	adds	r2, #48	; 0x30
 80078ea:	d311      	bcc.n	8007910 <memcpy+0xbc>
 80078ec:	f851 3b04 	ldr.w	r3, [r1], #4
 80078f0:	f840 3b04 	str.w	r3, [r0], #4
 80078f4:	f851 3b04 	ldr.w	r3, [r1], #4
 80078f8:	f840 3b04 	str.w	r3, [r0], #4
 80078fc:	f851 3b04 	ldr.w	r3, [r1], #4
 8007900:	f840 3b04 	str.w	r3, [r0], #4
 8007904:	f851 3b04 	ldr.w	r3, [r1], #4
 8007908:	f840 3b04 	str.w	r3, [r0], #4
 800790c:	3a10      	subs	r2, #16
 800790e:	d2ed      	bcs.n	80078ec <memcpy+0x98>
 8007910:	320c      	adds	r2, #12
 8007912:	d305      	bcc.n	8007920 <memcpy+0xcc>
 8007914:	f851 3b04 	ldr.w	r3, [r1], #4
 8007918:	f840 3b04 	str.w	r3, [r0], #4
 800791c:	3a04      	subs	r2, #4
 800791e:	d2f9      	bcs.n	8007914 <memcpy+0xc0>
 8007920:	3204      	adds	r2, #4
 8007922:	d008      	beq.n	8007936 <memcpy+0xe2>
 8007924:	07d2      	lsls	r2, r2, #31
 8007926:	bf1c      	itt	ne
 8007928:	f811 3b01 	ldrbne.w	r3, [r1], #1
 800792c:	f800 3b01 	strbne.w	r3, [r0], #1
 8007930:	d301      	bcc.n	8007936 <memcpy+0xe2>
 8007932:	880b      	ldrh	r3, [r1, #0]
 8007934:	8003      	strh	r3, [r0, #0]
 8007936:	4660      	mov	r0, ip
 8007938:	4770      	bx	lr
 800793a:	bf00      	nop
 800793c:	2a08      	cmp	r2, #8
 800793e:	d313      	bcc.n	8007968 <memcpy+0x114>
 8007940:	078b      	lsls	r3, r1, #30
 8007942:	d08d      	beq.n	8007860 <memcpy+0xc>
 8007944:	f010 0303 	ands.w	r3, r0, #3
 8007948:	d08a      	beq.n	8007860 <memcpy+0xc>
 800794a:	f1c3 0304 	rsb	r3, r3, #4
 800794e:	1ad2      	subs	r2, r2, r3
 8007950:	07db      	lsls	r3, r3, #31
 8007952:	bf1c      	itt	ne
 8007954:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8007958:	f800 3b01 	strbne.w	r3, [r0], #1
 800795c:	d380      	bcc.n	8007860 <memcpy+0xc>
 800795e:	f831 3b02 	ldrh.w	r3, [r1], #2
 8007962:	f820 3b02 	strh.w	r3, [r0], #2
 8007966:	e77b      	b.n	8007860 <memcpy+0xc>
 8007968:	3a04      	subs	r2, #4
 800796a:	d3d9      	bcc.n	8007920 <memcpy+0xcc>
 800796c:	3a01      	subs	r2, #1
 800796e:	f811 3b01 	ldrb.w	r3, [r1], #1
 8007972:	f800 3b01 	strb.w	r3, [r0], #1
 8007976:	d2f9      	bcs.n	800796c <memcpy+0x118>
 8007978:	780b      	ldrb	r3, [r1, #0]
 800797a:	7003      	strb	r3, [r0, #0]
 800797c:	784b      	ldrb	r3, [r1, #1]
 800797e:	7043      	strb	r3, [r0, #1]
 8007980:	788b      	ldrb	r3, [r1, #2]
 8007982:	7083      	strb	r3, [r0, #2]
 8007984:	4660      	mov	r0, ip
 8007986:	4770      	bx	lr

08007988 <__aeabi_dmul>:
 8007988:	b570      	push	{r4, r5, r6, lr}
 800798a:	f04f 0cff 	mov.w	ip, #255	; 0xff
 800798e:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 8007992:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8007996:	bf1d      	ittte	ne
 8007998:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 800799c:	ea94 0f0c 	teqne	r4, ip
 80079a0:	ea95 0f0c 	teqne	r5, ip
 80079a4:	f000 f8de 	bleq	8007b64 <__aeabi_dmul+0x1dc>
 80079a8:	442c      	add	r4, r5
 80079aa:	ea81 0603 	eor.w	r6, r1, r3
 80079ae:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 80079b2:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 80079b6:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 80079ba:	bf18      	it	ne
 80079bc:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 80079c0:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80079c4:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 80079c8:	d038      	beq.n	8007a3c <__aeabi_dmul+0xb4>
 80079ca:	fba0 ce02 	umull	ip, lr, r0, r2
 80079ce:	f04f 0500 	mov.w	r5, #0
 80079d2:	fbe1 e502 	umlal	lr, r5, r1, r2
 80079d6:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 80079da:	fbe0 e503 	umlal	lr, r5, r0, r3
 80079de:	f04f 0600 	mov.w	r6, #0
 80079e2:	fbe1 5603 	umlal	r5, r6, r1, r3
 80079e6:	f09c 0f00 	teq	ip, #0
 80079ea:	bf18      	it	ne
 80079ec:	f04e 0e01 	orrne.w	lr, lr, #1
 80079f0:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 80079f4:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 80079f8:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 80079fc:	d204      	bcs.n	8007a08 <__aeabi_dmul+0x80>
 80079fe:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 8007a02:	416d      	adcs	r5, r5
 8007a04:	eb46 0606 	adc.w	r6, r6, r6
 8007a08:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 8007a0c:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 8007a10:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 8007a14:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 8007a18:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 8007a1c:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 8007a20:	bf88      	it	hi
 8007a22:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 8007a26:	d81e      	bhi.n	8007a66 <__aeabi_dmul+0xde>
 8007a28:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 8007a2c:	bf08      	it	eq
 8007a2e:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 8007a32:	f150 0000 	adcs.w	r0, r0, #0
 8007a36:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8007a3a:	bd70      	pop	{r4, r5, r6, pc}
 8007a3c:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 8007a40:	ea46 0101 	orr.w	r1, r6, r1
 8007a44:	ea40 0002 	orr.w	r0, r0, r2
 8007a48:	ea81 0103 	eor.w	r1, r1, r3
 8007a4c:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 8007a50:	bfc2      	ittt	gt
 8007a52:	ebd4 050c 	rsbsgt	r5, r4, ip
 8007a56:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 8007a5a:	bd70      	popgt	{r4, r5, r6, pc}
 8007a5c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8007a60:	f04f 0e00 	mov.w	lr, #0
 8007a64:	3c01      	subs	r4, #1
 8007a66:	f300 80ab 	bgt.w	8007bc0 <__aeabi_dmul+0x238>
 8007a6a:	f114 0f36 	cmn.w	r4, #54	; 0x36
 8007a6e:	bfde      	ittt	le
 8007a70:	2000      	movle	r0, #0
 8007a72:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 8007a76:	bd70      	pople	{r4, r5, r6, pc}
 8007a78:	f1c4 0400 	rsb	r4, r4, #0
 8007a7c:	3c20      	subs	r4, #32
 8007a7e:	da35      	bge.n	8007aec <__aeabi_dmul+0x164>
 8007a80:	340c      	adds	r4, #12
 8007a82:	dc1b      	bgt.n	8007abc <__aeabi_dmul+0x134>
 8007a84:	f104 0414 	add.w	r4, r4, #20
 8007a88:	f1c4 0520 	rsb	r5, r4, #32
 8007a8c:	fa00 f305 	lsl.w	r3, r0, r5
 8007a90:	fa20 f004 	lsr.w	r0, r0, r4
 8007a94:	fa01 f205 	lsl.w	r2, r1, r5
 8007a98:	ea40 0002 	orr.w	r0, r0, r2
 8007a9c:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 8007aa0:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8007aa4:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8007aa8:	fa21 f604 	lsr.w	r6, r1, r4
 8007aac:	eb42 0106 	adc.w	r1, r2, r6
 8007ab0:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8007ab4:	bf08      	it	eq
 8007ab6:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8007aba:	bd70      	pop	{r4, r5, r6, pc}
 8007abc:	f1c4 040c 	rsb	r4, r4, #12
 8007ac0:	f1c4 0520 	rsb	r5, r4, #32
 8007ac4:	fa00 f304 	lsl.w	r3, r0, r4
 8007ac8:	fa20 f005 	lsr.w	r0, r0, r5
 8007acc:	fa01 f204 	lsl.w	r2, r1, r4
 8007ad0:	ea40 0002 	orr.w	r0, r0, r2
 8007ad4:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8007ad8:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8007adc:	f141 0100 	adc.w	r1, r1, #0
 8007ae0:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8007ae4:	bf08      	it	eq
 8007ae6:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8007aea:	bd70      	pop	{r4, r5, r6, pc}
 8007aec:	f1c4 0520 	rsb	r5, r4, #32
 8007af0:	fa00 f205 	lsl.w	r2, r0, r5
 8007af4:	ea4e 0e02 	orr.w	lr, lr, r2
 8007af8:	fa20 f304 	lsr.w	r3, r0, r4
 8007afc:	fa01 f205 	lsl.w	r2, r1, r5
 8007b00:	ea43 0302 	orr.w	r3, r3, r2
 8007b04:	fa21 f004 	lsr.w	r0, r1, r4
 8007b08:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8007b0c:	fa21 f204 	lsr.w	r2, r1, r4
 8007b10:	ea20 0002 	bic.w	r0, r0, r2
 8007b14:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 8007b18:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8007b1c:	bf08      	it	eq
 8007b1e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8007b22:	bd70      	pop	{r4, r5, r6, pc}
 8007b24:	f094 0f00 	teq	r4, #0
 8007b28:	d10f      	bne.n	8007b4a <__aeabi_dmul+0x1c2>
 8007b2a:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 8007b2e:	0040      	lsls	r0, r0, #1
 8007b30:	eb41 0101 	adc.w	r1, r1, r1
 8007b34:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8007b38:	bf08      	it	eq
 8007b3a:	3c01      	subeq	r4, #1
 8007b3c:	d0f7      	beq.n	8007b2e <__aeabi_dmul+0x1a6>
 8007b3e:	ea41 0106 	orr.w	r1, r1, r6
 8007b42:	f095 0f00 	teq	r5, #0
 8007b46:	bf18      	it	ne
 8007b48:	4770      	bxne	lr
 8007b4a:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 8007b4e:	0052      	lsls	r2, r2, #1
 8007b50:	eb43 0303 	adc.w	r3, r3, r3
 8007b54:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 8007b58:	bf08      	it	eq
 8007b5a:	3d01      	subeq	r5, #1
 8007b5c:	d0f7      	beq.n	8007b4e <__aeabi_dmul+0x1c6>
 8007b5e:	ea43 0306 	orr.w	r3, r3, r6
 8007b62:	4770      	bx	lr
 8007b64:	ea94 0f0c 	teq	r4, ip
 8007b68:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8007b6c:	bf18      	it	ne
 8007b6e:	ea95 0f0c 	teqne	r5, ip
 8007b72:	d00c      	beq.n	8007b8e <__aeabi_dmul+0x206>
 8007b74:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8007b78:	bf18      	it	ne
 8007b7a:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8007b7e:	d1d1      	bne.n	8007b24 <__aeabi_dmul+0x19c>
 8007b80:	ea81 0103 	eor.w	r1, r1, r3
 8007b84:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8007b88:	f04f 0000 	mov.w	r0, #0
 8007b8c:	bd70      	pop	{r4, r5, r6, pc}
 8007b8e:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8007b92:	bf06      	itte	eq
 8007b94:	4610      	moveq	r0, r2
 8007b96:	4619      	moveq	r1, r3
 8007b98:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8007b9c:	d019      	beq.n	8007bd2 <__aeabi_dmul+0x24a>
 8007b9e:	ea94 0f0c 	teq	r4, ip
 8007ba2:	d102      	bne.n	8007baa <__aeabi_dmul+0x222>
 8007ba4:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 8007ba8:	d113      	bne.n	8007bd2 <__aeabi_dmul+0x24a>
 8007baa:	ea95 0f0c 	teq	r5, ip
 8007bae:	d105      	bne.n	8007bbc <__aeabi_dmul+0x234>
 8007bb0:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 8007bb4:	bf1c      	itt	ne
 8007bb6:	4610      	movne	r0, r2
 8007bb8:	4619      	movne	r1, r3
 8007bba:	d10a      	bne.n	8007bd2 <__aeabi_dmul+0x24a>
 8007bbc:	ea81 0103 	eor.w	r1, r1, r3
 8007bc0:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8007bc4:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8007bc8:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8007bcc:	f04f 0000 	mov.w	r0, #0
 8007bd0:	bd70      	pop	{r4, r5, r6, pc}
 8007bd2:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8007bd6:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 8007bda:	bd70      	pop	{r4, r5, r6, pc}

08007bdc <__aeabi_ddiv>:
 8007bdc:	b570      	push	{r4, r5, r6, lr}
 8007bde:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8007be2:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 8007be6:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8007bea:	bf1d      	ittte	ne
 8007bec:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8007bf0:	ea94 0f0c 	teqne	r4, ip
 8007bf4:	ea95 0f0c 	teqne	r5, ip
 8007bf8:	f000 f8a7 	bleq	8007d4a <__aeabi_ddiv+0x16e>
 8007bfc:	eba4 0405 	sub.w	r4, r4, r5
 8007c00:	ea81 0e03 	eor.w	lr, r1, r3
 8007c04:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8007c08:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8007c0c:	f000 8088 	beq.w	8007d20 <__aeabi_ddiv+0x144>
 8007c10:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8007c14:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 8007c18:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 8007c1c:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 8007c20:	ea4f 2202 	mov.w	r2, r2, lsl #8
 8007c24:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 8007c28:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 8007c2c:	ea4f 2600 	mov.w	r6, r0, lsl #8
 8007c30:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 8007c34:	429d      	cmp	r5, r3
 8007c36:	bf08      	it	eq
 8007c38:	4296      	cmpeq	r6, r2
 8007c3a:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 8007c3e:	f504 7440 	add.w	r4, r4, #768	; 0x300
 8007c42:	d202      	bcs.n	8007c4a <__aeabi_ddiv+0x6e>
 8007c44:	085b      	lsrs	r3, r3, #1
 8007c46:	ea4f 0232 	mov.w	r2, r2, rrx
 8007c4a:	1ab6      	subs	r6, r6, r2
 8007c4c:	eb65 0503 	sbc.w	r5, r5, r3
 8007c50:	085b      	lsrs	r3, r3, #1
 8007c52:	ea4f 0232 	mov.w	r2, r2, rrx
 8007c56:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 8007c5a:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 8007c5e:	ebb6 0e02 	subs.w	lr, r6, r2
 8007c62:	eb75 0e03 	sbcs.w	lr, r5, r3
 8007c66:	bf22      	ittt	cs
 8007c68:	1ab6      	subcs	r6, r6, r2
 8007c6a:	4675      	movcs	r5, lr
 8007c6c:	ea40 000c 	orrcs.w	r0, r0, ip
 8007c70:	085b      	lsrs	r3, r3, #1
 8007c72:	ea4f 0232 	mov.w	r2, r2, rrx
 8007c76:	ebb6 0e02 	subs.w	lr, r6, r2
 8007c7a:	eb75 0e03 	sbcs.w	lr, r5, r3
 8007c7e:	bf22      	ittt	cs
 8007c80:	1ab6      	subcs	r6, r6, r2
 8007c82:	4675      	movcs	r5, lr
 8007c84:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8007c88:	085b      	lsrs	r3, r3, #1
 8007c8a:	ea4f 0232 	mov.w	r2, r2, rrx
 8007c8e:	ebb6 0e02 	subs.w	lr, r6, r2
 8007c92:	eb75 0e03 	sbcs.w	lr, r5, r3
 8007c96:	bf22      	ittt	cs
 8007c98:	1ab6      	subcs	r6, r6, r2
 8007c9a:	4675      	movcs	r5, lr
 8007c9c:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8007ca0:	085b      	lsrs	r3, r3, #1
 8007ca2:	ea4f 0232 	mov.w	r2, r2, rrx
 8007ca6:	ebb6 0e02 	subs.w	lr, r6, r2
 8007caa:	eb75 0e03 	sbcs.w	lr, r5, r3
 8007cae:	bf22      	ittt	cs
 8007cb0:	1ab6      	subcs	r6, r6, r2
 8007cb2:	4675      	movcs	r5, lr
 8007cb4:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8007cb8:	ea55 0e06 	orrs.w	lr, r5, r6
 8007cbc:	d018      	beq.n	8007cf0 <__aeabi_ddiv+0x114>
 8007cbe:	ea4f 1505 	mov.w	r5, r5, lsl #4
 8007cc2:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 8007cc6:	ea4f 1606 	mov.w	r6, r6, lsl #4
 8007cca:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8007cce:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 8007cd2:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 8007cd6:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 8007cda:	d1c0      	bne.n	8007c5e <__aeabi_ddiv+0x82>
 8007cdc:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8007ce0:	d10b      	bne.n	8007cfa <__aeabi_ddiv+0x11e>
 8007ce2:	ea41 0100 	orr.w	r1, r1, r0
 8007ce6:	f04f 0000 	mov.w	r0, #0
 8007cea:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 8007cee:	e7b6      	b.n	8007c5e <__aeabi_ddiv+0x82>
 8007cf0:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8007cf4:	bf04      	itt	eq
 8007cf6:	4301      	orreq	r1, r0
 8007cf8:	2000      	moveq	r0, #0
 8007cfa:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 8007cfe:	bf88      	it	hi
 8007d00:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 8007d04:	f63f aeaf 	bhi.w	8007a66 <__aeabi_dmul+0xde>
 8007d08:	ebb5 0c03 	subs.w	ip, r5, r3
 8007d0c:	bf04      	itt	eq
 8007d0e:	ebb6 0c02 	subseq.w	ip, r6, r2
 8007d12:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8007d16:	f150 0000 	adcs.w	r0, r0, #0
 8007d1a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8007d1e:	bd70      	pop	{r4, r5, r6, pc}
 8007d20:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 8007d24:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 8007d28:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 8007d2c:	bfc2      	ittt	gt
 8007d2e:	ebd4 050c 	rsbsgt	r5, r4, ip
 8007d32:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 8007d36:	bd70      	popgt	{r4, r5, r6, pc}
 8007d38:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8007d3c:	f04f 0e00 	mov.w	lr, #0
 8007d40:	3c01      	subs	r4, #1
 8007d42:	e690      	b.n	8007a66 <__aeabi_dmul+0xde>
 8007d44:	ea45 0e06 	orr.w	lr, r5, r6
 8007d48:	e68d      	b.n	8007a66 <__aeabi_dmul+0xde>
 8007d4a:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8007d4e:	ea94 0f0c 	teq	r4, ip
 8007d52:	bf08      	it	eq
 8007d54:	ea95 0f0c 	teqeq	r5, ip
 8007d58:	f43f af3b 	beq.w	8007bd2 <__aeabi_dmul+0x24a>
 8007d5c:	ea94 0f0c 	teq	r4, ip
 8007d60:	d10a      	bne.n	8007d78 <__aeabi_ddiv+0x19c>
 8007d62:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8007d66:	f47f af34 	bne.w	8007bd2 <__aeabi_dmul+0x24a>
 8007d6a:	ea95 0f0c 	teq	r5, ip
 8007d6e:	f47f af25 	bne.w	8007bbc <__aeabi_dmul+0x234>
 8007d72:	4610      	mov	r0, r2
 8007d74:	4619      	mov	r1, r3
 8007d76:	e72c      	b.n	8007bd2 <__aeabi_dmul+0x24a>
 8007d78:	ea95 0f0c 	teq	r5, ip
 8007d7c:	d106      	bne.n	8007d8c <__aeabi_ddiv+0x1b0>
 8007d7e:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8007d82:	f43f aefd 	beq.w	8007b80 <__aeabi_dmul+0x1f8>
 8007d86:	4610      	mov	r0, r2
 8007d88:	4619      	mov	r1, r3
 8007d8a:	e722      	b.n	8007bd2 <__aeabi_dmul+0x24a>
 8007d8c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8007d90:	bf18      	it	ne
 8007d92:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8007d96:	f47f aec5 	bne.w	8007b24 <__aeabi_dmul+0x19c>
 8007d9a:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 8007d9e:	f47f af0d 	bne.w	8007bbc <__aeabi_dmul+0x234>
 8007da2:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 8007da6:	f47f aeeb 	bne.w	8007b80 <__aeabi_dmul+0x1f8>
 8007daa:	e712      	b.n	8007bd2 <__aeabi_dmul+0x24a>

08007dac <__gedf2>:
 8007dac:	f04f 3cff 	mov.w	ip, #4294967295
 8007db0:	e006      	b.n	8007dc0 <__cmpdf2+0x4>
 8007db2:	bf00      	nop

08007db4 <__ledf2>:
 8007db4:	f04f 0c01 	mov.w	ip, #1
 8007db8:	e002      	b.n	8007dc0 <__cmpdf2+0x4>
 8007dba:	bf00      	nop

08007dbc <__cmpdf2>:
 8007dbc:	f04f 0c01 	mov.w	ip, #1
 8007dc0:	f84d cd04 	str.w	ip, [sp, #-4]!
 8007dc4:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8007dc8:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8007dcc:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8007dd0:	bf18      	it	ne
 8007dd2:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 8007dd6:	d01b      	beq.n	8007e10 <__cmpdf2+0x54>
 8007dd8:	b001      	add	sp, #4
 8007dda:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 8007dde:	bf0c      	ite	eq
 8007de0:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 8007de4:	ea91 0f03 	teqne	r1, r3
 8007de8:	bf02      	ittt	eq
 8007dea:	ea90 0f02 	teqeq	r0, r2
 8007dee:	2000      	moveq	r0, #0
 8007df0:	4770      	bxeq	lr
 8007df2:	f110 0f00 	cmn.w	r0, #0
 8007df6:	ea91 0f03 	teq	r1, r3
 8007dfa:	bf58      	it	pl
 8007dfc:	4299      	cmppl	r1, r3
 8007dfe:	bf08      	it	eq
 8007e00:	4290      	cmpeq	r0, r2
 8007e02:	bf2c      	ite	cs
 8007e04:	17d8      	asrcs	r0, r3, #31
 8007e06:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 8007e0a:	f040 0001 	orr.w	r0, r0, #1
 8007e0e:	4770      	bx	lr
 8007e10:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8007e14:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8007e18:	d102      	bne.n	8007e20 <__cmpdf2+0x64>
 8007e1a:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 8007e1e:	d107      	bne.n	8007e30 <__cmpdf2+0x74>
 8007e20:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8007e24:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8007e28:	d1d6      	bne.n	8007dd8 <__cmpdf2+0x1c>
 8007e2a:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 8007e2e:	d0d3      	beq.n	8007dd8 <__cmpdf2+0x1c>
 8007e30:	f85d 0b04 	ldr.w	r0, [sp], #4
 8007e34:	4770      	bx	lr
 8007e36:	bf00      	nop

08007e38 <__aeabi_cdrcmple>:
 8007e38:	4684      	mov	ip, r0
 8007e3a:	4610      	mov	r0, r2
 8007e3c:	4662      	mov	r2, ip
 8007e3e:	468c      	mov	ip, r1
 8007e40:	4619      	mov	r1, r3
 8007e42:	4663      	mov	r3, ip
 8007e44:	e000      	b.n	8007e48 <__aeabi_cdcmpeq>
 8007e46:	bf00      	nop

08007e48 <__aeabi_cdcmpeq>:
 8007e48:	b501      	push	{r0, lr}
 8007e4a:	f7ff ffb7 	bl	8007dbc <__cmpdf2>
 8007e4e:	2800      	cmp	r0, #0
 8007e50:	bf48      	it	mi
 8007e52:	f110 0f00 	cmnmi.w	r0, #0
 8007e56:	bd01      	pop	{r0, pc}

08007e58 <__aeabi_dcmpeq>:
 8007e58:	f84d ed08 	str.w	lr, [sp, #-8]!
 8007e5c:	f7ff fff4 	bl	8007e48 <__aeabi_cdcmpeq>
 8007e60:	bf0c      	ite	eq
 8007e62:	2001      	moveq	r0, #1
 8007e64:	2000      	movne	r0, #0
 8007e66:	f85d fb08 	ldr.w	pc, [sp], #8
 8007e6a:	bf00      	nop

08007e6c <__aeabi_dcmplt>:
 8007e6c:	f84d ed08 	str.w	lr, [sp, #-8]!
 8007e70:	f7ff ffea 	bl	8007e48 <__aeabi_cdcmpeq>
 8007e74:	bf34      	ite	cc
 8007e76:	2001      	movcc	r0, #1
 8007e78:	2000      	movcs	r0, #0
 8007e7a:	f85d fb08 	ldr.w	pc, [sp], #8
 8007e7e:	bf00      	nop

08007e80 <__aeabi_dcmple>:
 8007e80:	f84d ed08 	str.w	lr, [sp, #-8]!
 8007e84:	f7ff ffe0 	bl	8007e48 <__aeabi_cdcmpeq>
 8007e88:	bf94      	ite	ls
 8007e8a:	2001      	movls	r0, #1
 8007e8c:	2000      	movhi	r0, #0
 8007e8e:	f85d fb08 	ldr.w	pc, [sp], #8
 8007e92:	bf00      	nop

08007e94 <__aeabi_dcmpge>:
 8007e94:	f84d ed08 	str.w	lr, [sp, #-8]!
 8007e98:	f7ff ffce 	bl	8007e38 <__aeabi_cdrcmple>
 8007e9c:	bf94      	ite	ls
 8007e9e:	2001      	movls	r0, #1
 8007ea0:	2000      	movhi	r0, #0
 8007ea2:	f85d fb08 	ldr.w	pc, [sp], #8
 8007ea6:	bf00      	nop

08007ea8 <__aeabi_dcmpgt>:
 8007ea8:	f84d ed08 	str.w	lr, [sp, #-8]!
 8007eac:	f7ff ffc4 	bl	8007e38 <__aeabi_cdrcmple>
 8007eb0:	bf34      	ite	cc
 8007eb2:	2001      	movcc	r0, #1
 8007eb4:	2000      	movcs	r0, #0
 8007eb6:	f85d fb08 	ldr.w	pc, [sp], #8
 8007eba:	bf00      	nop

08007ebc <main>:
static void IMU_Task( void *pvParameters );
static void Control_Task( void *pvParameters );


int main()
{
 8007ebc:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8007ebe:	4b24      	ldr	r3, [pc, #144]	; (8007f50 <main+0x94>)
 8007ec0:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8007ec4:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 8007ec8:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

	RCC_Configuration();
 8007ecc:	f7fa fab6 	bl	800243c <RCC_Configuration>
	NVIC_Configuration();
 8007ed0:	f7fa facc 	bl	800246c <NVIC_Configuration>
	GPIO_Configuration();
 8007ed4:	f7fa faff 	bl	80024d6 <GPIO_Configuration>
	USART_Configuration();
 8007ed8:	f7fa fbfe 	bl	80026d8 <USART_Configuration>
	setup_xBeeS6();
 8007edc:	f7fa ff76 	bl	8002dcc <setup_xBeeS6>

	SPI_Configuration();
 8007ee0:	f7fa fc3c 	bl	800275c <SPI_Configuration>
	I2C_Configuration();
 8007ee4:	f7fa fc6c 	bl	80027c0 <I2C_Configuration>
	//TIM2_PWM_Configuration();
	TIM3_PWM_Configuration();
 8007ee8:	f7fa fd16 	bl	8002918 <TIM3_PWM_Configuration>
	TIM4_Configuration();
 8007eec:	f7fa fd64 	bl	80029b8 <TIM4_Configuration>
	ADC_Configuration();
 8007ef0:	f7fa fd8d 	bl	8002a0e <ADC_Configuration>
	EXTI_Configuration();
 8007ef4:	f7fa fd8a 	bl	8002a0c <EXTI_Configuration>
	DMA_Configuration(&accBuffer[0]);
 8007ef8:	4816      	ldr	r0, [pc, #88]	; (8007f54 <main+0x98>)
 8007efa:	f7fa fc7f 	bl	80027fc <DMA_Configuration>
	//TIM4_PWM_INPUT_Configuration();

	SETTINGS_init(&GlobalSettings);
 8007efe:	4816      	ldr	r0, [pc, #88]	; (8007f58 <main+0x9c>)
 8007f00:	f7fa ff10 	bl	8002d24 <SETTINGS_init>
	CTRLSTATES_init(&CtrlStates);
 8007f04:	4815      	ldr	r0, [pc, #84]	; (8007f5c <main+0xa0>)
 8007f06:	f7fa ff5d 	bl	8002dc4 <CTRLSTATES_init>

	xCoRoutineCreate( vLedCtrlCoRoutine, 0, 0 );
 8007f0a:	2100      	movs	r1, #0
 8007f0c:	460a      	mov	r2, r1
 8007f0e:	4814      	ldr	r0, [pc, #80]	; (8007f60 <main+0xa4>)
	    //GPIOC->ODR &= ~GPIO_Pin_11;	// Clear Debug Pin

	}
*/

	xTaskCreate( IMU_Task, ( signed char * ) "IMU_Gyro", configMINIMAL_STACK_SIZE, NULL, 4, NULL );
 8007f10:	2400      	movs	r4, #0
	//TIM4_PWM_INPUT_Configuration();

	SETTINGS_init(&GlobalSettings);
	CTRLSTATES_init(&CtrlStates);

	xCoRoutineCreate( vLedCtrlCoRoutine, 0, 0 );
 8007f12:	f7fd fddf 	bl	8005ad4 <xCoRoutineCreate>

	//xCoRoutineCreate( vRemoteCtrlWatchdogCoRoutine, 1, 0 );

	/* Motor Enstufe ausschalten */
	//GPIO_ResetBits(GPIOB, GPIO_Pin_1 | GPIO_Pin_2);
	Disable_Motor();
 8007f16:	f7f8 fef7 	bl	8000d08 <Disable_Motor>
	    //GPIOC->ODR &= ~GPIO_Pin_11;	// Clear Debug Pin

	}
*/

	xTaskCreate( IMU_Task, ( signed char * ) "IMU_Gyro", configMINIMAL_STACK_SIZE, NULL, 4, NULL );
 8007f1a:	2304      	movs	r3, #4
 8007f1c:	e88d 0018 	stmia.w	sp, {r3, r4}
 8007f20:	4910      	ldr	r1, [pc, #64]	; (8007f64 <main+0xa8>)
 8007f22:	9402      	str	r4, [sp, #8]
 8007f24:	f44f 72a0 	mov.w	r2, #320	; 0x140
 8007f28:	4623      	mov	r3, r4
 8007f2a:	9403      	str	r4, [sp, #12]
 8007f2c:	480e      	ldr	r0, [pc, #56]	; (8007f68 <main+0xac>)
 8007f2e:	f7fe faf7 	bl	8006520 <xTaskGenericCreate>
	xTaskCreate( Control_Task, ( signed char * ) "Pos_Contr", configMINIMAL_STACK_SIZE, NULL, 3, NULL );
 8007f32:	2303      	movs	r3, #3
 8007f34:	e88d 0018 	stmia.w	sp, {r3, r4}
 8007f38:	490c      	ldr	r1, [pc, #48]	; (8007f6c <main+0xb0>)
 8007f3a:	9402      	str	r4, [sp, #8]
 8007f3c:	f44f 72a0 	mov.w	r2, #320	; 0x140
 8007f40:	4623      	mov	r3, r4
 8007f42:	9403      	str	r4, [sp, #12]
 8007f44:	480a      	ldr	r0, [pc, #40]	; (8007f70 <main+0xb4>)
 8007f46:	f7fe faeb 	bl	8006520 <xTaskGenericCreate>
	//xTaskCreate( IMU_Print_Values, ( signed char * ) "Print_Euler", configMINIMAL_STACK_SIZE, NULL, 2, NULL );

	/* Start the tasks and timer running. */
	vTaskStartScheduler();
 8007f4a:	f7fe fcbf 	bl	80068cc <vTaskStartScheduler>
 8007f4e:	e7fe      	b.n	8007f4e <main+0x92>
 8007f50:	e000ed00 	.word	0xe000ed00
 8007f54:	20002fd8 	.word	0x20002fd8
 8007f58:	20002f04 	.word	0x20002f04
 8007f5c:	20002f64 	.word	0x20002f64
 8007f60:	08001f91 	.word	0x08001f91
 8007f64:	08009d23 	.word	0x08009d23
 8007f68:	08001e2b 	.word	0x08001e2b
 8007f6c:	08009d2c 	.word	0x08009d2c
 8007f70:	08001e19 	.word	0x08001e19

08007f74 <Reset_Handler>:
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 8007f74:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 8007f76:	f000 b804 	b.w	8007f82 <LoopCopyDataInit>

08007f7a <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 8007f7a:	4b0c      	ldr	r3, [pc, #48]	; (8007fac <LoopFillZerobss+0x12>)
  ldr  r3, [r3, r1]
 8007f7c:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 8007f7e:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 8007f80:	3104      	adds	r1, #4

08007f82 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 8007f82:	480b      	ldr	r0, [pc, #44]	; (8007fb0 <LoopFillZerobss+0x16>)
  ldr  r3, =_edata
 8007f84:	4b0b      	ldr	r3, [pc, #44]	; (8007fb4 <LoopFillZerobss+0x1a>)
  adds  r2, r0, r1
 8007f86:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 8007f88:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 8007f8a:	f4ff aff6 	bcc.w	8007f7a <CopyDataInit>
  ldr  r2, =_sbss
 8007f8e:	4a0a      	ldr	r2, [pc, #40]	; (8007fb8 <LoopFillZerobss+0x1e>)
  b  LoopFillZerobss
 8007f90:	f000 b803 	b.w	8007f9a <LoopFillZerobss>

08007f94 <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 8007f94:	2300      	movs	r3, #0
  str  r3, [r2], #4
 8007f96:	f842 3b04 	str.w	r3, [r2], #4

08007f9a <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 8007f9a:	4b08      	ldr	r3, [pc, #32]	; (8007fbc <LoopFillZerobss+0x22>)
  cmp  r2, r3
 8007f9c:	429a      	cmp	r2, r3
  bcc  FillZerobss
 8007f9e:	f4ff aff9 	bcc.w	8007f94 <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit   
 8007fa2:	f7ff f979 	bl	8007298 <SystemInit>
/* Call the application's entry point.*/
  bl  main
 8007fa6:	f7ff ff89 	bl	8007ebc <main>
  bx  lr    
 8007faa:	4770      	bx	lr
/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
  b  LoopCopyDataInit

CopyDataInit:
  ldr  r3, =_sidata
 8007fac:	0800a19c 	.word	0x0800a19c
  ldr  r3, [r3, r1]
  str  r3, [r0, r1]
  adds  r1, r1, #4
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 8007fb0:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 8007fb4:	2000047c 	.word	0x2000047c
  adds  r2, r0, r1
  cmp  r2, r3
  bcc  CopyDataInit
  ldr  r2, =_sbss
 8007fb8:	2000047c 	.word	0x2000047c
FillZerobss:
  movs  r3, #0
  str  r3, [r2], #4
    
LoopFillZerobss:
  ldr  r3, = _ebss
 8007fbc:	200033dc 	.word	0x200033dc

08007fc0 <ADC1_2_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8007fc0:	f7ff bffe 	b.w	8007fc0 <ADC1_2_IRQHandler>

08007fc4 <memcmp>:
 8007fc4:	2a03      	cmp	r2, #3
 8007fc6:	b470      	push	{r4, r5, r6}
 8007fc8:	d928      	bls.n	800801c <memcmp+0x58>
 8007fca:	ea40 0301 	orr.w	r3, r0, r1
 8007fce:	079b      	lsls	r3, r3, #30
 8007fd0:	d013      	beq.n	8007ffa <memcmp+0x36>
 8007fd2:	7805      	ldrb	r5, [r0, #0]
 8007fd4:	780c      	ldrb	r4, [r1, #0]
 8007fd6:	42a5      	cmp	r5, r4
 8007fd8:	d124      	bne.n	8008024 <memcmp+0x60>
 8007fda:	3a01      	subs	r2, #1
 8007fdc:	2300      	movs	r3, #0
 8007fde:	e005      	b.n	8007fec <memcmp+0x28>
 8007fe0:	f810 5f01 	ldrb.w	r5, [r0, #1]!
 8007fe4:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 8007fe8:	42a5      	cmp	r5, r4
 8007fea:	d11b      	bne.n	8008024 <memcmp+0x60>
 8007fec:	4293      	cmp	r3, r2
 8007fee:	f103 0301 	add.w	r3, r3, #1
 8007ff2:	d1f5      	bne.n	8007fe0 <memcmp+0x1c>
 8007ff4:	2000      	movs	r0, #0
 8007ff6:	bc70      	pop	{r4, r5, r6}
 8007ff8:	4770      	bx	lr
 8007ffa:	460c      	mov	r4, r1
 8007ffc:	4603      	mov	r3, r0
 8007ffe:	6825      	ldr	r5, [r4, #0]
 8008000:	681e      	ldr	r6, [r3, #0]
 8008002:	42ae      	cmp	r6, r5
 8008004:	4621      	mov	r1, r4
 8008006:	4618      	mov	r0, r3
 8008008:	f104 0404 	add.w	r4, r4, #4
 800800c:	f103 0304 	add.w	r3, r3, #4
 8008010:	d104      	bne.n	800801c <memcmp+0x58>
 8008012:	3a04      	subs	r2, #4
 8008014:	2a03      	cmp	r2, #3
 8008016:	4618      	mov	r0, r3
 8008018:	4621      	mov	r1, r4
 800801a:	d8f0      	bhi.n	8007ffe <memcmp+0x3a>
 800801c:	2a00      	cmp	r2, #0
 800801e:	d1d8      	bne.n	8007fd2 <memcmp+0xe>
 8008020:	4610      	mov	r0, r2
 8008022:	e7e8      	b.n	8007ff6 <memcmp+0x32>
 8008024:	1b28      	subs	r0, r5, r4
 8008026:	bc70      	pop	{r4, r5, r6}
 8008028:	4770      	bx	lr
 800802a:	bf00      	nop

0800802c <memset>:
 800802c:	b4f0      	push	{r4, r5, r6, r7}
 800802e:	0784      	lsls	r4, r0, #30
 8008030:	d043      	beq.n	80080ba <memset+0x8e>
 8008032:	1e54      	subs	r4, r2, #1
 8008034:	2a00      	cmp	r2, #0
 8008036:	d03e      	beq.n	80080b6 <memset+0x8a>
 8008038:	b2cd      	uxtb	r5, r1
 800803a:	4603      	mov	r3, r0
 800803c:	e003      	b.n	8008046 <memset+0x1a>
 800803e:	1e62      	subs	r2, r4, #1
 8008040:	2c00      	cmp	r4, #0
 8008042:	d038      	beq.n	80080b6 <memset+0x8a>
 8008044:	4614      	mov	r4, r2
 8008046:	f803 5b01 	strb.w	r5, [r3], #1
 800804a:	079a      	lsls	r2, r3, #30
 800804c:	d1f7      	bne.n	800803e <memset+0x12>
 800804e:	2c03      	cmp	r4, #3
 8008050:	d92a      	bls.n	80080a8 <memset+0x7c>
 8008052:	b2cd      	uxtb	r5, r1
 8008054:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 8008058:	2c0f      	cmp	r4, #15
 800805a:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 800805e:	d915      	bls.n	800808c <memset+0x60>
 8008060:	f1a4 0710 	sub.w	r7, r4, #16
 8008064:	093f      	lsrs	r7, r7, #4
 8008066:	f103 0610 	add.w	r6, r3, #16
 800806a:	eb06 1607 	add.w	r6, r6, r7, lsl #4
 800806e:	461a      	mov	r2, r3
 8008070:	6015      	str	r5, [r2, #0]
 8008072:	6055      	str	r5, [r2, #4]
 8008074:	6095      	str	r5, [r2, #8]
 8008076:	60d5      	str	r5, [r2, #12]
 8008078:	3210      	adds	r2, #16
 800807a:	42b2      	cmp	r2, r6
 800807c:	d1f8      	bne.n	8008070 <memset+0x44>
 800807e:	f004 040f 	and.w	r4, r4, #15
 8008082:	3701      	adds	r7, #1
 8008084:	2c03      	cmp	r4, #3
 8008086:	eb03 1307 	add.w	r3, r3, r7, lsl #4
 800808a:	d90d      	bls.n	80080a8 <memset+0x7c>
 800808c:	461e      	mov	r6, r3
 800808e:	4622      	mov	r2, r4
 8008090:	3a04      	subs	r2, #4
 8008092:	2a03      	cmp	r2, #3
 8008094:	f846 5b04 	str.w	r5, [r6], #4
 8008098:	d8fa      	bhi.n	8008090 <memset+0x64>
 800809a:	1f22      	subs	r2, r4, #4
 800809c:	f022 0203 	bic.w	r2, r2, #3
 80080a0:	3204      	adds	r2, #4
 80080a2:	4413      	add	r3, r2
 80080a4:	f004 0403 	and.w	r4, r4, #3
 80080a8:	b12c      	cbz	r4, 80080b6 <memset+0x8a>
 80080aa:	b2c9      	uxtb	r1, r1
 80080ac:	441c      	add	r4, r3
 80080ae:	f803 1b01 	strb.w	r1, [r3], #1
 80080b2:	42a3      	cmp	r3, r4
 80080b4:	d1fb      	bne.n	80080ae <memset+0x82>
 80080b6:	bcf0      	pop	{r4, r5, r6, r7}
 80080b8:	4770      	bx	lr
 80080ba:	4614      	mov	r4, r2
 80080bc:	4603      	mov	r3, r0
 80080be:	e7c6      	b.n	800804e <memset+0x22>

080080c0 <cosf>:
 80080c0:	b500      	push	{lr}
 80080c2:	ee10 3a10 	vmov	r3, s0
 80080c6:	4a1a      	ldr	r2, [pc, #104]	; (8008130 <cosf+0x70>)
 80080c8:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 80080cc:	4293      	cmp	r3, r2
 80080ce:	b083      	sub	sp, #12
 80080d0:	dd19      	ble.n	8008106 <cosf+0x46>
 80080d2:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 80080d6:	db04      	blt.n	80080e2 <cosf+0x22>
 80080d8:	ee30 0a40 	vsub.f32	s0, s0, s0
 80080dc:	b003      	add	sp, #12
 80080de:	f85d fb04 	ldr.w	pc, [sp], #4
 80080e2:	4668      	mov	r0, sp
 80080e4:	f000 fcfc 	bl	8008ae0 <__ieee754_rem_pio2f>
 80080e8:	f000 0003 	and.w	r0, r0, #3
 80080ec:	2801      	cmp	r0, #1
 80080ee:	ed9d 0a00 	vldr	s0, [sp]
 80080f2:	eddd 0a01 	vldr	s1, [sp, #4]
 80080f6:	d012      	beq.n	800811e <cosf+0x5e>
 80080f8:	2802      	cmp	r0, #2
 80080fa:	d00b      	beq.n	8008114 <cosf+0x54>
 80080fc:	b1a0      	cbz	r0, 8008128 <cosf+0x68>
 80080fe:	2001      	movs	r0, #1
 8008100:	f001 f9ee 	bl	80094e0 <__kernel_sinf>
 8008104:	e7ea      	b.n	80080dc <cosf+0x1c>
 8008106:	eddf 0a0b 	vldr	s1, [pc, #44]	; 8008134 <cosf+0x74>
 800810a:	f000 fe81 	bl	8008e10 <__kernel_cosf>
 800810e:	b003      	add	sp, #12
 8008110:	f85d fb04 	ldr.w	pc, [sp], #4
 8008114:	f000 fe7c 	bl	8008e10 <__kernel_cosf>
 8008118:	eeb1 0a40 	vneg.f32	s0, s0
 800811c:	e7de      	b.n	80080dc <cosf+0x1c>
 800811e:	f001 f9df 	bl	80094e0 <__kernel_sinf>
 8008122:	eeb1 0a40 	vneg.f32	s0, s0
 8008126:	e7d9      	b.n	80080dc <cosf+0x1c>
 8008128:	f000 fe72 	bl	8008e10 <__kernel_cosf>
 800812c:	e7d6      	b.n	80080dc <cosf+0x1c>
 800812e:	bf00      	nop
 8008130:	3f490fd8 	.word	0x3f490fd8
 8008134:	00000000 	.word	0x00000000

08008138 <sinf>:
 8008138:	b500      	push	{lr}
 800813a:	ee10 3a10 	vmov	r3, s0
 800813e:	4a1b      	ldr	r2, [pc, #108]	; (80081ac <sinf+0x74>)
 8008140:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8008144:	4293      	cmp	r3, r2
 8008146:	b083      	sub	sp, #12
 8008148:	dd1a      	ble.n	8008180 <sinf+0x48>
 800814a:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 800814e:	db04      	blt.n	800815a <sinf+0x22>
 8008150:	ee30 0a40 	vsub.f32	s0, s0, s0
 8008154:	b003      	add	sp, #12
 8008156:	f85d fb04 	ldr.w	pc, [sp], #4
 800815a:	4668      	mov	r0, sp
 800815c:	f000 fcc0 	bl	8008ae0 <__ieee754_rem_pio2f>
 8008160:	f000 0003 	and.w	r0, r0, #3
 8008164:	2801      	cmp	r0, #1
 8008166:	ed9d 0a00 	vldr	s0, [sp]
 800816a:	eddd 0a01 	vldr	s1, [sp, #4]
 800816e:	d015      	beq.n	800819c <sinf+0x64>
 8008170:	2802      	cmp	r0, #2
 8008172:	d00d      	beq.n	8008190 <sinf+0x58>
 8008174:	b1a8      	cbz	r0, 80081a2 <sinf+0x6a>
 8008176:	f000 fe4b 	bl	8008e10 <__kernel_cosf>
 800817a:	eeb1 0a40 	vneg.f32	s0, s0
 800817e:	e7e9      	b.n	8008154 <sinf+0x1c>
 8008180:	eddf 0a0b 	vldr	s1, [pc, #44]	; 80081b0 <sinf+0x78>
 8008184:	2000      	movs	r0, #0
 8008186:	f001 f9ab 	bl	80094e0 <__kernel_sinf>
 800818a:	b003      	add	sp, #12
 800818c:	f85d fb04 	ldr.w	pc, [sp], #4
 8008190:	2001      	movs	r0, #1
 8008192:	f001 f9a5 	bl	80094e0 <__kernel_sinf>
 8008196:	eeb1 0a40 	vneg.f32	s0, s0
 800819a:	e7db      	b.n	8008154 <sinf+0x1c>
 800819c:	f000 fe38 	bl	8008e10 <__kernel_cosf>
 80081a0:	e7d8      	b.n	8008154 <sinf+0x1c>
 80081a2:	2001      	movs	r0, #1
 80081a4:	f001 f99c 	bl	80094e0 <__kernel_sinf>
 80081a8:	e7d4      	b.n	8008154 <sinf+0x1c>
 80081aa:	bf00      	nop
 80081ac:	3f490fd8 	.word	0x3f490fd8
 80081b0:	00000000 	.word	0x00000000

080081b4 <atan2>:
 80081b4:	f000 b91c 	b.w	80083f0 <__ieee754_atan2>

080081b8 <sqrt>:
 80081b8:	b570      	push	{r4, r5, r6, lr}
 80081ba:	ed2d 8b04 	vpush	{d8-d9}
 80081be:	eeb0 8a40 	vmov.f32	s16, s0
 80081c2:	eef0 8a60 	vmov.f32	s17, s1
 80081c6:	4e29      	ldr	r6, [pc, #164]	; (800826c <sqrt+0xb4>)
 80081c8:	b08a      	sub	sp, #40	; 0x28
 80081ca:	f000 fa05 	bl	80085d8 <__ieee754_sqrt>
 80081ce:	f996 3000 	ldrsb.w	r3, [r6]
 80081d2:	eeb0 9a40 	vmov.f32	s18, s0
 80081d6:	eef0 9a60 	vmov.f32	s19, s1
 80081da:	3301      	adds	r3, #1
 80081dc:	d00f      	beq.n	80081fe <sqrt+0x46>
 80081de:	eeb0 0a48 	vmov.f32	s0, s16
 80081e2:	eef0 0a68 	vmov.f32	s1, s17
 80081e6:	f001 fb89 	bl	80098fc <__fpclassifyd>
 80081ea:	b140      	cbz	r0, 80081fe <sqrt+0x46>
 80081ec:	2400      	movs	r4, #0
 80081ee:	2500      	movs	r5, #0
 80081f0:	ec51 0b18 	vmov	r0, r1, d8
 80081f4:	4622      	mov	r2, r4
 80081f6:	462b      	mov	r3, r5
 80081f8:	f7ff fe38 	bl	8007e6c <__aeabi_dcmplt>
 80081fc:	b938      	cbnz	r0, 800820e <sqrt+0x56>
 80081fe:	eeb0 0a49 	vmov.f32	s0, s18
 8008202:	eef0 0a69 	vmov.f32	s1, s19
 8008206:	b00a      	add	sp, #40	; 0x28
 8008208:	ecbd 8b04 	vpop	{d8-d9}
 800820c:	bd70      	pop	{r4, r5, r6, pc}
 800820e:	4b18      	ldr	r3, [pc, #96]	; (8008270 <sqrt+0xb8>)
 8008210:	7836      	ldrb	r6, [r6, #0]
 8008212:	9301      	str	r3, [sp, #4]
 8008214:	2201      	movs	r2, #1
 8008216:	2300      	movs	r3, #0
 8008218:	ed8d 8b04 	vstr	d8, [sp, #16]
 800821c:	ed8d 8b02 	vstr	d8, [sp, #8]
 8008220:	9200      	str	r2, [sp, #0]
 8008222:	9308      	str	r3, [sp, #32]
 8008224:	b96e      	cbnz	r6, 8008242 <sqrt+0x8a>
 8008226:	e9cd 4506 	strd	r4, r5, [sp, #24]
 800822a:	4668      	mov	r0, sp
 800822c:	f001 fb90 	bl	8009950 <matherr>
 8008230:	b188      	cbz	r0, 8008256 <sqrt+0x9e>
 8008232:	9b08      	ldr	r3, [sp, #32]
 8008234:	b9a3      	cbnz	r3, 8008260 <sqrt+0xa8>
 8008236:	ed9d 0b06 	vldr	d0, [sp, #24]
 800823a:	b00a      	add	sp, #40	; 0x28
 800823c:	ecbd 8b04 	vpop	{d8-d9}
 8008240:	bd70      	pop	{r4, r5, r6, pc}
 8008242:	4620      	mov	r0, r4
 8008244:	4629      	mov	r1, r5
 8008246:	4622      	mov	r2, r4
 8008248:	462b      	mov	r3, r5
 800824a:	f7ff fcc7 	bl	8007bdc <__aeabi_ddiv>
 800824e:	2e02      	cmp	r6, #2
 8008250:	e9cd 0106 	strd	r0, r1, [sp, #24]
 8008254:	d1e9      	bne.n	800822a <sqrt+0x72>
 8008256:	f001 fd4b 	bl	8009cf0 <__errno>
 800825a:	2321      	movs	r3, #33	; 0x21
 800825c:	6003      	str	r3, [r0, #0]
 800825e:	e7e8      	b.n	8008232 <sqrt+0x7a>
 8008260:	f001 fd46 	bl	8009cf0 <__errno>
 8008264:	9b08      	ldr	r3, [sp, #32]
 8008266:	6003      	str	r3, [r0, #0]
 8008268:	e7e5      	b.n	8008236 <sqrt+0x7e>
 800826a:	bf00      	nop
 800826c:	20000048 	.word	0x20000048
 8008270:	08009d4c 	.word	0x08009d4c

08008274 <asinf>:
 8008274:	b510      	push	{r4, lr}
 8008276:	ed2d 8b02 	vpush	{d8}
 800827a:	4c2a      	ldr	r4, [pc, #168]	; (8008324 <asinf+0xb0>)
 800827c:	b08a      	sub	sp, #40	; 0x28
 800827e:	eeb0 8a40 	vmov.f32	s16, s0
 8008282:	f000 fa75 	bl	8008770 <__ieee754_asinf>
 8008286:	f994 3000 	ldrsb.w	r3, [r4]
 800828a:	3301      	adds	r3, #1
 800828c:	eef0 8a40 	vmov.f32	s17, s0
 8008290:	d004      	beq.n	800829c <asinf+0x28>
 8008292:	eeb0 0a48 	vmov.f32	s0, s16
 8008296:	f001 fc97 	bl	8009bc8 <__fpclassifyf>
 800829a:	b928      	cbnz	r0, 80082a8 <asinf+0x34>
 800829c:	eeb0 0a68 	vmov.f32	s0, s17
 80082a0:	b00a      	add	sp, #40	; 0x28
 80082a2:	ecbd 8b02 	vpop	{d8}
 80082a6:	bd10      	pop	{r4, pc}
 80082a8:	eeb0 0a48 	vmov.f32	s0, s16
 80082ac:	f001 fc34 	bl	8009b18 <fabsf>
 80082b0:	eef7 7a00 	vmov.f32	s15, #112	; 0x70
 80082b4:	eeb4 0ae7 	vcmpe.f32	s0, s15
 80082b8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80082bc:	ddee      	ble.n	800829c <asinf+0x28>
 80082be:	2301      	movs	r3, #1
 80082c0:	4a19      	ldr	r2, [pc, #100]	; (8008328 <asinf+0xb4>)
 80082c2:	9300      	str	r3, [sp, #0]
 80082c4:	ee18 0a10 	vmov	r0, s16
 80082c8:	2300      	movs	r3, #0
 80082ca:	9201      	str	r2, [sp, #4]
 80082cc:	9308      	str	r3, [sp, #32]
 80082ce:	f7ff f9f5 	bl	80076bc <__aeabi_f2d>
 80082d2:	4602      	mov	r2, r0
 80082d4:	460b      	mov	r3, r1
 80082d6:	4815      	ldr	r0, [pc, #84]	; (800832c <asinf+0xb8>)
 80082d8:	e9cd 2304 	strd	r2, r3, [sp, #16]
 80082dc:	e9cd 2302 	strd	r2, r3, [sp, #8]
 80082e0:	f001 fb3a 	bl	8009958 <nan>
 80082e4:	f994 3000 	ldrsb.w	r3, [r4]
 80082e8:	2b02      	cmp	r3, #2
 80082ea:	ed8d 0b06 	vstr	d0, [sp, #24]
 80082ee:	d00f      	beq.n	8008310 <asinf+0x9c>
 80082f0:	4668      	mov	r0, sp
 80082f2:	f001 fb2d 	bl	8009950 <matherr>
 80082f6:	b158      	cbz	r0, 8008310 <asinf+0x9c>
 80082f8:	9b08      	ldr	r3, [sp, #32]
 80082fa:	b973      	cbnz	r3, 800831a <asinf+0xa6>
 80082fc:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 8008300:	f7ff fa58 	bl	80077b4 <__aeabi_d2f>
 8008304:	ee00 0a10 	vmov	s0, r0
 8008308:	b00a      	add	sp, #40	; 0x28
 800830a:	ecbd 8b02 	vpop	{d8}
 800830e:	bd10      	pop	{r4, pc}
 8008310:	f001 fcee 	bl	8009cf0 <__errno>
 8008314:	2321      	movs	r3, #33	; 0x21
 8008316:	6003      	str	r3, [r0, #0]
 8008318:	e7ee      	b.n	80082f8 <asinf+0x84>
 800831a:	f001 fce9 	bl	8009cf0 <__errno>
 800831e:	9b08      	ldr	r3, [sp, #32]
 8008320:	6003      	str	r3, [r0, #0]
 8008322:	e7eb      	b.n	80082fc <asinf+0x88>
 8008324:	20000048 	.word	0x20000048
 8008328:	08009d54 	.word	0x08009d54
 800832c:	08009d50 	.word	0x08009d50

08008330 <atan2f>:
 8008330:	f000 bb26 	b.w	8008980 <__ieee754_atan2f>

08008334 <sqrtf>:
 8008334:	b510      	push	{r4, lr}
 8008336:	ed2d 8b02 	vpush	{d8}
 800833a:	4c2a      	ldr	r4, [pc, #168]	; (80083e4 <sqrtf+0xb0>)
 800833c:	b08a      	sub	sp, #40	; 0x28
 800833e:	eeb0 8a40 	vmov.f32	s16, s0
 8008342:	f000 fd13 	bl	8008d6c <__ieee754_sqrtf>
 8008346:	f994 3000 	ldrsb.w	r3, [r4]
 800834a:	3301      	adds	r3, #1
 800834c:	eef0 8a40 	vmov.f32	s17, s0
 8008350:	d009      	beq.n	8008366 <sqrtf+0x32>
 8008352:	eeb0 0a48 	vmov.f32	s0, s16
 8008356:	f001 fc37 	bl	8009bc8 <__fpclassifyf>
 800835a:	b120      	cbz	r0, 8008366 <sqrtf+0x32>
 800835c:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 8008360:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008364:	d405      	bmi.n	8008372 <sqrtf+0x3e>
 8008366:	eeb0 0a68 	vmov.f32	s0, s17
 800836a:	b00a      	add	sp, #40	; 0x28
 800836c:	ecbd 8b02 	vpop	{d8}
 8008370:	bd10      	pop	{r4, pc}
 8008372:	2301      	movs	r3, #1
 8008374:	4a1c      	ldr	r2, [pc, #112]	; (80083e8 <sqrtf+0xb4>)
 8008376:	9300      	str	r3, [sp, #0]
 8008378:	ee18 0a10 	vmov	r0, s16
 800837c:	2300      	movs	r3, #0
 800837e:	9201      	str	r2, [sp, #4]
 8008380:	9308      	str	r3, [sp, #32]
 8008382:	f7ff f99b 	bl	80076bc <__aeabi_f2d>
 8008386:	7824      	ldrb	r4, [r4, #0]
 8008388:	e9cd 0104 	strd	r0, r1, [sp, #16]
 800838c:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8008390:	b99c      	cbnz	r4, 80083ba <sqrtf+0x86>
 8008392:	2200      	movs	r2, #0
 8008394:	2300      	movs	r3, #0
 8008396:	e9cd 2306 	strd	r2, r3, [sp, #24]
 800839a:	4668      	mov	r0, sp
 800839c:	f001 fad8 	bl	8009950 <matherr>
 80083a0:	b1a8      	cbz	r0, 80083ce <sqrtf+0x9a>
 80083a2:	9b08      	ldr	r3, [sp, #32]
 80083a4:	b9c3      	cbnz	r3, 80083d8 <sqrtf+0xa4>
 80083a6:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 80083aa:	f7ff fa03 	bl	80077b4 <__aeabi_d2f>
 80083ae:	ee00 0a10 	vmov	s0, r0
 80083b2:	b00a      	add	sp, #40	; 0x28
 80083b4:	ecbd 8b02 	vpop	{d8}
 80083b8:	bd10      	pop	{r4, pc}
 80083ba:	2000      	movs	r0, #0
 80083bc:	2100      	movs	r1, #0
 80083be:	4602      	mov	r2, r0
 80083c0:	460b      	mov	r3, r1
 80083c2:	f7ff fc0b 	bl	8007bdc <__aeabi_ddiv>
 80083c6:	2c02      	cmp	r4, #2
 80083c8:	e9cd 0106 	strd	r0, r1, [sp, #24]
 80083cc:	d1e5      	bne.n	800839a <sqrtf+0x66>
 80083ce:	f001 fc8f 	bl	8009cf0 <__errno>
 80083d2:	2321      	movs	r3, #33	; 0x21
 80083d4:	6003      	str	r3, [r0, #0]
 80083d6:	e7e4      	b.n	80083a2 <sqrtf+0x6e>
 80083d8:	f001 fc8a 	bl	8009cf0 <__errno>
 80083dc:	9b08      	ldr	r3, [sp, #32]
 80083de:	6003      	str	r3, [r0, #0]
 80083e0:	e7e1      	b.n	80083a6 <sqrtf+0x72>
 80083e2:	bf00      	nop
 80083e4:	20000048 	.word	0x20000048
 80083e8:	08009d5c 	.word	0x08009d5c
 80083ec:	00000000 	.word	0x00000000

080083f0 <__ieee754_atan2>:
 80083f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80083f2:	eeb0 7a40 	vmov.f32	s14, s0
 80083f6:	eef0 7a60 	vmov.f32	s15, s1
 80083fa:	ec53 2b11 	vmov	r2, r3, d1
 80083fe:	4256      	negs	r6, r2
 8008400:	4316      	orrs	r6, r2
 8008402:	f023 4500 	bic.w	r5, r3, #2147483648	; 0x80000000
 8008406:	4c72      	ldr	r4, [pc, #456]	; (80085d0 <__ieee754_atan2+0x1e0>)
 8008408:	ea45 76d6 	orr.w	r6, r5, r6, lsr #31
 800840c:	42a6      	cmp	r6, r4
 800840e:	ec51 0b10 	vmov	r0, r1, d0
 8008412:	d845      	bhi.n	80084a0 <__ieee754_atan2+0xb0>
 8008414:	4247      	negs	r7, r0
 8008416:	4307      	orrs	r7, r0
 8008418:	f021 4600 	bic.w	r6, r1, #2147483648	; 0x80000000
 800841c:	ea46 77d7 	orr.w	r7, r6, r7, lsr #31
 8008420:	42a7      	cmp	r7, r4
 8008422:	d83d      	bhi.n	80084a0 <__ieee754_atan2+0xb0>
 8008424:	f103 4440 	add.w	r4, r3, #3221225472	; 0xc0000000
 8008428:	f504 1480 	add.w	r4, r4, #1048576	; 0x100000
 800842c:	4314      	orrs	r4, r2
 800842e:	d04b      	beq.n	80084c8 <__ieee754_atan2+0xd8>
 8008430:	179c      	asrs	r4, r3, #30
 8008432:	f004 0402 	and.w	r4, r4, #2
 8008436:	ea56 0700 	orrs.w	r7, r6, r0
 800843a:	ea44 74d1 	orr.w	r4, r4, r1, lsr #31
 800843e:	d038      	beq.n	80084b2 <__ieee754_atan2+0xc2>
 8008440:	ea55 0702 	orrs.w	r7, r5, r2
 8008444:	d03b      	beq.n	80084be <__ieee754_atan2+0xce>
 8008446:	4f62      	ldr	r7, [pc, #392]	; (80085d0 <__ieee754_atan2+0x1e0>)
 8008448:	42bd      	cmp	r5, r7
 800844a:	d04c      	beq.n	80084e6 <__ieee754_atan2+0xf6>
 800844c:	4f60      	ldr	r7, [pc, #384]	; (80085d0 <__ieee754_atan2+0x1e0>)
 800844e:	42be      	cmp	r6, r7
 8008450:	d035      	beq.n	80084be <__ieee754_atan2+0xce>
 8008452:	1b75      	subs	r5, r6, r5
 8008454:	152d      	asrs	r5, r5, #20
 8008456:	2d3c      	cmp	r5, #60	; 0x3c
 8008458:	dc41      	bgt.n	80084de <__ieee754_atan2+0xee>
 800845a:	2b00      	cmp	r3, #0
 800845c:	db72      	blt.n	8008544 <__ieee754_atan2+0x154>
 800845e:	ec51 0b17 	vmov	r0, r1, d7
 8008462:	ec53 2b11 	vmov	r2, r3, d1
 8008466:	f7ff fbb9 	bl	8007bdc <__aeabi_ddiv>
 800846a:	ec41 0b10 	vmov	d0, r0, r1
 800846e:	f001 fa3b 	bl	80098e8 <fabs>
 8008472:	f001 f87d 	bl	8009570 <atan>
 8008476:	ec51 0b10 	vmov	r0, r1, d0
 800847a:	2c01      	cmp	r4, #1
 800847c:	d05d      	beq.n	800853a <__ieee754_atan2+0x14a>
 800847e:	2c02      	cmp	r4, #2
 8008480:	d04c      	beq.n	800851c <__ieee754_atan2+0x12c>
 8008482:	2c00      	cmp	r4, #0
 8008484:	d047      	beq.n	8008516 <__ieee754_atan2+0x126>
 8008486:	a33c      	add	r3, pc, #240	; (adr r3, 8008578 <__ieee754_atan2+0x188>)
 8008488:	e9d3 2300 	ldrd	r2, r3, [r3]
 800848c:	f7fe ffb6 	bl	80073fc <__aeabi_dsub>
 8008490:	a33b      	add	r3, pc, #236	; (adr r3, 8008580 <__ieee754_atan2+0x190>)
 8008492:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008496:	f7fe ffb1 	bl	80073fc <__aeabi_dsub>
 800849a:	ec41 0b10 	vmov	d0, r0, r1
 800849e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80084a0:	ec51 0b11 	vmov	r0, r1, d1
 80084a4:	ec53 2b17 	vmov	r2, r3, d7
 80084a8:	f7fe ffaa 	bl	8007400 <__adddf3>
 80084ac:	ec41 0b10 	vmov	d0, r0, r1
 80084b0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80084b2:	2c03      	cmp	r4, #3
 80084b4:	d8c4      	bhi.n	8008440 <__ieee754_atan2+0x50>
 80084b6:	e8df f004 	tbb	[pc, r4]
 80084ba:	0b0b      	.short	0x0b0b
 80084bc:	0c0f      	.short	0x0c0f
 80084be:	2900      	cmp	r1, #0
 80084c0:	db26      	blt.n	8008510 <__ieee754_atan2+0x120>
 80084c2:	ed9f 0b31 	vldr	d0, [pc, #196]	; 8008588 <__ieee754_atan2+0x198>
 80084c6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80084c8:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 80084cc:	f001 b850 	b.w	8009570 <atan>
 80084d0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80084d2:	ed9f 0b2f 	vldr	d0, [pc, #188]	; 8008590 <__ieee754_atan2+0x1a0>
 80084d6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80084d8:	ed9f 0b29 	vldr	d0, [pc, #164]	; 8008580 <__ieee754_atan2+0x190>
 80084dc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80084de:	a12a      	add	r1, pc, #168	; (adr r1, 8008588 <__ieee754_atan2+0x198>)
 80084e0:	e9d1 0100 	ldrd	r0, r1, [r1]
 80084e4:	e7c9      	b.n	800847a <__ieee754_atan2+0x8a>
 80084e6:	42ae      	cmp	r6, r5
 80084e8:	d031      	beq.n	800854e <__ieee754_atan2+0x15e>
 80084ea:	2c03      	cmp	r4, #3
 80084ec:	d8ae      	bhi.n	800844c <__ieee754_atan2+0x5c>
 80084ee:	a701      	add	r7, pc, #4	; (adr r7, 80084f4 <__ieee754_atan2+0x104>)
 80084f0:	f857 f024 	ldr.w	pc, [r7, r4, lsl #2]
 80084f4:	0800850b 	.word	0x0800850b
 80084f8:	08008505 	.word	0x08008505
 80084fc:	080084d9 	.word	0x080084d9
 8008500:	080084d3 	.word	0x080084d3
 8008504:	ed9f 0b24 	vldr	d0, [pc, #144]	; 8008598 <__ieee754_atan2+0x1a8>
 8008508:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800850a:	ed9f 0b25 	vldr	d0, [pc, #148]	; 80085a0 <__ieee754_atan2+0x1b0>
 800850e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8008510:	ed9f 0b25 	vldr	d0, [pc, #148]	; 80085a8 <__ieee754_atan2+0x1b8>
 8008514:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8008516:	ec41 0b10 	vmov	d0, r0, r1
 800851a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800851c:	a316      	add	r3, pc, #88	; (adr r3, 8008578 <__ieee754_atan2+0x188>)
 800851e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008522:	f7fe ff6b 	bl	80073fc <__aeabi_dsub>
 8008526:	4602      	mov	r2, r0
 8008528:	460b      	mov	r3, r1
 800852a:	a115      	add	r1, pc, #84	; (adr r1, 8008580 <__ieee754_atan2+0x190>)
 800852c:	e9d1 0100 	ldrd	r0, r1, [r1]
 8008530:	f7fe ff64 	bl	80073fc <__aeabi_dsub>
 8008534:	ec41 0b10 	vmov	d0, r0, r1
 8008538:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800853a:	f101 4100 	add.w	r1, r1, #2147483648	; 0x80000000
 800853e:	ec41 0b10 	vmov	d0, r0, r1
 8008542:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8008544:	353c      	adds	r5, #60	; 0x3c
 8008546:	da8a      	bge.n	800845e <__ieee754_atan2+0x6e>
 8008548:	2000      	movs	r0, #0
 800854a:	2100      	movs	r1, #0
 800854c:	e795      	b.n	800847a <__ieee754_atan2+0x8a>
 800854e:	2c03      	cmp	r4, #3
 8008550:	d8b5      	bhi.n	80084be <__ieee754_atan2+0xce>
 8008552:	e8df f004 	tbb	[pc, r4]
 8008556:	0205      	.short	0x0205
 8008558:	080b      	.short	0x080b
 800855a:	ed9f 0b15 	vldr	d0, [pc, #84]	; 80085b0 <__ieee754_atan2+0x1c0>
 800855e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8008560:	ed9f 0b15 	vldr	d0, [pc, #84]	; 80085b8 <__ieee754_atan2+0x1c8>
 8008564:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8008566:	ed9f 0b16 	vldr	d0, [pc, #88]	; 80085c0 <__ieee754_atan2+0x1d0>
 800856a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800856c:	ed9f 0b16 	vldr	d0, [pc, #88]	; 80085c8 <__ieee754_atan2+0x1d8>
 8008570:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8008572:	bf00      	nop
 8008574:	f3af 8000 	nop.w
 8008578:	33145c07 	.word	0x33145c07
 800857c:	3ca1a626 	.word	0x3ca1a626
 8008580:	54442d18 	.word	0x54442d18
 8008584:	400921fb 	.word	0x400921fb
 8008588:	54442d18 	.word	0x54442d18
 800858c:	3ff921fb 	.word	0x3ff921fb
 8008590:	54442d18 	.word	0x54442d18
 8008594:	c00921fb 	.word	0xc00921fb
 8008598:	00000000 	.word	0x00000000
 800859c:	80000000 	.word	0x80000000
	...
 80085a8:	54442d18 	.word	0x54442d18
 80085ac:	bff921fb 	.word	0xbff921fb
 80085b0:	54442d18 	.word	0x54442d18
 80085b4:	bfe921fb 	.word	0xbfe921fb
 80085b8:	54442d18 	.word	0x54442d18
 80085bc:	3fe921fb 	.word	0x3fe921fb
 80085c0:	7f3321d2 	.word	0x7f3321d2
 80085c4:	c002d97c 	.word	0xc002d97c
 80085c8:	7f3321d2 	.word	0x7f3321d2
 80085cc:	4002d97c 	.word	0x4002d97c
 80085d0:	7ff00000 	.word	0x7ff00000
 80085d4:	f3af 8000 	nop.w

080085d8 <__ieee754_sqrt>:
 80085d8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80085dc:	ec53 2b10 	vmov	r2, r3, d0
 80085e0:	f023 4400 	bic.w	r4, r3, #2147483648	; 0x80000000
 80085e4:	0d24      	lsrs	r4, r4, #20
 80085e6:	4d61      	ldr	r5, [pc, #388]	; (800876c <__ieee754_sqrt+0x194>)
 80085e8:	0524      	lsls	r4, r4, #20
 80085ea:	42ac      	cmp	r4, r5
 80085ec:	ed2d 8b02 	vpush	{d8}
 80085f0:	eeb0 8a40 	vmov.f32	s16, s0
 80085f4:	eef0 8a60 	vmov.f32	s17, s1
 80085f8:	4619      	mov	r1, r3
 80085fa:	ee10 0a10 	vmov	r0, s0
 80085fe:	f000 8094 	beq.w	800872a <__ieee754_sqrt+0x152>
 8008602:	2b00      	cmp	r3, #0
 8008604:	dd74      	ble.n	80086f0 <__ieee754_sqrt+0x118>
 8008606:	151f      	asrs	r7, r3, #20
 8008608:	d07d      	beq.n	8008706 <__ieee754_sqrt+0x12e>
 800860a:	f2a7 37ff 	subw	r7, r7, #1023	; 0x3ff
 800860e:	f3c1 0113 	ubfx	r1, r1, #0, #20
 8008612:	07fa      	lsls	r2, r7, #31
 8008614:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8008618:	d45f      	bmi.n	80086da <__ieee754_sqrt+0x102>
 800861a:	0fc3      	lsrs	r3, r0, #31
 800861c:	f04f 0c00 	mov.w	ip, #0
 8008620:	eb03 0341 	add.w	r3, r3, r1, lsl #1
 8008624:	0042      	lsls	r2, r0, #1
 8008626:	107f      	asrs	r7, r7, #1
 8008628:	4665      	mov	r5, ip
 800862a:	2016      	movs	r0, #22
 800862c:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 8008630:	186c      	adds	r4, r5, r1
 8008632:	429c      	cmp	r4, r3
 8008634:	ea4f 76d2 	mov.w	r6, r2, lsr #31
 8008638:	ea4f 0242 	mov.w	r2, r2, lsl #1
 800863c:	dc02      	bgt.n	8008644 <__ieee754_sqrt+0x6c>
 800863e:	1b1b      	subs	r3, r3, r4
 8008640:	1865      	adds	r5, r4, r1
 8008642:	448c      	add	ip, r1
 8008644:	3801      	subs	r0, #1
 8008646:	eb06 0343 	add.w	r3, r6, r3, lsl #1
 800864a:	ea4f 0151 	mov.w	r1, r1, lsr #1
 800864e:	d1ef      	bne.n	8008630 <__ieee754_sqrt+0x58>
 8008650:	4680      	mov	r8, r0
 8008652:	2620      	movs	r6, #32
 8008654:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
 8008658:	e009      	b.n	800866e <__ieee754_sqrt+0x96>
 800865a:	d023      	beq.n	80086a4 <__ieee754_sqrt+0xcc>
 800865c:	0fd4      	lsrs	r4, r2, #31
 800865e:	3e01      	subs	r6, #1
 8008660:	ea4f 0151 	mov.w	r1, r1, lsr #1
 8008664:	eb04 0343 	add.w	r3, r4, r3, lsl #1
 8008668:	ea4f 0242 	mov.w	r2, r2, lsl #1
 800866c:	d01e      	beq.n	80086ac <__ieee754_sqrt+0xd4>
 800866e:	42ab      	cmp	r3, r5
 8008670:	eb01 0408 	add.w	r4, r1, r8
 8008674:	ddf1      	ble.n	800865a <__ieee754_sqrt+0x82>
 8008676:	f004 4900 	and.w	r9, r4, #2147483648	; 0x80000000
 800867a:	f1b9 4f00 	cmp.w	r9, #2147483648	; 0x80000000
 800867e:	eb04 0801 	add.w	r8, r4, r1
 8008682:	d009      	beq.n	8008698 <__ieee754_sqrt+0xc0>
 8008684:	46a9      	mov	r9, r5
 8008686:	1b5b      	subs	r3, r3, r5
 8008688:	4294      	cmp	r4, r2
 800868a:	bf88      	it	hi
 800868c:	f103 33ff 	addhi.w	r3, r3, #4294967295
 8008690:	1b12      	subs	r2, r2, r4
 8008692:	4408      	add	r0, r1
 8008694:	464d      	mov	r5, r9
 8008696:	e7e1      	b.n	800865c <__ieee754_sqrt+0x84>
 8008698:	f1b8 0f00 	cmp.w	r8, #0
 800869c:	dbf2      	blt.n	8008684 <__ieee754_sqrt+0xac>
 800869e:	f105 0901 	add.w	r9, r5, #1
 80086a2:	e7f0      	b.n	8008686 <__ieee754_sqrt+0xae>
 80086a4:	4294      	cmp	r4, r2
 80086a6:	d9e6      	bls.n	8008676 <__ieee754_sqrt+0x9e>
 80086a8:	461d      	mov	r5, r3
 80086aa:	e7d7      	b.n	800865c <__ieee754_sqrt+0x84>
 80086ac:	431a      	orrs	r2, r3
 80086ae:	d119      	bne.n	80086e4 <__ieee754_sqrt+0x10c>
 80086b0:	0846      	lsrs	r6, r0, #1
 80086b2:	ea4f 016c 	mov.w	r1, ip, asr #1
 80086b6:	f101 517f 	add.w	r1, r1, #1069547520	; 0x3fc00000
 80086ba:	f01c 0f01 	tst.w	ip, #1
 80086be:	f501 1100 	add.w	r1, r1, #2097152	; 0x200000
 80086c2:	bf18      	it	ne
 80086c4:	f046 4600 	orrne.w	r6, r6, #2147483648	; 0x80000000
 80086c8:	eb01 5307 	add.w	r3, r1, r7, lsl #20
 80086cc:	4632      	mov	r2, r6
 80086ce:	ec43 2b10 	vmov	d0, r2, r3
 80086d2:	ecbd 8b02 	vpop	{d8}
 80086d6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80086da:	0fc3      	lsrs	r3, r0, #31
 80086dc:	eb03 0141 	add.w	r1, r3, r1, lsl #1
 80086e0:	0040      	lsls	r0, r0, #1
 80086e2:	e79a      	b.n	800861a <__ieee754_sqrt+0x42>
 80086e4:	1c43      	adds	r3, r0, #1
 80086e6:	d02e      	beq.n	8008746 <__ieee754_sqrt+0x16e>
 80086e8:	f000 0301 	and.w	r3, r0, #1
 80086ec:	4418      	add	r0, r3
 80086ee:	e7df      	b.n	80086b0 <__ieee754_sqrt+0xd8>
 80086f0:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
 80086f4:	4311      	orrs	r1, r2
 80086f6:	d0ec      	beq.n	80086d2 <__ieee754_sqrt+0xfa>
 80086f8:	bb63      	cbnz	r3, 8008754 <__ieee754_sqrt+0x17c>
 80086fa:	461f      	mov	r7, r3
 80086fc:	0ac1      	lsrs	r1, r0, #11
 80086fe:	3f15      	subs	r7, #21
 8008700:	0540      	lsls	r0, r0, #21
 8008702:	2900      	cmp	r1, #0
 8008704:	d0fa      	beq.n	80086fc <__ieee754_sqrt+0x124>
 8008706:	f411 1380 	ands.w	r3, r1, #1048576	; 0x100000
 800870a:	d11f      	bne.n	800874c <__ieee754_sqrt+0x174>
 800870c:	0049      	lsls	r1, r1, #1
 800870e:	02cc      	lsls	r4, r1, #11
 8008710:	f103 0301 	add.w	r3, r3, #1
 8008714:	d5fa      	bpl.n	800870c <__ieee754_sqrt+0x134>
 8008716:	f1c3 0201 	rsb	r2, r3, #1
 800871a:	f1c3 0420 	rsb	r4, r3, #32
 800871e:	fa20 f404 	lsr.w	r4, r0, r4
 8008722:	4321      	orrs	r1, r4
 8008724:	4417      	add	r7, r2
 8008726:	4098      	lsls	r0, r3
 8008728:	e76f      	b.n	800860a <__ieee754_sqrt+0x32>
 800872a:	ec51 0b10 	vmov	r0, r1, d0
 800872e:	f7ff f92b 	bl	8007988 <__aeabi_dmul>
 8008732:	ec53 2b18 	vmov	r2, r3, d8
 8008736:	f7fe fe63 	bl	8007400 <__adddf3>
 800873a:	ecbd 8b02 	vpop	{d8}
 800873e:	ec41 0b10 	vmov	d0, r0, r1
 8008742:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8008746:	f10c 0c01 	add.w	ip, ip, #1
 800874a:	e7b2      	b.n	80086b2 <__ieee754_sqrt+0xda>
 800874c:	2420      	movs	r4, #32
 800874e:	2201      	movs	r2, #1
 8008750:	2300      	movs	r3, #0
 8008752:	e7e4      	b.n	800871e <__ieee754_sqrt+0x146>
 8008754:	ec51 0b10 	vmov	r0, r1, d0
 8008758:	460b      	mov	r3, r1
 800875a:	f7fe fe4f 	bl	80073fc <__aeabi_dsub>
 800875e:	4602      	mov	r2, r0
 8008760:	460b      	mov	r3, r1
 8008762:	f7ff fa3b 	bl	8007bdc <__aeabi_ddiv>
 8008766:	ec41 0b10 	vmov	d0, r0, r1
 800876a:	e7b2      	b.n	80086d2 <__ieee754_sqrt+0xfa>
 800876c:	7ff00000 	.word	0x7ff00000

08008770 <__ieee754_asinf>:
 8008770:	b538      	push	{r3, r4, r5, lr}
 8008772:	ee10 5a10 	vmov	r5, s0
 8008776:	f025 4400 	bic.w	r4, r5, #2147483648	; 0x80000000
 800877a:	f1b4 5f7e 	cmp.w	r4, #1065353216	; 0x3f800000
 800877e:	ed2d 8b04 	vpush	{d8-d9}
 8008782:	f000 8098 	beq.w	80088b6 <__ieee754_asinf+0x146>
 8008786:	dc18      	bgt.n	80087ba <__ieee754_asinf+0x4a>
 8008788:	f1b4 5f7c 	cmp.w	r4, #1056964608	; 0x3f000000
 800878c:	da1e      	bge.n	80087cc <__ieee754_asinf+0x5c>
 800878e:	f1b4 5f48 	cmp.w	r4, #838860800	; 0x32000000
 8008792:	f280 809d 	bge.w	80088d0 <__ieee754_asinf+0x160>
 8008796:	ed9f 7a6a 	vldr	s14, [pc, #424]	; 8008940 <__ieee754_asinf+0x1d0>
 800879a:	ee30 7a07 	vadd.f32	s14, s0, s14
 800879e:	eef7 7a00 	vmov.f32	s15, #112	; 0x70
 80087a2:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80087a6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80087aa:	dd0f      	ble.n	80087cc <__ieee754_asinf+0x5c>
 80087ac:	ecbd 8b04 	vpop	{d8-d9}
 80087b0:	eef0 7a40 	vmov.f32	s15, s0
 80087b4:	eeb0 0a67 	vmov.f32	s0, s15
 80087b8:	bd38      	pop	{r3, r4, r5, pc}
 80087ba:	ee30 0a40 	vsub.f32	s0, s0, s0
 80087be:	eec0 7a00 	vdiv.f32	s15, s0, s0
 80087c2:	ecbd 8b04 	vpop	{d8-d9}
 80087c6:	eeb0 0a67 	vmov.f32	s0, s15
 80087ca:	bd38      	pop	{r3, r4, r5, pc}
 80087cc:	f001 f9a4 	bl	8009b18 <fabsf>
 80087d0:	eef7 3a00 	vmov.f32	s7, #112	; 0x70
 80087d4:	ee33 0ac0 	vsub.f32	s0, s7, s0
 80087d8:	eef6 7a00 	vmov.f32	s15, #96	; 0x60
 80087dc:	ee20 8a27 	vmul.f32	s16, s0, s15
 80087e0:	eddf 2a58 	vldr	s5, [pc, #352]	; 8008944 <__ieee754_asinf+0x1d4>
 80087e4:	ed9f 4a58 	vldr	s8, [pc, #352]	; 8008948 <__ieee754_asinf+0x1d8>
 80087e8:	ed9f 5a58 	vldr	s10, [pc, #352]	; 800894c <__ieee754_asinf+0x1dc>
 80087ec:	ed9f 3a58 	vldr	s6, [pc, #352]	; 8008950 <__ieee754_asinf+0x1e0>
 80087f0:	ed9f 6a58 	vldr	s12, [pc, #352]	; 8008954 <__ieee754_asinf+0x1e4>
 80087f4:	eddf 4a58 	vldr	s9, [pc, #352]	; 8008958 <__ieee754_asinf+0x1e8>
 80087f8:	eddf 6a58 	vldr	s13, [pc, #352]	; 800895c <__ieee754_asinf+0x1ec>
 80087fc:	eddf 5a58 	vldr	s11, [pc, #352]	; 8008960 <__ieee754_asinf+0x1f0>
 8008800:	eddf 7a58 	vldr	s15, [pc, #352]	; 8008964 <__ieee754_asinf+0x1f4>
 8008804:	ed9f 7a58 	vldr	s14, [pc, #352]	; 8008968 <__ieee754_asinf+0x1f8>
 8008808:	eea8 4a22 	vfma.f32	s8, s16, s5
 800880c:	eee8 4a03 	vfma.f32	s9, s16, s6
 8008810:	eea4 5a08 	vfma.f32	s10, s8, s16
 8008814:	eee4 5a88 	vfma.f32	s11, s9, s16
 8008818:	eea5 6a08 	vfma.f32	s12, s10, s16
 800881c:	eea5 7a88 	vfma.f32	s14, s11, s16
 8008820:	eee6 6a08 	vfma.f32	s13, s12, s16
 8008824:	eef0 8a63 	vmov.f32	s17, s7
 8008828:	eee6 7a88 	vfma.f32	s15, s13, s16
 800882c:	eeb0 0a48 	vmov.f32	s0, s16
 8008830:	eee7 8a08 	vfma.f32	s17, s14, s16
 8008834:	ee27 9a88 	vmul.f32	s18, s15, s16
 8008838:	f000 fa98 	bl	8008d6c <__ieee754_sqrtf>
 800883c:	4b4b      	ldr	r3, [pc, #300]	; (800896c <__ieee754_asinf+0x1fc>)
 800883e:	429c      	cmp	r4, r3
 8008840:	dc2a      	bgt.n	8008898 <__ieee754_asinf+0x128>
 8008842:	ee10 2a10 	vmov	r2, s0
 8008846:	f422 637f 	bic.w	r3, r2, #4080	; 0xff0
 800884a:	f023 030f 	bic.w	r3, r3, #15
 800884e:	ee07 3a10 	vmov	s14, r3
 8008852:	eef1 5a47 	vneg.f32	s11, s14
 8008856:	eea5 8a87 	vfma.f32	s16, s11, s14
 800885a:	ee70 7a07 	vadd.f32	s15, s0, s14
 800885e:	eec9 8a28 	vdiv.f32	s17, s18, s17
 8008862:	ee88 8a27 	vdiv.f32	s16, s16, s15
 8008866:	ed9f 7a42 	vldr	s14, [pc, #264]	; 8008970 <__ieee754_asinf+0x200>
 800886a:	eddf 6a42 	vldr	s13, [pc, #264]	; 8008974 <__ieee754_asinf+0x204>
 800886e:	eeb0 6a00 	vmov.f32	s12, #0
 8008872:	eea8 7a46 	vfms.f32	s14, s16, s12
 8008876:	ee30 0a00 	vadd.f32	s0, s0, s0
 800887a:	eef0 7a66 	vmov.f32	s15, s13
 800887e:	eee5 7a86 	vfma.f32	s15, s11, s12
 8008882:	ee90 7a28 	vfnms.f32	s14, s0, s17
 8008886:	ee77 7a67 	vsub.f32	s15, s14, s15
 800888a:	ee76 7ae7 	vsub.f32	s15, s13, s15
 800888e:	2d00      	cmp	r5, #0
 8008890:	dc97      	bgt.n	80087c2 <__ieee754_asinf+0x52>
 8008892:	eef1 7a67 	vneg.f32	s15, s15
 8008896:	e794      	b.n	80087c2 <__ieee754_asinf+0x52>
 8008898:	eec9 8a28 	vdiv.f32	s17, s18, s17
 800889c:	ed9f 7a36 	vldr	s14, [pc, #216]	; 8008978 <__ieee754_asinf+0x208>
 80088a0:	eddf 7a36 	vldr	s15, [pc, #216]	; 800897c <__ieee754_asinf+0x20c>
 80088a4:	eea0 0a28 	vfma.f32	s0, s0, s17
 80088a8:	eef0 6a00 	vmov.f32	s13, #0
 80088ac:	eea0 7a26 	vfma.f32	s14, s0, s13
 80088b0:	ee77 7ac7 	vsub.f32	s15, s15, s14
 80088b4:	e7eb      	b.n	800888e <__ieee754_asinf+0x11e>
 80088b6:	eddf 7a2e 	vldr	s15, [pc, #184]	; 8008970 <__ieee754_asinf+0x200>
 80088ba:	ed9f 7a30 	vldr	s14, [pc, #192]	; 800897c <__ieee754_asinf+0x20c>
 80088be:	ee60 7a27 	vmul.f32	s15, s0, s15
 80088c2:	ecbd 8b04 	vpop	{d8-d9}
 80088c6:	eee0 7a07 	vfma.f32	s15, s0, s14
 80088ca:	eeb0 0a67 	vmov.f32	s0, s15
 80088ce:	bd38      	pop	{r3, r4, r5, pc}
 80088d0:	ee60 7a00 	vmul.f32	s15, s0, s0
 80088d4:	eddf 2a1b 	vldr	s5, [pc, #108]	; 8008944 <__ieee754_asinf+0x1d4>
 80088d8:	eddf 3a1b 	vldr	s7, [pc, #108]	; 8008948 <__ieee754_asinf+0x1d8>
 80088dc:	eddf 4a1b 	vldr	s9, [pc, #108]	; 800894c <__ieee754_asinf+0x1dc>
 80088e0:	ed9f 3a1b 	vldr	s6, [pc, #108]	; 8008950 <__ieee754_asinf+0x1e0>
 80088e4:	ed9f 4a1c 	vldr	s8, [pc, #112]	; 8008958 <__ieee754_asinf+0x1e8>
 80088e8:	ed9f 7a1a 	vldr	s14, [pc, #104]	; 8008954 <__ieee754_asinf+0x1e4>
 80088ec:	ed9f 5a1c 	vldr	s10, [pc, #112]	; 8008960 <__ieee754_asinf+0x1f0>
 80088f0:	eddf 5a1a 	vldr	s11, [pc, #104]	; 800895c <__ieee754_asinf+0x1ec>
 80088f4:	ed9f 6a1c 	vldr	s12, [pc, #112]	; 8008968 <__ieee754_asinf+0x1f8>
 80088f8:	eddf 6a1a 	vldr	s13, [pc, #104]	; 8008964 <__ieee754_asinf+0x1f4>
 80088fc:	eee7 3aa2 	vfma.f32	s7, s15, s5
 8008900:	ecbd 8b04 	vpop	{d8-d9}
 8008904:	eee3 4aa7 	vfma.f32	s9, s7, s15
 8008908:	eea7 4a83 	vfma.f32	s8, s15, s6
 800890c:	eea4 7aa7 	vfma.f32	s14, s9, s15
 8008910:	eea4 5a27 	vfma.f32	s10, s8, s15
 8008914:	eee7 5a27 	vfma.f32	s11, s14, s15
 8008918:	eea5 6a27 	vfma.f32	s12, s10, s15
 800891c:	eee5 6aa7 	vfma.f32	s13, s11, s15
 8008920:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 8008924:	eea6 7a27 	vfma.f32	s14, s12, s15
 8008928:	ee66 7aa7 	vmul.f32	s15, s13, s15
 800892c:	ee87 7a87 	vdiv.f32	s14, s15, s14
 8008930:	eef0 7a40 	vmov.f32	s15, s0
 8008934:	eee0 7a07 	vfma.f32	s15, s0, s14
 8008938:	eeb0 0a67 	vmov.f32	s0, s15
 800893c:	bd38      	pop	{r3, r4, r5, pc}
 800893e:	bf00      	nop
 8008940:	7149f2ca 	.word	0x7149f2ca
 8008944:	3811ef08 	.word	0x3811ef08
 8008948:	3a4f7f04 	.word	0x3a4f7f04
 800894c:	bd241146 	.word	0xbd241146
 8008950:	3d9dc62e 	.word	0x3d9dc62e
 8008954:	3e4e0aa8 	.word	0x3e4e0aa8
 8008958:	bf303361 	.word	0xbf303361
 800895c:	bea6b090 	.word	0xbea6b090
 8008960:	4001572d 	.word	0x4001572d
 8008964:	3e2aaaab 	.word	0x3e2aaaab
 8008968:	c019d139 	.word	0xc019d139
 800896c:	3f799999 	.word	0x3f799999
 8008970:	b33bbd2e 	.word	0xb33bbd2e
 8008974:	3f490fdb 	.word	0x3f490fdb
 8008978:	333bbd2e 	.word	0x333bbd2e
 800897c:	3fc90fdb 	.word	0x3fc90fdb

08008980 <__ieee754_atan2f>:
 8008980:	ee10 2a90 	vmov	r2, s1
 8008984:	f022 4100 	bic.w	r1, r2, #2147483648	; 0x80000000
 8008988:	f1b1 4fff 	cmp.w	r1, #2139095040	; 0x7f800000
 800898c:	b538      	push	{r3, r4, r5, lr}
 800898e:	eef0 7a40 	vmov.f32	s15, s0
 8008992:	dc18      	bgt.n	80089c6 <__ieee754_atan2f+0x46>
 8008994:	ee10 4a10 	vmov	r4, s0
 8008998:	f024 4000 	bic.w	r0, r4, #2147483648	; 0x80000000
 800899c:	f1b0 4fff 	cmp.w	r0, #2139095040	; 0x7f800000
 80089a0:	dc11      	bgt.n	80089c6 <__ieee754_atan2f+0x46>
 80089a2:	f1b2 5f7e 	cmp.w	r2, #1065353216	; 0x3f800000
 80089a6:	d042      	beq.n	8008a2e <__ieee754_atan2f+0xae>
 80089a8:	1795      	asrs	r5, r2, #30
 80089aa:	f005 0502 	and.w	r5, r5, #2
 80089ae:	ea45 75d4 	orr.w	r5, r5, r4, lsr #31
 80089b2:	b968      	cbnz	r0, 80089d0 <__ieee754_atan2f+0x50>
 80089b4:	2d02      	cmp	r5, #2
 80089b6:	d037      	beq.n	8008a28 <__ieee754_atan2f+0xa8>
 80089b8:	ed9f 0a3e 	vldr	s0, [pc, #248]	; 8008ab4 <__ieee754_atan2f+0x134>
 80089bc:	2d03      	cmp	r5, #3
 80089be:	bf18      	it	ne
 80089c0:	eeb0 0a67 	vmovne.f32	s0, s15
 80089c4:	bd38      	pop	{r3, r4, r5, pc}
 80089c6:	ee07 2a10 	vmov	s14, r2
 80089ca:	ee37 0a27 	vadd.f32	s0, s14, s15
 80089ce:	bd38      	pop	{r3, r4, r5, pc}
 80089d0:	b311      	cbz	r1, 8008a18 <__ieee754_atan2f+0x98>
 80089d2:	f1b1 4fff 	cmp.w	r1, #2139095040	; 0x7f800000
 80089d6:	d02e      	beq.n	8008a36 <__ieee754_atan2f+0xb6>
 80089d8:	f1b0 4fff 	cmp.w	r0, #2139095040	; 0x7f800000
 80089dc:	d01c      	beq.n	8008a18 <__ieee754_atan2f+0x98>
 80089de:	1a41      	subs	r1, r0, r1
 80089e0:	15c9      	asrs	r1, r1, #23
 80089e2:	293c      	cmp	r1, #60	; 0x3c
 80089e4:	dc1d      	bgt.n	8008a22 <__ieee754_atan2f+0xa2>
 80089e6:	2a00      	cmp	r2, #0
 80089e8:	db48      	blt.n	8008a7c <__ieee754_atan2f+0xfc>
 80089ea:	ee07 2a10 	vmov	s14, r2
 80089ee:	ee87 0a87 	vdiv.f32	s0, s15, s14
 80089f2:	f001 f891 	bl	8009b18 <fabsf>
 80089f6:	f000 ffb7 	bl	8009968 <atanf>
 80089fa:	2d01      	cmp	r5, #1
 80089fc:	d037      	beq.n	8008a6e <__ieee754_atan2f+0xee>
 80089fe:	2d02      	cmp	r5, #2
 8008a00:	d02c      	beq.n	8008a5c <__ieee754_atan2f+0xdc>
 8008a02:	2d00      	cmp	r5, #0
 8008a04:	d03f      	beq.n	8008a86 <__ieee754_atan2f+0x106>
 8008a06:	ed9f 7a2c 	vldr	s14, [pc, #176]	; 8008ab8 <__ieee754_atan2f+0x138>
 8008a0a:	eddf 7a2c 	vldr	s15, [pc, #176]	; 8008abc <__ieee754_atan2f+0x13c>
 8008a0e:	ee30 0a07 	vadd.f32	s0, s0, s14
 8008a12:	ee30 0a67 	vsub.f32	s0, s0, s15
 8008a16:	bd38      	pop	{r3, r4, r5, pc}
 8008a18:	2c00      	cmp	r4, #0
 8008a1a:	db1c      	blt.n	8008a56 <__ieee754_atan2f+0xd6>
 8008a1c:	ed9f 0a28 	vldr	s0, [pc, #160]	; 8008ac0 <__ieee754_atan2f+0x140>
 8008a20:	bd38      	pop	{r3, r4, r5, pc}
 8008a22:	ed9f 0a27 	vldr	s0, [pc, #156]	; 8008ac0 <__ieee754_atan2f+0x140>
 8008a26:	e7e8      	b.n	80089fa <__ieee754_atan2f+0x7a>
 8008a28:	ed9f 0a24 	vldr	s0, [pc, #144]	; 8008abc <__ieee754_atan2f+0x13c>
 8008a2c:	bd38      	pop	{r3, r4, r5, pc}
 8008a2e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8008a32:	f000 bf99 	b.w	8009968 <atanf>
 8008a36:	f1b0 4fff 	cmp.w	r0, #2139095040	; 0x7f800000
 8008a3a:	d025      	beq.n	8008a88 <__ieee754_atan2f+0x108>
 8008a3c:	2d02      	cmp	r5, #2
 8008a3e:	d0f3      	beq.n	8008a28 <__ieee754_atan2f+0xa8>
 8008a40:	2d03      	cmp	r5, #3
 8008a42:	d02e      	beq.n	8008aa2 <__ieee754_atan2f+0x122>
 8008a44:	eddf 7a1f 	vldr	s15, [pc, #124]	; 8008ac4 <__ieee754_atan2f+0x144>
 8008a48:	ed9f 0a1f 	vldr	s0, [pc, #124]	; 8008ac8 <__ieee754_atan2f+0x148>
 8008a4c:	2d01      	cmp	r5, #1
 8008a4e:	bf18      	it	ne
 8008a50:	eeb0 0a67 	vmovne.f32	s0, s15
 8008a54:	bd38      	pop	{r3, r4, r5, pc}
 8008a56:	ed9f 0a1d 	vldr	s0, [pc, #116]	; 8008acc <__ieee754_atan2f+0x14c>
 8008a5a:	bd38      	pop	{r3, r4, r5, pc}
 8008a5c:	ed9f 7a16 	vldr	s14, [pc, #88]	; 8008ab8 <__ieee754_atan2f+0x138>
 8008a60:	eddf 7a16 	vldr	s15, [pc, #88]	; 8008abc <__ieee754_atan2f+0x13c>
 8008a64:	ee30 0a07 	vadd.f32	s0, s0, s14
 8008a68:	ee37 0ac0 	vsub.f32	s0, s15, s0
 8008a6c:	bd38      	pop	{r3, r4, r5, pc}
 8008a6e:	ee10 3a10 	vmov	r3, s0
 8008a72:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
 8008a76:	ee00 3a10 	vmov	s0, r3
 8008a7a:	bd38      	pop	{r3, r4, r5, pc}
 8008a7c:	313c      	adds	r1, #60	; 0x3c
 8008a7e:	dab4      	bge.n	80089ea <__ieee754_atan2f+0x6a>
 8008a80:	ed9f 0a10 	vldr	s0, [pc, #64]	; 8008ac4 <__ieee754_atan2f+0x144>
 8008a84:	e7b9      	b.n	80089fa <__ieee754_atan2f+0x7a>
 8008a86:	bd38      	pop	{r3, r4, r5, pc}
 8008a88:	2d02      	cmp	r5, #2
 8008a8a:	d010      	beq.n	8008aae <__ieee754_atan2f+0x12e>
 8008a8c:	2d03      	cmp	r5, #3
 8008a8e:	d00b      	beq.n	8008aa8 <__ieee754_atan2f+0x128>
 8008a90:	eddf 7a0f 	vldr	s15, [pc, #60]	; 8008ad0 <__ieee754_atan2f+0x150>
 8008a94:	ed9f 0a0f 	vldr	s0, [pc, #60]	; 8008ad4 <__ieee754_atan2f+0x154>
 8008a98:	2d01      	cmp	r5, #1
 8008a9a:	bf18      	it	ne
 8008a9c:	eeb0 0a67 	vmovne.f32	s0, s15
 8008aa0:	bd38      	pop	{r3, r4, r5, pc}
 8008aa2:	ed9f 0a04 	vldr	s0, [pc, #16]	; 8008ab4 <__ieee754_atan2f+0x134>
 8008aa6:	bd38      	pop	{r3, r4, r5, pc}
 8008aa8:	ed9f 0a0b 	vldr	s0, [pc, #44]	; 8008ad8 <__ieee754_atan2f+0x158>
 8008aac:	bd38      	pop	{r3, r4, r5, pc}
 8008aae:	ed9f 0a0b 	vldr	s0, [pc, #44]	; 8008adc <__ieee754_atan2f+0x15c>
 8008ab2:	bd38      	pop	{r3, r4, r5, pc}
 8008ab4:	c0490fdb 	.word	0xc0490fdb
 8008ab8:	33bbbd2e 	.word	0x33bbbd2e
 8008abc:	40490fdb 	.word	0x40490fdb
 8008ac0:	3fc90fdb 	.word	0x3fc90fdb
 8008ac4:	00000000 	.word	0x00000000
 8008ac8:	80000000 	.word	0x80000000
 8008acc:	bfc90fdb 	.word	0xbfc90fdb
 8008ad0:	3f490fdb 	.word	0x3f490fdb
 8008ad4:	bf490fdb 	.word	0xbf490fdb
 8008ad8:	c016cbe4 	.word	0xc016cbe4
 8008adc:	4016cbe4 	.word	0x4016cbe4

08008ae0 <__ieee754_rem_pio2f>:
 8008ae0:	b570      	push	{r4, r5, r6, lr}
 8008ae2:	ee10 3a10 	vmov	r3, s0
 8008ae6:	4a93      	ldr	r2, [pc, #588]	; (8008d34 <__ieee754_rem_pio2f+0x254>)
 8008ae8:	f023 4400 	bic.w	r4, r3, #2147483648	; 0x80000000
 8008aec:	4294      	cmp	r4, r2
 8008aee:	b086      	sub	sp, #24
 8008af0:	ee10 6a10 	vmov	r6, s0
 8008af4:	4605      	mov	r5, r0
 8008af6:	dd66      	ble.n	8008bc6 <__ieee754_rem_pio2f+0xe6>
 8008af8:	4a8f      	ldr	r2, [pc, #572]	; (8008d38 <__ieee754_rem_pio2f+0x258>)
 8008afa:	4294      	cmp	r4, r2
 8008afc:	dc1a      	bgt.n	8008b34 <__ieee754_rem_pio2f+0x54>
 8008afe:	2b00      	cmp	r3, #0
 8008b00:	eddf 7a8e 	vldr	s15, [pc, #568]	; 8008d3c <__ieee754_rem_pio2f+0x25c>
 8008b04:	4a8e      	ldr	r2, [pc, #568]	; (8008d40 <__ieee754_rem_pio2f+0x260>)
 8008b06:	f024 040f 	bic.w	r4, r4, #15
 8008b0a:	f340 80db 	ble.w	8008cc4 <__ieee754_rem_pio2f+0x1e4>
 8008b0e:	4294      	cmp	r4, r2
 8008b10:	ee70 7a67 	vsub.f32	s15, s0, s15
 8008b14:	d066      	beq.n	8008be4 <__ieee754_rem_pio2f+0x104>
 8008b16:	ed9f 7a8b 	vldr	s14, [pc, #556]	; 8008d44 <__ieee754_rem_pio2f+0x264>
 8008b1a:	ee77 6ac7 	vsub.f32	s13, s15, s14
 8008b1e:	2001      	movs	r0, #1
 8008b20:	ee77 7ae6 	vsub.f32	s15, s15, s13
 8008b24:	edc5 6a00 	vstr	s13, [r5]
 8008b28:	ee37 7ac7 	vsub.f32	s14, s15, s14
 8008b2c:	ed85 7a01 	vstr	s14, [r5, #4]
 8008b30:	b006      	add	sp, #24
 8008b32:	bd70      	pop	{r4, r5, r6, pc}
 8008b34:	4a84      	ldr	r2, [pc, #528]	; (8008d48 <__ieee754_rem_pio2f+0x268>)
 8008b36:	4294      	cmp	r4, r2
 8008b38:	dd66      	ble.n	8008c08 <__ieee754_rem_pio2f+0x128>
 8008b3a:	f1b4 4fff 	cmp.w	r4, #2139095040	; 0x7f800000
 8008b3e:	da49      	bge.n	8008bd4 <__ieee754_rem_pio2f+0xf4>
 8008b40:	15e2      	asrs	r2, r4, #23
 8008b42:	3a86      	subs	r2, #134	; 0x86
 8008b44:	eba4 54c2 	sub.w	r4, r4, r2, lsl #23
 8008b48:	ee07 4a10 	vmov	s14, r4
 8008b4c:	eefd 7ac7 	vcvt.s32.f32	s15, s14
 8008b50:	eddf 6a7e 	vldr	s13, [pc, #504]	; 8008d4c <__ieee754_rem_pio2f+0x26c>
 8008b54:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8008b58:	ee37 7a67 	vsub.f32	s14, s14, s15
 8008b5c:	edcd 7a03 	vstr	s15, [sp, #12]
 8008b60:	ee27 7a26 	vmul.f32	s14, s14, s13
 8008b64:	eefd 7ac7 	vcvt.s32.f32	s15, s14
 8008b68:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8008b6c:	ee37 7a67 	vsub.f32	s14, s14, s15
 8008b70:	edcd 7a04 	vstr	s15, [sp, #16]
 8008b74:	ee27 7a26 	vmul.f32	s14, s14, s13
 8008b78:	eeb5 7a40 	vcmp.f32	s14, #0.0
 8008b7c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008b80:	ed8d 7a05 	vstr	s14, [sp, #20]
 8008b84:	f040 80b1 	bne.w	8008cea <__ieee754_rem_pio2f+0x20a>
 8008b88:	eef5 7a40 	vcmp.f32	s15, #0.0
 8008b8c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008b90:	bf0c      	ite	eq
 8008b92:	2301      	moveq	r3, #1
 8008b94:	2302      	movne	r3, #2
 8008b96:	496e      	ldr	r1, [pc, #440]	; (8008d50 <__ieee754_rem_pio2f+0x270>)
 8008b98:	2002      	movs	r0, #2
 8008b9a:	e88d 0003 	stmia.w	sp, {r0, r1}
 8008b9e:	a803      	add	r0, sp, #12
 8008ba0:	4629      	mov	r1, r5
 8008ba2:	f000 f9b7 	bl	8008f14 <__kernel_rem_pio2f>
 8008ba6:	2e00      	cmp	r6, #0
 8008ba8:	da12      	bge.n	8008bd0 <__ieee754_rem_pio2f+0xf0>
 8008baa:	ed95 7a00 	vldr	s14, [r5]
 8008bae:	edd5 7a01 	vldr	s15, [r5, #4]
 8008bb2:	eeb1 7a47 	vneg.f32	s14, s14
 8008bb6:	eef1 7a67 	vneg.f32	s15, s15
 8008bba:	4240      	negs	r0, r0
 8008bbc:	ed85 7a00 	vstr	s14, [r5]
 8008bc0:	edc5 7a01 	vstr	s15, [r5, #4]
 8008bc4:	e004      	b.n	8008bd0 <__ieee754_rem_pio2f+0xf0>
 8008bc6:	2200      	movs	r2, #0
 8008bc8:	ed85 0a00 	vstr	s0, [r5]
 8008bcc:	6042      	str	r2, [r0, #4]
 8008bce:	2000      	movs	r0, #0
 8008bd0:	b006      	add	sp, #24
 8008bd2:	bd70      	pop	{r4, r5, r6, pc}
 8008bd4:	ee70 7a40 	vsub.f32	s15, s0, s0
 8008bd8:	2000      	movs	r0, #0
 8008bda:	edc5 7a01 	vstr	s15, [r5, #4]
 8008bde:	edc5 7a00 	vstr	s15, [r5]
 8008be2:	e7f5      	b.n	8008bd0 <__ieee754_rem_pio2f+0xf0>
 8008be4:	eddf 6a5b 	vldr	s13, [pc, #364]	; 8008d54 <__ieee754_rem_pio2f+0x274>
 8008be8:	ed9f 7a5b 	vldr	s14, [pc, #364]	; 8008d58 <__ieee754_rem_pio2f+0x278>
 8008bec:	ee77 7ae6 	vsub.f32	s15, s15, s13
 8008bf0:	2001      	movs	r0, #1
 8008bf2:	ee77 6ac7 	vsub.f32	s13, s15, s14
 8008bf6:	ee77 7ae6 	vsub.f32	s15, s15, s13
 8008bfa:	edc5 6a00 	vstr	s13, [r5]
 8008bfe:	ee37 7ac7 	vsub.f32	s14, s15, s14
 8008c02:	ed85 7a01 	vstr	s14, [r5, #4]
 8008c06:	e7e3      	b.n	8008bd0 <__ieee754_rem_pio2f+0xf0>
 8008c08:	f000 ff86 	bl	8009b18 <fabsf>
 8008c0c:	eddf 6a53 	vldr	s13, [pc, #332]	; 8008d5c <__ieee754_rem_pio2f+0x27c>
 8008c10:	eddf 5a4a 	vldr	s11, [pc, #296]	; 8008d3c <__ieee754_rem_pio2f+0x25c>
 8008c14:	eddf 7a4b 	vldr	s15, [pc, #300]	; 8008d44 <__ieee754_rem_pio2f+0x264>
 8008c18:	eeb6 7a00 	vmov.f32	s14, #96	; 0x60
 8008c1c:	eea0 7a26 	vfma.f32	s14, s0, s13
 8008c20:	eebd 7ac7 	vcvt.s32.f32	s14, s14
 8008c24:	eef8 6ac7 	vcvt.f32.s32	s13, s14
 8008c28:	ee17 0a10 	vmov	r0, s14
 8008c2c:	eeb1 6a66 	vneg.f32	s12, s13
 8008c30:	281f      	cmp	r0, #31
 8008c32:	eea6 0a25 	vfma.f32	s0, s12, s11
 8008c36:	ee66 7aa7 	vmul.f32	s15, s13, s15
 8008c3a:	dc1d      	bgt.n	8008c78 <__ieee754_rem_pio2f+0x198>
 8008c3c:	4b48      	ldr	r3, [pc, #288]	; (8008d60 <__ieee754_rem_pio2f+0x280>)
 8008c3e:	1e41      	subs	r1, r0, #1
 8008c40:	f024 02ff 	bic.w	r2, r4, #255	; 0xff
 8008c44:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8008c48:	429a      	cmp	r2, r3
 8008c4a:	d015      	beq.n	8008c78 <__ieee754_rem_pio2f+0x198>
 8008c4c:	ee30 7a67 	vsub.f32	s14, s0, s15
 8008c50:	ed85 7a00 	vstr	s14, [r5]
 8008c54:	ee30 0a47 	vsub.f32	s0, s0, s14
 8008c58:	2e00      	cmp	r6, #0
 8008c5a:	ee70 7a67 	vsub.f32	s15, s0, s15
 8008c5e:	edc5 7a01 	vstr	s15, [r5, #4]
 8008c62:	dab5      	bge.n	8008bd0 <__ieee754_rem_pio2f+0xf0>
 8008c64:	eeb1 7a47 	vneg.f32	s14, s14
 8008c68:	eef1 7a67 	vneg.f32	s15, s15
 8008c6c:	ed85 7a00 	vstr	s14, [r5]
 8008c70:	edc5 7a01 	vstr	s15, [r5, #4]
 8008c74:	4240      	negs	r0, r0
 8008c76:	e7ab      	b.n	8008bd0 <__ieee754_rem_pio2f+0xf0>
 8008c78:	ee30 7a67 	vsub.f32	s14, s0, s15
 8008c7c:	15e4      	asrs	r4, r4, #23
 8008c7e:	ee17 2a10 	vmov	r2, s14
 8008c82:	f3c2 53c7 	ubfx	r3, r2, #23, #8
 8008c86:	1ae3      	subs	r3, r4, r3
 8008c88:	2b08      	cmp	r3, #8
 8008c8a:	dde1      	ble.n	8008c50 <__ieee754_rem_pio2f+0x170>
 8008c8c:	ed9f 7a31 	vldr	s14, [pc, #196]	; 8008d54 <__ieee754_rem_pio2f+0x274>
 8008c90:	ed9f 5a31 	vldr	s10, [pc, #196]	; 8008d58 <__ieee754_rem_pio2f+0x278>
 8008c94:	eef0 5a40 	vmov.f32	s11, s0
 8008c98:	eee6 5a07 	vfma.f32	s11, s12, s14
 8008c9c:	ee70 7a65 	vsub.f32	s15, s0, s11
 8008ca0:	eee6 7a07 	vfma.f32	s15, s12, s14
 8008ca4:	eed6 7a85 	vfnms.f32	s15, s13, s10
 8008ca8:	ee35 7ae7 	vsub.f32	s14, s11, s15
 8008cac:	ee17 2a10 	vmov	r2, s14
 8008cb0:	f3c2 53c7 	ubfx	r3, r2, #23, #8
 8008cb4:	1ae4      	subs	r4, r4, r3
 8008cb6:	2c19      	cmp	r4, #25
 8008cb8:	dc2c      	bgt.n	8008d14 <__ieee754_rem_pio2f+0x234>
 8008cba:	ed85 7a00 	vstr	s14, [r5]
 8008cbe:	eeb0 0a65 	vmov.f32	s0, s11
 8008cc2:	e7c7      	b.n	8008c54 <__ieee754_rem_pio2f+0x174>
 8008cc4:	4294      	cmp	r4, r2
 8008cc6:	ee70 7a27 	vadd.f32	s15, s0, s15
 8008cca:	d010      	beq.n	8008cee <__ieee754_rem_pio2f+0x20e>
 8008ccc:	ed9f 7a1d 	vldr	s14, [pc, #116]	; 8008d44 <__ieee754_rem_pio2f+0x264>
 8008cd0:	ee77 6a87 	vadd.f32	s13, s15, s14
 8008cd4:	f04f 30ff 	mov.w	r0, #4294967295
 8008cd8:	ee77 7ae6 	vsub.f32	s15, s15, s13
 8008cdc:	edc5 6a00 	vstr	s13, [r5]
 8008ce0:	ee37 7a87 	vadd.f32	s14, s15, s14
 8008ce4:	ed85 7a01 	vstr	s14, [r5, #4]
 8008ce8:	e772      	b.n	8008bd0 <__ieee754_rem_pio2f+0xf0>
 8008cea:	2303      	movs	r3, #3
 8008cec:	e753      	b.n	8008b96 <__ieee754_rem_pio2f+0xb6>
 8008cee:	eddf 6a19 	vldr	s13, [pc, #100]	; 8008d54 <__ieee754_rem_pio2f+0x274>
 8008cf2:	ed9f 7a19 	vldr	s14, [pc, #100]	; 8008d58 <__ieee754_rem_pio2f+0x278>
 8008cf6:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8008cfa:	f04f 30ff 	mov.w	r0, #4294967295
 8008cfe:	ee77 6a87 	vadd.f32	s13, s15, s14
 8008d02:	ee77 7ae6 	vsub.f32	s15, s15, s13
 8008d06:	edc5 6a00 	vstr	s13, [r5]
 8008d0a:	ee37 7a87 	vadd.f32	s14, s15, s14
 8008d0e:	ed85 7a01 	vstr	s14, [r5, #4]
 8008d12:	e75d      	b.n	8008bd0 <__ieee754_rem_pio2f+0xf0>
 8008d14:	ed9f 7a13 	vldr	s14, [pc, #76]	; 8008d64 <__ieee754_rem_pio2f+0x284>
 8008d18:	ed9f 5a13 	vldr	s10, [pc, #76]	; 8008d68 <__ieee754_rem_pio2f+0x288>
 8008d1c:	eeb0 0a65 	vmov.f32	s0, s11
 8008d20:	eea6 0a07 	vfma.f32	s0, s12, s14
 8008d24:	ee75 7ac0 	vsub.f32	s15, s11, s0
 8008d28:	eee6 7a07 	vfma.f32	s15, s12, s14
 8008d2c:	eed6 7a85 	vfnms.f32	s15, s13, s10
 8008d30:	e78c      	b.n	8008c4c <__ieee754_rem_pio2f+0x16c>
 8008d32:	bf00      	nop
 8008d34:	3f490fd8 	.word	0x3f490fd8
 8008d38:	4016cbe3 	.word	0x4016cbe3
 8008d3c:	3fc90f80 	.word	0x3fc90f80
 8008d40:	3fc90fd0 	.word	0x3fc90fd0
 8008d44:	37354443 	.word	0x37354443
 8008d48:	43490f80 	.word	0x43490f80
 8008d4c:	43800000 	.word	0x43800000
 8008d50:	08009de4 	.word	0x08009de4
 8008d54:	37354400 	.word	0x37354400
 8008d58:	2e85a308 	.word	0x2e85a308
 8008d5c:	3f22f984 	.word	0x3f22f984
 8008d60:	08009d64 	.word	0x08009d64
 8008d64:	2e85a300 	.word	0x2e85a300
 8008d68:	248d3132 	.word	0x248d3132

08008d6c <__ieee754_sqrtf>:
 8008d6c:	ee10 3a10 	vmov	r3, s0
 8008d70:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
 8008d74:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
 8008d78:	b470      	push	{r4, r5, r6}
 8008d7a:	d230      	bcs.n	8008dde <__ieee754_sqrtf+0x72>
 8008d7c:	b36a      	cbz	r2, 8008dda <__ieee754_sqrtf+0x6e>
 8008d7e:	2b00      	cmp	r3, #0
 8008d80:	db3d      	blt.n	8008dfe <__ieee754_sqrtf+0x92>
 8008d82:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
 8008d86:	ea4f 51e3 	mov.w	r1, r3, asr #23
 8008d8a:	d32c      	bcc.n	8008de6 <__ieee754_sqrtf+0x7a>
 8008d8c:	f1a1 027f 	sub.w	r2, r1, #127	; 0x7f
 8008d90:	f3c3 0316 	ubfx	r3, r3, #0, #23
 8008d94:	07d1      	lsls	r1, r2, #31
 8008d96:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8008d9a:	bf48      	it	mi
 8008d9c:	005b      	lslmi	r3, r3, #1
 8008d9e:	2500      	movs	r5, #0
 8008da0:	1056      	asrs	r6, r2, #1
 8008da2:	005b      	lsls	r3, r3, #1
 8008da4:	462c      	mov	r4, r5
 8008da6:	2119      	movs	r1, #25
 8008da8:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8008dac:	18a0      	adds	r0, r4, r2
 8008dae:	4298      	cmp	r0, r3
 8008db0:	dc02      	bgt.n	8008db8 <__ieee754_sqrtf+0x4c>
 8008db2:	1a1b      	subs	r3, r3, r0
 8008db4:	1884      	adds	r4, r0, r2
 8008db6:	4415      	add	r5, r2
 8008db8:	3901      	subs	r1, #1
 8008dba:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8008dbe:	ea4f 0252 	mov.w	r2, r2, lsr #1
 8008dc2:	d1f3      	bne.n	8008dac <__ieee754_sqrtf+0x40>
 8008dc4:	b113      	cbz	r3, 8008dcc <__ieee754_sqrtf+0x60>
 8008dc6:	f005 0301 	and.w	r3, r5, #1
 8008dca:	441d      	add	r5, r3
 8008dcc:	106d      	asrs	r5, r5, #1
 8008dce:	f105 557c 	add.w	r5, r5, #1056964608	; 0x3f000000
 8008dd2:	eb05 55c6 	add.w	r5, r5, r6, lsl #23
 8008dd6:	ee00 5a10 	vmov	s0, r5
 8008dda:	bc70      	pop	{r4, r5, r6}
 8008ddc:	4770      	bx	lr
 8008dde:	eea0 0a00 	vfma.f32	s0, s0, s0
 8008de2:	bc70      	pop	{r4, r5, r6}
 8008de4:	4770      	bx	lr
 8008de6:	f413 0200 	ands.w	r2, r3, #8388608	; 0x800000
 8008dea:	d10d      	bne.n	8008e08 <__ieee754_sqrtf+0x9c>
 8008dec:	005b      	lsls	r3, r3, #1
 8008dee:	0218      	lsls	r0, r3, #8
 8008df0:	f102 0201 	add.w	r2, r2, #1
 8008df4:	d5fa      	bpl.n	8008dec <__ieee754_sqrtf+0x80>
 8008df6:	f1c2 0201 	rsb	r2, r2, #1
 8008dfa:	4411      	add	r1, r2
 8008dfc:	e7c6      	b.n	8008d8c <__ieee754_sqrtf+0x20>
 8008dfe:	ee30 0a40 	vsub.f32	s0, s0, s0
 8008e02:	ee80 0a00 	vdiv.f32	s0, s0, s0
 8008e06:	e7e8      	b.n	8008dda <__ieee754_sqrtf+0x6e>
 8008e08:	2201      	movs	r2, #1
 8008e0a:	4411      	add	r1, r2
 8008e0c:	e7be      	b.n	8008d8c <__ieee754_sqrtf+0x20>
 8008e0e:	bf00      	nop

08008e10 <__kernel_cosf>:
 8008e10:	ee10 3a10 	vmov	r3, s0
 8008e14:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8008e18:	f1b3 5f48 	cmp.w	r3, #838860800	; 0x32000000
 8008e1c:	da2c      	bge.n	8008e78 <__kernel_cosf+0x68>
 8008e1e:	eefd 7ac0 	vcvt.s32.f32	s15, s0
 8008e22:	ee17 3a90 	vmov	r3, s15
 8008e26:	2b00      	cmp	r3, #0
 8008e28:	d060      	beq.n	8008eec <__kernel_cosf+0xdc>
 8008e2a:	ee60 7a00 	vmul.f32	s15, s0, s0
 8008e2e:	eddf 4a31 	vldr	s9, [pc, #196]	; 8008ef4 <__kernel_cosf+0xe4>
 8008e32:	ed9f 5a31 	vldr	s10, [pc, #196]	; 8008ef8 <__kernel_cosf+0xe8>
 8008e36:	eddf 5a31 	vldr	s11, [pc, #196]	; 8008efc <__kernel_cosf+0xec>
 8008e3a:	ed9f 6a31 	vldr	s12, [pc, #196]	; 8008f00 <__kernel_cosf+0xf0>
 8008e3e:	eddf 6a31 	vldr	s13, [pc, #196]	; 8008f04 <__kernel_cosf+0xf4>
 8008e42:	ed9f 7a31 	vldr	s14, [pc, #196]	; 8008f08 <__kernel_cosf+0xf8>
 8008e46:	eea7 5aa4 	vfma.f32	s10, s15, s9
 8008e4a:	eee5 5a27 	vfma.f32	s11, s10, s15
 8008e4e:	eea5 6aa7 	vfma.f32	s12, s11, s15
 8008e52:	eee6 6a27 	vfma.f32	s13, s12, s15
 8008e56:	eea6 7aa7 	vfma.f32	s14, s13, s15
 8008e5a:	ee27 7a27 	vmul.f32	s14, s14, s15
 8008e5e:	ee20 0ac0 	vnmul.f32	s0, s1, s0
 8008e62:	eef6 6a00 	vmov.f32	s13, #96	; 0x60
 8008e66:	eea7 0a87 	vfma.f32	s0, s15, s14
 8008e6a:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 8008e6e:	ee97 0aa6 	vfnms.f32	s0, s15, s13
 8008e72:	ee37 0a40 	vsub.f32	s0, s14, s0
 8008e76:	4770      	bx	lr
 8008e78:	ee60 7a00 	vmul.f32	s15, s0, s0
 8008e7c:	eddf 4a1d 	vldr	s9, [pc, #116]	; 8008ef4 <__kernel_cosf+0xe4>
 8008e80:	ed9f 5a1d 	vldr	s10, [pc, #116]	; 8008ef8 <__kernel_cosf+0xe8>
 8008e84:	eddf 5a1d 	vldr	s11, [pc, #116]	; 8008efc <__kernel_cosf+0xec>
 8008e88:	ed9f 6a1d 	vldr	s12, [pc, #116]	; 8008f00 <__kernel_cosf+0xf0>
 8008e8c:	eddf 6a1d 	vldr	s13, [pc, #116]	; 8008f04 <__kernel_cosf+0xf4>
 8008e90:	ed9f 7a1d 	vldr	s14, [pc, #116]	; 8008f08 <__kernel_cosf+0xf8>
 8008e94:	4a1d      	ldr	r2, [pc, #116]	; (8008f0c <__kernel_cosf+0xfc>)
 8008e96:	eea7 5aa4 	vfma.f32	s10, s15, s9
 8008e9a:	4293      	cmp	r3, r2
 8008e9c:	eee5 5a27 	vfma.f32	s11, s10, s15
 8008ea0:	eea5 6aa7 	vfma.f32	s12, s11, s15
 8008ea4:	eee6 6a27 	vfma.f32	s13, s12, s15
 8008ea8:	eea6 7aa7 	vfma.f32	s14, s13, s15
 8008eac:	ee27 7a27 	vmul.f32	s14, s14, s15
 8008eb0:	ddd5      	ble.n	8008e5e <__kernel_cosf+0x4e>
 8008eb2:	4a17      	ldr	r2, [pc, #92]	; (8008f10 <__kernel_cosf+0x100>)
 8008eb4:	4293      	cmp	r3, r2
 8008eb6:	dc14      	bgt.n	8008ee2 <__kernel_cosf+0xd2>
 8008eb8:	f103 437f 	add.w	r3, r3, #4278190080	; 0xff000000
 8008ebc:	ee06 3a90 	vmov	s13, r3
 8008ec0:	eef7 5a00 	vmov.f32	s11, #112	; 0x70
 8008ec4:	ee75 5ae6 	vsub.f32	s11, s11, s13
 8008ec8:	ee60 0ac0 	vnmul.f32	s1, s1, s0
 8008ecc:	eeb6 6a00 	vmov.f32	s12, #96	; 0x60
 8008ed0:	eee7 0a87 	vfma.f32	s1, s15, s14
 8008ed4:	eed7 6a86 	vfnms.f32	s13, s15, s12
 8008ed8:	ee76 0ae0 	vsub.f32	s1, s13, s1
 8008edc:	ee35 0ae0 	vsub.f32	s0, s11, s1
 8008ee0:	4770      	bx	lr
 8008ee2:	eef6 5a07 	vmov.f32	s11, #103	; 0x67
 8008ee6:	eef5 6a02 	vmov.f32	s13, #82	; 0x52
 8008eea:	e7ed      	b.n	8008ec8 <__kernel_cosf+0xb8>
 8008eec:	eeb7 0a00 	vmov.f32	s0, #112	; 0x70
 8008ef0:	4770      	bx	lr
 8008ef2:	bf00      	nop
 8008ef4:	ad47d74e 	.word	0xad47d74e
 8008ef8:	310f74f6 	.word	0x310f74f6
 8008efc:	b493f27c 	.word	0xb493f27c
 8008f00:	37d00d01 	.word	0x37d00d01
 8008f04:	bab60b61 	.word	0xbab60b61
 8008f08:	3d2aaaab 	.word	0x3d2aaaab
 8008f0c:	3e999999 	.word	0x3e999999
 8008f10:	3f480000 	.word	0x3f480000

08008f14 <__kernel_rem_pio2f>:
 8008f14:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008f18:	ed2d 8b04 	vpush	{d8-d9}
 8008f1c:	b0d7      	sub	sp, #348	; 0x15c
 8008f1e:	4ca5      	ldr	r4, [pc, #660]	; (80091b4 <__kernel_rem_pio2f+0x2a0>)
 8008f20:	9d64      	ldr	r5, [sp, #400]	; 0x190
 8008f22:	9103      	str	r1, [sp, #12]
 8008f24:	f103 39ff 	add.w	r9, r3, #4294967295
 8008f28:	f854 8025 	ldr.w	r8, [r4, r5, lsl #2]
 8008f2c:	461d      	mov	r5, r3
 8008f2e:	1ed3      	subs	r3, r2, #3
 8008f30:	bf48      	it	mi
 8008f32:	1d13      	addmi	r3, r2, #4
 8008f34:	10db      	asrs	r3, r3, #3
 8008f36:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 8008f3a:	9304      	str	r3, [sp, #16]
 8008f3c:	9e04      	ldr	r6, [sp, #16]
 8008f3e:	43db      	mvns	r3, r3
 8008f40:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 8008f44:	4682      	mov	sl, r0
 8008f46:	eb19 0008 	adds.w	r0, r9, r8
 8008f4a:	9302      	str	r3, [sp, #8]
 8008f4c:	ebc9 0306 	rsb	r3, r9, r6
 8008f50:	d418      	bmi.n	8008f84 <__kernel_rem_pio2f+0x70>
 8008f52:	9e65      	ldr	r6, [sp, #404]	; 0x194
 8008f54:	4418      	add	r0, r3
 8008f56:	3001      	adds	r0, #1
 8008f58:	a91a      	add	r1, sp, #104	; 0x68
 8008f5a:	eb06 0483 	add.w	r4, r6, r3, lsl #2
 8008f5e:	2200      	movs	r2, #0
 8008f60:	2b00      	cmp	r3, #0
 8008f62:	bfaa      	itet	ge
 8008f64:	58a6      	ldrge	r6, [r4, r2]
 8008f66:	eddf 7a94 	vldrlt	s15, [pc, #592]	; 80091b8 <__kernel_rem_pio2f+0x2a4>
 8008f6a:	ee07 6a10 	vmovge	s14, r6
 8008f6e:	f103 0301 	add.w	r3, r3, #1
 8008f72:	bfa8      	it	ge
 8008f74:	eef8 7ac7 	vcvtge.f32.s32	s15, s14
 8008f78:	4283      	cmp	r3, r0
 8008f7a:	ece1 7a01 	vstmia	r1!, {s15}
 8008f7e:	f102 0204 	add.w	r2, r2, #4
 8008f82:	d1ed      	bne.n	8008f60 <__kernel_rem_pio2f+0x4c>
 8008f84:	f1b8 0f00 	cmp.w	r8, #0
 8008f88:	ea4f 0b88 	mov.w	fp, r8, lsl #2
 8008f8c:	db1d      	blt.n	8008fca <__kernel_rem_pio2f+0xb6>
 8008f8e:	a81a      	add	r0, sp, #104	; 0x68
 8008f90:	ae43      	add	r6, sp, #268	; 0x10c
 8008f92:	eb00 0485 	add.w	r4, r0, r5, lsl #2
 8008f96:	445e      	add	r6, fp
 8008f98:	a842      	add	r0, sp, #264	; 0x108
 8008f9a:	f1b9 0f00 	cmp.w	r9, #0
 8008f9e:	f2c0 81ae 	blt.w	80092fe <__kernel_rem_pio2f+0x3ea>
 8008fa2:	eddf 7a85 	vldr	s15, [pc, #532]	; 80091b8 <__kernel_rem_pio2f+0x2a4>
 8008fa6:	4651      	mov	r1, sl
 8008fa8:	4622      	mov	r2, r4
 8008faa:	2300      	movs	r3, #0
 8008fac:	ecf1 6a01 	vldmia	r1!, {s13}
 8008fb0:	ed32 7a01 	vldmdb	r2!, {s14}
 8008fb4:	3301      	adds	r3, #1
 8008fb6:	42ab      	cmp	r3, r5
 8008fb8:	eee6 7a87 	vfma.f32	s15, s13, s14
 8008fbc:	d1f6      	bne.n	8008fac <__kernel_rem_pio2f+0x98>
 8008fbe:	ece0 7a01 	vstmia	r0!, {s15}
 8008fc2:	42b0      	cmp	r0, r6
 8008fc4:	f104 0404 	add.w	r4, r4, #4
 8008fc8:	d1e7      	bne.n	8008f9a <__kernel_rem_pio2f+0x86>
 8008fca:	f10d 0c18 	add.w	ip, sp, #24
 8008fce:	4644      	mov	r4, r8
 8008fd0:	f8cd 8014 	str.w	r8, [sp, #20]
 8008fd4:	eddf 8a7a 	vldr	s17, [pc, #488]	; 80091c0 <__kernel_rem_pio2f+0x2ac>
 8008fd8:	ed9f 8a78 	vldr	s16, [pc, #480]	; 80091bc <__kernel_rem_pio2f+0x2a8>
 8008fdc:	f8dd 8008 	ldr.w	r8, [sp, #8]
 8008fe0:	44e3      	add	fp, ip
 8008fe2:	00a6      	lsls	r6, r4, #2
 8008fe4:	ab56      	add	r3, sp, #344	; 0x158
 8008fe6:	4433      	add	r3, r6
 8008fe8:	2c00      	cmp	r4, #0
 8008fea:	ed13 0a14 	vldr	s0, [r3, #-80]	; 0xffffffb0
 8008fee:	dd1b      	ble.n	8009028 <__kernel_rem_pio2f+0x114>
 8008ff0:	f1ac 0104 	sub.w	r1, ip, #4
 8008ff4:	aa42      	add	r2, sp, #264	; 0x108
 8008ff6:	4432      	add	r2, r6
 8008ff8:	4431      	add	r1, r6
 8008ffa:	ab05      	add	r3, sp, #20
 8008ffc:	ee60 7a28 	vmul.f32	s15, s0, s17
 8009000:	eeb0 7a40 	vmov.f32	s14, s0
 8009004:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8009008:	ed72 6a01 	vldmdb	r2!, {s13}
 800900c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8009010:	eea7 7ac8 	vfms.f32	s14, s15, s16
 8009014:	ee37 0aa6 	vadd.f32	s0, s15, s13
 8009018:	eebd 7ac7 	vcvt.s32.f32	s14, s14
 800901c:	ee17 0a10 	vmov	r0, s14
 8009020:	f843 0f04 	str.w	r0, [r3, #4]!
 8009024:	428b      	cmp	r3, r1
 8009026:	d1e9      	bne.n	8008ffc <__kernel_rem_pio2f+0xe8>
 8009028:	4640      	mov	r0, r8
 800902a:	f8cd c000 	str.w	ip, [sp]
 800902e:	f000 fde7 	bl	8009c00 <scalbnf>
 8009032:	eeb0 9a40 	vmov.f32	s18, s0
 8009036:	eeb4 0a00 	vmov.f32	s0, #64	; 0x40
 800903a:	ee29 0a00 	vmul.f32	s0, s18, s0
 800903e:	f000 fd73 	bl	8009b28 <floorf>
 8009042:	eef2 7a00 	vmov.f32	s15, #32
 8009046:	eea0 9a67 	vfms.f32	s18, s0, s15
 800904a:	f1b8 0f00 	cmp.w	r8, #0
 800904e:	f8dd c000 	ldr.w	ip, [sp]
 8009052:	eefd 9ac9 	vcvt.s32.f32	s19, s18
 8009056:	eef8 7ae9 	vcvt.f32.s32	s15, s19
 800905a:	ee39 9a67 	vsub.f32	s18, s18, s15
 800905e:	f340 80a1 	ble.w	80091a4 <__kernel_rem_pio2f+0x290>
 8009062:	1e61      	subs	r1, r4, #1
 8009064:	f1c8 0008 	rsb	r0, r8, #8
 8009068:	f85c 3021 	ldr.w	r3, [ip, r1, lsl #2]
 800906c:	fa43 f200 	asr.w	r2, r3, r0
 8009070:	fa02 f000 	lsl.w	r0, r2, r0
 8009074:	1a1b      	subs	r3, r3, r0
 8009076:	f84c 3021 	str.w	r3, [ip, r1, lsl #2]
 800907a:	ee19 1a90 	vmov	r1, s19
 800907e:	f1c8 0007 	rsb	r0, r8, #7
 8009082:	4411      	add	r1, r2
 8009084:	fa43 f000 	asr.w	r0, r3, r0
 8009088:	ee09 1a90 	vmov	s19, r1
 800908c:	9001      	str	r0, [sp, #4]
 800908e:	9b01      	ldr	r3, [sp, #4]
 8009090:	2b00      	cmp	r3, #0
 8009092:	dd2d      	ble.n	80090f0 <__kernel_rem_pio2f+0x1dc>
 8009094:	ee19 2a90 	vmov	r2, s19
 8009098:	2c00      	cmp	r4, #0
 800909a:	f102 0201 	add.w	r2, r2, #1
 800909e:	ee09 2a90 	vmov	s19, r2
 80090a2:	f340 8140 	ble.w	8009326 <__kernel_rem_pio2f+0x412>
 80090a6:	4663      	mov	r3, ip
 80090a8:	eb0c 0706 	add.w	r7, ip, r6
 80090ac:	2100      	movs	r1, #0
 80090ae:	f853 2b04 	ldr.w	r2, [r3], #4
 80090b2:	f1c2 00ff 	rsb	r0, r2, #255	; 0xff
 80090b6:	b911      	cbnz	r1, 80090be <__kernel_rem_pio2f+0x1aa>
 80090b8:	f5c2 7080 	rsb	r0, r2, #256	; 0x100
 80090bc:	b112      	cbz	r2, 80090c4 <__kernel_rem_pio2f+0x1b0>
 80090be:	f843 0c04 	str.w	r0, [r3, #-4]
 80090c2:	2101      	movs	r1, #1
 80090c4:	42bb      	cmp	r3, r7
 80090c6:	d1f2      	bne.n	80090ae <__kernel_rem_pio2f+0x19a>
 80090c8:	f1b8 0f00 	cmp.w	r8, #0
 80090cc:	dd0d      	ble.n	80090ea <__kernel_rem_pio2f+0x1d6>
 80090ce:	f1b8 0f01 	cmp.w	r8, #1
 80090d2:	f000 8102 	beq.w	80092da <__kernel_rem_pio2f+0x3c6>
 80090d6:	f1b8 0f02 	cmp.w	r8, #2
 80090da:	d106      	bne.n	80090ea <__kernel_rem_pio2f+0x1d6>
 80090dc:	1e62      	subs	r2, r4, #1
 80090de:	f85c 3022 	ldr.w	r3, [ip, r2, lsl #2]
 80090e2:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 80090e6:	f84c 3022 	str.w	r3, [ip, r2, lsl #2]
 80090ea:	9b01      	ldr	r3, [sp, #4]
 80090ec:	2b02      	cmp	r3, #2
 80090ee:	d069      	beq.n	80091c4 <__kernel_rem_pio2f+0x2b0>
 80090f0:	eeb5 9a40 	vcmp.f32	s18, #0.0
 80090f4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80090f8:	d178      	bne.n	80091ec <__kernel_rem_pio2f+0x2d8>
 80090fa:	9905      	ldr	r1, [sp, #20]
 80090fc:	1e67      	subs	r7, r4, #1
 80090fe:	42b9      	cmp	r1, r7
 8009100:	dc0a      	bgt.n	8009118 <__kernel_rem_pio2f+0x204>
 8009102:	4466      	add	r6, ip
 8009104:	2300      	movs	r3, #0
 8009106:	f856 2d04 	ldr.w	r2, [r6, #-4]!
 800910a:	455e      	cmp	r6, fp
 800910c:	ea43 0302 	orr.w	r3, r3, r2
 8009110:	d1f9      	bne.n	8009106 <__kernel_rem_pio2f+0x1f2>
 8009112:	2b00      	cmp	r3, #0
 8009114:	f040 81b1 	bne.w	800947a <__kernel_rem_pio2f+0x566>
 8009118:	9a05      	ldr	r2, [sp, #20]
 800911a:	1e53      	subs	r3, r2, #1
 800911c:	f85c 2023 	ldr.w	r2, [ip, r3, lsl #2]
 8009120:	2a00      	cmp	r2, #0
 8009122:	f040 81a7 	bne.w	8009474 <__kernel_rem_pio2f+0x560>
 8009126:	eb0c 0383 	add.w	r3, ip, r3, lsl #2
 800912a:	f04f 0e01 	mov.w	lr, #1
 800912e:	f853 2d04 	ldr.w	r2, [r3, #-4]!
 8009132:	f10e 0e01 	add.w	lr, lr, #1
 8009136:	2a00      	cmp	r2, #0
 8009138:	d0f9      	beq.n	800912e <__kernel_rem_pio2f+0x21a>
 800913a:	44a6      	add	lr, r4
 800913c:	1c66      	adds	r6, r4, #1
 800913e:	4576      	cmp	r6, lr
 8009140:	dc2e      	bgt.n	80091a0 <__kernel_rem_pio2f+0x28c>
 8009142:	9804      	ldr	r0, [sp, #16]
 8009144:	9f04      	ldr	r7, [sp, #16]
 8009146:	4420      	add	r0, r4
 8009148:	9c65      	ldr	r4, [sp, #404]	; 0x194
 800914a:	eb09 0306 	add.w	r3, r9, r6
 800914e:	a91a      	add	r1, sp, #104	; 0x68
 8009150:	eb04 0080 	add.w	r0, r4, r0, lsl #2
 8009154:	eb01 0483 	add.w	r4, r1, r3, lsl #2
 8009158:	9b65      	ldr	r3, [sp, #404]	; 0x194
 800915a:	4477      	add	r7, lr
 800915c:	aa42      	add	r2, sp, #264	; 0x108
 800915e:	eb02 0686 	add.w	r6, r2, r6, lsl #2
 8009162:	eb03 0787 	add.w	r7, r3, r7, lsl #2
 8009166:	f850 1f04 	ldr.w	r1, [r0, #4]!
 800916a:	ee07 1a90 	vmov	s15, r1
 800916e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8009172:	f1b9 0f00 	cmp.w	r9, #0
 8009176:	ece4 7a01 	vstmia	r4!, {s15}
 800917a:	eddf 7a0f 	vldr	s15, [pc, #60]	; 80091b8 <__kernel_rem_pio2f+0x2a4>
 800917e:	db0b      	blt.n	8009198 <__kernel_rem_pio2f+0x284>
 8009180:	4651      	mov	r1, sl
 8009182:	4622      	mov	r2, r4
 8009184:	2300      	movs	r3, #0
 8009186:	ecf1 6a01 	vldmia	r1!, {s13}
 800918a:	ed32 7a01 	vldmdb	r2!, {s14}
 800918e:	3301      	adds	r3, #1
 8009190:	42ab      	cmp	r3, r5
 8009192:	eee6 7a87 	vfma.f32	s15, s13, s14
 8009196:	d1f6      	bne.n	8009186 <__kernel_rem_pio2f+0x272>
 8009198:	42b8      	cmp	r0, r7
 800919a:	ece6 7a01 	vstmia	r6!, {s15}
 800919e:	d1e2      	bne.n	8009166 <__kernel_rem_pio2f+0x252>
 80091a0:	4674      	mov	r4, lr
 80091a2:	e71e      	b.n	8008fe2 <__kernel_rem_pio2f+0xce>
 80091a4:	f040 80a1 	bne.w	80092ea <__kernel_rem_pio2f+0x3d6>
 80091a8:	1e63      	subs	r3, r4, #1
 80091aa:	f85c 3023 	ldr.w	r3, [ip, r3, lsl #2]
 80091ae:	121b      	asrs	r3, r3, #8
 80091b0:	9301      	str	r3, [sp, #4]
 80091b2:	e76c      	b.n	800908e <__kernel_rem_pio2f+0x17a>
 80091b4:	0800a0fc 	.word	0x0800a0fc
 80091b8:	00000000 	.word	0x00000000
 80091bc:	43800000 	.word	0x43800000
 80091c0:	3b800000 	.word	0x3b800000
 80091c4:	eeb7 0a00 	vmov.f32	s0, #112	; 0x70
 80091c8:	ee30 9a49 	vsub.f32	s18, s0, s18
 80091cc:	2900      	cmp	r1, #0
 80091ce:	d08f      	beq.n	80090f0 <__kernel_rem_pio2f+0x1dc>
 80091d0:	4640      	mov	r0, r8
 80091d2:	f8cd c000 	str.w	ip, [sp]
 80091d6:	f000 fd13 	bl	8009c00 <scalbnf>
 80091da:	ee39 9a40 	vsub.f32	s18, s18, s0
 80091de:	f8dd c000 	ldr.w	ip, [sp]
 80091e2:	eeb5 9a40 	vcmp.f32	s18, #0.0
 80091e6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80091ea:	d086      	beq.n	80090fa <__kernel_rem_pio2f+0x1e6>
 80091ec:	9b02      	ldr	r3, [sp, #8]
 80091ee:	f8cd c000 	str.w	ip, [sp]
 80091f2:	eeb0 0a49 	vmov.f32	s0, s18
 80091f6:	4258      	negs	r0, r3
 80091f8:	f8dd 8014 	ldr.w	r8, [sp, #20]
 80091fc:	f000 fd00 	bl	8009c00 <scalbnf>
 8009200:	ed5f 7a12 	vldr	s15, [pc, #-72]	; 80091bc <__kernel_rem_pio2f+0x2a8>
 8009204:	f8dd c000 	ldr.w	ip, [sp]
 8009208:	eeb4 0ae7 	vcmpe.f32	s0, s15
 800920c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009210:	f2c0 8154 	blt.w	80094bc <__kernel_rem_pio2f+0x5a8>
 8009214:	ed1f 7a16 	vldr	s14, [pc, #-88]	; 80091c0 <__kernel_rem_pio2f+0x2ac>
 8009218:	9a02      	ldr	r2, [sp, #8]
 800921a:	ee20 7a07 	vmul.f32	s14, s0, s14
 800921e:	1c67      	adds	r7, r4, #1
 8009220:	eebd 7ac7 	vcvt.s32.f32	s14, s14
 8009224:	3208      	adds	r2, #8
 8009226:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 800922a:	9202      	str	r2, [sp, #8]
 800922c:	eea7 0a67 	vfms.f32	s0, s14, s15
 8009230:	eebd 7ac7 	vcvt.s32.f32	s14, s14
 8009234:	eebd 0ac0 	vcvt.s32.f32	s0, s0
 8009238:	ee10 3a10 	vmov	r3, s0
 800923c:	f84c 3024 	str.w	r3, [ip, r4, lsl #2]
 8009240:	ee17 4a10 	vmov	r4, s14
 8009244:	f84c 4027 	str.w	r4, [ip, r7, lsl #2]
 8009248:	9802      	ldr	r0, [sp, #8]
 800924a:	f8cd c000 	str.w	ip, [sp]
 800924e:	eeb7 0a00 	vmov.f32	s0, #112	; 0x70
 8009252:	f000 fcd5 	bl	8009c00 <scalbnf>
 8009256:	2f00      	cmp	r7, #0
 8009258:	f8dd c000 	ldr.w	ip, [sp]
 800925c:	db36      	blt.n	80092cc <__kernel_rem_pio2f+0x3b8>
 800925e:	1c7d      	adds	r5, r7, #1
 8009260:	00aa      	lsls	r2, r5, #2
 8009262:	ae42      	add	r6, sp, #264	; 0x108
 8009264:	ed1f 7a2a 	vldr	s14, [pc, #-168]	; 80091c0 <__kernel_rem_pio2f+0x2ac>
 8009268:	eb0c 0302 	add.w	r3, ip, r2
 800926c:	4432      	add	r2, r6
 800926e:	ed73 7a01 	vldmdb	r3!, {s15}
 8009272:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8009276:	4563      	cmp	r3, ip
 8009278:	ee67 7a80 	vmul.f32	s15, s15, s0
 800927c:	ee20 0a07 	vmul.f32	s0, s0, s14
 8009280:	ed62 7a01 	vstmdb	r2!, {s15}
 8009284:	d1f3      	bne.n	800926e <__kernel_rem_pio2f+0x35a>
 8009286:	a842      	add	r0, sp, #264	; 0x108
 8009288:	eb00 0487 	add.w	r4, r0, r7, lsl #2
 800928c:	2000      	movs	r0, #0
 800928e:	f1b8 0f00 	cmp.w	r8, #0
 8009292:	f2c0 80e9 	blt.w	8009468 <__kernel_rem_pio2f+0x554>
 8009296:	4990      	ldr	r1, [pc, #576]	; (80094d8 <__kernel_rem_pio2f+0x5c4>)
 8009298:	eddf 7a90 	vldr	s15, [pc, #576]	; 80094dc <__kernel_rem_pio2f+0x5c8>
 800929c:	4622      	mov	r2, r4
 800929e:	2300      	movs	r3, #0
 80092a0:	e001      	b.n	80092a6 <__kernel_rem_pio2f+0x392>
 80092a2:	4283      	cmp	r3, r0
 80092a4:	dc08      	bgt.n	80092b8 <__kernel_rem_pio2f+0x3a4>
 80092a6:	ecf1 6a01 	vldmia	r1!, {s13}
 80092aa:	ecb2 7a01 	vldmia	r2!, {s14}
 80092ae:	3301      	adds	r3, #1
 80092b0:	4598      	cmp	r8, r3
 80092b2:	eee6 7a87 	vfma.f32	s15, s13, s14
 80092b6:	daf4      	bge.n	80092a2 <__kernel_rem_pio2f+0x38e>
 80092b8:	a956      	add	r1, sp, #344	; 0x158
 80092ba:	eb01 0380 	add.w	r3, r1, r0, lsl #2
 80092be:	3001      	adds	r0, #1
 80092c0:	4285      	cmp	r5, r0
 80092c2:	f1a4 0404 	sub.w	r4, r4, #4
 80092c6:	ed43 7a28 	vstr	s15, [r3, #-160]	; 0xffffff60
 80092ca:	d1e0      	bne.n	800928e <__kernel_rem_pio2f+0x37a>
 80092cc:	9c64      	ldr	r4, [sp, #400]	; 0x190
 80092ce:	2c03      	cmp	r4, #3
 80092d0:	d87f      	bhi.n	80093d2 <__kernel_rem_pio2f+0x4be>
 80092d2:	e8df f004 	tbb	[pc, r4]
 80092d6:	87b3      	.short	0x87b3
 80092d8:	2a87      	.short	0x2a87
 80092da:	1e62      	subs	r2, r4, #1
 80092dc:	f85c 3022 	ldr.w	r3, [ip, r2, lsl #2]
 80092e0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80092e4:	f84c 3022 	str.w	r3, [ip, r2, lsl #2]
 80092e8:	e6ff      	b.n	80090ea <__kernel_rem_pio2f+0x1d6>
 80092ea:	eef6 7a00 	vmov.f32	s15, #96	; 0x60
 80092ee:	eeb4 9ae7 	vcmpe.f32	s18, s15
 80092f2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80092f6:	da0c      	bge.n	8009312 <__kernel_rem_pio2f+0x3fe>
 80092f8:	2200      	movs	r2, #0
 80092fa:	9201      	str	r2, [sp, #4]
 80092fc:	e6f8      	b.n	80090f0 <__kernel_rem_pio2f+0x1dc>
 80092fe:	eddf 7a77 	vldr	s15, [pc, #476]	; 80094dc <__kernel_rem_pio2f+0x5c8>
 8009302:	ece0 7a01 	vstmia	r0!, {s15}
 8009306:	42b0      	cmp	r0, r6
 8009308:	f104 0404 	add.w	r4, r4, #4
 800930c:	f47f ae45 	bne.w	8008f9a <__kernel_rem_pio2f+0x86>
 8009310:	e65b      	b.n	8008fca <__kernel_rem_pio2f+0xb6>
 8009312:	ee19 2a90 	vmov	r2, s19
 8009316:	2102      	movs	r1, #2
 8009318:	3201      	adds	r2, #1
 800931a:	2c00      	cmp	r4, #0
 800931c:	9101      	str	r1, [sp, #4]
 800931e:	ee09 2a90 	vmov	s19, r2
 8009322:	f73f aec0 	bgt.w	80090a6 <__kernel_rem_pio2f+0x192>
 8009326:	2100      	movs	r1, #0
 8009328:	e6ce      	b.n	80090c8 <__kernel_rem_pio2f+0x1b4>
 800932a:	2f00      	cmp	r7, #0
 800932c:	f340 80b9 	ble.w	80094a2 <__kernel_rem_pio2f+0x58e>
 8009330:	00b9      	lsls	r1, r7, #2
 8009332:	ab56      	add	r3, sp, #344	; 0x158
 8009334:	1c7a      	adds	r2, r7, #1
 8009336:	ae2e      	add	r6, sp, #184	; 0xb8
 8009338:	440b      	add	r3, r1
 800933a:	eb06 0282 	add.w	r2, r6, r2, lsl #2
 800933e:	ed53 7a28 	vldr	s15, [r3, #-160]	; 0xffffff60
 8009342:	a82f      	add	r0, sp, #188	; 0xbc
 8009344:	4613      	mov	r3, r2
 8009346:	ed53 6a02 	vldr	s13, [r3, #-8]
 800934a:	ee36 7aa7 	vadd.f32	s14, s13, s15
 800934e:	ee76 6ac7 	vsub.f32	s13, s13, s14
 8009352:	ee76 6aa7 	vadd.f32	s13, s13, s15
 8009356:	eef0 7a47 	vmov.f32	s15, s14
 800935a:	ed63 6a01 	vstmdb	r3!, {s13}
 800935e:	4283      	cmp	r3, r0
 8009360:	ed03 7a01 	vstr	s14, [r3, #-4]
 8009364:	d1ef      	bne.n	8009346 <__kernel_rem_pio2f+0x432>
 8009366:	2f01      	cmp	r7, #1
 8009368:	f340 809b 	ble.w	80094a2 <__kernel_rem_pio2f+0x58e>
 800936c:	a856      	add	r0, sp, #344	; 0x158
 800936e:	4401      	add	r1, r0
 8009370:	ed51 7a28 	vldr	s15, [r1, #-160]	; 0xffffff60
 8009374:	4613      	mov	r3, r2
 8009376:	a930      	add	r1, sp, #192	; 0xc0
 8009378:	ed53 6a02 	vldr	s13, [r3, #-8]
 800937c:	ee36 7aa7 	vadd.f32	s14, s13, s15
 8009380:	ee76 6ac7 	vsub.f32	s13, s13, s14
 8009384:	ee76 6aa7 	vadd.f32	s13, s13, s15
 8009388:	eef0 7a47 	vmov.f32	s15, s14
 800938c:	ed63 6a01 	vstmdb	r3!, {s13}
 8009390:	428b      	cmp	r3, r1
 8009392:	ed03 7a01 	vstr	s14, [r3, #-4]
 8009396:	d1ef      	bne.n	8009378 <__kernel_rem_pio2f+0x464>
 8009398:	eddf 7a50 	vldr	s15, [pc, #320]	; 80094dc <__kernel_rem_pio2f+0x5c8>
 800939c:	4613      	mov	r3, r2
 800939e:	ed33 7a01 	vldmdb	r3!, {s14}
 80093a2:	4299      	cmp	r1, r3
 80093a4:	ee77 7a87 	vadd.f32	s15, s15, s14
 80093a8:	d1f9      	bne.n	800939e <__kernel_rem_pio2f+0x48a>
 80093aa:	9c01      	ldr	r4, [sp, #4]
 80093ac:	2c00      	cmp	r4, #0
 80093ae:	d07d      	beq.n	80094ac <__kernel_rem_pio2f+0x598>
 80093b0:	eddd 6a2e 	vldr	s13, [sp, #184]	; 0xb8
 80093b4:	ed9d 7a2f 	vldr	s14, [sp, #188]	; 0xbc
 80093b8:	9e03      	ldr	r6, [sp, #12]
 80093ba:	eef1 7a67 	vneg.f32	s15, s15
 80093be:	eef1 6a66 	vneg.f32	s13, s13
 80093c2:	eeb1 7a47 	vneg.f32	s14, s14
 80093c6:	edc6 7a02 	vstr	s15, [r6, #8]
 80093ca:	edc6 6a00 	vstr	s13, [r6]
 80093ce:	ed86 7a01 	vstr	s14, [r6, #4]
 80093d2:	ee19 1a90 	vmov	r1, s19
 80093d6:	f001 0007 	and.w	r0, r1, #7
 80093da:	b057      	add	sp, #348	; 0x15c
 80093dc:	ecbd 8b04 	vpop	{d8-d9}
 80093e0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80093e4:	2f00      	cmp	r7, #0
 80093e6:	db74      	blt.n	80094d2 <__kernel_rem_pio2f+0x5be>
 80093e8:	aa2e      	add	r2, sp, #184	; 0xb8
 80093ea:	1c7b      	adds	r3, r7, #1
 80093ec:	eddf 7a3b 	vldr	s15, [pc, #236]	; 80094dc <__kernel_rem_pio2f+0x5c8>
 80093f0:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 80093f4:	ed33 7a01 	vldmdb	r3!, {s14}
 80093f8:	4293      	cmp	r3, r2
 80093fa:	ee77 7a87 	vadd.f32	s15, s15, s14
 80093fe:	d1f9      	bne.n	80093f4 <__kernel_rem_pio2f+0x4e0>
 8009400:	9a01      	ldr	r2, [sp, #4]
 8009402:	b3a2      	cbz	r2, 800946e <__kernel_rem_pio2f+0x55a>
 8009404:	eeb1 7a67 	vneg.f32	s14, s15
 8009408:	eddd 6a2e 	vldr	s13, [sp, #184]	; 0xb8
 800940c:	9b03      	ldr	r3, [sp, #12]
 800940e:	2f00      	cmp	r7, #0
 8009410:	ed83 7a00 	vstr	s14, [r3]
 8009414:	ee76 7ae7 	vsub.f32	s15, s13, s15
 8009418:	dd08      	ble.n	800942c <__kernel_rem_pio2f+0x518>
 800941a:	ab2f      	add	r3, sp, #188	; 0xbc
 800941c:	eb03 0787 	add.w	r7, r3, r7, lsl #2
 8009420:	ecb3 7a01 	vldmia	r3!, {s14}
 8009424:	42bb      	cmp	r3, r7
 8009426:	ee77 7a87 	vadd.f32	s15, s15, s14
 800942a:	d1f9      	bne.n	8009420 <__kernel_rem_pio2f+0x50c>
 800942c:	9c01      	ldr	r4, [sp, #4]
 800942e:	b10c      	cbz	r4, 8009434 <__kernel_rem_pio2f+0x520>
 8009430:	eef1 7a67 	vneg.f32	s15, s15
 8009434:	9d03      	ldr	r5, [sp, #12]
 8009436:	edc5 7a01 	vstr	s15, [r5, #4]
 800943a:	e7ca      	b.n	80093d2 <__kernel_rem_pio2f+0x4be>
 800943c:	2f00      	cmp	r7, #0
 800943e:	db45      	blt.n	80094cc <__kernel_rem_pio2f+0x5b8>
 8009440:	1c7b      	adds	r3, r7, #1
 8009442:	aa2e      	add	r2, sp, #184	; 0xb8
 8009444:	eddf 7a25 	vldr	s15, [pc, #148]	; 80094dc <__kernel_rem_pio2f+0x5c8>
 8009448:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 800944c:	ed33 7a01 	vldmdb	r3!, {s14}
 8009450:	4293      	cmp	r3, r2
 8009452:	ee77 7a87 	vadd.f32	s15, s15, s14
 8009456:	d1f9      	bne.n	800944c <__kernel_rem_pio2f+0x538>
 8009458:	9e01      	ldr	r6, [sp, #4]
 800945a:	b10e      	cbz	r6, 8009460 <__kernel_rem_pio2f+0x54c>
 800945c:	eef1 7a67 	vneg.f32	s15, s15
 8009460:	9903      	ldr	r1, [sp, #12]
 8009462:	edc1 7a00 	vstr	s15, [r1]
 8009466:	e7b4      	b.n	80093d2 <__kernel_rem_pio2f+0x4be>
 8009468:	eddf 7a1c 	vldr	s15, [pc, #112]	; 80094dc <__kernel_rem_pio2f+0x5c8>
 800946c:	e724      	b.n	80092b8 <__kernel_rem_pio2f+0x3a4>
 800946e:	eeb0 7a67 	vmov.f32	s14, s15
 8009472:	e7c9      	b.n	8009408 <__kernel_rem_pio2f+0x4f4>
 8009474:	f04f 0e01 	mov.w	lr, #1
 8009478:	e65f      	b.n	800913a <__kernel_rem_pio2f+0x226>
 800947a:	9a02      	ldr	r2, [sp, #8]
 800947c:	f85c 3027 	ldr.w	r3, [ip, r7, lsl #2]
 8009480:	f8dd 8014 	ldr.w	r8, [sp, #20]
 8009484:	3a08      	subs	r2, #8
 8009486:	9202      	str	r2, [sp, #8]
 8009488:	2b00      	cmp	r3, #0
 800948a:	f47f aedd 	bne.w	8009248 <__kernel_rem_pio2f+0x334>
 800948e:	eb0c 0387 	add.w	r3, ip, r7, lsl #2
 8009492:	f853 1d04 	ldr.w	r1, [r3, #-4]!
 8009496:	3f01      	subs	r7, #1
 8009498:	3a08      	subs	r2, #8
 800949a:	2900      	cmp	r1, #0
 800949c:	d0f9      	beq.n	8009492 <__kernel_rem_pio2f+0x57e>
 800949e:	9202      	str	r2, [sp, #8]
 80094a0:	e6d2      	b.n	8009248 <__kernel_rem_pio2f+0x334>
 80094a2:	9c01      	ldr	r4, [sp, #4]
 80094a4:	eddf 7a0d 	vldr	s15, [pc, #52]	; 80094dc <__kernel_rem_pio2f+0x5c8>
 80094a8:	2c00      	cmp	r4, #0
 80094aa:	d181      	bne.n	80093b0 <__kernel_rem_pio2f+0x49c>
 80094ac:	9d03      	ldr	r5, [sp, #12]
 80094ae:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
 80094b0:	9b2f      	ldr	r3, [sp, #188]	; 0xbc
 80094b2:	edc5 7a02 	vstr	s15, [r5, #8]
 80094b6:	602a      	str	r2, [r5, #0]
 80094b8:	606b      	str	r3, [r5, #4]
 80094ba:	e78a      	b.n	80093d2 <__kernel_rem_pio2f+0x4be>
 80094bc:	eebd 0ac0 	vcvt.s32.f32	s0, s0
 80094c0:	4627      	mov	r7, r4
 80094c2:	ee10 5a10 	vmov	r5, s0
 80094c6:	f84c 5024 	str.w	r5, [ip, r4, lsl #2]
 80094ca:	e6bd      	b.n	8009248 <__kernel_rem_pio2f+0x334>
 80094cc:	eddf 7a03 	vldr	s15, [pc, #12]	; 80094dc <__kernel_rem_pio2f+0x5c8>
 80094d0:	e7c2      	b.n	8009458 <__kernel_rem_pio2f+0x544>
 80094d2:	eddf 7a02 	vldr	s15, [pc, #8]	; 80094dc <__kernel_rem_pio2f+0x5c8>
 80094d6:	e793      	b.n	8009400 <__kernel_rem_pio2f+0x4ec>
 80094d8:	0800a108 	.word	0x0800a108
 80094dc:	00000000 	.word	0x00000000

080094e0 <__kernel_sinf>:
 80094e0:	ee10 3a10 	vmov	r3, s0
 80094e4:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 80094e8:	f1b3 5f48 	cmp.w	r3, #838860800	; 0x32000000
 80094ec:	da04      	bge.n	80094f8 <__kernel_sinf+0x18>
 80094ee:	eefd 7ac0 	vcvt.s32.f32	s15, s0
 80094f2:	ee17 3a90 	vmov	r3, s15
 80094f6:	b323      	cbz	r3, 8009542 <__kernel_sinf+0x62>
 80094f8:	ee60 7a00 	vmul.f32	s15, s0, s0
 80094fc:	ed9f 5a15 	vldr	s10, [pc, #84]	; 8009554 <__kernel_sinf+0x74>
 8009500:	ed9f 6a15 	vldr	s12, [pc, #84]	; 8009558 <__kernel_sinf+0x78>
 8009504:	eddf 6a15 	vldr	s13, [pc, #84]	; 800955c <__kernel_sinf+0x7c>
 8009508:	ed9f 7a15 	vldr	s14, [pc, #84]	; 8009560 <__kernel_sinf+0x80>
 800950c:	eddf 5a15 	vldr	s11, [pc, #84]	; 8009564 <__kernel_sinf+0x84>
 8009510:	eea7 6a85 	vfma.f32	s12, s15, s10
 8009514:	ee27 5a80 	vmul.f32	s10, s15, s0
 8009518:	eee6 6a27 	vfma.f32	s13, s12, s15
 800951c:	eea6 7aa7 	vfma.f32	s14, s13, s15
 8009520:	eee7 5a27 	vfma.f32	s11, s14, s15
 8009524:	b170      	cbz	r0, 8009544 <__kernel_sinf+0x64>
 8009526:	ee65 5ac5 	vnmul.f32	s11, s11, s10
 800952a:	eeb6 7a00 	vmov.f32	s14, #96	; 0x60
 800952e:	eee0 5a87 	vfma.f32	s11, s1, s14
 8009532:	ed9f 7a0d 	vldr	s14, [pc, #52]	; 8009568 <__kernel_sinf+0x88>
 8009536:	eed5 0aa7 	vfnms.f32	s1, s11, s15
 800953a:	eee5 0a07 	vfma.f32	s1, s10, s14
 800953e:	ee30 0a60 	vsub.f32	s0, s0, s1
 8009542:	4770      	bx	lr
 8009544:	ed9f 7a09 	vldr	s14, [pc, #36]	; 800956c <__kernel_sinf+0x8c>
 8009548:	eea7 7aa5 	vfma.f32	s14, s15, s11
 800954c:	eea7 0a05 	vfma.f32	s0, s14, s10
 8009550:	4770      	bx	lr
 8009552:	bf00      	nop
 8009554:	2f2ec9d3 	.word	0x2f2ec9d3
 8009558:	b2d72f34 	.word	0xb2d72f34
 800955c:	3638ef1b 	.word	0x3638ef1b
 8009560:	b9500d01 	.word	0xb9500d01
 8009564:	3c088889 	.word	0x3c088889
 8009568:	3e2aaaab 	.word	0x3e2aaaab
 800956c:	be2aaaab 	.word	0xbe2aaaab

08009570 <atan>:
 8009570:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8009574:	ec55 4b10 	vmov	r4, r5, d0
 8009578:	4bbd      	ldr	r3, [pc, #756]	; (8009870 <atan+0x300>)
 800957a:	f025 4600 	bic.w	r6, r5, #2147483648	; 0x80000000
 800957e:	429e      	cmp	r6, r3
 8009580:	b083      	sub	sp, #12
 8009582:	46a9      	mov	r9, r5
 8009584:	dd0e      	ble.n	80095a4 <atan+0x34>
 8009586:	49bb      	ldr	r1, [pc, #748]	; (8009874 <atan+0x304>)
 8009588:	428e      	cmp	r6, r1
 800958a:	f300 80b3 	bgt.w	80096f4 <atan+0x184>
 800958e:	f000 80ae 	beq.w	80096ee <atan+0x17e>
 8009592:	f1b9 0f00 	cmp.w	r9, #0
 8009596:	f340 80f8 	ble.w	800978a <atan+0x21a>
 800959a:	ed9f 0b99 	vldr	d0, [pc, #612]	; 8009800 <atan+0x290>
 800959e:	b003      	add	sp, #12
 80095a0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80095a4:	4bb4      	ldr	r3, [pc, #720]	; (8009878 <atan+0x308>)
 80095a6:	429e      	cmp	r6, r3
 80095a8:	f300 80c3 	bgt.w	8009732 <atan+0x1c2>
 80095ac:	f1a3 73de 	sub.w	r3, r3, #29097984	; 0x1bc0000
 80095b0:	429e      	cmp	r6, r3
 80095b2:	f340 80aa 	ble.w	800970a <atan+0x19a>
 80095b6:	f04f 3cff 	mov.w	ip, #4294967295
 80095ba:	4622      	mov	r2, r4
 80095bc:	462b      	mov	r3, r5
 80095be:	4620      	mov	r0, r4
 80095c0:	4629      	mov	r1, r5
 80095c2:	f8cd c004 	str.w	ip, [sp, #4]
 80095c6:	f7fe f9df 	bl	8007988 <__aeabi_dmul>
 80095ca:	4602      	mov	r2, r0
 80095cc:	460b      	mov	r3, r1
 80095ce:	4682      	mov	sl, r0
 80095d0:	468b      	mov	fp, r1
 80095d2:	f7fe f9d9 	bl	8007988 <__aeabi_dmul>
 80095d6:	a38c      	add	r3, pc, #560	; (adr r3, 8009808 <atan+0x298>)
 80095d8:	e9d3 2300 	ldrd	r2, r3, [r3]
 80095dc:	4606      	mov	r6, r0
 80095de:	460f      	mov	r7, r1
 80095e0:	f7fe f9d2 	bl	8007988 <__aeabi_dmul>
 80095e4:	a38a      	add	r3, pc, #552	; (adr r3, 8009810 <atan+0x2a0>)
 80095e6:	e9d3 2300 	ldrd	r2, r3, [r3]
 80095ea:	f7fd ff09 	bl	8007400 <__adddf3>
 80095ee:	4632      	mov	r2, r6
 80095f0:	463b      	mov	r3, r7
 80095f2:	f7fe f9c9 	bl	8007988 <__aeabi_dmul>
 80095f6:	a388      	add	r3, pc, #544	; (adr r3, 8009818 <atan+0x2a8>)
 80095f8:	e9d3 2300 	ldrd	r2, r3, [r3]
 80095fc:	f7fd ff00 	bl	8007400 <__adddf3>
 8009600:	4632      	mov	r2, r6
 8009602:	463b      	mov	r3, r7
 8009604:	f7fe f9c0 	bl	8007988 <__aeabi_dmul>
 8009608:	a385      	add	r3, pc, #532	; (adr r3, 8009820 <atan+0x2b0>)
 800960a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800960e:	f7fd fef7 	bl	8007400 <__adddf3>
 8009612:	4632      	mov	r2, r6
 8009614:	463b      	mov	r3, r7
 8009616:	f7fe f9b7 	bl	8007988 <__aeabi_dmul>
 800961a:	a383      	add	r3, pc, #524	; (adr r3, 8009828 <atan+0x2b8>)
 800961c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009620:	f7fd feee 	bl	8007400 <__adddf3>
 8009624:	4632      	mov	r2, r6
 8009626:	463b      	mov	r3, r7
 8009628:	f7fe f9ae 	bl	8007988 <__aeabi_dmul>
 800962c:	a380      	add	r3, pc, #512	; (adr r3, 8009830 <atan+0x2c0>)
 800962e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009632:	f7fd fee5 	bl	8007400 <__adddf3>
 8009636:	4652      	mov	r2, sl
 8009638:	465b      	mov	r3, fp
 800963a:	f7fe f9a5 	bl	8007988 <__aeabi_dmul>
 800963e:	a37e      	add	r3, pc, #504	; (adr r3, 8009838 <atan+0x2c8>)
 8009640:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009644:	4682      	mov	sl, r0
 8009646:	468b      	mov	fp, r1
 8009648:	4630      	mov	r0, r6
 800964a:	4639      	mov	r1, r7
 800964c:	f7fe f99c 	bl	8007988 <__aeabi_dmul>
 8009650:	a37b      	add	r3, pc, #492	; (adr r3, 8009840 <atan+0x2d0>)
 8009652:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009656:	f7fd fed1 	bl	80073fc <__aeabi_dsub>
 800965a:	4632      	mov	r2, r6
 800965c:	463b      	mov	r3, r7
 800965e:	f7fe f993 	bl	8007988 <__aeabi_dmul>
 8009662:	a379      	add	r3, pc, #484	; (adr r3, 8009848 <atan+0x2d8>)
 8009664:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009668:	f7fd fec8 	bl	80073fc <__aeabi_dsub>
 800966c:	4632      	mov	r2, r6
 800966e:	463b      	mov	r3, r7
 8009670:	f7fe f98a 	bl	8007988 <__aeabi_dmul>
 8009674:	a376      	add	r3, pc, #472	; (adr r3, 8009850 <atan+0x2e0>)
 8009676:	e9d3 2300 	ldrd	r2, r3, [r3]
 800967a:	f7fd febf 	bl	80073fc <__aeabi_dsub>
 800967e:	4632      	mov	r2, r6
 8009680:	463b      	mov	r3, r7
 8009682:	f7fe f981 	bl	8007988 <__aeabi_dmul>
 8009686:	a374      	add	r3, pc, #464	; (adr r3, 8009858 <atan+0x2e8>)
 8009688:	e9d3 2300 	ldrd	r2, r3, [r3]
 800968c:	f7fd feb6 	bl	80073fc <__aeabi_dsub>
 8009690:	4632      	mov	r2, r6
 8009692:	463b      	mov	r3, r7
 8009694:	f7fe f978 	bl	8007988 <__aeabi_dmul>
 8009698:	f8dd c004 	ldr.w	ip, [sp, #4]
 800969c:	f1bc 3fff 	cmp.w	ip, #4294967295
 80096a0:	4602      	mov	r2, r0
 80096a2:	460b      	mov	r3, r1
 80096a4:	d07a      	beq.n	800979c <atan+0x22c>
 80096a6:	4650      	mov	r0, sl
 80096a8:	4659      	mov	r1, fp
 80096aa:	ea4f 06cc 	mov.w	r6, ip, lsl #3
 80096ae:	f7fd fea7 	bl	8007400 <__adddf3>
 80096b2:	4622      	mov	r2, r4
 80096b4:	462b      	mov	r3, r5
 80096b6:	f7fe f967 	bl	8007988 <__aeabi_dmul>
 80096ba:	4f70      	ldr	r7, [pc, #448]	; (800987c <atan+0x30c>)
 80096bc:	4b70      	ldr	r3, [pc, #448]	; (8009880 <atan+0x310>)
 80096be:	4437      	add	r7, r6
 80096c0:	441e      	add	r6, r3
 80096c2:	e9d6 2300 	ldrd	r2, r3, [r6]
 80096c6:	f7fd fe99 	bl	80073fc <__aeabi_dsub>
 80096ca:	4622      	mov	r2, r4
 80096cc:	462b      	mov	r3, r5
 80096ce:	f7fd fe95 	bl	80073fc <__aeabi_dsub>
 80096d2:	4602      	mov	r2, r0
 80096d4:	460b      	mov	r3, r1
 80096d6:	e9d7 0100 	ldrd	r0, r1, [r7]
 80096da:	f7fd fe8f 	bl	80073fc <__aeabi_dsub>
 80096de:	f1b9 0f00 	cmp.w	r9, #0
 80096e2:	db55      	blt.n	8009790 <atan+0x220>
 80096e4:	ec41 0b10 	vmov	d0, r0, r1
 80096e8:	b003      	add	sp, #12
 80096ea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80096ee:	2c00      	cmp	r4, #0
 80096f0:	f43f af4f 	beq.w	8009592 <atan+0x22>
 80096f4:	4620      	mov	r0, r4
 80096f6:	4629      	mov	r1, r5
 80096f8:	4622      	mov	r2, r4
 80096fa:	462b      	mov	r3, r5
 80096fc:	f7fd fe80 	bl	8007400 <__adddf3>
 8009700:	ec41 0b10 	vmov	d0, r0, r1
 8009704:	b003      	add	sp, #12
 8009706:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800970a:	a355      	add	r3, pc, #340	; (adr r3, 8009860 <atan+0x2f0>)
 800970c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009710:	ee10 0a10 	vmov	r0, s0
 8009714:	4629      	mov	r1, r5
 8009716:	f7fd fe73 	bl	8007400 <__adddf3>
 800971a:	2200      	movs	r2, #0
 800971c:	4b59      	ldr	r3, [pc, #356]	; (8009884 <atan+0x314>)
 800971e:	f7fe fbc3 	bl	8007ea8 <__aeabi_dcmpgt>
 8009722:	2800      	cmp	r0, #0
 8009724:	f43f af47 	beq.w	80095b6 <atan+0x46>
 8009728:	ec45 4b10 	vmov	d0, r4, r5
 800972c:	b003      	add	sp, #12
 800972e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8009732:	f000 f8d9 	bl	80098e8 <fabs>
 8009736:	4b54      	ldr	r3, [pc, #336]	; (8009888 <atan+0x318>)
 8009738:	429e      	cmp	r6, r3
 800973a:	ec55 4b10 	vmov	r4, r5, d0
 800973e:	dc3e      	bgt.n	80097be <atan+0x24e>
 8009740:	f5a3 2350 	sub.w	r3, r3, #851968	; 0xd0000
 8009744:	429e      	cmp	r6, r3
 8009746:	ee10 0a10 	vmov	r0, s0
 800974a:	4629      	mov	r1, r5
 800974c:	f300 80ae 	bgt.w	80098ac <atan+0x33c>
 8009750:	ee10 2a10 	vmov	r2, s0
 8009754:	462b      	mov	r3, r5
 8009756:	f7fd fe53 	bl	8007400 <__adddf3>
 800975a:	2200      	movs	r2, #0
 800975c:	4b49      	ldr	r3, [pc, #292]	; (8009884 <atan+0x314>)
 800975e:	f7fd fe4d 	bl	80073fc <__aeabi_dsub>
 8009762:	2200      	movs	r2, #0
 8009764:	4606      	mov	r6, r0
 8009766:	460f      	mov	r7, r1
 8009768:	4620      	mov	r0, r4
 800976a:	4629      	mov	r1, r5
 800976c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8009770:	f7fd fe46 	bl	8007400 <__adddf3>
 8009774:	4602      	mov	r2, r0
 8009776:	460b      	mov	r3, r1
 8009778:	4630      	mov	r0, r6
 800977a:	4639      	mov	r1, r7
 800977c:	f7fe fa2e 	bl	8007bdc <__aeabi_ddiv>
 8009780:	f04f 0c00 	mov.w	ip, #0
 8009784:	4604      	mov	r4, r0
 8009786:	460d      	mov	r5, r1
 8009788:	e717      	b.n	80095ba <atan+0x4a>
 800978a:	ed9f 0b37 	vldr	d0, [pc, #220]	; 8009868 <atan+0x2f8>
 800978e:	e7b9      	b.n	8009704 <atan+0x194>
 8009790:	4602      	mov	r2, r0
 8009792:	f101 4300 	add.w	r3, r1, #2147483648	; 0x80000000
 8009796:	ec43 2b10 	vmov	d0, r2, r3
 800979a:	e7b3      	b.n	8009704 <atan+0x194>
 800979c:	4650      	mov	r0, sl
 800979e:	4659      	mov	r1, fp
 80097a0:	f7fd fe2e 	bl	8007400 <__adddf3>
 80097a4:	4622      	mov	r2, r4
 80097a6:	462b      	mov	r3, r5
 80097a8:	f7fe f8ee 	bl	8007988 <__aeabi_dmul>
 80097ac:	4602      	mov	r2, r0
 80097ae:	460b      	mov	r3, r1
 80097b0:	4620      	mov	r0, r4
 80097b2:	4629      	mov	r1, r5
 80097b4:	f7fd fe22 	bl	80073fc <__aeabi_dsub>
 80097b8:	ec41 0b10 	vmov	d0, r0, r1
 80097bc:	e7a2      	b.n	8009704 <atan+0x194>
 80097be:	4b33      	ldr	r3, [pc, #204]	; (800988c <atan+0x31c>)
 80097c0:	429e      	cmp	r6, r3
 80097c2:	dc67      	bgt.n	8009894 <atan+0x324>
 80097c4:	ee10 0a10 	vmov	r0, s0
 80097c8:	4629      	mov	r1, r5
 80097ca:	2200      	movs	r2, #0
 80097cc:	4b30      	ldr	r3, [pc, #192]	; (8009890 <atan+0x320>)
 80097ce:	f7fd fe15 	bl	80073fc <__aeabi_dsub>
 80097d2:	2200      	movs	r2, #0
 80097d4:	4606      	mov	r6, r0
 80097d6:	460f      	mov	r7, r1
 80097d8:	4620      	mov	r0, r4
 80097da:	4629      	mov	r1, r5
 80097dc:	4b2c      	ldr	r3, [pc, #176]	; (8009890 <atan+0x320>)
 80097de:	f7fe f8d3 	bl	8007988 <__aeabi_dmul>
 80097e2:	2200      	movs	r2, #0
 80097e4:	4b27      	ldr	r3, [pc, #156]	; (8009884 <atan+0x314>)
 80097e6:	f7fd fe0b 	bl	8007400 <__adddf3>
 80097ea:	4602      	mov	r2, r0
 80097ec:	460b      	mov	r3, r1
 80097ee:	4630      	mov	r0, r6
 80097f0:	4639      	mov	r1, r7
 80097f2:	f7fe f9f3 	bl	8007bdc <__aeabi_ddiv>
 80097f6:	f04f 0c02 	mov.w	ip, #2
 80097fa:	4604      	mov	r4, r0
 80097fc:	460d      	mov	r5, r1
 80097fe:	e6dc      	b.n	80095ba <atan+0x4a>
 8009800:	54442d18 	.word	0x54442d18
 8009804:	3ff921fb 	.word	0x3ff921fb
 8009808:	e322da11 	.word	0xe322da11
 800980c:	3f90ad3a 	.word	0x3f90ad3a
 8009810:	24760deb 	.word	0x24760deb
 8009814:	3fa97b4b 	.word	0x3fa97b4b
 8009818:	a0d03d51 	.word	0xa0d03d51
 800981c:	3fb10d66 	.word	0x3fb10d66
 8009820:	c54c206e 	.word	0xc54c206e
 8009824:	3fb745cd 	.word	0x3fb745cd
 8009828:	920083ff 	.word	0x920083ff
 800982c:	3fc24924 	.word	0x3fc24924
 8009830:	5555550d 	.word	0x5555550d
 8009834:	3fd55555 	.word	0x3fd55555
 8009838:	2c6a6c2f 	.word	0x2c6a6c2f
 800983c:	bfa2b444 	.word	0xbfa2b444
 8009840:	52defd9a 	.word	0x52defd9a
 8009844:	3fadde2d 	.word	0x3fadde2d
 8009848:	af749a6d 	.word	0xaf749a6d
 800984c:	3fb3b0f2 	.word	0x3fb3b0f2
 8009850:	fe231671 	.word	0xfe231671
 8009854:	3fbc71c6 	.word	0x3fbc71c6
 8009858:	9998ebc4 	.word	0x9998ebc4
 800985c:	3fc99999 	.word	0x3fc99999
 8009860:	8800759c 	.word	0x8800759c
 8009864:	7e37e43c 	.word	0x7e37e43c
 8009868:	54442d18 	.word	0x54442d18
 800986c:	bff921fb 	.word	0xbff921fb
 8009870:	440fffff 	.word	0x440fffff
 8009874:	7ff00000 	.word	0x7ff00000
 8009878:	3fdbffff 	.word	0x3fdbffff
 800987c:	0800a158 	.word	0x0800a158
 8009880:	0800a138 	.word	0x0800a138
 8009884:	3ff00000 	.word	0x3ff00000
 8009888:	3ff2ffff 	.word	0x3ff2ffff
 800988c:	40037fff 	.word	0x40037fff
 8009890:	3ff80000 	.word	0x3ff80000
 8009894:	462b      	mov	r3, r5
 8009896:	ee10 2a10 	vmov	r2, s0
 800989a:	2000      	movs	r0, #0
 800989c:	490f      	ldr	r1, [pc, #60]	; (80098dc <atan+0x36c>)
 800989e:	f7fe f99d 	bl	8007bdc <__aeabi_ddiv>
 80098a2:	f04f 0c03 	mov.w	ip, #3
 80098a6:	4604      	mov	r4, r0
 80098a8:	460d      	mov	r5, r1
 80098aa:	e686      	b.n	80095ba <atan+0x4a>
 80098ac:	2200      	movs	r2, #0
 80098ae:	4b0c      	ldr	r3, [pc, #48]	; (80098e0 <atan+0x370>)
 80098b0:	f7fd fda4 	bl	80073fc <__aeabi_dsub>
 80098b4:	2200      	movs	r2, #0
 80098b6:	4606      	mov	r6, r0
 80098b8:	460f      	mov	r7, r1
 80098ba:	4620      	mov	r0, r4
 80098bc:	4629      	mov	r1, r5
 80098be:	4b08      	ldr	r3, [pc, #32]	; (80098e0 <atan+0x370>)
 80098c0:	f7fd fd9e 	bl	8007400 <__adddf3>
 80098c4:	4602      	mov	r2, r0
 80098c6:	460b      	mov	r3, r1
 80098c8:	4630      	mov	r0, r6
 80098ca:	4639      	mov	r1, r7
 80098cc:	f7fe f986 	bl	8007bdc <__aeabi_ddiv>
 80098d0:	f04f 0c01 	mov.w	ip, #1
 80098d4:	4604      	mov	r4, r0
 80098d6:	460d      	mov	r5, r1
 80098d8:	e66f      	b.n	80095ba <atan+0x4a>
 80098da:	bf00      	nop
 80098dc:	bff00000 	.word	0xbff00000
 80098e0:	3ff00000 	.word	0x3ff00000
 80098e4:	f3af 8000 	nop.w

080098e8 <fabs>:
 80098e8:	ec51 0b10 	vmov	r0, r1, d0
 80098ec:	ec53 2b10 	vmov	r2, r3, d0
 80098f0:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
 80098f4:	ec43 2b10 	vmov	d0, r2, r3
 80098f8:	4770      	bx	lr
 80098fa:	bf00      	nop

080098fc <__fpclassifyd>:
 80098fc:	ec53 2b10 	vmov	r2, r3, d0
 8009900:	f033 4100 	bics.w	r1, r3, #2147483648	; 0x80000000
 8009904:	b410      	push	{r4}
 8009906:	d008      	beq.n	800991a <__fpclassifyd+0x1e>
 8009908:	480f      	ldr	r0, [pc, #60]	; (8009948 <__fpclassifyd+0x4c>)
 800990a:	f5a1 1480 	sub.w	r4, r1, #1048576	; 0x100000
 800990e:	4284      	cmp	r4, r0
 8009910:	d80a      	bhi.n	8009928 <__fpclassifyd+0x2c>
 8009912:	2004      	movs	r0, #4
 8009914:	f85d 4b04 	ldr.w	r4, [sp], #4
 8009918:	4770      	bx	lr
 800991a:	2a00      	cmp	r2, #0
 800991c:	bf0c      	ite	eq
 800991e:	2002      	moveq	r0, #2
 8009920:	2003      	movne	r0, #3
 8009922:	f85d 4b04 	ldr.w	r4, [sp], #4
 8009926:	4770      	bx	lr
 8009928:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 800992c:	d201      	bcs.n	8009932 <__fpclassifyd+0x36>
 800992e:	2003      	movs	r0, #3
 8009930:	e7f7      	b.n	8009922 <__fpclassifyd+0x26>
 8009932:	4806      	ldr	r0, [pc, #24]	; (800994c <__fpclassifyd+0x50>)
 8009934:	4281      	cmp	r1, r0
 8009936:	d001      	beq.n	800993c <__fpclassifyd+0x40>
 8009938:	2000      	movs	r0, #0
 800993a:	e7f2      	b.n	8009922 <__fpclassifyd+0x26>
 800993c:	f1d2 0001 	rsbs	r0, r2, #1
 8009940:	bf38      	it	cc
 8009942:	2000      	movcc	r0, #0
 8009944:	e7ed      	b.n	8009922 <__fpclassifyd+0x26>
 8009946:	bf00      	nop
 8009948:	7fdfffff 	.word	0x7fdfffff
 800994c:	7ff00000 	.word	0x7ff00000

08009950 <matherr>:
 8009950:	2000      	movs	r0, #0
 8009952:	4770      	bx	lr
 8009954:	0000      	movs	r0, r0
	...

08009958 <nan>:
 8009958:	ed9f 0b01 	vldr	d0, [pc, #4]	; 8009960 <nan+0x8>
 800995c:	4770      	bx	lr
 800995e:	bf00      	nop
 8009960:	00000000 	.word	0x00000000
 8009964:	7ff80000 	.word	0x7ff80000

08009968 <atanf>:
 8009968:	b538      	push	{r3, r4, r5, lr}
 800996a:	ee10 5a10 	vmov	r5, s0
 800996e:	f025 4400 	bic.w	r4, r5, #2147483648	; 0x80000000
 8009972:	f1b4 4fa1 	cmp.w	r4, #1350565888	; 0x50800000
 8009976:	eef0 7a40 	vmov.f32	s15, s0
 800997a:	db0b      	blt.n	8009994 <atanf+0x2c>
 800997c:	f1b4 4fff 	cmp.w	r4, #2139095040	; 0x7f800000
 8009980:	dc56      	bgt.n	8009a30 <atanf+0xc8>
 8009982:	eddf 7a52 	vldr	s15, [pc, #328]	; 8009acc <atanf+0x164>
 8009986:	ed9f 0a52 	vldr	s0, [pc, #328]	; 8009ad0 <atanf+0x168>
 800998a:	2d00      	cmp	r5, #0
 800998c:	bfc8      	it	gt
 800998e:	eeb0 0a67 	vmovgt.f32	s0, s15
 8009992:	bd38      	pop	{r3, r4, r5, pc}
 8009994:	4b4f      	ldr	r3, [pc, #316]	; (8009ad4 <atanf+0x16c>)
 8009996:	429c      	cmp	r4, r3
 8009998:	dc59      	bgt.n	8009a4e <atanf+0xe6>
 800999a:	f1b4 5f44 	cmp.w	r4, #822083584	; 0x31000000
 800999e:	db4a      	blt.n	8009a36 <atanf+0xce>
 80099a0:	f04f 33ff 	mov.w	r3, #4294967295
 80099a4:	ee67 6aa7 	vmul.f32	s13, s15, s15
 80099a8:	ed9f 1a4b 	vldr	s2, [pc, #300]	; 8009ad8 <atanf+0x170>
 80099ac:	ed9f 2a4b 	vldr	s4, [pc, #300]	; 8009adc <atanf+0x174>
 80099b0:	ed9f 3a4b 	vldr	s6, [pc, #300]	; 8009ae0 <atanf+0x178>
 80099b4:	eddf 1a4b 	vldr	s3, [pc, #300]	; 8009ae4 <atanf+0x17c>
 80099b8:	eddf 2a4b 	vldr	s5, [pc, #300]	; 8009ae8 <atanf+0x180>
 80099bc:	ed9f 4a4b 	vldr	s8, [pc, #300]	; 8009aec <atanf+0x184>
 80099c0:	eddf 3a4b 	vldr	s7, [pc, #300]	; 8009af0 <atanf+0x188>
 80099c4:	ed9f 5a4b 	vldr	s10, [pc, #300]	; 8009af4 <atanf+0x18c>
 80099c8:	eddf 4a4b 	vldr	s9, [pc, #300]	; 8009af8 <atanf+0x190>
 80099cc:	ed9f 6a4b 	vldr	s12, [pc, #300]	; 8009afc <atanf+0x194>
 80099d0:	eddf 5a4b 	vldr	s11, [pc, #300]	; 8009b00 <atanf+0x198>
 80099d4:	ee26 7aa6 	vmul.f32	s14, s13, s13
 80099d8:	1c5a      	adds	r2, r3, #1
 80099da:	eea7 2a01 	vfma.f32	s4, s14, s2
 80099de:	eee7 2a21 	vfma.f32	s5, s14, s3
 80099e2:	eea2 3a07 	vfma.f32	s6, s4, s14
 80099e6:	eee2 3a87 	vfma.f32	s7, s5, s14
 80099ea:	eea3 4a07 	vfma.f32	s8, s6, s14
 80099ee:	eee3 4a87 	vfma.f32	s9, s7, s14
 80099f2:	eea4 5a07 	vfma.f32	s10, s8, s14
 80099f6:	eee4 5a87 	vfma.f32	s11, s9, s14
 80099fa:	eea5 6a07 	vfma.f32	s12, s10, s14
 80099fe:	ee25 7a87 	vmul.f32	s14, s11, s14
 8009a02:	ee66 6a26 	vmul.f32	s13, s12, s13
 8009a06:	d03a      	beq.n	8009a7e <atanf+0x116>
 8009a08:	493e      	ldr	r1, [pc, #248]	; (8009b04 <atanf+0x19c>)
 8009a0a:	4a3f      	ldr	r2, [pc, #252]	; (8009b08 <atanf+0x1a0>)
 8009a0c:	009b      	lsls	r3, r3, #2
 8009a0e:	4419      	add	r1, r3
 8009a10:	ee36 7a87 	vadd.f32	s14, s13, s14
 8009a14:	ed91 5a00 	vldr	s10, [r1]
 8009a18:	ee97 5a27 	vfnms.f32	s10, s14, s15
 8009a1c:	4413      	add	r3, r2
 8009a1e:	2d00      	cmp	r5, #0
 8009a20:	ed93 0a00 	vldr	s0, [r3]
 8009a24:	ee75 7a67 	vsub.f32	s15, s10, s15
 8009a28:	ee30 0a67 	vsub.f32	s0, s0, s15
 8009a2c:	db24      	blt.n	8009a78 <atanf+0x110>
 8009a2e:	bd38      	pop	{r3, r4, r5, pc}
 8009a30:	ee30 0a00 	vadd.f32	s0, s0, s0
 8009a34:	bd38      	pop	{r3, r4, r5, pc}
 8009a36:	eddf 6a35 	vldr	s13, [pc, #212]	; 8009b0c <atanf+0x1a4>
 8009a3a:	ee70 6a26 	vadd.f32	s13, s0, s13
 8009a3e:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 8009a42:	eef4 6ac7 	vcmpe.f32	s13, s14
 8009a46:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009a4a:	dda9      	ble.n	80099a0 <atanf+0x38>
 8009a4c:	bd38      	pop	{r3, r4, r5, pc}
 8009a4e:	f000 f863 	bl	8009b18 <fabsf>
 8009a52:	4b2f      	ldr	r3, [pc, #188]	; (8009b10 <atanf+0x1a8>)
 8009a54:	429c      	cmp	r4, r3
 8009a56:	dc19      	bgt.n	8009a8c <atanf+0x124>
 8009a58:	f5a3 03d0 	sub.w	r3, r3, #6815744	; 0x680000
 8009a5c:	429c      	cmp	r4, r3
 8009a5e:	dc2a      	bgt.n	8009ab6 <atanf+0x14e>
 8009a60:	eef0 7a00 	vmov.f32	s15, #0
 8009a64:	eebf 7a00 	vmov.f32	s14, #240	; 0xf0
 8009a68:	eea0 7a27 	vfma.f32	s14, s0, s15
 8009a6c:	2300      	movs	r3, #0
 8009a6e:	ee70 7a27 	vadd.f32	s15, s0, s15
 8009a72:	eec7 7a27 	vdiv.f32	s15, s14, s15
 8009a76:	e795      	b.n	80099a4 <atanf+0x3c>
 8009a78:	eeb1 0a40 	vneg.f32	s0, s0
 8009a7c:	bd38      	pop	{r3, r4, r5, pc}
 8009a7e:	ee36 7a87 	vadd.f32	s14, s13, s14
 8009a82:	eeb0 0a67 	vmov.f32	s0, s15
 8009a86:	eea7 0a67 	vfms.f32	s0, s14, s15
 8009a8a:	bd38      	pop	{r3, r4, r5, pc}
 8009a8c:	4b21      	ldr	r3, [pc, #132]	; (8009b14 <atanf+0x1ac>)
 8009a8e:	429c      	cmp	r4, r3
 8009a90:	dc0b      	bgt.n	8009aaa <atanf+0x142>
 8009a92:	eef7 7a08 	vmov.f32	s15, #120	; 0x78
 8009a96:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 8009a9a:	eea0 7a27 	vfma.f32	s14, s0, s15
 8009a9e:	2302      	movs	r3, #2
 8009aa0:	ee70 7a67 	vsub.f32	s15, s0, s15
 8009aa4:	eec7 7a87 	vdiv.f32	s15, s15, s14
 8009aa8:	e77c      	b.n	80099a4 <atanf+0x3c>
 8009aaa:	eeff 7a00 	vmov.f32	s15, #240	; 0xf0
 8009aae:	eec7 7a80 	vdiv.f32	s15, s15, s0
 8009ab2:	2303      	movs	r3, #3
 8009ab4:	e776      	b.n	80099a4 <atanf+0x3c>
 8009ab6:	eeb7 7a00 	vmov.f32	s14, #112	; 0x70
 8009aba:	ee70 7a47 	vsub.f32	s15, s0, s14
 8009abe:	ee30 7a07 	vadd.f32	s14, s0, s14
 8009ac2:	2301      	movs	r3, #1
 8009ac4:	eec7 7a87 	vdiv.f32	s15, s15, s14
 8009ac8:	e76c      	b.n	80099a4 <atanf+0x3c>
 8009aca:	bf00      	nop
 8009acc:	3fc90fdb 	.word	0x3fc90fdb
 8009ad0:	bfc90fdb 	.word	0xbfc90fdb
 8009ad4:	3edfffff 	.word	0x3edfffff
 8009ad8:	3c8569d7 	.word	0x3c8569d7
 8009adc:	3d4bda59 	.word	0x3d4bda59
 8009ae0:	3d886b35 	.word	0x3d886b35
 8009ae4:	bd15a221 	.word	0xbd15a221
 8009ae8:	bd6ef16b 	.word	0xbd6ef16b
 8009aec:	3dba2e6e 	.word	0x3dba2e6e
 8009af0:	bd9d8795 	.word	0xbd9d8795
 8009af4:	3e124925 	.word	0x3e124925
 8009af8:	bde38e38 	.word	0xbde38e38
 8009afc:	3eaaaaab 	.word	0x3eaaaaab
 8009b00:	be4ccccd 	.word	0xbe4ccccd
 8009b04:	0800a178 	.word	0x0800a178
 8009b08:	0800a188 	.word	0x0800a188
 8009b0c:	7149f2ca 	.word	0x7149f2ca
 8009b10:	3f97ffff 	.word	0x3f97ffff
 8009b14:	401bffff 	.word	0x401bffff

08009b18 <fabsf>:
 8009b18:	ee10 2a10 	vmov	r2, s0
 8009b1c:	f022 4300 	bic.w	r3, r2, #2147483648	; 0x80000000
 8009b20:	ee00 3a10 	vmov	s0, r3
 8009b24:	4770      	bx	lr
 8009b26:	bf00      	nop

08009b28 <floorf>:
 8009b28:	ee10 3a10 	vmov	r3, s0
 8009b2c:	f023 4000 	bic.w	r0, r3, #2147483648	; 0x80000000
 8009b30:	0dc1      	lsrs	r1, r0, #23
 8009b32:	397f      	subs	r1, #127	; 0x7f
 8009b34:	2916      	cmp	r1, #22
 8009b36:	b410      	push	{r4}
 8009b38:	dc18      	bgt.n	8009b6c <floorf+0x44>
 8009b3a:	2900      	cmp	r1, #0
 8009b3c:	461c      	mov	r4, r3
 8009b3e:	db22      	blt.n	8009b86 <floorf+0x5e>
 8009b40:	481e      	ldr	r0, [pc, #120]	; (8009bbc <floorf+0x94>)
 8009b42:	4108      	asrs	r0, r1
 8009b44:	4218      	tst	r0, r3
 8009b46:	d014      	beq.n	8009b72 <floorf+0x4a>
 8009b48:	eddf 7a1d 	vldr	s15, [pc, #116]	; 8009bc0 <floorf+0x98>
 8009b4c:	ee70 7a27 	vadd.f32	s15, s0, s15
 8009b50:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8009b54:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009b58:	dd0b      	ble.n	8009b72 <floorf+0x4a>
 8009b5a:	2b00      	cmp	r3, #0
 8009b5c:	db21      	blt.n	8009ba2 <floorf+0x7a>
 8009b5e:	ea24 0000 	bic.w	r0, r4, r0
 8009b62:	ee00 0a10 	vmov	s0, r0
 8009b66:	f85d 4b04 	ldr.w	r4, [sp], #4
 8009b6a:	4770      	bx	lr
 8009b6c:	f1b0 4fff 	cmp.w	r0, #2139095040	; 0x7f800000
 8009b70:	d204      	bcs.n	8009b7c <floorf+0x54>
 8009b72:	ee00 3a10 	vmov	s0, r3
 8009b76:	f85d 4b04 	ldr.w	r4, [sp], #4
 8009b7a:	4770      	bx	lr
 8009b7c:	ee30 0a00 	vadd.f32	s0, s0, s0
 8009b80:	f85d 4b04 	ldr.w	r4, [sp], #4
 8009b84:	4770      	bx	lr
 8009b86:	eddf 7a0e 	vldr	s15, [pc, #56]	; 8009bc0 <floorf+0x98>
 8009b8a:	ee70 7a27 	vadd.f32	s15, s0, s15
 8009b8e:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8009b92:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8009b96:	ddec      	ble.n	8009b72 <floorf+0x4a>
 8009b98:	2b00      	cmp	r3, #0
 8009b9a:	db08      	blt.n	8009bae <floorf+0x86>
 8009b9c:	ed9f 0a09 	vldr	s0, [pc, #36]	; 8009bc4 <floorf+0x9c>
 8009ba0:	e7e9      	b.n	8009b76 <floorf+0x4e>
 8009ba2:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
 8009ba6:	fa43 f101 	asr.w	r1, r3, r1
 8009baa:	440c      	add	r4, r1
 8009bac:	e7d7      	b.n	8009b5e <floorf+0x36>
 8009bae:	2800      	cmp	r0, #0
 8009bb0:	eebf 0a00 	vmov.f32	s0, #240	; 0xf0
 8009bb4:	bf08      	it	eq
 8009bb6:	ee00 3a10 	vmoveq	s0, r3
 8009bba:	e7dc      	b.n	8009b76 <floorf+0x4e>
 8009bbc:	007fffff 	.word	0x007fffff
 8009bc0:	7149f2ca 	.word	0x7149f2ca
 8009bc4:	00000000 	.word	0x00000000

08009bc8 <__fpclassifyf>:
 8009bc8:	ee10 3a10 	vmov	r3, s0
 8009bcc:	f033 4000 	bics.w	r0, r3, #2147483648	; 0x80000000
 8009bd0:	d101      	bne.n	8009bd6 <__fpclassifyf+0xe>
 8009bd2:	2002      	movs	r0, #2
 8009bd4:	4770      	bx	lr
 8009bd6:	f5a0 0300 	sub.w	r3, r0, #8388608	; 0x800000
 8009bda:	f1b3 4ffe 	cmp.w	r3, #2130706432	; 0x7f000000
 8009bde:	d201      	bcs.n	8009be4 <__fpclassifyf+0x1c>
 8009be0:	2004      	movs	r0, #4
 8009be2:	4770      	bx	lr
 8009be4:	4b05      	ldr	r3, [pc, #20]	; (8009bfc <__fpclassifyf+0x34>)
 8009be6:	1e42      	subs	r2, r0, #1
 8009be8:	429a      	cmp	r2, r3
 8009bea:	d801      	bhi.n	8009bf0 <__fpclassifyf+0x28>
 8009bec:	2003      	movs	r0, #3
 8009bee:	4770      	bx	lr
 8009bf0:	f1b0 43ff 	subs.w	r3, r0, #2139095040	; 0x7f800000
 8009bf4:	4258      	negs	r0, r3
 8009bf6:	4158      	adcs	r0, r3
 8009bf8:	4770      	bx	lr
 8009bfa:	bf00      	nop
 8009bfc:	007ffffe 	.word	0x007ffffe

08009c00 <scalbnf>:
 8009c00:	b508      	push	{r3, lr}
 8009c02:	ee10 3a10 	vmov	r3, s0
 8009c06:	f033 4100 	bics.w	r1, r3, #2147483648	; 0x80000000
 8009c0a:	ed2d 8b02 	vpush	{d8}
 8009c0e:	ee10 2a10 	vmov	r2, s0
 8009c12:	d011      	beq.n	8009c38 <scalbnf+0x38>
 8009c14:	f1b1 4fff 	cmp.w	r1, #2139095040	; 0x7f800000
 8009c18:	d211      	bcs.n	8009c3e <scalbnf+0x3e>
 8009c1a:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
 8009c1e:	d313      	bcc.n	8009c48 <scalbnf+0x48>
 8009c20:	0dc9      	lsrs	r1, r1, #23
 8009c22:	4401      	add	r1, r0
 8009c24:	29fe      	cmp	r1, #254	; 0xfe
 8009c26:	dc30      	bgt.n	8009c8a <scalbnf+0x8a>
 8009c28:	2900      	cmp	r1, #0
 8009c2a:	dd1c      	ble.n	8009c66 <scalbnf+0x66>
 8009c2c:	f022 42ff 	bic.w	r2, r2, #2139095040	; 0x7f800000
 8009c30:	ea42 52c1 	orr.w	r2, r2, r1, lsl #23
 8009c34:	ee00 2a10 	vmov	s0, r2
 8009c38:	ecbd 8b02 	vpop	{d8}
 8009c3c:	bd08      	pop	{r3, pc}
 8009c3e:	ecbd 8b02 	vpop	{d8}
 8009c42:	ee30 0a00 	vadd.f32	s0, s0, s0
 8009c46:	bd08      	pop	{r3, pc}
 8009c48:	eddf 7a1e 	vldr	s15, [pc, #120]	; 8009cc4 <scalbnf+0xc4>
 8009c4c:	4a1e      	ldr	r2, [pc, #120]	; (8009cc8 <scalbnf+0xc8>)
 8009c4e:	ee20 7a27 	vmul.f32	s14, s0, s15
 8009c52:	4290      	cmp	r0, r2
 8009c54:	ee17 3a10 	vmov	r3, s14
 8009c58:	db22      	blt.n	8009ca0 <scalbnf+0xa0>
 8009c5a:	f3c3 51c7 	ubfx	r1, r3, #23, #8
 8009c5e:	ee17 2a10 	vmov	r2, s14
 8009c62:	3919      	subs	r1, #25
 8009c64:	e7dd      	b.n	8009c22 <scalbnf+0x22>
 8009c66:	f111 0f16 	cmn.w	r1, #22
 8009c6a:	da1e      	bge.n	8009caa <scalbnf+0xaa>
 8009c6c:	f24c 3250 	movw	r2, #50000	; 0xc350
 8009c70:	4290      	cmp	r0, r2
 8009c72:	dc0a      	bgt.n	8009c8a <scalbnf+0x8a>
 8009c74:	ed9f 8a15 	vldr	s16, [pc, #84]	; 8009ccc <scalbnf+0xcc>
 8009c78:	ee00 3a90 	vmov	s1, r3
 8009c7c:	eeb0 0a48 	vmov.f32	s0, s16
 8009c80:	f000 f82a 	bl	8009cd8 <copysignf>
 8009c84:	ee20 0a08 	vmul.f32	s0, s0, s16
 8009c88:	e7d6      	b.n	8009c38 <scalbnf+0x38>
 8009c8a:	ed9f 8a11 	vldr	s16, [pc, #68]	; 8009cd0 <scalbnf+0xd0>
 8009c8e:	ee00 3a90 	vmov	s1, r3
 8009c92:	eeb0 0a48 	vmov.f32	s0, s16
 8009c96:	f000 f81f 	bl	8009cd8 <copysignf>
 8009c9a:	ee20 0a08 	vmul.f32	s0, s0, s16
 8009c9e:	e7cb      	b.n	8009c38 <scalbnf+0x38>
 8009ca0:	ed9f 0a0a 	vldr	s0, [pc, #40]	; 8009ccc <scalbnf+0xcc>
 8009ca4:	ee27 0a00 	vmul.f32	s0, s14, s0
 8009ca8:	e7c6      	b.n	8009c38 <scalbnf+0x38>
 8009caa:	3119      	adds	r1, #25
 8009cac:	f022 42ff 	bic.w	r2, r2, #2139095040	; 0x7f800000
 8009cb0:	ea42 52c1 	orr.w	r2, r2, r1, lsl #23
 8009cb4:	eddf 7a07 	vldr	s15, [pc, #28]	; 8009cd4 <scalbnf+0xd4>
 8009cb8:	ee07 2a10 	vmov	s14, r2
 8009cbc:	ee27 0a27 	vmul.f32	s0, s14, s15
 8009cc0:	e7ba      	b.n	8009c38 <scalbnf+0x38>
 8009cc2:	bf00      	nop
 8009cc4:	4c000000 	.word	0x4c000000
 8009cc8:	ffff3cb0 	.word	0xffff3cb0
 8009ccc:	0da24260 	.word	0x0da24260
 8009cd0:	7149f2ca 	.word	0x7149f2ca
 8009cd4:	33000000 	.word	0x33000000

08009cd8 <copysignf>:
 8009cd8:	ee10 1a10 	vmov	r1, s0
 8009cdc:	f021 4200 	bic.w	r2, r1, #2147483648	; 0x80000000
 8009ce0:	ee10 1a90 	vmov	r1, s1
 8009ce4:	f001 4300 	and.w	r3, r1, #2147483648	; 0x80000000
 8009ce8:	4313      	orrs	r3, r2
 8009cea:	ee00 3a10 	vmov	s0, r3
 8009cee:	4770      	bx	lr

08009cf0 <__errno>:
 8009cf0:	4b01      	ldr	r3, [pc, #4]	; (8009cf8 <__errno+0x8>)
 8009cf2:	6818      	ldr	r0, [r3, #0]
 8009cf4:	4770      	bx	lr
 8009cf6:	bf00      	nop
 8009cf8:	20000478 	.word	0x20000478

08009cfc <ucExpectedStackBytes.5238>:
 8009cfc:	a5a5a5a5 a5a5a5a5 a5a5a5a5 a5a5a5a5     ................
 8009d0c:	a5a5a5a5 6f727245 79472072 54206f72     ....Error Gyro T
 8009d1c:	21747365 49000d0a 475f554d 006f7279     est!...IMU_Gyro.
 8009d2c:	5f736f50 746e6f43 6e280072 296c6c75     Pos_Contr.(null)
 8009d3c:	4c444900 6d540045 76532072 00000063     .IDLE.Tmr Svc...
 8009d4c:	74727173 00000000 6e697361 00000066     sqrt....asinf...
 8009d5c:	74727173 00000066                       sqrtf...

08009d64 <npio2_hw>:
 8009d64:	3fc90f00 40490f00 4096cb00 40c90f00     ...?..I@...@...@
 8009d74:	40fb5300 4116cb00 412fed00 41490f00     .S.@...A../A..IA
 8009d84:	41623100 417b5300 418a3a00 4196cb00     .1bA.S{A.:.A...A
 8009d94:	41a35c00 41afed00 41bc7e00 41c90f00     .\.A...A.~.A...A
 8009da4:	41d5a000 41e23100 41eec200 41fb5300     ...A.1.A...A.S.A
 8009db4:	4203f200 420a3a00 42108300 4216cb00     ...B.:.B...B...B
 8009dc4:	421d1400 42235c00 4229a500 422fed00     ...B.\#B..)B../B
 8009dd4:	42363600 423c7e00 4242c700 42490f00     .66B.~<B..BB..IB

08009de4 <two_over_pi>:
 8009de4:	000000a2 000000f9 00000083 0000006e     ............n...
 8009df4:	0000004e 00000044 00000015 00000029     N...D.......)...
 8009e04:	000000fc 00000027 00000057 000000d1     ....'...W.......
 8009e14:	000000f5 00000034 000000dd 000000c0     ....4...........
 8009e24:	000000db 00000062 00000095 00000099     ....b...........
 8009e34:	0000003c 00000043 00000090 00000041     <...C.......A...
 8009e44:	000000fe 00000051 00000063 000000ab     ....Q...c.......
 8009e54:	000000de 000000bb 000000c5 00000061     ............a...
 8009e64:	000000b7 00000024 0000006e 0000003a     ....$...n...:...
 8009e74:	00000042 0000004d 000000d2 000000e0     B...M...........
 8009e84:	00000006 00000049 0000002e 000000ea     ....I...........
 8009e94:	00000009 000000d1 00000092 0000001c     ................
 8009ea4:	000000fe 0000001d 000000eb 0000001c     ................
 8009eb4:	000000b1 00000029 000000a7 0000003e     ....).......>...
 8009ec4:	000000e8 00000082 00000035 000000f5     ........5.......
 8009ed4:	0000002e 000000bb 00000044 00000084     ........D.......
 8009ee4:	000000e9 0000009c 00000070 00000026     ........p...&...
 8009ef4:	000000b4 0000005f 0000007e 00000041     ...._...~...A...
 8009f04:	00000039 00000091 000000d6 00000039     9...........9...
 8009f14:	00000083 00000053 00000039 000000f4     ....S...9.......
 8009f24:	0000009c 00000084 0000005f 0000008b     ........_.......
 8009f34:	000000bd 000000f9 00000028 0000003b     ........(...;...
 8009f44:	0000001f 000000f8 00000097 000000ff     ................
 8009f54:	000000de 00000005 00000098 0000000f     ................
 8009f64:	000000ef 0000002f 00000011 0000008b     ..../...........
 8009f74:	0000005a 0000000a 0000006d 0000001f     Z.......m.......
 8009f84:	0000006d 00000036 0000007e 000000cf     m...6...~.......
 8009f94:	00000027 000000cb 00000009 000000b7     '...............
 8009fa4:	0000004f 00000046 0000003f 00000066     O...F...?...f...
 8009fb4:	0000009e 0000005f 000000ea 0000002d     ...._.......-...
 8009fc4:	00000075 00000027 000000ba 000000c7     u...'...........
 8009fd4:	000000eb 000000e5 000000f1 0000007b     ............{...
 8009fe4:	0000003d 00000007 00000039 000000f7     =.......9.......
 8009ff4:	0000008a 00000052 00000092 000000ea     ....R...........
 800a004:	0000006b 000000fb 0000005f 000000b1     k......._.......
 800a014:	0000001f 0000008d 0000005d 00000008     ........].......
 800a024:	00000056 00000003 00000030 00000046     V.......0...F...
 800a034:	000000fc 0000007b 0000006b 000000ab     ....{...k.......
 800a044:	000000f0 000000cf 000000bc 00000020     ............ ...
 800a054:	0000009a 000000f4 00000036 0000001d     ........6.......
 800a064:	000000a9 000000e3 00000091 00000061     ............a...
 800a074:	0000005e 000000e6 0000001b 00000008     ^...............
 800a084:	00000065 00000099 00000085 0000005f     e..........._...
 800a094:	00000014 000000a0 00000068 00000040     ........h...@...
 800a0a4:	0000008d 000000ff 000000d8 00000080     ................
 800a0b4:	0000004d 00000073 00000027 00000031     M...s...'...1...
 800a0c4:	00000006 00000006 00000015 00000056     ............V...
 800a0d4:	000000ca 00000073 000000a8 000000c9     ....s...........
 800a0e4:	00000060 000000e2 0000007b 000000c0     `.......{.......
 800a0f4:	0000008c 0000006b                       ....k...

0800a0fc <init_jk>:
 800a0fc:	00000004 00000007 00000009              ............

0800a108 <PIo2>:
 800a108:	3fc90000 39f00000 37da0000 33a20000     ...?...9...7...3
 800a118:	2e840000 2b500000 27c20000 22d00000     ......P+...'..."
 800a128:	1fc40000 1bc60000 17440000 00000000     ..........D.....

0800a138 <atanlo>:
 800a138:	222f65e2 3c7a2b7f 33145c07 3c81a626     .e/".+z<.\.3&..<
 800a148:	7af0cbbd 3c700788 33145c07 3c91a626     ...z..p<.\.3&..<

0800a158 <atanhi>:
 800a158:	0561bb4f 3fddac67 54442d18 3fe921fb     O.a.g..?.-DT.!.?
 800a168:	d281f69b 3fef730b 54442d18 3ff921fb     .....s.?.-DT.!.?

0800a178 <atanlo>:
 800a178:	31ac3769 33222168 33140fb4 33a22168     i7.1h!"3...3h!.3

0800a188 <atanhi>:
 800a188:	3eed6338 3f490fda 3f7b985e 3fc90fda     8c.>..I?^.{?...?
 800a198:	00000043                                C...
