
STM32F3_Vertibot.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000188  08000000  08000000  00008000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000a8a4  08000188  08000188  00008188  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .data         00000140  20000000  0800aa2c  00018000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          00002f2c  20000140  20000140  00018140  2**2
                  ALLOC
  4 ._user_heap_stack 00000200  2000306c  2000306c  00018140  2**0
                  ALLOC
  5 .ARM.attributes 00000031  00000000  00000000  00018140  2**0
                  CONTENTS, READONLY
  6 .debug_info   00016ba5  00000000  00000000  00018171  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000042eb  00000000  00000000  0002ed16  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_aranges 000004a8  00000000  00000000  00033008  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_macro  00013058  00000000  00000000  000334b0  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   0000c788  00000000  00000000  00046508  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0005cbcf  00000000  00000000  00052c90  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .comment      00000030  00000000  00000000  000af85f  2**0
                  CONTENTS, READONLY
 13 .debug_loc    0000b113  00000000  00000000  000af88f  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00003454  00000000  00000000  000ba9a4  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 00000280  00000000  00000000  000bddf8  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08000188 <IMU_init>:
void IMU_init(struct IMU_values *IMU, float dt)
{
	IMU->dt = dt;	

	IMU->dcm_xe_line[0] = 1;
	IMU->dcm_xe_line[1] = 0;
 8000188:	2300      	movs	r3, #0
//! Initialization of the main dcm-variables used for the Gyro input
void IMU_init(struct IMU_values *IMU, float dt)
{
	IMU->dt = dt;	

	IMU->dcm_xe_line[0] = 1;
 800018a:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000


//! Initialization of the main dcm-variables used for the Gyro input
void IMU_init(struct IMU_values *IMU, float dt)
{
	IMU->dt = dt;	
 800018e:	6001      	str	r1, [r0, #0]

	IMU->dcm_xe_line[0] = 1;
 8000190:	6042      	str	r2, [r0, #4]
	IMU->dcm_xe_line[1] = 0;
 8000192:	6083      	str	r3, [r0, #8]
	IMU->dcm_xe_line[2] = 0;
 8000194:	60c3      	str	r3, [r0, #12]

	IMU->dcm_ye_line[0] = 0;
 8000196:	6103      	str	r3, [r0, #16]
	IMU->dcm_ye_line[1] = 1;
 8000198:	6142      	str	r2, [r0, #20]
	IMU->dcm_ye_line[2] = 0;
 800019a:	6183      	str	r3, [r0, #24]

	IMU->dcm_ze_line[0] = 0;
 800019c:	61c3      	str	r3, [r0, #28]
	IMU->dcm_ze_line[1] = 0;
 800019e:	6203      	str	r3, [r0, #32]
	IMU->dcm_ze_line[2] = 1;			
 80001a0:	6242      	str	r2, [r0, #36]	; 0x24

	IMU->velocity_vector[0] = 0;
 80001a2:	6283      	str	r3, [r0, #40]	; 0x28
	IMU->velocity_vector[1] = 0;
 80001a4:	62c3      	str	r3, [r0, #44]	; 0x2c
	IMU->velocity_vector[2] = 0;
 80001a6:	6303      	str	r3, [r0, #48]	; 0x30
 80001a8:	4770      	bx	lr

080001aa <IMU_init_drift_correction>:
//! Initialization of the drift-correction variables - this is mainly solved with a PI-Controller
void IMU_init_drift_correction(struct IMU_values *IMU, float kp)
{
	IMU->kp = kp;

	IMU->accel_vector[0] = 0;
 80001aa:	2300      	movs	r3, #0


//! Initialization of the drift-correction variables - this is mainly solved with a PI-Controller
void IMU_init_drift_correction(struct IMU_values *IMU, float kp)
{
	IMU->kp = kp;
 80001ac:	64c1      	str	r1, [r0, #76]	; 0x4c

	IMU->accel_vector[0] = 0;
 80001ae:	6343      	str	r3, [r0, #52]	; 0x34
	IMU->accel_vector[1] = 0;
 80001b0:	6383      	str	r3, [r0, #56]	; 0x38
	IMU->accel_vector[2] = 0;
 80001b2:	63c3      	str	r3, [r0, #60]	; 0x3c

	IMU->mag_vector[0] = 0;
 80001b4:	6403      	str	r3, [r0, #64]	; 0x40
	IMU->mag_vector[1] = 0;
 80001b6:	6443      	str	r3, [r0, #68]	; 0x44
	IMU->mag_vector[2] = 0;
 80001b8:	6483      	str	r3, [r0, #72]	; 0x48

	IMU->kp_vector_ACC[0] = 0;
 80001ba:	6603      	str	r3, [r0, #96]	; 0x60
	IMU->kp_vector_ACC[1] = 0;
 80001bc:	6643      	str	r3, [r0, #100]	; 0x64
	IMU->kp_vector_ACC[2] = 0;
 80001be:	6683      	str	r3, [r0, #104]	; 0x68

	IMU->kp_vector_MAG[0] = 0;
 80001c0:	66c3      	str	r3, [r0, #108]	; 0x6c
	IMU->kp_vector_MAG[1] = 0;
 80001c2:	6703      	str	r3, [r0, #112]	; 0x70
	IMU->kp_vector_MAG[2] = 0;
 80001c4:	6743      	str	r3, [r0, #116]	; 0x74

	IMU->error_rollpitch[0] = 0;
 80001c6:	6503      	str	r3, [r0, #80]	; 0x50
	IMU->error_rollpitch[1] = 0;
 80001c8:	6543      	str	r3, [r0, #84]	; 0x54
	IMU->error_rollpitch[2] = 0;
 80001ca:	6583      	str	r3, [r0, #88]	; 0x58

	IMU->error_yaw = 0;
 80001cc:	65c3      	str	r3, [r0, #92]	; 0x5c
 80001ce:	4770      	bx	lr

080001d0 <IMU_update>:
}


//! Update of the dcm-matrix
void IMU_update(struct IMU_values *IMU)
{
 80001d0:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	float result[3];

	/*dt-factor + addition of omega_vector, which holds the PI-Values*/
	IMU->velocity_vector[0] = (IMU->velocity_vector[0]*IMU->dt) - (IMU->kp_vector_ACC[0]) - (IMU->kp_vector_MAG[0]);
 80001d2:	6805      	ldr	r5, [r0, #0]
}


//! Update of the dcm-matrix
void IMU_update(struct IMU_values *IMU)
{
 80001d4:	4604      	mov	r4, r0
	float result[3];

	/*dt-factor + addition of omega_vector, which holds the PI-Values*/
	IMU->velocity_vector[0] = (IMU->velocity_vector[0]*IMU->dt) - (IMU->kp_vector_ACC[0]) - (IMU->kp_vector_MAG[0]);
 80001d6:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 80001d8:	4628      	mov	r0, r5
 80001da:	f007 fb6b 	bl	80078b4 <__aeabi_fmul>
 80001de:	6e21      	ldr	r1, [r4, #96]	; 0x60
 80001e0:	f007 fa5e 	bl	80076a0 <__aeabi_fsub>
 80001e4:	6ee1      	ldr	r1, [r4, #108]	; 0x6c
 80001e6:	f007 fa5b 	bl	80076a0 <__aeabi_fsub>
	IMU->velocity_vector[1] = (IMU->velocity_vector[1]*IMU->dt) - (IMU->kp_vector_ACC[1]) - (IMU->kp_vector_MAG[1]);
 80001ea:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
void IMU_update(struct IMU_values *IMU)
{
	float result[3];

	/*dt-factor + addition of omega_vector, which holds the PI-Values*/
	IMU->velocity_vector[0] = (IMU->velocity_vector[0]*IMU->dt) - (IMU->kp_vector_ACC[0]) - (IMU->kp_vector_MAG[0]);
 80001ec:	62a0      	str	r0, [r4, #40]	; 0x28
	IMU->velocity_vector[1] = (IMU->velocity_vector[1]*IMU->dt) - (IMU->kp_vector_ACC[1]) - (IMU->kp_vector_MAG[1]);
 80001ee:	4628      	mov	r0, r5
 80001f0:	f007 fb60 	bl	80078b4 <__aeabi_fmul>
 80001f4:	6e61      	ldr	r1, [r4, #100]	; 0x64
 80001f6:	f007 fa53 	bl	80076a0 <__aeabi_fsub>
 80001fa:	6f21      	ldr	r1, [r4, #112]	; 0x70
 80001fc:	f007 fa50 	bl	80076a0 <__aeabi_fsub>
	IMU->velocity_vector[2] = (IMU->velocity_vector[2]*IMU->dt) - (IMU->kp_vector_ACC[2]) - (IMU->kp_vector_MAG[2]);
 8000200:	6b21      	ldr	r1, [r4, #48]	; 0x30
{
	float result[3];

	/*dt-factor + addition of omega_vector, which holds the PI-Values*/
	IMU->velocity_vector[0] = (IMU->velocity_vector[0]*IMU->dt) - (IMU->kp_vector_ACC[0]) - (IMU->kp_vector_MAG[0]);
	IMU->velocity_vector[1] = (IMU->velocity_vector[1]*IMU->dt) - (IMU->kp_vector_ACC[1]) - (IMU->kp_vector_MAG[1]);
 8000202:	62e0      	str	r0, [r4, #44]	; 0x2c
	IMU->velocity_vector[2] = (IMU->velocity_vector[2]*IMU->dt) - (IMU->kp_vector_ACC[2]) - (IMU->kp_vector_MAG[2]);
 8000204:	4628      	mov	r0, r5
 8000206:	f007 fb55 	bl	80078b4 <__aeabi_fmul>
 800020a:	6ea1      	ldr	r1, [r4, #104]	; 0x68
 800020c:	f007 fa48 	bl	80076a0 <__aeabi_fsub>
 8000210:	6f61      	ldr	r1, [r4, #116]	; 0x74
 8000212:	f007 fa45 	bl	80076a0 <__aeabi_fsub>

	/*Update of the first dcm-line (xe)*/
	VectorCrossProduct(result, IMU->dcm_xe_line, IMU->velocity_vector);
 8000216:	1d26      	adds	r6, r4, #4
 8000218:	f104 0528 	add.w	r5, r4, #40	; 0x28
	float result[3];

	/*dt-factor + addition of omega_vector, which holds the PI-Values*/
	IMU->velocity_vector[0] = (IMU->velocity_vector[0]*IMU->dt) - (IMU->kp_vector_ACC[0]) - (IMU->kp_vector_MAG[0]);
	IMU->velocity_vector[1] = (IMU->velocity_vector[1]*IMU->dt) - (IMU->kp_vector_ACC[1]) - (IMU->kp_vector_MAG[1]);
	IMU->velocity_vector[2] = (IMU->velocity_vector[2]*IMU->dt) - (IMU->kp_vector_ACC[2]) - (IMU->kp_vector_MAG[2]);
 800021c:	6320      	str	r0, [r4, #48]	; 0x30

	/*Update of the first dcm-line (xe)*/
	VectorCrossProduct(result, IMU->dcm_xe_line, IMU->velocity_vector);
 800021e:	4631      	mov	r1, r6
 8000220:	a801      	add	r0, sp, #4
 8000222:	462a      	mov	r2, r5
 8000224:	f001 fb3a 	bl	800189c <VectorCrossProduct>
	VectorAdd(IMU->dcm_xe_line, IMU->dcm_xe_line, result);
 8000228:	4630      	mov	r0, r6
 800022a:	4631      	mov	r1, r6
 800022c:	aa01      	add	r2, sp, #4

	/*Update of the second dcm-line(ye)*/
	VectorCrossProduct(result, IMU->dcm_ye_line, IMU->velocity_vector);
 800022e:	f104 0610 	add.w	r6, r4, #16
	IMU->velocity_vector[1] = (IMU->velocity_vector[1]*IMU->dt) - (IMU->kp_vector_ACC[1]) - (IMU->kp_vector_MAG[1]);
	IMU->velocity_vector[2] = (IMU->velocity_vector[2]*IMU->dt) - (IMU->kp_vector_ACC[2]) - (IMU->kp_vector_MAG[2]);

	/*Update of the first dcm-line (xe)*/
	VectorCrossProduct(result, IMU->dcm_xe_line, IMU->velocity_vector);
	VectorAdd(IMU->dcm_xe_line, IMU->dcm_xe_line, result);
 8000232:	f001 fb76 	bl	8001922 <VectorAdd>

	/*Update of the second dcm-line(ye)*/
	VectorCrossProduct(result, IMU->dcm_ye_line, IMU->velocity_vector);
 8000236:	a801      	add	r0, sp, #4
 8000238:	4631      	mov	r1, r6
 800023a:	462a      	mov	r2, r5
 800023c:	f001 fb2e 	bl	800189c <VectorCrossProduct>
	VectorAdd(IMU->dcm_ye_line, IMU->dcm_ye_line, result);

	/*Update of the second dcm-line(ze)*/
	VectorCrossProduct(result, IMU->dcm_ze_line, IMU->velocity_vector);
 8000240:	341c      	adds	r4, #28
	VectorCrossProduct(result, IMU->dcm_xe_line, IMU->velocity_vector);
	VectorAdd(IMU->dcm_xe_line, IMU->dcm_xe_line, result);

	/*Update of the second dcm-line(ye)*/
	VectorCrossProduct(result, IMU->dcm_ye_line, IMU->velocity_vector);
	VectorAdd(IMU->dcm_ye_line, IMU->dcm_ye_line, result);
 8000242:	4630      	mov	r0, r6
 8000244:	4631      	mov	r1, r6
 8000246:	aa01      	add	r2, sp, #4
 8000248:	f001 fb6b 	bl	8001922 <VectorAdd>

	/*Update of the second dcm-line(ze)*/
	VectorCrossProduct(result, IMU->dcm_ze_line, IMU->velocity_vector);
 800024c:	a801      	add	r0, sp, #4
 800024e:	4621      	mov	r1, r4
 8000250:	462a      	mov	r2, r5
 8000252:	f001 fb23 	bl	800189c <VectorCrossProduct>
	VectorAdd(IMU->dcm_ze_line, IMU->dcm_ze_line, result);
 8000256:	4620      	mov	r0, r4
 8000258:	4621      	mov	r1, r4
 800025a:	aa01      	add	r2, sp, #4
 800025c:	f001 fb61 	bl	8001922 <VectorAdd>
}
 8000260:	bd7f      	pop	{r0, r1, r2, r3, r4, r5, r6, pc}

08000262 <IMU_normalize>:


//! Normalization of the vectors
void IMU_normalize(struct IMU_values *IMU)
{
 8000262:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000264:	4604      	mov	r4, r0
	float normfactor;
	normfactor = sqrtf(IMU->dcm_xe_line[0]*IMU->dcm_xe_line[0] + IMU->dcm_xe_line[1]*IMU->dcm_xe_line[1] + IMU->dcm_xe_line[2]*IMU->dcm_xe_line[2]);
 8000266:	6840      	ldr	r0, [r0, #4]
 8000268:	68a7      	ldr	r7, [r4, #8]
 800026a:	4601      	mov	r1, r0
 800026c:	f007 fb22 	bl	80078b4 <__aeabi_fmul>
 8000270:	4639      	mov	r1, r7
 8000272:	4605      	mov	r5, r0
 8000274:	4638      	mov	r0, r7
 8000276:	f007 fb1d 	bl	80078b4 <__aeabi_fmul>
 800027a:	4601      	mov	r1, r0
 800027c:	4628      	mov	r0, r5
 800027e:	f007 fa11 	bl	80076a4 <__addsf3>
 8000282:	68e6      	ldr	r6, [r4, #12]
 8000284:	4605      	mov	r5, r0
 8000286:	4631      	mov	r1, r6
 8000288:	4630      	mov	r0, r6
 800028a:	f007 fb13 	bl	80078b4 <__aeabi_fmul>
 800028e:	4601      	mov	r1, r0
 8000290:	4628      	mov	r0, r5
 8000292:	f007 fa07 	bl	80076a4 <__addsf3>
 8000296:	f007 ffbb 	bl	8008210 <sqrtf>
 800029a:	4605      	mov	r5, r0
	IMU->dcm_xe_line[0] = IMU->dcm_xe_line[0]/normfactor;	
 800029c:	4629      	mov	r1, r5
 800029e:	6860      	ldr	r0, [r4, #4]
 80002a0:	f007 fbbc 	bl	8007a1c <__aeabi_fdiv>
	IMU->dcm_xe_line[1] = IMU->dcm_xe_line[1]/normfactor;	
 80002a4:	4629      	mov	r1, r5
//! Normalization of the vectors
void IMU_normalize(struct IMU_values *IMU)
{
	float normfactor;
	normfactor = sqrtf(IMU->dcm_xe_line[0]*IMU->dcm_xe_line[0] + IMU->dcm_xe_line[1]*IMU->dcm_xe_line[1] + IMU->dcm_xe_line[2]*IMU->dcm_xe_line[2]);
	IMU->dcm_xe_line[0] = IMU->dcm_xe_line[0]/normfactor;	
 80002a6:	6060      	str	r0, [r4, #4]
	IMU->dcm_xe_line[1] = IMU->dcm_xe_line[1]/normfactor;	
 80002a8:	68a0      	ldr	r0, [r4, #8]
 80002aa:	f007 fbb7 	bl	8007a1c <__aeabi_fdiv>
	IMU->dcm_xe_line[2] = IMU->dcm_xe_line[2]/normfactor;	
 80002ae:	4629      	mov	r1, r5
void IMU_normalize(struct IMU_values *IMU)
{
	float normfactor;
	normfactor = sqrtf(IMU->dcm_xe_line[0]*IMU->dcm_xe_line[0] + IMU->dcm_xe_line[1]*IMU->dcm_xe_line[1] + IMU->dcm_xe_line[2]*IMU->dcm_xe_line[2]);
	IMU->dcm_xe_line[0] = IMU->dcm_xe_line[0]/normfactor;	
	IMU->dcm_xe_line[1] = IMU->dcm_xe_line[1]/normfactor;	
 80002b0:	60a0      	str	r0, [r4, #8]
	IMU->dcm_xe_line[2] = IMU->dcm_xe_line[2]/normfactor;	
 80002b2:	68e0      	ldr	r0, [r4, #12]
 80002b4:	f007 fbb2 	bl	8007a1c <__aeabi_fdiv>
 80002b8:	60e0      	str	r0, [r4, #12]

	normfactor = sqrtf(IMU->dcm_ye_line[0]*IMU->dcm_ye_line[0] + IMU->dcm_ye_line[1]*IMU->dcm_ye_line[1] + IMU->dcm_ye_line[2]*IMU->dcm_ye_line[2]);
 80002ba:	6920      	ldr	r0, [r4, #16]
 80002bc:	6967      	ldr	r7, [r4, #20]
 80002be:	4601      	mov	r1, r0
 80002c0:	f007 faf8 	bl	80078b4 <__aeabi_fmul>
 80002c4:	4639      	mov	r1, r7
 80002c6:	4605      	mov	r5, r0
 80002c8:	4638      	mov	r0, r7
 80002ca:	f007 faf3 	bl	80078b4 <__aeabi_fmul>
 80002ce:	4601      	mov	r1, r0
 80002d0:	4628      	mov	r0, r5
 80002d2:	f007 f9e7 	bl	80076a4 <__addsf3>
 80002d6:	69a6      	ldr	r6, [r4, #24]
 80002d8:	4605      	mov	r5, r0
 80002da:	4631      	mov	r1, r6
 80002dc:	4630      	mov	r0, r6
 80002de:	f007 fae9 	bl	80078b4 <__aeabi_fmul>
 80002e2:	4601      	mov	r1, r0
 80002e4:	4628      	mov	r0, r5
 80002e6:	f007 f9dd 	bl	80076a4 <__addsf3>
 80002ea:	f007 ff91 	bl	8008210 <sqrtf>
 80002ee:	4605      	mov	r5, r0
	IMU->dcm_ye_line[0] = IMU->dcm_ye_line[0]/normfactor;	
 80002f0:	4629      	mov	r1, r5
 80002f2:	6920      	ldr	r0, [r4, #16]
 80002f4:	f007 fb92 	bl	8007a1c <__aeabi_fdiv>
	IMU->dcm_ye_line[1] = IMU->dcm_ye_line[1]/normfactor;	
 80002f8:	4629      	mov	r1, r5
	IMU->dcm_xe_line[0] = IMU->dcm_xe_line[0]/normfactor;	
	IMU->dcm_xe_line[1] = IMU->dcm_xe_line[1]/normfactor;	
	IMU->dcm_xe_line[2] = IMU->dcm_xe_line[2]/normfactor;	

	normfactor = sqrtf(IMU->dcm_ye_line[0]*IMU->dcm_ye_line[0] + IMU->dcm_ye_line[1]*IMU->dcm_ye_line[1] + IMU->dcm_ye_line[2]*IMU->dcm_ye_line[2]);
	IMU->dcm_ye_line[0] = IMU->dcm_ye_line[0]/normfactor;	
 80002fa:	6120      	str	r0, [r4, #16]
	IMU->dcm_ye_line[1] = IMU->dcm_ye_line[1]/normfactor;	
 80002fc:	6960      	ldr	r0, [r4, #20]
 80002fe:	f007 fb8d 	bl	8007a1c <__aeabi_fdiv>
	IMU->dcm_ye_line[2] = IMU->dcm_ye_line[2]/normfactor;	
 8000302:	4629      	mov	r1, r5
	IMU->dcm_xe_line[1] = IMU->dcm_xe_line[1]/normfactor;	
	IMU->dcm_xe_line[2] = IMU->dcm_xe_line[2]/normfactor;	

	normfactor = sqrtf(IMU->dcm_ye_line[0]*IMU->dcm_ye_line[0] + IMU->dcm_ye_line[1]*IMU->dcm_ye_line[1] + IMU->dcm_ye_line[2]*IMU->dcm_ye_line[2]);
	IMU->dcm_ye_line[0] = IMU->dcm_ye_line[0]/normfactor;	
	IMU->dcm_ye_line[1] = IMU->dcm_ye_line[1]/normfactor;	
 8000304:	6160      	str	r0, [r4, #20]
	IMU->dcm_ye_line[2] = IMU->dcm_ye_line[2]/normfactor;	
 8000306:	69a0      	ldr	r0, [r4, #24]
 8000308:	f007 fb88 	bl	8007a1c <__aeabi_fdiv>
 800030c:	61a0      	str	r0, [r4, #24]

	normfactor = sqrtf(IMU->dcm_ze_line[0]*IMU->dcm_ze_line[0] + IMU->dcm_ze_line[1]*IMU->dcm_ze_line[1] + IMU->dcm_ze_line[2]*IMU->dcm_ze_line[2]);
 800030e:	69e0      	ldr	r0, [r4, #28]
 8000310:	6a27      	ldr	r7, [r4, #32]
 8000312:	4601      	mov	r1, r0
 8000314:	f007 face 	bl	80078b4 <__aeabi_fmul>
 8000318:	4639      	mov	r1, r7
 800031a:	4605      	mov	r5, r0
 800031c:	4638      	mov	r0, r7
 800031e:	f007 fac9 	bl	80078b4 <__aeabi_fmul>
 8000322:	4601      	mov	r1, r0
 8000324:	4628      	mov	r0, r5
 8000326:	f007 f9bd 	bl	80076a4 <__addsf3>
 800032a:	6a66      	ldr	r6, [r4, #36]	; 0x24
 800032c:	4605      	mov	r5, r0
 800032e:	4631      	mov	r1, r6
 8000330:	4630      	mov	r0, r6
 8000332:	f007 fabf 	bl	80078b4 <__aeabi_fmul>
 8000336:	4601      	mov	r1, r0
 8000338:	4628      	mov	r0, r5
 800033a:	f007 f9b3 	bl	80076a4 <__addsf3>
 800033e:	f007 ff67 	bl	8008210 <sqrtf>
 8000342:	4605      	mov	r5, r0
	IMU->dcm_ze_line[0] = IMU->dcm_ze_line[0]/normfactor;	
 8000344:	4629      	mov	r1, r5
 8000346:	69e0      	ldr	r0, [r4, #28]
 8000348:	f007 fb68 	bl	8007a1c <__aeabi_fdiv>
	IMU->dcm_ze_line[1] = IMU->dcm_ze_line[1]/normfactor;	
 800034c:	4629      	mov	r1, r5
	IMU->dcm_ye_line[0] = IMU->dcm_ye_line[0]/normfactor;	
	IMU->dcm_ye_line[1] = IMU->dcm_ye_line[1]/normfactor;	
	IMU->dcm_ye_line[2] = IMU->dcm_ye_line[2]/normfactor;	

	normfactor = sqrtf(IMU->dcm_ze_line[0]*IMU->dcm_ze_line[0] + IMU->dcm_ze_line[1]*IMU->dcm_ze_line[1] + IMU->dcm_ze_line[2]*IMU->dcm_ze_line[2]);
	IMU->dcm_ze_line[0] = IMU->dcm_ze_line[0]/normfactor;	
 800034e:	61e0      	str	r0, [r4, #28]
	IMU->dcm_ze_line[1] = IMU->dcm_ze_line[1]/normfactor;	
 8000350:	6a20      	ldr	r0, [r4, #32]
 8000352:	f007 fb63 	bl	8007a1c <__aeabi_fdiv>
	IMU->dcm_ze_line[2] = IMU->dcm_ze_line[2]/normfactor;		
 8000356:	4629      	mov	r1, r5
	IMU->dcm_ye_line[1] = IMU->dcm_ye_line[1]/normfactor;	
	IMU->dcm_ye_line[2] = IMU->dcm_ye_line[2]/normfactor;	

	normfactor = sqrtf(IMU->dcm_ze_line[0]*IMU->dcm_ze_line[0] + IMU->dcm_ze_line[1]*IMU->dcm_ze_line[1] + IMU->dcm_ze_line[2]*IMU->dcm_ze_line[2]);
	IMU->dcm_ze_line[0] = IMU->dcm_ze_line[0]/normfactor;	
	IMU->dcm_ze_line[1] = IMU->dcm_ze_line[1]/normfactor;	
 8000358:	6220      	str	r0, [r4, #32]
	IMU->dcm_ze_line[2] = IMU->dcm_ze_line[2]/normfactor;		
 800035a:	6a60      	ldr	r0, [r4, #36]	; 0x24
 800035c:	f007 fb5e 	bl	8007a1c <__aeabi_fdiv>
 8000360:	6260      	str	r0, [r4, #36]	; 0x24
 8000362:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08000364 <IMU_ortho_adjust>:
}

//! Keep the orthogonality
void IMU_ortho_adjust(struct IMU_values *IMU)
{
 8000364:	b5f0      	push	{r4, r5, r6, r7, lr}

	float result_x[3];
	float result_y[3];

	/*calc the orthogonality error*/	
	ortho_error = -VectorDotProduct(&IMU->dcm_xe_line[0], &IMU->dcm_ye_line[0])*0.5f;
 8000366:	f100 0410 	add.w	r4, r0, #16
 800036a:	1d05      	adds	r5, r0, #4
	IMU->dcm_ze_line[2] = IMU->dcm_ze_line[2]/normfactor;		
}

//! Keep the orthogonality
void IMU_ortho_adjust(struct IMU_values *IMU)
{
 800036c:	b087      	sub	sp, #28
 800036e:	4606      	mov	r6, r0

	float result_x[3];
	float result_y[3];

	/*calc the orthogonality error*/	
	ortho_error = -VectorDotProduct(&IMU->dcm_xe_line[0], &IMU->dcm_ye_line[0])*0.5f;
 8000370:	4621      	mov	r1, r4
 8000372:	4628      	mov	r0, r5
 8000374:	f001 fa80 	bl	8001878 <VectorDotProduct>
 8000378:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 800037c:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
 8000380:	f007 fa98 	bl	80078b4 <__aeabi_fmul>
 8000384:	4607      	mov	r7, r0
	
	/*add the half of the error to xe and ye*/
	VectorScale(&result_y[0],&IMU->dcm_ye_line[0],ortho_error);
 8000386:	4621      	mov	r1, r4
 8000388:	a803      	add	r0, sp, #12
 800038a:	463a      	mov	r2, r7
 800038c:	f001 fab5 	bl	80018fa <VectorScale>
	VectorScale(&result_x[0],&IMU->dcm_xe_line[0],ortho_error);
 8000390:	4668      	mov	r0, sp
 8000392:	4629      	mov	r1, r5
 8000394:	463a      	mov	r2, r7
 8000396:	f001 fab0 	bl	80018fa <VectorScale>

	VectorAdd(&IMU->dcm_xe_line[0], &IMU->dcm_xe_line[0], &result_y[0]);
 800039a:	4628      	mov	r0, r5
 800039c:	4629      	mov	r1, r5
 800039e:	aa03      	add	r2, sp, #12
 80003a0:	f001 fabf 	bl	8001922 <VectorAdd>
	VectorAdd(&IMU->dcm_ye_line[0], &IMU->dcm_ye_line[0], &result_x[0]);
 80003a4:	4620      	mov	r0, r4
 80003a6:	4621      	mov	r1, r4
 80003a8:	466a      	mov	r2, sp
 80003aa:	f001 faba 	bl	8001922 <VectorAdd>
	
	/*the ze-line will be recalculated with the crossproduct*/	
	VectorCrossProduct(&IMU->dcm_ze_line[0],&IMU->dcm_xe_line[0],&IMU->dcm_ye_line[0]);   
 80003ae:	f106 001c 	add.w	r0, r6, #28
 80003b2:	4629      	mov	r1, r5
 80003b4:	4622      	mov	r2, r4
 80003b6:	f001 fa71 	bl	800189c <VectorCrossProduct>
}
 80003ba:	b007      	add	sp, #28
 80003bc:	bdf0      	pop	{r4, r5, r6, r7, pc}

080003be <IMU_drift_correction_ACC>:


//! Roll-pitch Drift-Correction with Accelerometer
void IMU_drift_correction_ACC(struct IMU_values *IMU)
{
 80003be:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80003c2:	4604      	mov	r4, r0
	float normfactor;
	float error_absolute;

	normfactor = sqrtf((IMU->accel_vector[0]*IMU->accel_vector[0]) + (IMU->accel_vector[1]*IMU->accel_vector[1]) + (IMU->accel_vector[2]*IMU->accel_vector[2]));
 80003c4:	6b40      	ldr	r0, [r0, #52]	; 0x34
 80003c6:	6ba7      	ldr	r7, [r4, #56]	; 0x38
 80003c8:	4601      	mov	r1, r0
 80003ca:	f007 fa73 	bl	80078b4 <__aeabi_fmul>
 80003ce:	4639      	mov	r1, r7
 80003d0:	4605      	mov	r5, r0
 80003d2:	4638      	mov	r0, r7
 80003d4:	f007 fa6e 	bl	80078b4 <__aeabi_fmul>
 80003d8:	4601      	mov	r1, r0
 80003da:	4628      	mov	r0, r5
 80003dc:	f007 f962 	bl	80076a4 <__addsf3>
 80003e0:	6be6      	ldr	r6, [r4, #60]	; 0x3c
 80003e2:	4605      	mov	r5, r0
 80003e4:	4631      	mov	r1, r6
 80003e6:	4630      	mov	r0, r6
 80003e8:	f007 fa64 	bl	80078b4 <__aeabi_fmul>
 80003ec:	4601      	mov	r1, r0
 80003ee:	4628      	mov	r0, r5
 80003f0:	f007 f958 	bl	80076a4 <__addsf3>
 80003f4:	f007 ff0c 	bl	8008210 <sqrtf>

	if(normfactor != 0)
 80003f8:	2100      	movs	r1, #0
void IMU_drift_correction_ACC(struct IMU_values *IMU)
{
	float normfactor;
	float error_absolute;

	normfactor = sqrtf((IMU->accel_vector[0]*IMU->accel_vector[0]) + (IMU->accel_vector[1]*IMU->accel_vector[1]) + (IMU->accel_vector[2]*IMU->accel_vector[2]));
 80003fa:	4605      	mov	r5, r0

	if(normfactor != 0)
 80003fc:	f007 fbee 	bl	8007bdc <__aeabi_fcmpeq>
 8000400:	b970      	cbnz	r0, 8000420 <IMU_drift_correction_ACC+0x62>
	{
		IMU->accel_vector[0] = IMU->accel_vector[0]/normfactor;
 8000402:	6b60      	ldr	r0, [r4, #52]	; 0x34
 8000404:	4629      	mov	r1, r5
 8000406:	f007 fb09 	bl	8007a1c <__aeabi_fdiv>
		IMU->accel_vector[1] = IMU->accel_vector[1]/normfactor;
 800040a:	4629      	mov	r1, r5

	normfactor = sqrtf((IMU->accel_vector[0]*IMU->accel_vector[0]) + (IMU->accel_vector[1]*IMU->accel_vector[1]) + (IMU->accel_vector[2]*IMU->accel_vector[2]));

	if(normfactor != 0)
	{
		IMU->accel_vector[0] = IMU->accel_vector[0]/normfactor;
 800040c:	6360      	str	r0, [r4, #52]	; 0x34
		IMU->accel_vector[1] = IMU->accel_vector[1]/normfactor;
 800040e:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8000410:	f007 fb04 	bl	8007a1c <__aeabi_fdiv>
		IMU->accel_vector[2] = IMU->accel_vector[2]/normfactor;
 8000414:	4629      	mov	r1, r5
	normfactor = sqrtf((IMU->accel_vector[0]*IMU->accel_vector[0]) + (IMU->accel_vector[1]*IMU->accel_vector[1]) + (IMU->accel_vector[2]*IMU->accel_vector[2]));

	if(normfactor != 0)
	{
		IMU->accel_vector[0] = IMU->accel_vector[0]/normfactor;
		IMU->accel_vector[1] = IMU->accel_vector[1]/normfactor;
 8000416:	63a0      	str	r0, [r4, #56]	; 0x38
		IMU->accel_vector[2] = IMU->accel_vector[2]/normfactor;
 8000418:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 800041a:	f007 faff 	bl	8007a1c <__aeabi_fdiv>
 800041e:	63e0      	str	r0, [r4, #60]	; 0x3c
	}
	
	/*Calc the error between the gyrobased calculations and the vector of the accelerometer, 
	this will be done with the crossproduct of the two vectors*/
	VectorCrossProduct(&IMU->error_rollpitch[0], &IMU->dcm_ze_line[0], &IMU->accel_vector[0]);
 8000420:	f104 0550 	add.w	r5, r4, #80	; 0x50
 8000424:	f104 0234 	add.w	r2, r4, #52	; 0x34
 8000428:	4628      	mov	r0, r5
 800042a:	f104 011c 	add.w	r1, r4, #28
 800042e:	f001 fa35 	bl	800189c <VectorCrossProduct>
	//VectorCrossProduct(&IMU->error_rollpitch[0], &IMU->dcm_ze_line[0], &test[0]);
	
	error_absolute = sqrtf((IMU->error_rollpitch[0]*IMU->error_rollpitch[0]) + (IMU->error_rollpitch[1]*IMU->error_rollpitch[1]) + (IMU->error_rollpitch[2]*IMU->error_rollpitch[2]));
 8000432:	6d20      	ldr	r0, [r4, #80]	; 0x50
 8000434:	f8d4 8054 	ldr.w	r8, [r4, #84]	; 0x54
 8000438:	4601      	mov	r1, r0
 800043a:	f007 fa3b 	bl	80078b4 <__aeabi_fmul>
 800043e:	4641      	mov	r1, r8
 8000440:	4606      	mov	r6, r0
 8000442:	4640      	mov	r0, r8
 8000444:	f007 fa36 	bl	80078b4 <__aeabi_fmul>
 8000448:	4601      	mov	r1, r0
 800044a:	4630      	mov	r0, r6
 800044c:	f007 f92a 	bl	80076a4 <__addsf3>
 8000450:	6da7      	ldr	r7, [r4, #88]	; 0x58
 8000452:	4606      	mov	r6, r0
 8000454:	4639      	mov	r1, r7
 8000456:	4638      	mov	r0, r7
 8000458:	f007 fa2c 	bl	80078b4 <__aeabi_fmul>
 800045c:	4601      	mov	r1, r0
 800045e:	4630      	mov	r0, r6
 8000460:	f007 f920 	bl	80076a4 <__addsf3>
 8000464:	f007 fed4 	bl	8008210 <sqrtf>
	else
	{
		VectorScale(&IMU->kp_vector[0], &IMU->error_rollpitch[0], IMU->kp);
	}
	*/
	VectorScale(&IMU->kp_vector_ACC[0], &IMU->error_rollpitch[0], (IMU->kp+(IMU->kp*error_absolute)));
 8000468:	6ce6      	ldr	r6, [r4, #76]	; 0x4c
	/*Calc the error between the gyrobased calculations and the vector of the accelerometer, 
	this will be done with the crossproduct of the two vectors*/
	VectorCrossProduct(&IMU->error_rollpitch[0], &IMU->dcm_ze_line[0], &IMU->accel_vector[0]);
	//VectorCrossProduct(&IMU->error_rollpitch[0], &IMU->dcm_ze_line[0], &test[0]);
	
	error_absolute = sqrtf((IMU->error_rollpitch[0]*IMU->error_rollpitch[0]) + (IMU->error_rollpitch[1]*IMU->error_rollpitch[1]) + (IMU->error_rollpitch[2]*IMU->error_rollpitch[2]));
 800046a:	4601      	mov	r1, r0
	else
	{
		VectorScale(&IMU->kp_vector[0], &IMU->error_rollpitch[0], IMU->kp);
	}
	*/
	VectorScale(&IMU->kp_vector_ACC[0], &IMU->error_rollpitch[0], (IMU->kp+(IMU->kp*error_absolute)));
 800046c:	4630      	mov	r0, r6
 800046e:	f007 fa21 	bl	80078b4 <__aeabi_fmul>
 8000472:	4601      	mov	r1, r0
 8000474:	4630      	mov	r0, r6
 8000476:	f007 f915 	bl	80076a4 <__addsf3>
 800047a:	3460      	adds	r4, #96	; 0x60
 800047c:	4602      	mov	r2, r0
 800047e:	4629      	mov	r1, r5
 8000480:	4620      	mov	r0, r4
	//printf("%f\n", (IMU->kp+(IMU->kp*error_absolute)));
}
 8000482:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	else
	{
		VectorScale(&IMU->kp_vector[0], &IMU->error_rollpitch[0], IMU->kp);
	}
	*/
	VectorScale(&IMU->kp_vector_ACC[0], &IMU->error_rollpitch[0], (IMU->kp+(IMU->kp*error_absolute)));
 8000486:	f001 ba38 	b.w	80018fa <VectorScale>

0800048a <IMU_drift_correction_MAG>:
}


//! yaw Drift-Correction with Magnetometer
void IMU_drift_correction_MAG(struct IMU_values *IMU)
{
 800048a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800048c:	4604      	mov	r4, r0
	float normfactor;
	//float error_absolute;

	normfactor = sqrtf((IMU->mag_vector[0]*IMU->mag_vector[0]) + (IMU->mag_vector[1]*IMU->mag_vector[1]) + (IMU->mag_vector[2]*IMU->mag_vector[2]));
 800048e:	6c00      	ldr	r0, [r0, #64]	; 0x40
 8000490:	6c67      	ldr	r7, [r4, #68]	; 0x44
 8000492:	4601      	mov	r1, r0
 8000494:	f007 fa0e 	bl	80078b4 <__aeabi_fmul>
 8000498:	4639      	mov	r1, r7
 800049a:	4605      	mov	r5, r0
 800049c:	4638      	mov	r0, r7
 800049e:	f007 fa09 	bl	80078b4 <__aeabi_fmul>
 80004a2:	4601      	mov	r1, r0
 80004a4:	4628      	mov	r0, r5
 80004a6:	f007 f8fd 	bl	80076a4 <__addsf3>
 80004aa:	6ca6      	ldr	r6, [r4, #72]	; 0x48
 80004ac:	4605      	mov	r5, r0
 80004ae:	4631      	mov	r1, r6
 80004b0:	4630      	mov	r0, r6
 80004b2:	f007 f9ff 	bl	80078b4 <__aeabi_fmul>
 80004b6:	4601      	mov	r1, r0
 80004b8:	4628      	mov	r0, r5
 80004ba:	f007 f8f3 	bl	80076a4 <__addsf3>
 80004be:	f007 fea7 	bl	8008210 <sqrtf>

	if(normfactor != 0)
 80004c2:	2100      	movs	r1, #0
void IMU_drift_correction_MAG(struct IMU_values *IMU)
{
	float normfactor;
	//float error_absolute;

	normfactor = sqrtf((IMU->mag_vector[0]*IMU->mag_vector[0]) + (IMU->mag_vector[1]*IMU->mag_vector[1]) + (IMU->mag_vector[2]*IMU->mag_vector[2]));
 80004c4:	4605      	mov	r5, r0

	if(normfactor != 0)
 80004c6:	f007 fb89 	bl	8007bdc <__aeabi_fcmpeq>
 80004ca:	b970      	cbnz	r0, 80004ea <IMU_drift_correction_MAG+0x60>
	{
		IMU->mag_vector[0] = IMU->mag_vector[0]/normfactor;
 80004cc:	6c20      	ldr	r0, [r4, #64]	; 0x40
 80004ce:	4629      	mov	r1, r5
 80004d0:	f007 faa4 	bl	8007a1c <__aeabi_fdiv>
		IMU->mag_vector[1] = IMU->mag_vector[1]/normfactor;
 80004d4:	4629      	mov	r1, r5

	normfactor = sqrtf((IMU->mag_vector[0]*IMU->mag_vector[0]) + (IMU->mag_vector[1]*IMU->mag_vector[1]) + (IMU->mag_vector[2]*IMU->mag_vector[2]));

	if(normfactor != 0)
	{
		IMU->mag_vector[0] = IMU->mag_vector[0]/normfactor;
 80004d6:	6420      	str	r0, [r4, #64]	; 0x40
		IMU->mag_vector[1] = IMU->mag_vector[1]/normfactor;
 80004d8:	6c60      	ldr	r0, [r4, #68]	; 0x44
 80004da:	f007 fa9f 	bl	8007a1c <__aeabi_fdiv>
		IMU->mag_vector[2] = IMU->mag_vector[2]/normfactor;
 80004de:	4629      	mov	r1, r5
	normfactor = sqrtf((IMU->mag_vector[0]*IMU->mag_vector[0]) + (IMU->mag_vector[1]*IMU->mag_vector[1]) + (IMU->mag_vector[2]*IMU->mag_vector[2]));

	if(normfactor != 0)
	{
		IMU->mag_vector[0] = IMU->mag_vector[0]/normfactor;
		IMU->mag_vector[1] = IMU->mag_vector[1]/normfactor;
 80004e0:	6460      	str	r0, [r4, #68]	; 0x44
		IMU->mag_vector[2] = IMU->mag_vector[2]/normfactor;
 80004e2:	6ca0      	ldr	r0, [r4, #72]	; 0x48
 80004e4:	f007 fa9a 	bl	8007a1c <__aeabi_fdiv>
 80004e8:	64a0      	str	r0, [r4, #72]	; 0x48

	/*Calc the error between the gyrobased calculations and the vector of the accelerometer,
	this will be done with the crossproduct of the two vectors*/
	//VectorCrossProduct(&IMU->error_yaw[0], &IMU->dcm_xe_line[0], &IMU->mag_vector[0]);

	IMU->error_yaw = (IMU->dcm_xe_line[0]*IMU->mag_vector[1]) - (IMU->dcm_ye_line[0]*IMU->mag_vector[0]);
 80004ea:	6c61      	ldr	r1, [r4, #68]	; 0x44
 80004ec:	6860      	ldr	r0, [r4, #4]
 80004ee:	f007 f9e1 	bl	80078b4 <__aeabi_fmul>
 80004f2:	6c21      	ldr	r1, [r4, #64]	; 0x40
 80004f4:	4605      	mov	r5, r0
 80004f6:	6920      	ldr	r0, [r4, #16]
 80004f8:	f007 f9dc 	bl	80078b4 <__aeabi_fmul>
 80004fc:	4601      	mov	r1, r0
 80004fe:	4628      	mov	r0, r5
 8000500:	f007 f8ce 	bl	80076a0 <__aeabi_fsub>
	VectorScale(&IMU->kp_vector_MAG[0], &IMU->dcm_ze_line[0], (IMU->kp*IMU->error_yaw));
 8000504:	6ce1      	ldr	r1, [r4, #76]	; 0x4c

	/*Calc the error between the gyrobased calculations and the vector of the accelerometer,
	this will be done with the crossproduct of the two vectors*/
	//VectorCrossProduct(&IMU->error_yaw[0], &IMU->dcm_xe_line[0], &IMU->mag_vector[0]);

	IMU->error_yaw = (IMU->dcm_xe_line[0]*IMU->mag_vector[1]) - (IMU->dcm_ye_line[0]*IMU->mag_vector[0]);
 8000506:	65e0      	str	r0, [r4, #92]	; 0x5c
	VectorScale(&IMU->kp_vector_MAG[0], &IMU->dcm_ze_line[0], (IMU->kp*IMU->error_yaw));
 8000508:	f007 f9d4 	bl	80078b4 <__aeabi_fmul>
 800050c:	f104 066c 	add.w	r6, r4, #108	; 0x6c
 8000510:	f104 051c 	add.w	r5, r4, #28
 8000514:	4602      	mov	r2, r0
 8000516:	4629      	mov	r1, r5
 8000518:	4630      	mov	r0, r6
	//VectorScale(&IMU->kp_vector_MAG[0], &IMU->error_yaw[0], IMU->kp);
	//printf("%f\n", (IMU->kp+(IMU->kp*error_absolute)));
}
 800051a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	/*Calc the error between the gyrobased calculations and the vector of the accelerometer,
	this will be done with the crossproduct of the two vectors*/
	//VectorCrossProduct(&IMU->error_yaw[0], &IMU->dcm_xe_line[0], &IMU->mag_vector[0]);

	IMU->error_yaw = (IMU->dcm_xe_line[0]*IMU->mag_vector[1]) - (IMU->dcm_ye_line[0]*IMU->mag_vector[0]);
	VectorScale(&IMU->kp_vector_MAG[0], &IMU->dcm_ze_line[0], (IMU->kp*IMU->error_yaw));
 800051e:	f001 b9ec 	b.w	80018fa <VectorScale>

08000522 <IMU_DCM_to_Euler_deg>:
}


//! DCM to EULER Angles
void IMU_DCM_to_Euler_deg(struct IMU_values* IMU, struct EULER_angles *euler)
{
 8000522:	b538      	push	{r3, r4, r5, lr}
 8000524:	4604      	mov	r4, r0
	euler->pitch = (asinf(-IMU->dcm_ze_line[0]))*(180/M_PI);
 8000526:	69c0      	ldr	r0, [r0, #28]
}


//! DCM to EULER Angles
void IMU_DCM_to_Euler_deg(struct IMU_values* IMU, struct EULER_angles *euler)
{
 8000528:	460d      	mov	r5, r1
	euler->pitch = (asinf(-IMU->dcm_ze_line[0]))*(180/M_PI);
 800052a:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
 800052e:	f007 fe1b 	bl	8008168 <asinf>
 8000532:	490a      	ldr	r1, [pc, #40]	; (800055c <IMU_DCM_to_Euler_deg+0x3a>)
 8000534:	f007 f9be 	bl	80078b4 <__aeabi_fmul>
	euler->roll = (atan2f(IMU->dcm_ze_line[1],IMU->dcm_ze_line[2]))*(180/M_PI);
 8000538:	6a61      	ldr	r1, [r4, #36]	; 0x24


//! DCM to EULER Angles
void IMU_DCM_to_Euler_deg(struct IMU_values* IMU, struct EULER_angles *euler)
{
	euler->pitch = (asinf(-IMU->dcm_ze_line[0]))*(180/M_PI);
 800053a:	6068      	str	r0, [r5, #4]
	euler->roll = (atan2f(IMU->dcm_ze_line[1],IMU->dcm_ze_line[2]))*(180/M_PI);
 800053c:	6a20      	ldr	r0, [r4, #32]
 800053e:	f007 fe65 	bl	800820c <atan2f>
 8000542:	4906      	ldr	r1, [pc, #24]	; (800055c <IMU_DCM_to_Euler_deg+0x3a>)
 8000544:	f007 f9b6 	bl	80078b4 <__aeabi_fmul>
	euler->yaw = (atan2f(IMU->dcm_ye_line[0],IMU->dcm_xe_line[0]))*(180/M_PI);
 8000548:	6861      	ldr	r1, [r4, #4]

//! DCM to EULER Angles
void IMU_DCM_to_Euler_deg(struct IMU_values* IMU, struct EULER_angles *euler)
{
	euler->pitch = (asinf(-IMU->dcm_ze_line[0]))*(180/M_PI);
	euler->roll = (atan2f(IMU->dcm_ze_line[1],IMU->dcm_ze_line[2]))*(180/M_PI);
 800054a:	6028      	str	r0, [r5, #0]
	euler->yaw = (atan2f(IMU->dcm_ye_line[0],IMU->dcm_xe_line[0]))*(180/M_PI);
 800054c:	6920      	ldr	r0, [r4, #16]
 800054e:	f007 fe5d 	bl	800820c <atan2f>
 8000552:	4902      	ldr	r1, [pc, #8]	; (800055c <IMU_DCM_to_Euler_deg+0x3a>)
 8000554:	f007 f9ae 	bl	80078b4 <__aeabi_fmul>
 8000558:	60a8      	str	r0, [r5, #8]
 800055a:	bd38      	pop	{r3, r4, r5, pc}
 800055c:	42652ee0 	.word	0x42652ee0

08000560 <IMU_Euler_to_DCM>:
	//printf("%3.1f  %3.1f  %3.1f\n", roll*(180/M_PI), pitch*(180/M_PI), yaw*(180/M_PI));
}

//! EULER Angles to DCM
void IMU_Euler_to_DCM(struct IMU_values* IMU, struct EULER_angles *euler)
{
 8000560:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	/*First line DCM Matrix*/
	IMU->dcm_xe_line[0] = cosf(euler->pitch)*cosf(euler->yaw);
 8000564:	f8d1 b004 	ldr.w	fp, [r1, #4]
	//printf("%3.1f  %3.1f  %3.1f\n", roll*(180/M_PI), pitch*(180/M_PI), yaw*(180/M_PI));
}

//! EULER Angles to DCM
void IMU_Euler_to_DCM(struct IMU_values* IMU, struct EULER_angles *euler)
{
 8000568:	b085      	sub	sp, #20
 800056a:	4604      	mov	r4, r0
	/*First line DCM Matrix*/
	IMU->dcm_xe_line[0] = cosf(euler->pitch)*cosf(euler->yaw);
 800056c:	4658      	mov	r0, fp
	//printf("%3.1f  %3.1f  %3.1f\n", roll*(180/M_PI), pitch*(180/M_PI), yaw*(180/M_PI));
}

//! EULER Angles to DCM
void IMU_Euler_to_DCM(struct IMU_values* IMU, struct EULER_angles *euler)
{
 800056e:	460f      	mov	r7, r1
	/*First line DCM Matrix*/
	IMU->dcm_xe_line[0] = cosf(euler->pitch)*cosf(euler->yaw);
 8000570:	f007 fd30 	bl	8007fd4 <cosf>
 8000574:	f8d7 8008 	ldr.w	r8, [r7, #8]
 8000578:	4606      	mov	r6, r0
 800057a:	4640      	mov	r0, r8
 800057c:	f007 fd2a 	bl	8007fd4 <cosf>
 8000580:	4605      	mov	r5, r0
 8000582:	4629      	mov	r1, r5
 8000584:	4630      	mov	r0, r6
 8000586:	f007 f995 	bl	80078b4 <__aeabi_fmul>
 800058a:	6060      	str	r0, [r4, #4]
	IMU->dcm_xe_line[1] = (cosf(euler->pitch)*sinf(euler->yaw))+(sinf(euler->roll)*sinf(euler->pitch)*cosf(euler->yaw));
 800058c:	4640      	mov	r0, r8
 800058e:	f007 fd57 	bl	8008040 <sinf>
 8000592:	4680      	mov	r8, r0
 8000594:	4641      	mov	r1, r8
 8000596:	4630      	mov	r0, r6
 8000598:	f007 f98c 	bl	80078b4 <__aeabi_fmul>
 800059c:	f8d7 9000 	ldr.w	r9, [r7]
 80005a0:	4682      	mov	sl, r0
 80005a2:	4648      	mov	r0, r9
 80005a4:	f007 fd4c 	bl	8008040 <sinf>
 80005a8:	4607      	mov	r7, r0
 80005aa:	4658      	mov	r0, fp
 80005ac:	f007 fd48 	bl	8008040 <sinf>
 80005b0:	4683      	mov	fp, r0
 80005b2:	4659      	mov	r1, fp
 80005b4:	4638      	mov	r0, r7
 80005b6:	f007 f97d 	bl	80078b4 <__aeabi_fmul>
 80005ba:	4629      	mov	r1, r5
 80005bc:	9001      	str	r0, [sp, #4]
 80005be:	f007 f979 	bl	80078b4 <__aeabi_fmul>
 80005c2:	4601      	mov	r1, r0
 80005c4:	4650      	mov	r0, sl
 80005c6:	f007 f86d 	bl	80076a4 <__addsf3>
 80005ca:	60a0      	str	r0, [r4, #8]
	IMU->dcm_xe_line[2] = (sinf(euler->roll)*sinf(euler->yaw))-(cosf(euler->roll)*sinf(euler->pitch)*cosf(euler->yaw));
 80005cc:	4648      	mov	r0, r9
 80005ce:	f007 fd01 	bl	8007fd4 <cosf>
 80005d2:	4659      	mov	r1, fp
 80005d4:	4681      	mov	r9, r0
 80005d6:	f007 f96d 	bl	80078b4 <__aeabi_fmul>
 80005da:	4641      	mov	r1, r8
 80005dc:	9003      	str	r0, [sp, #12]
 80005de:	4638      	mov	r0, r7
 80005e0:	f007 f968 	bl	80078b4 <__aeabi_fmul>
 80005e4:	4629      	mov	r1, r5
 80005e6:	4684      	mov	ip, r0
 80005e8:	9803      	ldr	r0, [sp, #12]
 80005ea:	f8cd c008 	str.w	ip, [sp, #8]
 80005ee:	f007 f961 	bl	80078b4 <__aeabi_fmul>
 80005f2:	f8dd c008 	ldr.w	ip, [sp, #8]
 80005f6:	4601      	mov	r1, r0
 80005f8:	4660      	mov	r0, ip
 80005fa:	f007 f851 	bl	80076a0 <__aeabi_fsub>

	/*Second line DCM Matrix*/
	IMU->dcm_ye_line[0] = -(cosf(euler->pitch)*sinf(euler->yaw));
 80005fe:	f10a 4a00 	add.w	sl, sl, #2147483648	; 0x80000000
	IMU->dcm_ye_line[1] = (cosf(euler->roll)*cosf(euler->yaw))-(sinf(euler->roll)*sinf(euler->pitch)*sinf(euler->yaw));
 8000602:	4629      	mov	r1, r5
void IMU_Euler_to_DCM(struct IMU_values* IMU, struct EULER_angles *euler)
{
	/*First line DCM Matrix*/
	IMU->dcm_xe_line[0] = cosf(euler->pitch)*cosf(euler->yaw);
	IMU->dcm_xe_line[1] = (cosf(euler->pitch)*sinf(euler->yaw))+(sinf(euler->roll)*sinf(euler->pitch)*cosf(euler->yaw));
	IMU->dcm_xe_line[2] = (sinf(euler->roll)*sinf(euler->yaw))-(cosf(euler->roll)*sinf(euler->pitch)*cosf(euler->yaw));
 8000604:	60e0      	str	r0, [r4, #12]

	/*Second line DCM Matrix*/
	IMU->dcm_ye_line[0] = -(cosf(euler->pitch)*sinf(euler->yaw));
 8000606:	f8c4 a010 	str.w	sl, [r4, #16]
	IMU->dcm_ye_line[1] = (cosf(euler->roll)*cosf(euler->yaw))-(sinf(euler->roll)*sinf(euler->pitch)*sinf(euler->yaw));
 800060a:	4648      	mov	r0, r9
 800060c:	f007 f952 	bl	80078b4 <__aeabi_fmul>
 8000610:	9a01      	ldr	r2, [sp, #4]
 8000612:	4682      	mov	sl, r0
 8000614:	4641      	mov	r1, r8
 8000616:	4610      	mov	r0, r2
 8000618:	f007 f94c 	bl	80078b4 <__aeabi_fmul>
 800061c:	4601      	mov	r1, r0
 800061e:	4650      	mov	r0, sl
 8000620:	f007 f83e 	bl	80076a0 <__aeabi_fsub>
	IMU->dcm_ye_line[2] = (sinf(euler->roll)*cosf(euler->yaw)) + (cosf(euler->roll)*sinf(euler->pitch)*sinf(euler->yaw));
 8000624:	4629      	mov	r1, r5
	IMU->dcm_xe_line[1] = (cosf(euler->pitch)*sinf(euler->yaw))+(sinf(euler->roll)*sinf(euler->pitch)*cosf(euler->yaw));
	IMU->dcm_xe_line[2] = (sinf(euler->roll)*sinf(euler->yaw))-(cosf(euler->roll)*sinf(euler->pitch)*cosf(euler->yaw));

	/*Second line DCM Matrix*/
	IMU->dcm_ye_line[0] = -(cosf(euler->pitch)*sinf(euler->yaw));
	IMU->dcm_ye_line[1] = (cosf(euler->roll)*cosf(euler->yaw))-(sinf(euler->roll)*sinf(euler->pitch)*sinf(euler->yaw));
 8000626:	6160      	str	r0, [r4, #20]
	IMU->dcm_ye_line[2] = (sinf(euler->roll)*cosf(euler->yaw)) + (cosf(euler->roll)*sinf(euler->pitch)*sinf(euler->yaw));
 8000628:	4638      	mov	r0, r7
 800062a:	f007 f943 	bl	80078b4 <__aeabi_fmul>
 800062e:	4641      	mov	r1, r8
 8000630:	4605      	mov	r5, r0
 8000632:	9803      	ldr	r0, [sp, #12]
 8000634:	f007 f93e 	bl	80078b4 <__aeabi_fmul>
 8000638:	4601      	mov	r1, r0
 800063a:	4628      	mov	r0, r5
 800063c:	f007 f832 	bl	80076a4 <__addsf3>

	/*Third line DCM Matrix*/
	IMU->dcm_ze_line[0] = sinf(euler->pitch);
	IMU->dcm_ze_line[1] = -sinf(euler->roll)*cosf(euler->pitch);
 8000640:	4631      	mov	r1, r6
	IMU->dcm_xe_line[2] = (sinf(euler->roll)*sinf(euler->yaw))-(cosf(euler->roll)*sinf(euler->pitch)*cosf(euler->yaw));

	/*Second line DCM Matrix*/
	IMU->dcm_ye_line[0] = -(cosf(euler->pitch)*sinf(euler->yaw));
	IMU->dcm_ye_line[1] = (cosf(euler->roll)*cosf(euler->yaw))-(sinf(euler->roll)*sinf(euler->pitch)*sinf(euler->yaw));
	IMU->dcm_ye_line[2] = (sinf(euler->roll)*cosf(euler->yaw)) + (cosf(euler->roll)*sinf(euler->pitch)*sinf(euler->yaw));
 8000642:	61a0      	str	r0, [r4, #24]

	/*Third line DCM Matrix*/
	IMU->dcm_ze_line[0] = sinf(euler->pitch);
 8000644:	f8c4 b01c 	str.w	fp, [r4, #28]
	IMU->dcm_ze_line[1] = -sinf(euler->roll)*cosf(euler->pitch);
 8000648:	f107 4000 	add.w	r0, r7, #2147483648	; 0x80000000
 800064c:	f007 f932 	bl	80078b4 <__aeabi_fmul>
	IMU->dcm_ze_line[2] = cosf(euler->roll)*cosf(euler->pitch);
 8000650:	4631      	mov	r1, r6
	IMU->dcm_ye_line[1] = (cosf(euler->roll)*cosf(euler->yaw))-(sinf(euler->roll)*sinf(euler->pitch)*sinf(euler->yaw));
	IMU->dcm_ye_line[2] = (sinf(euler->roll)*cosf(euler->yaw)) + (cosf(euler->roll)*sinf(euler->pitch)*sinf(euler->yaw));

	/*Third line DCM Matrix*/
	IMU->dcm_ze_line[0] = sinf(euler->pitch);
	IMU->dcm_ze_line[1] = -sinf(euler->roll)*cosf(euler->pitch);
 8000652:	6220      	str	r0, [r4, #32]
	IMU->dcm_ze_line[2] = cosf(euler->roll)*cosf(euler->pitch);
 8000654:	4648      	mov	r0, r9
 8000656:	f007 f92d 	bl	80078b4 <__aeabi_fmul>
 800065a:	6260      	str	r0, [r4, #36]	; 0x24
}
 800065c:	b005      	add	sp, #20
 800065e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08000662 <IMU_DCM_to_XYZ>:

//! DCM to kartesic coordinates
void IMU_DCM_to_XYZ(struct IMU_values* IMU, struct XYZ_angles *XYZ)
{
 8000662:	b538      	push	{r3, r4, r5, lr}
 8000664:	4604      	mov	r4, r0
	XYZ->x = asinf(-IMU->dcm_ze_line[0])*(180/M_PI);
 8000666:	69c0      	ldr	r0, [r0, #28]
	IMU->dcm_ze_line[2] = cosf(euler->roll)*cosf(euler->pitch);
}

//! DCM to kartesic coordinates
void IMU_DCM_to_XYZ(struct IMU_values* IMU, struct XYZ_angles *XYZ)
{
 8000668:	460d      	mov	r5, r1
	XYZ->x = asinf(-IMU->dcm_ze_line[0])*(180/M_PI);
 800066a:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
 800066e:	f007 fd7b 	bl	8008168 <asinf>
 8000672:	490a      	ldr	r1, [pc, #40]	; (800069c <IMU_DCM_to_XYZ+0x3a>)
 8000674:	f007 f91e 	bl	80078b4 <__aeabi_fmul>
 8000678:	6028      	str	r0, [r5, #0]
	XYZ->y = asinf(IMU->dcm_ze_line[1])*(180/M_PI);
 800067a:	6a20      	ldr	r0, [r4, #32]
 800067c:	f007 fd74 	bl	8008168 <asinf>
 8000680:	4906      	ldr	r1, [pc, #24]	; (800069c <IMU_DCM_to_XYZ+0x3a>)
 8000682:	f007 f917 	bl	80078b4 <__aeabi_fmul>
	XYZ->z = (atan2f(IMU->dcm_ye_line[0],IMU->dcm_xe_line[0]))*(180/M_PI);
 8000686:	6861      	ldr	r1, [r4, #4]

//! DCM to kartesic coordinates
void IMU_DCM_to_XYZ(struct IMU_values* IMU, struct XYZ_angles *XYZ)
{
	XYZ->x = asinf(-IMU->dcm_ze_line[0])*(180/M_PI);
	XYZ->y = asinf(IMU->dcm_ze_line[1])*(180/M_PI);
 8000688:	6068      	str	r0, [r5, #4]
	XYZ->z = (atan2f(IMU->dcm_ye_line[0],IMU->dcm_xe_line[0]))*(180/M_PI);
 800068a:	6920      	ldr	r0, [r4, #16]
 800068c:	f007 fdbe 	bl	800820c <atan2f>
 8000690:	4902      	ldr	r1, [pc, #8]	; (800069c <IMU_DCM_to_XYZ+0x3a>)
 8000692:	f007 f90f 	bl	80078b4 <__aeabi_fmul>
 8000696:	60a8      	str	r0, [r5, #8]
 8000698:	bd38      	pop	{r3, r4, r5, pc}
 800069a:	bf00      	nop
 800069c:	42652ee0 	.word	0x42652ee0

080006a0 <L3GD20_SendByte>:
 */

#include <L3GD20_Lib_SPI.h>

static uint8_t L3GD20_SendByte(uint8_t byte)
{
 80006a0:	b510      	push	{r4, lr}
 80006a2:	4604      	mov	r4, r0
  /* Loop while DR register in not empty */
  while (SPI_I2S_GetFlagStatus(L3GD20_SPI, SPI_I2S_FLAG_TXE) == RESET)
 80006a4:	480a      	ldr	r0, [pc, #40]	; (80006d0 <L3GD20_SendByte+0x30>)
 80006a6:	2102      	movs	r1, #2
 80006a8:	f004 f837 	bl	800471a <SPI_I2S_GetFlagStatus>
 80006ac:	2800      	cmp	r0, #0
 80006ae:	d0f9      	beq.n	80006a4 <L3GD20_SendByte+0x4>
  {
  }

  /* Send a Byte through the SPI peripheral */
  SPI_SendData8(L3GD20_SPI, byte);
 80006b0:	4807      	ldr	r0, [pc, #28]	; (80006d0 <L3GD20_SendByte+0x30>)
 80006b2:	4621      	mov	r1, r4
 80006b4:	f003 ffd6 	bl	8004664 <SPI_SendData8>

  /* Wait to receive a Byte */
  while (SPI_I2S_GetFlagStatus(L3GD20_SPI, SPI_I2S_FLAG_RXNE) == RESET)
 80006b8:	4805      	ldr	r0, [pc, #20]	; (80006d0 <L3GD20_SendByte+0x30>)
 80006ba:	2101      	movs	r1, #1
 80006bc:	f004 f82d 	bl	800471a <SPI_I2S_GetFlagStatus>
 80006c0:	2800      	cmp	r0, #0
 80006c2:	d0f9      	beq.n	80006b8 <L3GD20_SendByte+0x18>
  {
  }

  /* Return the Byte read from the SPI bus */
  return (uint8_t)SPI_ReceiveData8(L3GD20_SPI);
 80006c4:	4802      	ldr	r0, [pc, #8]	; (80006d0 <L3GD20_SendByte+0x30>)
}
 80006c6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  while (SPI_I2S_GetFlagStatus(L3GD20_SPI, SPI_I2S_FLAG_RXNE) == RESET)
  {
  }

  /* Return the Byte read from the SPI bus */
  return (uint8_t)SPI_ReceiveData8(L3GD20_SPI);
 80006ca:	f003 bfcf 	b.w	800466c <SPI_ReceiveData8>
 80006ce:	bf00      	nop
 80006d0:	40013000 	.word	0x40013000

080006d4 <L3GD20_Init>:
}



void L3GD20_Init(void)
{
 80006d4:	b510      	push	{r4, lr}

  ctrl5 = (uint8_t) (0x13); /* CTRL_REG5   low pass filter enable, high pass filter enabled */


  /* Write value to MEMS CTRL_REG1 regsister */
  L3GD20_CS_LOW();
 80006d6:	4c1d      	ldr	r4, [pc, #116]	; (800074c <L3GD20_Init+0x78>)
 80006d8:	2108      	movs	r1, #8
 80006da:	4620      	mov	r0, r4
 80006dc:	f003 f936 	bl	800394c <GPIO_ResetBits>
  L3GD20_SendByte(L3GD20_CTRL_REG1_ADDR);
 80006e0:	2020      	movs	r0, #32
 80006e2:	f7ff ffdd 	bl	80006a0 <L3GD20_SendByte>
  L3GD20_SendByte(ctrl1);
 80006e6:	20ff      	movs	r0, #255	; 0xff
 80006e8:	f7ff ffda 	bl	80006a0 <L3GD20_SendByte>
  L3GD20_CS_HIGH();
 80006ec:	4620      	mov	r0, r4
 80006ee:	2108      	movs	r1, #8
 80006f0:	f003 f92a 	bl	8003948 <GPIO_SetBits>

  /* Write value to MEMS CTRL_REG2 regsister */
  L3GD20_CS_LOW();
 80006f4:	2108      	movs	r1, #8
 80006f6:	4620      	mov	r0, r4
 80006f8:	f003 f928 	bl	800394c <GPIO_ResetBits>
  L3GD20_SendByte(L3GD20_CTRL_REG2_ADDR);
 80006fc:	2021      	movs	r0, #33	; 0x21
 80006fe:	f7ff ffcf 	bl	80006a0 <L3GD20_SendByte>
  L3GD20_SendByte(ctrl2);
 8000702:	2034      	movs	r0, #52	; 0x34
 8000704:	f7ff ffcc 	bl	80006a0 <L3GD20_SendByte>
  L3GD20_CS_HIGH();
 8000708:	4620      	mov	r0, r4
 800070a:	2108      	movs	r1, #8
 800070c:	f003 f91c 	bl	8003948 <GPIO_SetBits>

  /* Write value to MEMS CTRL_REG4 regsister */
  L3GD20_CS_LOW();
 8000710:	2108      	movs	r1, #8
 8000712:	4620      	mov	r0, r4
 8000714:	f003 f91a 	bl	800394c <GPIO_ResetBits>
  L3GD20_SendByte(L3GD20_CTRL_REG4_ADDR);
 8000718:	2023      	movs	r0, #35	; 0x23
 800071a:	f7ff ffc1 	bl	80006a0 <L3GD20_SendByte>
  L3GD20_SendByte(ctrl4);
 800071e:	20a0      	movs	r0, #160	; 0xa0
 8000720:	f7ff ffbe 	bl	80006a0 <L3GD20_SendByte>
  L3GD20_CS_HIGH();
 8000724:	4620      	mov	r0, r4
 8000726:	2108      	movs	r1, #8
 8000728:	f003 f90e 	bl	8003948 <GPIO_SetBits>

  /* Write value to MEMS CTRL_REG2 regsister */
  L3GD20_CS_LOW();
 800072c:	2108      	movs	r1, #8
 800072e:	4620      	mov	r0, r4
 8000730:	f003 f90c 	bl	800394c <GPIO_ResetBits>
  L3GD20_SendByte(L3GD20_CTRL_REG5_ADDR);
 8000734:	2024      	movs	r0, #36	; 0x24
 8000736:	f7ff ffb3 	bl	80006a0 <L3GD20_SendByte>
  L3GD20_SendByte(ctrl5);
 800073a:	2013      	movs	r0, #19
 800073c:	f7ff ffb0 	bl	80006a0 <L3GD20_SendByte>
  L3GD20_CS_HIGH();
 8000740:	4620      	mov	r0, r4
 8000742:	2108      	movs	r1, #8
}
 8000744:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  /* Write value to MEMS CTRL_REG2 regsister */
  L3GD20_CS_LOW();
  L3GD20_SendByte(L3GD20_CTRL_REG5_ADDR);
  L3GD20_SendByte(ctrl5);
  L3GD20_CS_HIGH();
 8000748:	f003 b8fe 	b.w	8003948 <GPIO_SetBits>
 800074c:	48001000 	.word	0x48001000

08000750 <L3GD20_Read>:
}


void L3GD20_Read(uint8_t* pBuffer, uint8_t ReadAddr, uint16_t NumByteToRead)
{
  if(NumByteToRead > 0x01)
 8000750:	2a01      	cmp	r2, #1
  L3GD20_CS_HIGH();
}


void L3GD20_Read(uint8_t* pBuffer, uint8_t ReadAddr, uint16_t NumByteToRead)
{
 8000752:	b570      	push	{r4, r5, r6, lr}
  if(NumByteToRead > 0x01)
  {
    ReadAddr |= (uint8_t)(READWRITE_CMD | MULTIPLEBYTE_CMD);
 8000754:	bf8c      	ite	hi
 8000756:	f041 06c0 	orrhi.w	r6, r1, #192	; 0xc0
  }
  else
  {
    ReadAddr |= (uint8_t)READWRITE_CMD;
 800075a:	f041 0680 	orrls.w	r6, r1, #128	; 0x80
  L3GD20_CS_HIGH();
}


void L3GD20_Read(uint8_t* pBuffer, uint8_t ReadAddr, uint16_t NumByteToRead)
{
 800075e:	4605      	mov	r5, r0
  else
  {
    ReadAddr |= (uint8_t)READWRITE_CMD;
  }
  /* Set chip select Low at the start of the transmission */
  L3GD20_CS_LOW();
 8000760:	2108      	movs	r1, #8
 8000762:	480b      	ldr	r0, [pc, #44]	; (8000790 <L3GD20_Read+0x40>)
  L3GD20_CS_HIGH();
}


void L3GD20_Read(uint8_t* pBuffer, uint8_t ReadAddr, uint16_t NumByteToRead)
{
 8000764:	4614      	mov	r4, r2
  else
  {
    ReadAddr |= (uint8_t)READWRITE_CMD;
  }
  /* Set chip select Low at the start of the transmission */
  L3GD20_CS_LOW();
 8000766:	f003 f8f1 	bl	800394c <GPIO_ResetBits>

  /* Send the Address of the indexed register */
  L3GD20_SendByte(ReadAddr);
 800076a:	4630      	mov	r0, r6
 800076c:	f7ff ff98 	bl	80006a0 <L3GD20_SendByte>

  /* Receive the data that will be read from the device (MSB First) */
  while(NumByteToRead > 0x00)
 8000770:	e006      	b.n	8000780 <L3GD20_Read+0x30>
  {
    /* Send dummy byte (0x00) to generate the SPI clock to L3GD20 (Slave device) */
    *pBuffer = L3GD20_SendByte(DUMMY_BYTE);
 8000772:	2000      	movs	r0, #0
 8000774:	f7ff ff94 	bl	80006a0 <L3GD20_SendByte>
    NumByteToRead--;
 8000778:	3c01      	subs	r4, #1

  /* Receive the data that will be read from the device (MSB First) */
  while(NumByteToRead > 0x00)
  {
    /* Send dummy byte (0x00) to generate the SPI clock to L3GD20 (Slave device) */
    *pBuffer = L3GD20_SendByte(DUMMY_BYTE);
 800077a:	f805 0b01 	strb.w	r0, [r5], #1
    NumByteToRead--;
 800077e:	b2a4      	uxth	r4, r4

  /* Send the Address of the indexed register */
  L3GD20_SendByte(ReadAddr);

  /* Receive the data that will be read from the device (MSB First) */
  while(NumByteToRead > 0x00)
 8000780:	2c00      	cmp	r4, #0
 8000782:	d1f6      	bne.n	8000772 <L3GD20_Read+0x22>
    NumByteToRead--;
    pBuffer++;
  }

  /* Set chip select High at the end of the transmission */
  L3GD20_CS_HIGH();
 8000784:	4802      	ldr	r0, [pc, #8]	; (8000790 <L3GD20_Read+0x40>)
 8000786:	2108      	movs	r1, #8
}
 8000788:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    NumByteToRead--;
    pBuffer++;
  }

  /* Set chip select High at the end of the transmission */
  L3GD20_CS_HIGH();
 800078c:	f003 b8dc 	b.w	8003948 <GPIO_SetBits>
 8000790:	48001000 	.word	0x48001000

08000794 <Gyro_convert>:
}


void Gyro_convert(uint8_t Buffer[6], struct gyroValues *gyro, uint8_t bigEndian)
{
 8000794:	b510      	push	{r4, lr}
 8000796:	7843      	ldrb	r3, [r0, #1]
 8000798:	7804      	ldrb	r4, [r0, #0]
	if(bigEndian)
 800079a:	b152      	cbz	r2, 80007b2 <Gyro_convert+0x1e>
	{
		gyro->gyroValueX = (Buffer[1] << 8) | (Buffer[0]);
 800079c:	ea44 2303 	orr.w	r3, r4, r3, lsl #8
 80007a0:	800b      	strh	r3, [r1, #0]
		gyro->gyroValueY = (Buffer[3] << 8) | (Buffer[2]);
 80007a2:	78c2      	ldrb	r2, [r0, #3]
 80007a4:	7883      	ldrb	r3, [r0, #2]
 80007a6:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80007aa:	804b      	strh	r3, [r1, #2]
		gyro->gyroValueZ = (Buffer[5] << 8) | (Buffer[4]);
 80007ac:	7942      	ldrb	r2, [r0, #5]
 80007ae:	7903      	ldrb	r3, [r0, #4]
 80007b0:	e009      	b.n	80007c6 <Gyro_convert+0x32>
	}
	else
	{
		gyro->gyroValueX = (Buffer[0] << 8) | (Buffer[1]);
 80007b2:	ea43 2304 	orr.w	r3, r3, r4, lsl #8
 80007b6:	800b      	strh	r3, [r1, #0]
		gyro->gyroValueY = (Buffer[2] << 8) | (Buffer[3]);
 80007b8:	7882      	ldrb	r2, [r0, #2]
 80007ba:	78c3      	ldrb	r3, [r0, #3]
 80007bc:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80007c0:	804b      	strh	r3, [r1, #2]
		gyro->gyroValueZ = (Buffer[4] << 8) | (Buffer[5]);
 80007c2:	7902      	ldrb	r2, [r0, #4]
 80007c4:	7943      	ldrb	r3, [r0, #5]
 80007c6:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80007ca:	808b      	strh	r3, [r1, #4]
 80007cc:	bd10      	pop	{r4, pc}

080007ce <Gyro_readValues>:
	}
}


void Gyro_readValues (struct gyroValues *gyro)
{
 80007ce:	b530      	push	{r4, r5, lr}
 80007d0:	b085      	sub	sp, #20
  uint8_t tmpbuffer[6] ={0};
 80007d2:	2400      	movs	r4, #0
	}
}


void Gyro_readValues (struct gyroValues *gyro)
{
 80007d4:	4605      	mov	r5, r0
  uint8_t tmpbuffer[6] ={0};
  uint8_t tmpreg = 0;
 80007d6:	a804      	add	r0, sp, #16
 80007d8:	f800 4d09 	strb.w	r4, [r0, #-9]!

  L3GD20_Read(&tmpreg,L3GD20_CTRL_REG4_ADDR,1);
 80007dc:	2123      	movs	r1, #35	; 0x23
 80007de:	2201      	movs	r2, #1
}


void Gyro_readValues (struct gyroValues *gyro)
{
  uint8_t tmpbuffer[6] ={0};
 80007e0:	9402      	str	r4, [sp, #8]
 80007e2:	f8ad 400c 	strh.w	r4, [sp, #12]
  uint8_t tmpreg = 0;

  L3GD20_Read(&tmpreg,L3GD20_CTRL_REG4_ADDR,1);
 80007e6:	f7ff ffb3 	bl	8000750 <L3GD20_Read>
  L3GD20_Read(tmpbuffer,L3GD20_OUT_X_L_ADDR,6);
 80007ea:	a802      	add	r0, sp, #8
 80007ec:	2128      	movs	r1, #40	; 0x28
 80007ee:	2206      	movs	r2, #6
 80007f0:	f7ff ffae 	bl	8000750 <L3GD20_Read>

  /* check in the control register 4 the data alignment (Big Endian or Little Endian)*/
  if(!(tmpreg & 0x40))
 80007f4:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80007f8:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80007fc:	b2db      	uxtb	r3, r3
 80007fe:	b9ab      	cbnz	r3, 800082c <Gyro_readValues+0x5e>

void Gyro_convert(uint8_t Buffer[6], struct gyroValues *gyro, uint8_t bigEndian)
{
	if(bigEndian)
	{
		gyro->gyroValueX = (Buffer[1] << 8) | (Buffer[0]);
 8000800:	f89d 2009 	ldrb.w	r2, [sp, #9]
 8000804:	f89d 3008 	ldrb.w	r3, [sp, #8]
 8000808:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 800080c:	802b      	strh	r3, [r5, #0]
		gyro->gyroValueY = (Buffer[3] << 8) | (Buffer[2]);
 800080e:	f89d 200b 	ldrb.w	r2, [sp, #11]
 8000812:	f89d 300a 	ldrb.w	r3, [sp, #10]
 8000816:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 800081a:	806b      	strh	r3, [r5, #2]
		gyro->gyroValueZ = (Buffer[5] << 8) | (Buffer[4]);
 800081c:	f89d 200d 	ldrb.w	r2, [sp, #13]
 8000820:	f89d 300c 	ldrb.w	r3, [sp, #12]
 8000824:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8000828:	80ab      	strh	r3, [r5, #4]
 800082a:	e004      	b.n	8000836 <Gyro_readValues+0x68>
  {
	Gyro_convert(&tmpbuffer[0], gyro, 1);
  }
  else
  {
   	Gyro_convert(&tmpbuffer[0], gyro, 0);
 800082c:	a802      	add	r0, sp, #8
 800082e:	4629      	mov	r1, r5
 8000830:	4622      	mov	r2, r4
 8000832:	f7ff ffaf 	bl	8000794 <Gyro_convert>
  }
}
 8000836:	b005      	add	sp, #20
 8000838:	bd30      	pop	{r4, r5, pc}

0800083a <Gyro_calibrate>:



//ACC und GYRO kalibrieren:
void Gyro_calibrate(struct gyroValues *gyroOffset)
{
 800083a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800083e:	4604      	mov	r4, r0
int i = 0;
int32_t tmpX = 0;
int32_t tmpY = 0;
int32_t tmpZ = 0;

L3GD20_Init();
 8000840:	f7ff ff48 	bl	80006d4 <L3GD20_Init>
 8000844:	2564      	movs	r5, #100	; 0x64

//discard the first 100 values
for(i=0;i<100;i++)
{
	Gyro_readValues(gyroOffset);
 8000846:	4620      	mov	r0, r4
 8000848:	f7ff ffc1 	bl	80007ce <Gyro_readValues>
int32_t tmpZ = 0;

L3GD20_Init();

//discard the first 100 values
for(i=0;i<100;i++)
 800084c:	3d01      	subs	r5, #1
 800084e:	d1fa      	bne.n	8000846 <Gyro_calibrate+0xc>
{
	Gyro_readValues(gyroOffset);
}

gyroOffset->gyroValueX = 0;
 8000850:	8025      	strh	r5, [r4, #0]
gyroOffset->gyroValueY = 0;
 8000852:	8065      	strh	r5, [r4, #2]
gyroOffset->gyroValueZ = 0;
 8000854:	80a5      	strh	r5, [r4, #4]
 8000856:	f44f 7896 	mov.w	r8, #300	; 0x12c
//ACC und GYRO kalibrieren:
void Gyro_calibrate(struct gyroValues *gyroOffset)
{
int i = 0;
int32_t tmpX = 0;
int32_t tmpY = 0;
 800085a:	462e      	mov	r6, r5

//ACC und GYRO kalibrieren:
void Gyro_calibrate(struct gyroValues *gyroOffset)
{
int i = 0;
int32_t tmpX = 0;
 800085c:	462f      	mov	r7, r5

/***************Calibrate the Gyro***************/
for(i=0;i<average_loop_value;i++)
{

	Gyro_readValues(gyroOffset);
 800085e:	4620      	mov	r0, r4
 8000860:	f7ff ffb5 	bl	80007ce <Gyro_readValues>
	tmpX += gyroOffset->gyroValueX;
 8000864:	f9b4 3000 	ldrsh.w	r3, [r4]
gyroOffset->gyroValueX = 0;
gyroOffset->gyroValueY = 0;
gyroOffset->gyroValueZ = 0;

/***************Calibrate the Gyro***************/
for(i=0;i<average_loop_value;i++)
 8000868:	f1b8 0801 	subs.w	r8, r8, #1
{

	Gyro_readValues(gyroOffset);
	tmpX += gyroOffset->gyroValueX;
 800086c:	441f      	add	r7, r3
	tmpY += gyroOffset->gyroValueY;
 800086e:	f9b4 3002 	ldrsh.w	r3, [r4, #2]
 8000872:	441e      	add	r6, r3
	tmpZ += gyroOffset->gyroValueZ;
 8000874:	f9b4 3004 	ldrsh.w	r3, [r4, #4]
 8000878:	441d      	add	r5, r3
gyroOffset->gyroValueX = 0;
gyroOffset->gyroValueY = 0;
gyroOffset->gyroValueZ = 0;

/***************Calibrate the Gyro***************/
for(i=0;i<average_loop_value;i++)
 800087a:	d1f0      	bne.n	800085e <Gyro_calibrate+0x24>
	tmpX += gyroOffset->gyroValueX;
	tmpY += gyroOffset->gyroValueY;
	tmpZ += gyroOffset->gyroValueZ;
}

gyroOffset->gyroValueX = tmpX/average_loop_value;
 800087c:	f44f 7396 	mov.w	r3, #300	; 0x12c
 8000880:	fb97 f7f3 	sdiv	r7, r7, r3
gyroOffset->gyroValueY = tmpY/average_loop_value;
 8000884:	fb96 f6f3 	sdiv	r6, r6, r3
gyroOffset->gyroValueZ = tmpZ/average_loop_value;
 8000888:	fb95 f5f3 	sdiv	r5, r5, r3
	tmpX += gyroOffset->gyroValueX;
	tmpY += gyroOffset->gyroValueY;
	tmpZ += gyroOffset->gyroValueZ;
}

gyroOffset->gyroValueX = tmpX/average_loop_value;
 800088c:	8027      	strh	r7, [r4, #0]
gyroOffset->gyroValueY = tmpY/average_loop_value;
 800088e:	8066      	strh	r6, [r4, #2]
gyroOffset->gyroValueZ = tmpZ/average_loop_value;
 8000890:	80a5      	strh	r5, [r4, #4]
 8000892:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8000896:	bf00      	nop

08000898 <LSM303DLHC_Write>:
#include <LSM303DLHC_Lib_I2C.h>


void LSM303DLHC_Write(uint8_t DeviceAddr, uint8_t RegAddr, uint8_t* pBuffer)
{
 8000898:	b573      	push	{r0, r1, r4, r5, r6, lr}
 800089a:	4604      	mov	r4, r0
 800089c:	460e      	mov	r6, r1
 800089e:	4615      	mov	r5, r2
  /* Test on BUSY Flag */
  while(I2C_GetFlagStatus(LSM303DLHC_I2C, I2C_ISR_BUSY) != RESET)
 80008a0:	4820      	ldr	r0, [pc, #128]	; (8000924 <LSM303DLHC_Write+0x8c>)
 80008a2:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 80008a6:	f003 f9fc 	bl	8003ca2 <I2C_GetFlagStatus>
 80008aa:	2800      	cmp	r0, #0
 80008ac:	d1f8      	bne.n	80008a0 <LSM303DLHC_Write+0x8>
  {
  }

  /* Configure slave address, nbytes, reload, end mode and start or stop generation */
  I2C_TransferHandling(LSM303DLHC_I2C, DeviceAddr, 1, I2C_Reload_Mode, I2C_Generate_Start_Write);
 80008ae:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 80008b2:	9300      	str	r3, [sp, #0]
 80008b4:	481b      	ldr	r0, [pc, #108]	; (8000924 <LSM303DLHC_Write+0x8c>)
 80008b6:	4621      	mov	r1, r4
 80008b8:	2201      	movs	r2, #1
 80008ba:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 80008be:	f003 f976 	bl	8003bae <I2C_TransferHandling>

  /* Wait until TXIS flag is set */
  while(I2C_GetFlagStatus(LSM303DLHC_I2C, I2C_ISR_TXIS) == RESET)
 80008c2:	4818      	ldr	r0, [pc, #96]	; (8000924 <LSM303DLHC_Write+0x8c>)
 80008c4:	2102      	movs	r1, #2
 80008c6:	f003 f9ec 	bl	8003ca2 <I2C_GetFlagStatus>
 80008ca:	2800      	cmp	r0, #0
 80008cc:	d0f9      	beq.n	80008c2 <LSM303DLHC_Write+0x2a>
  {
  }

  /* Send Register address */
  I2C_SendData(LSM303DLHC_I2C, (uint8_t) RegAddr);
 80008ce:	4815      	ldr	r0, [pc, #84]	; (8000924 <LSM303DLHC_Write+0x8c>)
 80008d0:	4631      	mov	r1, r6
 80008d2:	f003 f9d9 	bl	8003c88 <I2C_SendData>

  /* Wait until TCR flag is set */
  while(I2C_GetFlagStatus(LSM303DLHC_I2C, I2C_ISR_TCR) == RESET)
 80008d6:	4813      	ldr	r0, [pc, #76]	; (8000924 <LSM303DLHC_Write+0x8c>)
 80008d8:	2180      	movs	r1, #128	; 0x80
 80008da:	f003 f9e2 	bl	8003ca2 <I2C_GetFlagStatus>
 80008de:	2800      	cmp	r0, #0
 80008e0:	d0f9      	beq.n	80008d6 <LSM303DLHC_Write+0x3e>
  {
  }

  /* Configure slave address, nbytes, reload, end mode and start or stop generation */
  I2C_TransferHandling(LSM303DLHC_I2C, DeviceAddr, 1, I2C_AutoEnd_Mode, I2C_No_StartStop);
 80008e2:	2300      	movs	r3, #0
 80008e4:	9300      	str	r3, [sp, #0]
 80008e6:	480f      	ldr	r0, [pc, #60]	; (8000924 <LSM303DLHC_Write+0x8c>)
 80008e8:	4621      	mov	r1, r4
 80008ea:	2201      	movs	r2, #1
 80008ec:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 80008f0:	f003 f95d 	bl	8003bae <I2C_TransferHandling>

  /* Wait until TXIS flag is set */
  while(I2C_GetFlagStatus(LSM303DLHC_I2C, I2C_ISR_TXIS) == RESET)
 80008f4:	480b      	ldr	r0, [pc, #44]	; (8000924 <LSM303DLHC_Write+0x8c>)
 80008f6:	2102      	movs	r1, #2
 80008f8:	f003 f9d3 	bl	8003ca2 <I2C_GetFlagStatus>
 80008fc:	2800      	cmp	r0, #0
 80008fe:	d0f9      	beq.n	80008f4 <LSM303DLHC_Write+0x5c>
  {
  }

  /* Write data to TXDR */
  I2C_SendData(LSM303DLHC_I2C, *pBuffer);
 8000900:	4808      	ldr	r0, [pc, #32]	; (8000924 <LSM303DLHC_Write+0x8c>)
 8000902:	7829      	ldrb	r1, [r5, #0]
 8000904:	f003 f9c0 	bl	8003c88 <I2C_SendData>

  /* Wait until STOPF flag is set */
  while(I2C_GetFlagStatus(LSM303DLHC_I2C, I2C_ISR_STOPF) == RESET)
 8000908:	4806      	ldr	r0, [pc, #24]	; (8000924 <LSM303DLHC_Write+0x8c>)
 800090a:	2120      	movs	r1, #32
 800090c:	f003 f9c9 	bl	8003ca2 <I2C_GetFlagStatus>
 8000910:	2800      	cmp	r0, #0
 8000912:	d0f9      	beq.n	8000908 <LSM303DLHC_Write+0x70>
  {
  }

  /* Clear STOPF flag */
  I2C_ClearFlag(LSM303DLHC_I2C, I2C_ICR_STOPCF);
 8000914:	4803      	ldr	r0, [pc, #12]	; (8000924 <LSM303DLHC_Write+0x8c>)
 8000916:	2120      	movs	r1, #32
}
 8000918:	b002      	add	sp, #8
 800091a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  while(I2C_GetFlagStatus(LSM303DLHC_I2C, I2C_ISR_STOPF) == RESET)
  {
  }

  /* Clear STOPF flag */
  I2C_ClearFlag(LSM303DLHC_I2C, I2C_ICR_STOPCF);
 800091e:	f003 b9c6 	b.w	8003cae <I2C_ClearFlag>
 8000922:	bf00      	nop
 8000924:	40005400 	.word	0x40005400

08000928 <LSM303DLHC_Read>:
}


void LSM303DLHC_Read(uint8_t DeviceAddr, uint8_t RegAddr, uint8_t* pBuffer, uint16_t NumByteToRead)
{
 8000928:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800092a:	4607      	mov	r7, r0
 800092c:	460d      	mov	r5, r1
 800092e:	4616      	mov	r6, r2
 8000930:	461c      	mov	r4, r3
  /* Test on BUSY Flag */
  while(I2C_GetFlagStatus(LSM303DLHC_I2C, I2C_ISR_BUSY) != RESET)
 8000932:	4825      	ldr	r0, [pc, #148]	; (80009c8 <LSM303DLHC_Read+0xa0>)
 8000934:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8000938:	f003 f9b3 	bl	8003ca2 <I2C_GetFlagStatus>
 800093c:	4603      	mov	r3, r0
 800093e:	2800      	cmp	r0, #0
 8000940:	d1f7      	bne.n	8000932 <LSM303DLHC_Read+0xa>
  {
  }

  /* Configure slave address, nbytes, reload, end mode and start or stop generation */
  I2C_TransferHandling(LSM303DLHC_I2C, DeviceAddr, 1, I2C_SoftEnd_Mode, I2C_Generate_Start_Write);
 8000942:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8000946:	9200      	str	r2, [sp, #0]
 8000948:	481f      	ldr	r0, [pc, #124]	; (80009c8 <LSM303DLHC_Read+0xa0>)
 800094a:	4639      	mov	r1, r7
 800094c:	2201      	movs	r2, #1
 800094e:	f003 f92e 	bl	8003bae <I2C_TransferHandling>

  /* Wait until TXIS flag is set */
  while(I2C_GetFlagStatus(LSM303DLHC_I2C, I2C_ISR_TXIS) == RESET)
 8000952:	481d      	ldr	r0, [pc, #116]	; (80009c8 <LSM303DLHC_Read+0xa0>)
 8000954:	2102      	movs	r1, #2
 8000956:	f003 f9a4 	bl	8003ca2 <I2C_GetFlagStatus>
 800095a:	2800      	cmp	r0, #0
 800095c:	d0f9      	beq.n	8000952 <LSM303DLHC_Read+0x2a>
  {
  }

  if(NumByteToRead>1)
 800095e:	2c01      	cmp	r4, #1
      RegAddr |= 0x80;
 8000960:	bf88      	it	hi
 8000962:	f045 0580 	orrhi.w	r5, r5, #128	; 0x80


  /* Send Register address */
  I2C_SendData(LSM303DLHC_I2C, (uint8_t)RegAddr);
 8000966:	4818      	ldr	r0, [pc, #96]	; (80009c8 <LSM303DLHC_Read+0xa0>)
 8000968:	4629      	mov	r1, r5
 800096a:	f003 f98d 	bl	8003c88 <I2C_SendData>

  /* Wait until TC flag is set */
  while(I2C_GetFlagStatus(LSM303DLHC_I2C, I2C_ISR_TC) == RESET)
 800096e:	4816      	ldr	r0, [pc, #88]	; (80009c8 <LSM303DLHC_Read+0xa0>)
 8000970:	2140      	movs	r1, #64	; 0x40
 8000972:	f003 f996 	bl	8003ca2 <I2C_GetFlagStatus>
 8000976:	2800      	cmp	r0, #0
 8000978:	d0f9      	beq.n	800096e <LSM303DLHC_Read+0x46>
  {
  }

  /* Configure slave address, nbytes, reload, end mode and start or stop generation */
  I2C_TransferHandling(LSM303DLHC_I2C, DeviceAddr, NumByteToRead, I2C_AutoEnd_Mode, I2C_Generate_Start_Read);
 800097a:	f44f 5310 	mov.w	r3, #9216	; 0x2400
 800097e:	9300      	str	r3, [sp, #0]
 8000980:	4811      	ldr	r0, [pc, #68]	; (80009c8 <LSM303DLHC_Read+0xa0>)
 8000982:	4639      	mov	r1, r7
 8000984:	b2e2      	uxtb	r2, r4
 8000986:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800098a:	f003 f910 	bl	8003bae <I2C_TransferHandling>

  /* Wait until all data are received */
  while (NumByteToRead)
 800098e:	e00c      	b.n	80009aa <LSM303DLHC_Read+0x82>
  {
    /* Wait until RXNE flag is set */
    while(I2C_GetFlagStatus(LSM303DLHC_I2C, I2C_ISR_RXNE) == RESET)
 8000990:	480d      	ldr	r0, [pc, #52]	; (80009c8 <LSM303DLHC_Read+0xa0>)
 8000992:	2104      	movs	r1, #4
 8000994:	f003 f985 	bl	8003ca2 <I2C_GetFlagStatus>
 8000998:	2800      	cmp	r0, #0
 800099a:	d0f9      	beq.n	8000990 <LSM303DLHC_Read+0x68>
    {
    }

    /* Read data from RXDR */
    *pBuffer = I2C_ReceiveData(LSM303DLHC_I2C);
 800099c:	480a      	ldr	r0, [pc, #40]	; (80009c8 <LSM303DLHC_Read+0xa0>)
 800099e:	f003 f975 	bl	8003c8c <I2C_ReceiveData>
    /* Point to the next location where the byte read will be saved */
    pBuffer++;

    /* Decrement the read bytes counter */
    NumByteToRead--;
 80009a2:	3c01      	subs	r4, #1
    while(I2C_GetFlagStatus(LSM303DLHC_I2C, I2C_ISR_RXNE) == RESET)
    {
    }

    /* Read data from RXDR */
    *pBuffer = I2C_ReceiveData(LSM303DLHC_I2C);
 80009a4:	f806 0b01 	strb.w	r0, [r6], #1
    /* Point to the next location where the byte read will be saved */
    pBuffer++;

    /* Decrement the read bytes counter */
    NumByteToRead--;
 80009a8:	b2a4      	uxth	r4, r4

  /* Configure slave address, nbytes, reload, end mode and start or stop generation */
  I2C_TransferHandling(LSM303DLHC_I2C, DeviceAddr, NumByteToRead, I2C_AutoEnd_Mode, I2C_Generate_Start_Read);

  /* Wait until all data are received */
  while (NumByteToRead)
 80009aa:	2c00      	cmp	r4, #0
 80009ac:	d1f0      	bne.n	8000990 <LSM303DLHC_Read+0x68>
    /* Decrement the read bytes counter */
    NumByteToRead--;
  }

  /* Wait until STOPF flag is set */
  while(I2C_GetFlagStatus(LSM303DLHC_I2C, I2C_ISR_STOPF) == RESET)
 80009ae:	4806      	ldr	r0, [pc, #24]	; (80009c8 <LSM303DLHC_Read+0xa0>)
 80009b0:	2120      	movs	r1, #32
 80009b2:	f003 f976 	bl	8003ca2 <I2C_GetFlagStatus>
 80009b6:	2800      	cmp	r0, #0
 80009b8:	d0f9      	beq.n	80009ae <LSM303DLHC_Read+0x86>
  {
  }

  /* Clear STOPF flag */
  I2C_ClearFlag(LSM303DLHC_I2C, I2C_ICR_STOPCF);
 80009ba:	4803      	ldr	r0, [pc, #12]	; (80009c8 <LSM303DLHC_Read+0xa0>)
 80009bc:	2120      	movs	r1, #32
}
 80009be:	b003      	add	sp, #12
 80009c0:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  while(I2C_GetFlagStatus(LSM303DLHC_I2C, I2C_ISR_STOPF) == RESET)
  {
  }

  /* Clear STOPF flag */
  I2C_ClearFlag(LSM303DLHC_I2C, I2C_ICR_STOPCF);
 80009c4:	f003 b973 	b.w	8003cae <I2C_ClearFlag>
 80009c8:	40005400 	.word	0x40005400

080009cc <LSM303DLHC_ReadDMA>:
}

void LSM303DLHC_ReadDMA(uint8_t DeviceAddr, uint8_t RegAddr, uint8_t* pBuffer, uint16_t NumByteToRead)
{
 80009cc:	b573      	push	{r0, r1, r4, r5, r6, lr}
 80009ce:	4606      	mov	r6, r0
 80009d0:	460c      	mov	r4, r1
 80009d2:	461d      	mov	r5, r3
//	  return;
//  }

  //DMA_Configuration(pBuffer);
  /* Test on BUSY Flag */
  while(I2C_GetFlagStatus(LSM303DLHC_I2C, I2C_ISR_BUSY) != RESET)
 80009d4:	482c      	ldr	r0, [pc, #176]	; (8000a88 <LSM303DLHC_ReadDMA+0xbc>)
 80009d6:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 80009da:	f003 f962 	bl	8003ca2 <I2C_GetFlagStatus>
 80009de:	4603      	mov	r3, r0
 80009e0:	2800      	cmp	r0, #0
 80009e2:	d1f7      	bne.n	80009d4 <LSM303DLHC_ReadDMA+0x8>
  {
  }


  /* Configure slave address, nbytes, reload, end mode and start or stop generation */
  I2C_TransferHandling(LSM303DLHC_I2C, DeviceAddr, 1, I2C_SoftEnd_Mode, I2C_Generate_Start_Write);
 80009e4:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 80009e8:	9200      	str	r2, [sp, #0]
 80009ea:	4827      	ldr	r0, [pc, #156]	; (8000a88 <LSM303DLHC_ReadDMA+0xbc>)
 80009ec:	4631      	mov	r1, r6
 80009ee:	2201      	movs	r2, #1
 80009f0:	f003 f8dd 	bl	8003bae <I2C_TransferHandling>

  /* Wait until TXIS flag is set */
  while(I2C_GetFlagStatus(LSM303DLHC_I2C, I2C_ISR_TXIS) == RESET)
 80009f4:	4824      	ldr	r0, [pc, #144]	; (8000a88 <LSM303DLHC_ReadDMA+0xbc>)
 80009f6:	2102      	movs	r1, #2
 80009f8:	f003 f953 	bl	8003ca2 <I2C_GetFlagStatus>
 80009fc:	2800      	cmp	r0, #0
 80009fe:	d0f9      	beq.n	80009f4 <LSM303DLHC_ReadDMA+0x28>
  {
  }

  if(NumByteToRead>1)
 8000a00:	2d01      	cmp	r5, #1
      RegAddr |= 0x80;
 8000a02:	bf88      	it	hi
 8000a04:	f044 0480 	orrhi.w	r4, r4, #128	; 0x80

  //printf("M2%d ", 0);

  /* Send Register address */
  I2C_SendData(LSM303DLHC_I2C, (uint8_t)RegAddr);
 8000a08:	481f      	ldr	r0, [pc, #124]	; (8000a88 <LSM303DLHC_ReadDMA+0xbc>)
 8000a0a:	4621      	mov	r1, r4
 8000a0c:	f003 f93c 	bl	8003c88 <I2C_SendData>

  /* Wait until TXIS flag is set */
  while(I2C_GetFlagStatus(LSM303DLHC_I2C, I2C_ISR_TC) == RESET)
 8000a10:	481d      	ldr	r0, [pc, #116]	; (8000a88 <LSM303DLHC_ReadDMA+0xbc>)
 8000a12:	2140      	movs	r1, #64	; 0x40
 8000a14:	f003 f945 	bl	8003ca2 <I2C_GetFlagStatus>
 8000a18:	2800      	cmp	r0, #0
 8000a1a:	d0f9      	beq.n	8000a10 <LSM303DLHC_ReadDMA+0x44>
//  I2C_MasterRequestConfig(LSM303DLHC_I2C, I2C_Direction_Receiver);
//  I2C_GenerateSTART(LSM303DLHC_I2C, ENABLE);
//  I2C_SlaveAddressConfig(LSM303DLHC_I2C, DeviceAddr);
  //I2C_MasterRequestConfig(LSM303DLHC_I2C, I2C_Direction_Receiver);
  /* Configure slave address, nbytes, reload, end mode and start or stop generation */
  I2C_TransferHandling(LSM303DLHC_I2C, DeviceAddr, NumByteToRead, I2C_AutoEnd_Mode, I2C_Generate_Start_Read);
 8000a1c:	f44f 5310 	mov.w	r3, #9216	; 0x2400
 8000a20:	9300      	str	r3, [sp, #0]
 8000a22:	4819      	ldr	r0, [pc, #100]	; (8000a88 <LSM303DLHC_ReadDMA+0xbc>)
 8000a24:	4631      	mov	r1, r6
 8000a26:	b2ea      	uxtb	r2, r5
 8000a28:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8000a2c:	f003 f8bf 	bl	8003bae <I2C_TransferHandling>

  /* Enable DMA1 Channel5 */
  I2C_DMACmd(LSM303DLHC_I2C, I2C_DMAReq_Rx, ENABLE);
 8000a30:	4815      	ldr	r0, [pc, #84]	; (8000a88 <LSM303DLHC_ReadDMA+0xbc>)
 8000a32:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8000a36:	2201      	movs	r2, #1
 8000a38:	f003 f92b 	bl	8003c92 <I2C_DMACmd>
DMA_Cmd(DMA1_Channel7, ENABLE);
 8000a3c:	4813      	ldr	r0, [pc, #76]	; (8000a8c <LSM303DLHC_ReadDMA+0xc0>)
 8000a3e:	2101      	movs	r1, #1
 8000a40:	f002 fd7e 	bl	8003540 <DMA_Cmd>
//  }

//printf("M4%d ", 0);

  /* DMA1 Channel1 transfer complete test */
  while(!DMA_GetFlagStatus(DMA1_FLAG_TC7));
 8000a44:	f04f 7000 	mov.w	r0, #33554432	; 0x2000000
 8000a48:	f002 fd92 	bl	8003570 <DMA_GetFlagStatus>
 8000a4c:	2800      	cmp	r0, #0
 8000a4e:	d0f9      	beq.n	8000a44 <LSM303DLHC_ReadDMA+0x78>

  //printf("M5%d ", 0);

  DMA_ClearFlag(DMA1_FLAG_GL7);
 8000a50:	f04f 7080 	mov.w	r0, #16777216	; 0x1000000
 8000a54:	f002 fd9a 	bl	800358c <DMA_ClearFlag>

  I2C_DMACmd(LSM303DLHC_I2C, I2C_DMAReq_Rx, DISABLE);
 8000a58:	480b      	ldr	r0, [pc, #44]	; (8000a88 <LSM303DLHC_ReadDMA+0xbc>)
 8000a5a:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8000a5e:	2200      	movs	r2, #0
 8000a60:	f003 f917 	bl	8003c92 <I2C_DMACmd>
  DMA_Cmd(DMA1_Channel7, DISABLE);
 8000a64:	4809      	ldr	r0, [pc, #36]	; (8000a8c <LSM303DLHC_ReadDMA+0xc0>)
 8000a66:	2100      	movs	r1, #0
 8000a68:	f002 fd6a 	bl	8003540 <DMA_Cmd>
  //GPIO_SetBits(GPIOE,GPIO_Pin_9);

  //I2C_GenerateSTOP(LSM303DLHC_I2C, ENABLE);

  /* Wait until STOPF flag is set */
  while(I2C_GetFlagStatus(LSM303DLHC_I2C, I2C_ISR_STOPF) == RESET)
 8000a6c:	4806      	ldr	r0, [pc, #24]	; (8000a88 <LSM303DLHC_ReadDMA+0xbc>)
 8000a6e:	2120      	movs	r1, #32
 8000a70:	f003 f917 	bl	8003ca2 <I2C_GetFlagStatus>
 8000a74:	2800      	cmp	r0, #0
 8000a76:	d0f9      	beq.n	8000a6c <LSM303DLHC_ReadDMA+0xa0>
  {
  }

  /* Clear STOPF flag */
  I2C_ClearFlag(LSM303DLHC_I2C, I2C_ICR_STOPCF);
 8000a78:	4803      	ldr	r0, [pc, #12]	; (8000a88 <LSM303DLHC_ReadDMA+0xbc>)
 8000a7a:	2120      	movs	r1, #32
}
 8000a7c:	b002      	add	sp, #8
 8000a7e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  while(I2C_GetFlagStatus(LSM303DLHC_I2C, I2C_ISR_STOPF) == RESET)
  {
  }

  /* Clear STOPF flag */
  I2C_ClearFlag(LSM303DLHC_I2C, I2C_ICR_STOPCF);
 8000a82:	f003 b914 	b.w	8003cae <I2C_ClearFlag>
 8000a86:	bf00      	nop
 8000a88:	40005400 	.word	0x40005400
 8000a8c:	40020080 	.word	0x40020080

08000a90 <LSM303DLHC_AccInit>:
}


#ifdef LSM303_ACC
void LSM303DLHC_AccInit(void)
{
 8000a90:	b507      	push	{r0, r1, r2, lr}
  uint8_t ctrl1 = 0x00, ctrl2 = 0x00, ctrl4 = 0x00;
 8000a92:	2300      	movs	r3, #0
 8000a94:	f88d 3006 	strb.w	r3, [sp, #6]

  /* Configure MEMS: data rate, power mode, full scale and axes */
//  ctrl1 |= (uint8_t) (LSM303DLHC_NORMAL_MODE | LSM303DLHC_ODR_200_HZ |
//		  	  	  	  LSM303DLHC_AXES_ENABLE);

    ctrl1 |= (uint8_t) (LSM303DLHC_NORMAL_MODE | LSM303DLHC_ODR_1344_HZ |
 8000a98:	2397      	movs	r3, #151	; 0x97
 8000a9a:	f88d 3005 	strb.w	r3, [sp, #5]
  		  	  	  	  LSM303DLHC_FULLSCALE_16G | LSM303DLHC_HR_ENABLE);

  //ctrl4 = 0x30;

  /* Write value to ACC MEMS CTRL_REG1 regsister */
  LSM303DLHC_Write(ACC_I2C_ADDRESS, LSM303DLHC_CTRL_REG1_A, &ctrl1);
 8000a9e:	2032      	movs	r0, #50	; 0x32


//  ctrl4 |= (uint8_t) (LSM303DLHC_BlockUpdate_Continous | LSM303DLHC_BLE_LSB |
//		  	  	  	  LSM303DLHC_FULLSCALE_16G | LSM303DLHC_HR_ENABLE);

  ctrl4 |= (uint8_t) (LSM303DLHC_BlockUpdate_Continous | LSM303DLHC_BLE_LSB |
 8000aa0:	2338      	movs	r3, #56	; 0x38
  		  	  	  	  LSM303DLHC_FULLSCALE_16G | LSM303DLHC_HR_ENABLE);

  //ctrl4 = 0x30;

  /* Write value to ACC MEMS CTRL_REG1 regsister */
  LSM303DLHC_Write(ACC_I2C_ADDRESS, LSM303DLHC_CTRL_REG1_A, &ctrl1);
 8000aa2:	2120      	movs	r1, #32
 8000aa4:	f10d 0205 	add.w	r2, sp, #5


//  ctrl4 |= (uint8_t) (LSM303DLHC_BlockUpdate_Continous | LSM303DLHC_BLE_LSB |
//		  	  	  	  LSM303DLHC_FULLSCALE_16G | LSM303DLHC_HR_ENABLE);

  ctrl4 |= (uint8_t) (LSM303DLHC_BlockUpdate_Continous | LSM303DLHC_BLE_LSB |
 8000aa8:	f88d 3007 	strb.w	r3, [sp, #7]
  		  	  	  	  LSM303DLHC_FULLSCALE_16G | LSM303DLHC_HR_ENABLE);

  //ctrl4 = 0x30;

  /* Write value to ACC MEMS CTRL_REG1 regsister */
  LSM303DLHC_Write(ACC_I2C_ADDRESS, LSM303DLHC_CTRL_REG1_A, &ctrl1);
 8000aac:	f7ff fef4 	bl	8000898 <LSM303DLHC_Write>

  /* Write value to ACC MEMS CTRL_REG2 regsister */
  LSM303DLHC_Write(ACC_I2C_ADDRESS, LSM303DLHC_CTRL_REG2_A, &ctrl2);
 8000ab0:	2032      	movs	r0, #50	; 0x32
 8000ab2:	2121      	movs	r1, #33	; 0x21
 8000ab4:	f10d 0206 	add.w	r2, sp, #6
 8000ab8:	f7ff feee 	bl	8000898 <LSM303DLHC_Write>

  /* Write value to ACC MEMS CTRL_REG4 regsister */
  LSM303DLHC_Write(ACC_I2C_ADDRESS, LSM303DLHC_CTRL_REG4_A, &ctrl4);
 8000abc:	2032      	movs	r0, #50	; 0x32
 8000abe:	2123      	movs	r1, #35	; 0x23
 8000ac0:	f10d 0207 	add.w	r2, sp, #7
 8000ac4:	f7ff fee8 	bl	8000898 <LSM303DLHC_Write>
}
 8000ac8:	bd0e      	pop	{r1, r2, r3, pc}

08000aca <LSM303DLHC_ACC_readValues>:
	Acc_values->accGValue = Acc_values->accGValue*maxGOverflow;
}


void LSM303DLHC_ACC_readValues(struct accValues *accXYZ)
{
 8000aca:	b513      	push	{r0, r1, r4, lr}
	uint8_t buffer[6], cDivider;

	LSM303DLHC_Read(ACC_I2C_ADDRESS, LSM303DLHC_OUT_X_L_A, buffer, 6);
 8000acc:	2306      	movs	r3, #6
	Acc_values->accGValue = Acc_values->accGValue*maxGOverflow;
}


void LSM303DLHC_ACC_readValues(struct accValues *accXYZ)
{
 8000ace:	4604      	mov	r4, r0
	uint8_t buffer[6], cDivider;

	LSM303DLHC_Read(ACC_I2C_ADDRESS, LSM303DLHC_OUT_X_L_A, buffer, 6);
 8000ad0:	2128      	movs	r1, #40	; 0x28
 8000ad2:	466a      	mov	r2, sp
 8000ad4:	2032      	movs	r0, #50	; 0x32
 8000ad6:	f7ff ff27 	bl	8000928 <LSM303DLHC_Read>

	cDivider=16;

	/* check in the control register4 the data alignment */
	accXYZ->accValueX = ((int16_t)((uint16_t)buffer[1] << 8) + buffer[0])/cDivider;
 8000ada:	f89d 3000 	ldrb.w	r3, [sp]
 8000ade:	f99d 2001 	ldrsb.w	r2, [sp, #1]
	accXYZ->accValueY = ((int16_t)((uint16_t)buffer[3] << 8) + buffer[2])/cDivider;
 8000ae2:	f99d 1003 	ldrsb.w	r1, [sp, #3]
	LSM303DLHC_Read(ACC_I2C_ADDRESS, LSM303DLHC_OUT_X_L_A, buffer, 6);

	cDivider=16;

	/* check in the control register4 the data alignment */
	accXYZ->accValueX = ((int16_t)((uint16_t)buffer[1] << 8) + buffer[0])/cDivider;
 8000ae6:	eb03 2202 	add.w	r2, r3, r2, lsl #8
 8000aea:	2310      	movs	r3, #16
 8000aec:	fb92 f2f3 	sdiv	r2, r2, r3
 8000af0:	8022      	strh	r2, [r4, #0]
	accXYZ->accValueY = ((int16_t)((uint16_t)buffer[3] << 8) + buffer[2])/cDivider;
 8000af2:	f89d 2002 	ldrb.w	r2, [sp, #2]
 8000af6:	eb02 2201 	add.w	r2, r2, r1, lsl #8
 8000afa:	fb92 f2f3 	sdiv	r2, r2, r3
 8000afe:	8062      	strh	r2, [r4, #2]
	accXYZ->accValueZ = ((int16_t)((uint16_t)buffer[5] << 8) + buffer[4])/cDivider;
 8000b00:	f99d 1005 	ldrsb.w	r1, [sp, #5]
 8000b04:	f89d 2004 	ldrb.w	r2, [sp, #4]
 8000b08:	eb02 2201 	add.w	r2, r2, r1, lsl #8
 8000b0c:	fb92 f3f3 	sdiv	r3, r2, r3
 8000b10:	80a3      	strh	r3, [r4, #4]
}
 8000b12:	bd1c      	pop	{r2, r3, r4, pc}

08000b14 <LSM303DLHC_ACC_calibrate>:
  LSM303DLHC_Write(ACC_I2C_ADDRESS, LSM303DLHC_CTRL_REG4_A, &ctrl4);
}


void LSM303DLHC_ACC_calibrate(float maxGOverflow, struct accValues *Acc_values)
{
 8000b14:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8000b18:	4681      	mov	r9, r0
 8000b1a:	460c      	mov	r4, r1
	u8 i;
	uint32_t tmpX = 0;
	uint32_t tmpY = 0;
	uint32_t tmpZ = 0;

	LSM303DLHC_AccInit();
 8000b1c:	f7ff ffb8 	bl	8000a90 <LSM303DLHC_AccInit>
void LSM303DLHC_ACC_calibrate(float maxGOverflow, struct accValues *Acc_values)
{
	u8 i;
	uint32_t tmpX = 0;
	uint32_t tmpY = 0;
	uint32_t tmpZ = 0;
 8000b20:	2500      	movs	r5, #0

	LSM303DLHC_AccInit();
 8000b22:	f04f 080a 	mov.w	r8, #10

void LSM303DLHC_ACC_calibrate(float maxGOverflow, struct accValues *Acc_values)
{
	u8 i;
	uint32_t tmpX = 0;
	uint32_t tmpY = 0;
 8000b26:	462e      	mov	r6, r5


void LSM303DLHC_ACC_calibrate(float maxGOverflow, struct accValues *Acc_values)
{
	u8 i;
	uint32_t tmpX = 0;
 8000b28:	462f      	mov	r7, r5

	LSM303DLHC_AccInit();

	for(i=0;i<AVG_ROUNDS;i++)
	{
		LSM303DLHC_ACC_readValues(Acc_values);
 8000b2a:	4620      	mov	r0, r4
 8000b2c:	f7ff ffcd 	bl	8000aca <LSM303DLHC_ACC_readValues>

		tmpX += (Acc_values->accValueX);
 8000b30:	f9b4 3000 	ldrsh.w	r3, [r4]
		tmpY += (Acc_values->accValueY);
		tmpZ += (Acc_values->accValueZ);

		Delay(INIT_DELAY_TIME/10);
 8000b34:	f643 2098 	movw	r0, #15000	; 0x3a98

	for(i=0;i<AVG_ROUNDS;i++)
	{
		LSM303DLHC_ACC_readValues(Acc_values);

		tmpX += (Acc_values->accValueX);
 8000b38:	18ff      	adds	r7, r7, r3
		tmpY += (Acc_values->accValueY);
 8000b3a:	f9b4 3002 	ldrsh.w	r3, [r4, #2]
 8000b3e:	f108 38ff 	add.w	r8, r8, #4294967295
 8000b42:	18f6      	adds	r6, r6, r3
		tmpZ += (Acc_values->accValueZ);
 8000b44:	f9b4 3004 	ldrsh.w	r3, [r4, #4]
 8000b48:	18ed      	adds	r5, r5, r3

		Delay(INIT_DELAY_TIME/10);
 8000b4a:	f001 f91b 	bl	8001d84 <Delay>
	uint32_t tmpY = 0;
	uint32_t tmpZ = 0;

	LSM303DLHC_AccInit();

	for(i=0;i<AVG_ROUNDS;i++)
 8000b4e:	f018 08ff 	ands.w	r8, r8, #255	; 0xff
 8000b52:	d1ea      	bne.n	8000b2a <LSM303DLHC_ACC_calibrate+0x16>
		tmpY += (Acc_values->accValueY);
		tmpZ += (Acc_values->accValueZ);

		Delay(INIT_DELAY_TIME/10);
	}
	Acc_values->accValueX = (tmpX/AVG_ROUNDS);
 8000b54:	230a      	movs	r3, #10
	Acc_values->accValueY = (tmpY/AVG_ROUNDS);
 8000b56:	fbb6 f6f3 	udiv	r6, r6, r3
 8000b5a:	8066      	strh	r6, [r4, #2]
	Acc_values->accValueZ = (tmpZ/AVG_ROUNDS);

	Acc_values->accGValue = sqrtf((Acc_values->accValueX*Acc_values->accValueX) +
									(Acc_values->accValueY*Acc_values->accValueY) +
 8000b5c:	b236      	sxth	r6, r6
 8000b5e:	4376      	muls	r6, r6
		tmpY += (Acc_values->accValueY);
		tmpZ += (Acc_values->accValueZ);

		Delay(INIT_DELAY_TIME/10);
	}
	Acc_values->accValueX = (tmpX/AVG_ROUNDS);
 8000b60:	fbb7 f7f3 	udiv	r7, r7, r3
 8000b64:	8027      	strh	r7, [r4, #0]
	Acc_values->accValueY = (tmpY/AVG_ROUNDS);
	Acc_values->accValueZ = (tmpZ/AVG_ROUNDS);

	Acc_values->accGValue = sqrtf((Acc_values->accValueX*Acc_values->accValueX) +
 8000b66:	b23f      	sxth	r7, r7
 8000b68:	fb07 6007 	mla	r0, r7, r7, r6

		Delay(INIT_DELAY_TIME/10);
	}
	Acc_values->accValueX = (tmpX/AVG_ROUNDS);
	Acc_values->accValueY = (tmpY/AVG_ROUNDS);
	Acc_values->accValueZ = (tmpZ/AVG_ROUNDS);
 8000b6c:	fbb5 f5f3 	udiv	r5, r5, r3
 8000b70:	80a5      	strh	r5, [r4, #4]

	Acc_values->accGValue = sqrtf((Acc_values->accValueX*Acc_values->accValueX) +
									(Acc_values->accValueY*Acc_values->accValueY) +
									(Acc_values->accValueZ*Acc_values->accValueZ));
 8000b72:	b22d      	sxth	r5, r5
	}
	Acc_values->accValueX = (tmpX/AVG_ROUNDS);
	Acc_values->accValueY = (tmpY/AVG_ROUNDS);
	Acc_values->accValueZ = (tmpZ/AVG_ROUNDS);

	Acc_values->accGValue = sqrtf((Acc_values->accValueX*Acc_values->accValueX) +
 8000b74:	fb05 0005 	mla	r0, r5, r5, r0
 8000b78:	f006 fe48 	bl	800780c <__aeabi_i2f>
 8000b7c:	f007 fb48 	bl	8008210 <sqrtf>
									(Acc_values->accValueY*Acc_values->accValueY) +
									(Acc_values->accValueZ*Acc_values->accValueZ));

	/* Allow some kind of overflow */
	Acc_values->accGValue = Acc_values->accGValue*maxGOverflow;
 8000b80:	4649      	mov	r1, r9
 8000b82:	f006 fe97 	bl	80078b4 <__aeabi_fmul>
 8000b86:	60a0      	str	r0, [r4, #8]
 8000b88:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

08000b8c <LSM303DLHC_ACC_readValuesDMA>:
	accXYZ->accValueY = ((int16_t)((uint16_t)buffer[3] << 8) + buffer[2])/cDivider;
	accXYZ->accValueZ = ((int16_t)((uint16_t)buffer[5] << 8) + buffer[4])/cDivider;
}

void LSM303DLHC_ACC_readValuesDMA(struct accValues *accXYZ, uint8_t *buffer)
{
 8000b8c:	b538      	push	{r3, r4, r5, lr}
 8000b8e:	460c      	mov	r4, r1
 8000b90:	4605      	mov	r5, r0
	uint8_t cDivider;

	/* Read the register content */
	LSM303DLHC_ReadDMA(ACC_I2C_ADDRESS, LSM303DLHC_OUT_X_L_A, buffer, 6);
 8000b92:	2128      	movs	r1, #40	; 0x28
 8000b94:	4622      	mov	r2, r4
 8000b96:	2306      	movs	r3, #6
 8000b98:	2032      	movs	r0, #50	; 0x32
 8000b9a:	f7ff ff17 	bl	80009cc <LSM303DLHC_ReadDMA>

	cDivider=16;

	// TODO Faster conversation
	// gyro->gyroValueX = (Buffer[1] << 8) | (Buffer[0]);
	accXYZ->accValueX = ((int16_t)((uint16_t)buffer[1] << 8) + buffer[0])/cDivider;
 8000b9e:	7823      	ldrb	r3, [r4, #0]
 8000ba0:	f994 2001 	ldrsb.w	r2, [r4, #1]
 8000ba4:	eb03 2202 	add.w	r2, r3, r2, lsl #8
 8000ba8:	2310      	movs	r3, #16
 8000baa:	fb92 f2f3 	sdiv	r2, r2, r3
 8000bae:	802a      	strh	r2, [r5, #0]
	accXYZ->accValueY = ((int16_t)((uint16_t)buffer[3] << 8) + buffer[2])/cDivider;
 8000bb0:	f994 1003 	ldrsb.w	r1, [r4, #3]
 8000bb4:	78a2      	ldrb	r2, [r4, #2]
 8000bb6:	eb02 2201 	add.w	r2, r2, r1, lsl #8
 8000bba:	fb92 f2f3 	sdiv	r2, r2, r3
 8000bbe:	806a      	strh	r2, [r5, #2]
	accXYZ->accValueZ = ((int16_t)((uint16_t)buffer[5] << 8) + buffer[4])/cDivider;
 8000bc0:	f994 1005 	ldrsb.w	r1, [r4, #5]
 8000bc4:	7922      	ldrb	r2, [r4, #4]
 8000bc6:	eb02 2201 	add.w	r2, r2, r1, lsl #8
 8000bca:	fb92 f3f3 	sdiv	r3, r2, r3
 8000bce:	80ab      	strh	r3, [r5, #4]
 8000bd0:	bd38      	pop	{r3, r4, r5, pc}

08000bd2 <Mag_calibrate>:
//}

#endif

void Mag_calibrate(void)
{
 8000bd2:	b507      	push	{r0, r1, r2, lr}
	uint8_t cra_regm = 0x00, crb_regm = 0x00, mr_regm = 0x00;

	/* Configure MEMS: temp and Data rate */
	cra_regm |= (uint8_t) (LSM303DLHC_TEMPSENSOR_DISABLE | LSM303DLHC_ODR_30_HZ);
 8000bd4:	2314      	movs	r3, #20

#endif

void Mag_calibrate(void)
{
	uint8_t cra_regm = 0x00, crb_regm = 0x00, mr_regm = 0x00;
 8000bd6:	2100      	movs	r1, #0

	/* Configure MEMS: temp and Data rate */
	cra_regm |= (uint8_t) (LSM303DLHC_TEMPSENSOR_DISABLE | LSM303DLHC_ODR_30_HZ);
 8000bd8:	f88d 3005 	strb.w	r3, [sp, #5]

	/* Configure MEMS: working mode */
	mr_regm |= (uint8_t) (LSM303DLHC_CONTINUOS_CONVERSION);

	/* Write value to Mag MEMS CRA_REG regsister */
	LSM303DLHC_Write(MAG_I2C_ADDRESS, LSM303DLHC_CRA_REG_M, &cra_regm);
 8000bdc:	203c      	movs	r0, #60	; 0x3c

	/* Configure MEMS: temp and Data rate */
	cra_regm |= (uint8_t) (LSM303DLHC_TEMPSENSOR_DISABLE | LSM303DLHC_ODR_30_HZ);

	/* Configure MEMS: full Scale */
	crb_regm |= (uint8_t) (LSM303DLHC_FS_8_1_GA);
 8000bde:	23e0      	movs	r3, #224	; 0xe0

	/* Configure MEMS: working mode */
	mr_regm |= (uint8_t) (LSM303DLHC_CONTINUOS_CONVERSION);

	/* Write value to Mag MEMS CRA_REG regsister */
	LSM303DLHC_Write(MAG_I2C_ADDRESS, LSM303DLHC_CRA_REG_M, &cra_regm);
 8000be0:	f10d 0205 	add.w	r2, sp, #5

#endif

void Mag_calibrate(void)
{
	uint8_t cra_regm = 0x00, crb_regm = 0x00, mr_regm = 0x00;
 8000be4:	f88d 1007 	strb.w	r1, [sp, #7]

	/* Configure MEMS: temp and Data rate */
	cra_regm |= (uint8_t) (LSM303DLHC_TEMPSENSOR_DISABLE | LSM303DLHC_ODR_30_HZ);

	/* Configure MEMS: full Scale */
	crb_regm |= (uint8_t) (LSM303DLHC_FS_8_1_GA);
 8000be8:	f88d 3006 	strb.w	r3, [sp, #6]

	/* Configure MEMS: working mode */
	mr_regm |= (uint8_t) (LSM303DLHC_CONTINUOS_CONVERSION);

	/* Write value to Mag MEMS CRA_REG regsister */
	LSM303DLHC_Write(MAG_I2C_ADDRESS, LSM303DLHC_CRA_REG_M, &cra_regm);
 8000bec:	f7ff fe54 	bl	8000898 <LSM303DLHC_Write>

	/* Write value to Mag MEMS CRB_REG regsister */
	LSM303DLHC_Write(MAG_I2C_ADDRESS, LSM303DLHC_CRB_REG_M, &crb_regm);
 8000bf0:	203c      	movs	r0, #60	; 0x3c
 8000bf2:	2101      	movs	r1, #1
 8000bf4:	f10d 0206 	add.w	r2, sp, #6
 8000bf8:	f7ff fe4e 	bl	8000898 <LSM303DLHC_Write>

	/* Write value to Mag MEMS MR_REG regsister */
	LSM303DLHC_Write(MAG_I2C_ADDRESS, LSM303DLHC_MR_REG_M, &mr_regm);
 8000bfc:	203c      	movs	r0, #60	; 0x3c
 8000bfe:	2102      	movs	r1, #2
 8000c00:	f10d 0207 	add.w	r2, sp, #7
 8000c04:	f7ff fe48 	bl	8000898 <LSM303DLHC_Write>
}
 8000c08:	bd0e      	pop	{r1, r2, r3, pc}

08000c0a <Mag_readValues>:


void Mag_readValues (struct magValues *magXYZ)
{
 8000c0a:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  static uint8_t buffer[6] = {0};
  uint8_t CTRLB = 0;
 8000c0e:	2300      	movs	r3, #0
  uint16_t Magn_Sensitivity_XY = 0, Magn_Sensitivity_Z = 0;
  LSM303DLHC_Read(MAG_I2C_ADDRESS, LSM303DLHC_CRB_REG_M, &CTRLB, 1);
 8000c10:	2101      	movs	r1, #1


void Mag_readValues (struct magValues *magXYZ)
{
  static uint8_t buffer[6] = {0};
  uint8_t CTRLB = 0;
 8000c12:	aa02      	add	r2, sp, #8
 8000c14:	f802 3d01 	strb.w	r3, [r2, #-1]!
	LSM303DLHC_Write(MAG_I2C_ADDRESS, LSM303DLHC_MR_REG_M, &mr_regm);
}


void Mag_readValues (struct magValues *magXYZ)
{
 8000c18:	4606      	mov	r6, r0
  static uint8_t buffer[6] = {0};
  uint8_t CTRLB = 0;
  uint16_t Magn_Sensitivity_XY = 0, Magn_Sensitivity_Z = 0;
  LSM303DLHC_Read(MAG_I2C_ADDRESS, LSM303DLHC_CRB_REG_M, &CTRLB, 1);
 8000c1a:	460b      	mov	r3, r1
 8000c1c:	203c      	movs	r0, #60	; 0x3c
 8000c1e:	f7ff fe83 	bl	8000928 <LSM303DLHC_Read>

  LSM303DLHC_Read(MAG_I2C_ADDRESS, LSM303DLHC_OUT_X_H_M, buffer, 6);
 8000c22:	2306      	movs	r3, #6
 8000c24:	203c      	movs	r0, #60	; 0x3c
 8000c26:	2103      	movs	r1, #3
 8000c28:	4a38      	ldr	r2, [pc, #224]	; (8000d0c <Mag_readValues+0x102>)
 8000c2a:	f7ff fe7d 	bl	8000928 <LSM303DLHC_Read>
//  LSM303DLHC_Read(MAG_I2C_ADDRESS, LSM303DLHC_OUT_Y_H_M, buffer+2, 1);
//  LSM303DLHC_Read(MAG_I2C_ADDRESS, LSM303DLHC_OUT_Y_L_M, buffer+3, 1);
//  LSM303DLHC_Read(MAG_I2C_ADDRESS, LSM303DLHC_OUT_Z_H_M, buffer+4, 1);
//  LSM303DLHC_Read(MAG_I2C_ADDRESS, LSM303DLHC_OUT_Z_L_M, buffer+5, 1);
  /* Switch the sensitivity set in the CRTLB*/
  switch(CTRLB & 0xE0)
 8000c2e:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8000c32:	f003 03e0 	and.w	r3, r3, #224	; 0xe0
 8000c36:	2b80      	cmp	r3, #128	; 0x80
 8000c38:	d01a      	beq.n	8000c70 <Mag_readValues+0x66>
 8000c3a:	d806      	bhi.n	8000c4a <Mag_readValues+0x40>
 8000c3c:	2b40      	cmp	r3, #64	; 0x40
 8000c3e:	d00d      	beq.n	8000c5c <Mag_readValues+0x52>
 8000c40:	2b60      	cmp	r3, #96	; 0x60
 8000c42:	d010      	beq.n	8000c66 <Mag_readValues+0x5c>
 8000c44:	2b20      	cmp	r3, #32
 8000c46:	d106      	bne.n	8000c56 <Mag_readValues+0x4c>
 8000c48:	e024      	b.n	8000c94 <Mag_readValues+0x8a>
 8000c4a:	2bc0      	cmp	r3, #192	; 0xc0
 8000c4c:	d01a      	beq.n	8000c84 <Mag_readValues+0x7a>
 8000c4e:	2be0      	cmp	r3, #224	; 0xe0
 8000c50:	d01d      	beq.n	8000c8e <Mag_readValues+0x84>
 8000c52:	2ba0      	cmp	r3, #160	; 0xa0
 8000c54:	d011      	beq.n	8000c7a <Mag_readValues+0x70>

void Mag_readValues (struct magValues *magXYZ)
{
  static uint8_t buffer[6] = {0};
  uint8_t CTRLB = 0;
  uint16_t Magn_Sensitivity_XY = 0, Magn_Sensitivity_Z = 0;
 8000c56:	2400      	movs	r4, #0
 8000c58:	4620      	mov	r0, r4
 8000c5a:	e01f      	b.n	8000c9c <Mag_readValues+0x92>
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_1_3Ga;
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_1_3Ga;
    break;
  case LSM303DLHC_FS_1_9_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_1_9Ga;
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_1_9Ga;
 8000c5c:	f44f 743e 	mov.w	r4, #760	; 0x2f8
  case LSM303DLHC_FS_1_3_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_1_3Ga;
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_1_3Ga;
    break;
  case LSM303DLHC_FS_1_9_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_1_9Ga;
 8000c60:	f240 3057 	movw	r0, #855	; 0x357
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_1_9Ga;
    break;
 8000c64:	e01a      	b.n	8000c9c <Mag_readValues+0x92>
  case LSM303DLHC_FS_2_5_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_2_5Ga;
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_2_5Ga;
 8000c66:	f44f 7416 	mov.w	r4, #600	; 0x258
  case LSM303DLHC_FS_1_9_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_1_9Ga;
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_1_9Ga;
    break;
  case LSM303DLHC_FS_2_5_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_2_5Ga;
 8000c6a:	f240 209e 	movw	r0, #670	; 0x29e
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_2_5Ga;
    break;
 8000c6e:	e015      	b.n	8000c9c <Mag_readValues+0x92>
  case LSM303DLHC_FS_4_0_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_4Ga;
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_4Ga;
 8000c70:	f44f 74c8 	mov.w	r4, #400	; 0x190
  case LSM303DLHC_FS_2_5_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_2_5Ga;
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_2_5Ga;
    break;
  case LSM303DLHC_FS_4_0_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_4Ga;
 8000c74:	f44f 70e1 	mov.w	r0, #450	; 0x1c2
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_4Ga;
    break;
 8000c78:	e010      	b.n	8000c9c <Mag_readValues+0x92>
  case LSM303DLHC_FS_4_7_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_4_7Ga;
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_4_7Ga;
 8000c7a:	f240 1463 	movw	r4, #355	; 0x163
  case LSM303DLHC_FS_4_0_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_4Ga;
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_4Ga;
    break;
  case LSM303DLHC_FS_4_7_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_4_7Ga;
 8000c7e:	f44f 70c8 	mov.w	r0, #400	; 0x190
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_4_7Ga;
    break;
 8000c82:	e00b      	b.n	8000c9c <Mag_readValues+0x92>
  case LSM303DLHC_FS_5_6_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_5_6Ga;
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_5_6Ga;
 8000c84:	f240 1427 	movw	r4, #295	; 0x127
  case LSM303DLHC_FS_4_7_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_4_7Ga;
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_4_7Ga;
    break;
  case LSM303DLHC_FS_5_6_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_5_6Ga;
 8000c88:	f44f 70a5 	mov.w	r0, #330	; 0x14a
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_5_6Ga;
    break;
 8000c8c:	e006      	b.n	8000c9c <Mag_readValues+0x92>
  case LSM303DLHC_FS_8_1_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_8_1Ga;
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_8_1Ga;
 8000c8e:	24cd      	movs	r4, #205	; 0xcd
  case LSM303DLHC_FS_5_6_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_5_6Ga;
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_5_6Ga;
    break;
  case LSM303DLHC_FS_8_1_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_8_1Ga;
 8000c90:	20e6      	movs	r0, #230	; 0xe6
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_8_1Ga;
    break;
 8000c92:	e003      	b.n	8000c9c <Mag_readValues+0x92>
  /* Switch the sensitivity set in the CRTLB*/
  switch(CTRLB & 0xE0)
  {
  case LSM303DLHC_FS_1_3_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_1_3Ga;
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_1_3Ga;
 8000c94:	f44f 7475 	mov.w	r4, #980	; 0x3d4
//  LSM303DLHC_Read(MAG_I2C_ADDRESS, LSM303DLHC_OUT_Z_L_M, buffer+5, 1);
  /* Switch the sensitivity set in the CRTLB*/
  switch(CTRLB & 0xE0)
  {
  case LSM303DLHC_FS_1_3_GA:
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_1_3Ga;
 8000c98:	f240 404c 	movw	r0, #1100	; 0x44c
    Magn_Sensitivity_XY = LSM303DLHC_M_SENSITIVITY_XY_8_1Ga;
    Magn_Sensitivity_Z = LSM303DLHC_M_SENSITIVITY_Z_8_1Ga;
    break;
  }

  magXYZ->magValueX = (float)((int16_t)(((uint16_t)buffer[0] << 8) + buffer[1])*1000)/Magn_Sensitivity_XY;
 8000c9c:	f006 fdb6 	bl	800780c <__aeabi_i2f>
 8000ca0:	4d1a      	ldr	r5, [pc, #104]	; (8000d0c <Mag_readValues+0x102>)
 8000ca2:	4680      	mov	r8, r0
 8000ca4:	786b      	ldrb	r3, [r5, #1]
 8000ca6:	7828      	ldrb	r0, [r5, #0]
 8000ca8:	f44f 777a 	mov.w	r7, #1000	; 0x3e8
 8000cac:	eb03 2000 	add.w	r0, r3, r0, lsl #8
 8000cb0:	b200      	sxth	r0, r0
 8000cb2:	4378      	muls	r0, r7
 8000cb4:	f006 fdaa 	bl	800780c <__aeabi_i2f>
 8000cb8:	4641      	mov	r1, r8
 8000cba:	f006 feaf 	bl	8007a1c <__aeabi_fdiv>
 8000cbe:	f006 ffbf 	bl	8007c40 <__aeabi_f2iz>
 8000cc2:	8030      	strh	r0, [r6, #0]
  magXYZ->magValueZ = (float)((int16_t)(((uint16_t)buffer[2] << 8) + buffer[3])*1000)/Magn_Sensitivity_XY;
 8000cc4:	78eb      	ldrb	r3, [r5, #3]
 8000cc6:	78a8      	ldrb	r0, [r5, #2]
 8000cc8:	eb03 2000 	add.w	r0, r3, r0, lsl #8
 8000ccc:	b200      	sxth	r0, r0
 8000cce:	4378      	muls	r0, r7
 8000cd0:	f006 fd9c 	bl	800780c <__aeabi_i2f>
 8000cd4:	4641      	mov	r1, r8
 8000cd6:	f006 fea1 	bl	8007a1c <__aeabi_fdiv>
 8000cda:	f006 ffb1 	bl	8007c40 <__aeabi_f2iz>
 8000cde:	80b0      	strh	r0, [r6, #4]
  magXYZ->magValueY = (float)((int16_t)(((uint16_t)buffer[4] << 8) + buffer[5])*1000)/Magn_Sensitivity_Z;
 8000ce0:	796b      	ldrb	r3, [r5, #5]
 8000ce2:	7928      	ldrb	r0, [r5, #4]
 8000ce4:	eb03 2000 	add.w	r0, r3, r0, lsl #8
 8000ce8:	b200      	sxth	r0, r0
 8000cea:	4378      	muls	r0, r7
 8000cec:	f006 fd8e 	bl	800780c <__aeabi_i2f>
 8000cf0:	4605      	mov	r5, r0
 8000cf2:	4620      	mov	r0, r4
 8000cf4:	f006 fd8a 	bl	800780c <__aeabi_i2f>
 8000cf8:	4601      	mov	r1, r0
 8000cfa:	4628      	mov	r0, r5
 8000cfc:	f006 fe8e 	bl	8007a1c <__aeabi_fdiv>
 8000d00:	f006 ff9e 	bl	8007c40 <__aeabi_f2iz>
 8000d04:	8070      	strh	r0, [r6, #2]
}
 8000d06:	e8bd 81fc 	ldmia.w	sp!, {r2, r3, r4, r5, r6, r7, r8, pc}
 8000d0a:	bf00      	nop
 8000d0c:	20000140 	.word	0x20000140

08000d10 <PWM_Motor>:



void PWM_Motor(uint8_t Motor, uint16_t value)
{
	switch (Motor)
 8000d10:	2805      	cmp	r0, #5
 8000d12:	d816      	bhi.n	8000d42 <PWM_Motor+0x32>
 8000d14:	e8df f000 	tbb	[pc, r0]
 8000d18:	0a070503 	.word	0x0a070503
 8000d1c:	110d      	.short	0x110d
	{
	case 0:
		TIM_SetCompare1(TIM3, value);
 8000d1e:	4809      	ldr	r0, [pc, #36]	; (8000d44 <PWM_Motor+0x34>)
 8000d20:	e009      	b.n	8000d36 <PWM_Motor+0x26>
		break;
	case 1:
		TIM_SetCompare2(TIM3, value);
 8000d22:	4808      	ldr	r0, [pc, #32]	; (8000d44 <PWM_Motor+0x34>)
 8000d24:	e00b      	b.n	8000d3e <PWM_Motor+0x2e>
		break;
	case 2:
		TIM_SetCompare3(TIM3, value);
 8000d26:	4807      	ldr	r0, [pc, #28]	; (8000d44 <PWM_Motor+0x34>)
 8000d28:	f003 bfe2 	b.w	8004cf0 <TIM_SetCompare3>
		break;
	case 3:
		TIM_SetCompare4(TIM3, value);
 8000d2c:	4805      	ldr	r0, [pc, #20]	; (8000d44 <PWM_Motor+0x34>)
 8000d2e:	f003 bfe1 	b.w	8004cf4 <TIM_SetCompare4>
		break;
	case 4:
		TIM_SetCompare1(TIM2, value);
 8000d32:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8000d36:	f003 bfd7 	b.w	8004ce8 <TIM_SetCompare1>
		break;
	case 5:
		TIM_SetCompare2(TIM2, value);
 8000d3a:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8000d3e:	f003 bfd5 	b.w	8004cec <TIM_SetCompare2>
 8000d42:	4770      	bx	lr
 8000d44:	40000400 	.word	0x40000400

08000d48 <Enable_Motor>:
		break;
	}
}

void Enable_Motor(){
 8000d48:	b510      	push	{r4, lr}
	//GPIO_WriteBit(GPIOB, GPIO_Pin_0 | GPIO_Pin_1 , Bit_SET);
	GPIO_WriteBit(GPIOB, GPIO_Pin_0 , Bit_RESET);
 8000d4a:	4c06      	ldr	r4, [pc, #24]	; (8000d64 <Enable_Motor+0x1c>)
 8000d4c:	2101      	movs	r1, #1
 8000d4e:	4620      	mov	r0, r4
 8000d50:	2200      	movs	r2, #0
 8000d52:	f002 fdfd 	bl	8003950 <GPIO_WriteBit>
	GPIO_WriteBit(GPIOB, GPIO_Pin_1 , Bit_RESET);
 8000d56:	4620      	mov	r0, r4
 8000d58:	2102      	movs	r1, #2
 8000d5a:	2200      	movs	r2, #0
}
 8000d5c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
}

void Enable_Motor(){
	//GPIO_WriteBit(GPIOB, GPIO_Pin_0 | GPIO_Pin_1 , Bit_SET);
	GPIO_WriteBit(GPIOB, GPIO_Pin_0 , Bit_RESET);
	GPIO_WriteBit(GPIOB, GPIO_Pin_1 , Bit_RESET);
 8000d60:	f002 bdf6 	b.w	8003950 <GPIO_WriteBit>
 8000d64:	48000400 	.word	0x48000400

08000d68 <Disable_Motor>:
}

void Disable_Motor(){
	//GPIO_WriteBit(GPIOB, GPIO_Pin_0 | GPIO_Pin_1 , Bit_RESET);
	GPIO_WriteBit(GPIOB, GPIO_Pin_0 | GPIO_Pin_1 , Bit_SET);
 8000d68:	4802      	ldr	r0, [pc, #8]	; (8000d74 <Disable_Motor+0xc>)
 8000d6a:	2103      	movs	r1, #3
 8000d6c:	2201      	movs	r2, #1
 8000d6e:	f002 bdef 	b.w	8003950 <GPIO_WriteBit>
 8000d72:	bf00      	nop
 8000d74:	48000400 	.word	0x48000400

08000d78 <init_PID>:
//float CalcVirtualPlant(SmitPredictor_Control *value, float Input);
//float CalcDelay(SmitPredictor_Control *value, float Input);


void init_PID(float sample_rate, float kp, float ki, float kd, float kn, PID_Control *values)
{
 8000d78:	b510      	push	{r4, lr}
 8000d7a:	9c03      	ldr	r4, [sp, #12]
	values->sampling_rate = sample_rate;
	values->kp = kp;
	values->ki = ki;
	values->kd = kd;
 8000d7c:	6123      	str	r3, [r4, #16]
	values->kn = kn;
 8000d7e:	9b02      	ldr	r3, [sp, #8]
//float CalcDelay(SmitPredictor_Control *value, float Input);


void init_PID(float sample_rate, float kp, float ki, float kd, float kn, PID_Control *values)
{
	values->sampling_rate = sample_rate;
 8000d80:	6020      	str	r0, [r4, #0]
	values->kp = kp;
 8000d82:	60a1      	str	r1, [r4, #8]
	values->ki = ki;
 8000d84:	60e2      	str	r2, [r4, #12]
	values->kd = kd;
	values->kn = kn;
 8000d86:	6163      	str	r3, [r4, #20]
 8000d88:	bd10      	pop	{r4, pc}

08000d8a <init_SmithPredictor>:
}

void init_SmithPredictor(float a1, float a2, float b1, float b2, float b3, float gain, SmitPredictor_Control *values)
{
 8000d8a:	b510      	push	{r4, lr}
 8000d8c:	9c04      	ldr	r4, [sp, #16]
	values->a1 = a1;
	values->a2 = a2;
	values->b1 = b1;
	values->b2 = b2;
 8000d8e:	63a3      	str	r3, [r4, #56]	; 0x38
	values->b3 = b3;
 8000d90:	9b02      	ldr	r3, [sp, #8]
	values->kn = kn;
}

void init_SmithPredictor(float a1, float a2, float b1, float b2, float b3, float gain, SmitPredictor_Control *values)
{
	values->a1 = a1;
 8000d92:	62e0      	str	r0, [r4, #44]	; 0x2c
	values->a2 = a2;
	values->b1 = b1;
	values->b2 = b2;
	values->b3 = b3;
 8000d94:	63e3      	str	r3, [r4, #60]	; 0x3c
	values->gain = gain;
 8000d96:	9b03      	ldr	r3, [sp, #12]
}

void init_SmithPredictor(float a1, float a2, float b1, float b2, float b3, float gain, SmitPredictor_Control *values)
{
	values->a1 = a1;
	values->a2 = a2;
 8000d98:	6321      	str	r1, [r4, #48]	; 0x30
	values->b1 = b1;
 8000d9a:	6362      	str	r2, [r4, #52]	; 0x34
	values->b2 = b2;
	values->b3 = b3;
	values->gain = gain;
 8000d9c:	6423      	str	r3, [r4, #64]	; 0x40
 8000d9e:	bd10      	pop	{r4, pc}

08000da0 <resetIntegralValues_PID>:
}

void resetIntegralValues_PID(PID_Control *values)
{
	values->ealt = 0;
 8000da0:	2300      	movs	r3, #0
 8000da2:	6243      	str	r3, [r0, #36]	; 0x24
	values->Isum = 0;
 8000da4:	61c3      	str	r3, [r0, #28]
	values->Dsum = 0;
 8000da6:	6203      	str	r3, [r0, #32]
	values->y = 0;
 8000da8:	6043      	str	r3, [r0, #4]
 8000daa:	4770      	bx	lr

08000dac <calc_PID>:
//float D = (values->kd*values->e - values->Dsum ) * values->kn;
//values->Dsum += D * values->sampling_rate;


void calc_PID(float istwert, float sollwert, PID_Control *PID_Values)
{
 8000dac:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8000db0:	4603      	mov	r3, r0
	float P ,I ,D;

#define Isum_max 50.0f

	/* */
	PID_Values->e = sollwert - istwert;
 8000db2:	4608      	mov	r0, r1
 8000db4:	4619      	mov	r1, r3
//float D = (values->kd*values->e - values->Dsum ) * values->kn;
//values->Dsum += D * values->sampling_rate;


void calc_PID(float istwert, float sollwert, PID_Control *PID_Values)
{
 8000db6:	4614      	mov	r4, r2
	float P ,I ,D;

#define Isum_max 50.0f

	/* */
	PID_Values->e = sollwert - istwert;
 8000db8:	f006 fc72 	bl	80076a0 <__aeabi_fsub>
	/* Nichtlinearitt hinzufgen (x^3) */
	//PID_Values->e = PID_Values->e * PID_Values->e * PID_Values->e;


	// I-Anteil aufsummieren:
	PID_Values->Isum += (PID_Values->e*PID_Values->ki) * PID_Values->sampling_rate;
 8000dbc:	6827      	ldr	r7, [r4, #0]
 8000dbe:	68e1      	ldr	r1, [r4, #12]
	float P ,I ,D;

#define Isum_max 50.0f

	/* */
	PID_Values->e = sollwert - istwert;
 8000dc0:	61a0      	str	r0, [r4, #24]
 8000dc2:	4605      	mov	r5, r0
	/* Nichtlinearitt hinzufgen (x^3) */
	//PID_Values->e = PID_Values->e * PID_Values->e * PID_Values->e;


	// I-Anteil aufsummieren:
	PID_Values->Isum += (PID_Values->e*PID_Values->ki) * PID_Values->sampling_rate;
 8000dc4:	f006 fd76 	bl	80078b4 <__aeabi_fmul>
 8000dc8:	4639      	mov	r1, r7
 8000dca:	f006 fd73 	bl	80078b4 <__aeabi_fmul>
 8000dce:	69e1      	ldr	r1, [r4, #28]
 8000dd0:	f006 fc68 	bl	80076a4 <__addsf3>

	// Anti-Windup
	if (PID_Values->Isum > Isum_max) PID_Values->Isum = Isum_max;
 8000dd4:	4e1a      	ldr	r6, [pc, #104]	; (8000e40 <calc_PID+0x94>)
	/* Nichtlinearitt hinzufgen (x^3) */
	//PID_Values->e = PID_Values->e * PID_Values->e * PID_Values->e;


	// I-Anteil aufsummieren:
	PID_Values->Isum += (PID_Values->e*PID_Values->ki) * PID_Values->sampling_rate;
 8000dd6:	4680      	mov	r8, r0

	// Anti-Windup
	if (PID_Values->Isum > Isum_max) PID_Values->Isum = Isum_max;
 8000dd8:	4631      	mov	r1, r6
 8000dda:	f006 ff27 	bl	8007c2c <__aeabi_fcmpgt>
 8000dde:	b910      	cbnz	r0, 8000de6 <calc_PID+0x3a>
	/* Nichtlinearitt hinzufgen (x^3) */
	//PID_Values->e = PID_Values->e * PID_Values->e * PID_Values->e;


	// I-Anteil aufsummieren:
	PID_Values->Isum += (PID_Values->e*PID_Values->ki) * PID_Values->sampling_rate;
 8000de0:	f8c4 801c 	str.w	r8, [r4, #28]
 8000de4:	e000      	b.n	8000de8 <calc_PID+0x3c>

	// Anti-Windup
	if (PID_Values->Isum > Isum_max) PID_Values->Isum = Isum_max;
 8000de6:	61e6      	str	r6, [r4, #28]
	if (PID_Values->Isum < -Isum_max) PID_Values->Isum = -Isum_max;
 8000de8:	4e16      	ldr	r6, [pc, #88]	; (8000e44 <calc_PID+0x98>)
 8000dea:	69e0      	ldr	r0, [r4, #28]
 8000dec:	4631      	mov	r1, r6
 8000dee:	f006 feff 	bl	8007bf0 <__aeabi_fcmplt>
 8000df2:	b100      	cbz	r0, 8000df6 <calc_PID+0x4a>
 8000df4:	61e6      	str	r6, [r4, #28]

	P = (PID_Values->kp * PID_Values->e);
 8000df6:	4628      	mov	r0, r5
 8000df8:	68a1      	ldr	r1, [r4, #8]
 8000dfa:	f006 fd5b 	bl	80078b4 <__aeabi_fmul>
	//I = (PID_Values->Isum * PID_Values->ki);
	I = PID_Values->Isum;
	D = (PID_Values->kd * PID_Values->e - PID_Values->Dsum ) * PID_Values->kn;
 8000dfe:	6a26      	ldr	r6, [r4, #32]

	// Anti-Windup
	if (PID_Values->Isum > Isum_max) PID_Values->Isum = Isum_max;
	if (PID_Values->Isum < -Isum_max) PID_Values->Isum = -Isum_max;

	P = (PID_Values->kp * PID_Values->e);
 8000e00:	4681      	mov	r9, r0
	//I = (PID_Values->Isum * PID_Values->ki);
	I = PID_Values->Isum;
	D = (PID_Values->kd * PID_Values->e - PID_Values->Dsum ) * PID_Values->kn;
 8000e02:	6921      	ldr	r1, [r4, #16]
 8000e04:	4628      	mov	r0, r5
 8000e06:	f006 fd55 	bl	80078b4 <__aeabi_fmul>
 8000e0a:	4631      	mov	r1, r6
 8000e0c:	f006 fc48 	bl	80076a0 <__aeabi_fsub>
 8000e10:	6961      	ldr	r1, [r4, #20]
 8000e12:	f006 fd4f 	bl	80078b4 <__aeabi_fmul>
	PID_Values->Dsum += D * PID_Values->sampling_rate;
 8000e16:	4639      	mov	r1, r7
	if (PID_Values->Isum < -Isum_max) PID_Values->Isum = -Isum_max;

	P = (PID_Values->kp * PID_Values->e);
	//I = (PID_Values->Isum * PID_Values->ki);
	I = PID_Values->Isum;
	D = (PID_Values->kd * PID_Values->e - PID_Values->Dsum ) * PID_Values->kn;
 8000e18:	4605      	mov	r5, r0
	PID_Values->Dsum += D * PID_Values->sampling_rate;
 8000e1a:	f006 fd4b 	bl	80078b4 <__aeabi_fmul>
 8000e1e:	4601      	mov	r1, r0
 8000e20:	4630      	mov	r0, r6
 8000e22:	f006 fc3f 	bl	80076a4 <__addsf3>
	if (PID_Values->Isum > Isum_max) PID_Values->Isum = Isum_max;
	if (PID_Values->Isum < -Isum_max) PID_Values->Isum = -Isum_max;

	P = (PID_Values->kp * PID_Values->e);
	//I = (PID_Values->Isum * PID_Values->ki);
	I = PID_Values->Isum;
 8000e26:	f8d4 801c 	ldr.w	r8, [r4, #28]
	D = (PID_Values->kd * PID_Values->e - PID_Values->Dsum ) * PID_Values->kn;
	PID_Values->Dsum += D * PID_Values->sampling_rate;
 8000e2a:	6220      	str	r0, [r4, #32]

	// PID-Regler
	PID_Values->y = P + I + D;
 8000e2c:	4641      	mov	r1, r8
 8000e2e:	4648      	mov	r0, r9
 8000e30:	f006 fc38 	bl	80076a4 <__addsf3>
 8000e34:	4629      	mov	r1, r5
 8000e36:	f006 fc35 	bl	80076a4 <__addsf3>
 8000e3a:	6060      	str	r0, [r4, #4]
 8000e3c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8000e40:	42480000 	.word	0x42480000
 8000e44:	c2480000 	.word	0xc2480000

08000e48 <CalcVirtualPlant>:
//	PID_Values->ealt = PID_Values->e;


/* Simulate Virtual Plant */
/* checked */
float CalcVirtualPlant(SmitPredictor_Control *value, float Input){
 8000e48:	b570      	push	{r4, r5, r6, lr}
 8000e4a:	4604      	mov	r4, r0
 8000e4c:	460e      	mov	r6, r1

	/* Calculate first Section */
	value->vPlantyT1y[0] = value->b1 * value->vPlantyT1y[1] + value->a1 * value->vPlantyT1x[1];
 8000e4e:	6b40      	ldr	r0, [r0, #52]	; 0x34
 8000e50:	69a1      	ldr	r1, [r4, #24]
 8000e52:	f006 fd2f 	bl	80078b4 <__aeabi_fmul>
 8000e56:	6921      	ldr	r1, [r4, #16]
 8000e58:	4605      	mov	r5, r0
 8000e5a:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8000e5c:	f006 fd2a 	bl	80078b4 <__aeabi_fmul>
 8000e60:	4601      	mov	r1, r0
 8000e62:	4628      	mov	r0, r5
 8000e64:	f006 fc1e 	bl	80076a4 <__addsf3>
	value->vPlantyT1x[1] = Input;
	value->vPlantyT1y[1] = value->vPlantyT1y[0];

	/* Calculate second Section */
	value->vPlantyT2y[0] = value->vPlantyT2y[1] + value->a2 * value->vPlantyT2x[1];
 8000e68:	6a21      	ldr	r1, [r4, #32]
/* Simulate Virtual Plant */
/* checked */
float CalcVirtualPlant(SmitPredictor_Control *value, float Input){

	/* Calculate first Section */
	value->vPlantyT1y[0] = value->b1 * value->vPlantyT1y[1] + value->a1 * value->vPlantyT1x[1];
 8000e6a:	4605      	mov	r5, r0
 8000e6c:	6160      	str	r0, [r4, #20]
	value->vPlantyT1x[1] = Input;
	value->vPlantyT1y[1] = value->vPlantyT1y[0];
 8000e6e:	61a0      	str	r0, [r4, #24]
/* checked */
float CalcVirtualPlant(SmitPredictor_Control *value, float Input){

	/* Calculate first Section */
	value->vPlantyT1y[0] = value->b1 * value->vPlantyT1y[1] + value->a1 * value->vPlantyT1x[1];
	value->vPlantyT1x[1] = Input;
 8000e70:	6126      	str	r6, [r4, #16]
	value->vPlantyT1y[1] = value->vPlantyT1y[0];

	/* Calculate second Section */
	value->vPlantyT2y[0] = value->vPlantyT2y[1] + value->a2 * value->vPlantyT2x[1];
 8000e72:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8000e74:	f006 fd1e 	bl	80078b4 <__aeabi_fmul>
 8000e78:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8000e7a:	f006 fc13 	bl	80076a4 <__addsf3>
	value->vPlantyT2x[1] = value->vPlantyT1y[0];
 8000e7e:	6225      	str	r5, [r4, #32]
	value->vPlantyT1y[0] = value->b1 * value->vPlantyT1y[1] + value->a1 * value->vPlantyT1x[1];
	value->vPlantyT1x[1] = Input;
	value->vPlantyT1y[1] = value->vPlantyT1y[0];

	/* Calculate second Section */
	value->vPlantyT2y[0] = value->vPlantyT2y[1] + value->a2 * value->vPlantyT2x[1];
 8000e80:	6260      	str	r0, [r4, #36]	; 0x24
	value->vPlantyT2x[1] = value->vPlantyT1y[0];
	value->vPlantyT2y[1] = value->vPlantyT2y[0];
 8000e82:	62a0      	str	r0, [r4, #40]	; 0x28

	return value->vPlantyT2y[0];
}
 8000e84:	bd70      	pop	{r4, r5, r6, pc}

08000e86 <CalcVirtualPlant_xxx>:

/* Simulate Virtual Plant */
/* Fehler */
float CalcVirtualPlant_xxx(SmitPredictor_Control *value, float Input){
 8000e86:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	/* shift */
	value->w[2] = 	value->w[1];
 8000e88:	6845      	ldr	r5, [r0, #4]
	value->w[1] =	value->w[0];
 8000e8a:	6806      	ldr	r6, [r0, #0]
	return value->vPlantyT2y[0];
}

/* Simulate Virtual Plant */
/* Fehler */
float CalcVirtualPlant_xxx(SmitPredictor_Control *value, float Input){
 8000e8c:	4604      	mov	r4, r0
	/* shift */
	value->w[2] = 	value->w[1];
 8000e8e:	6085      	str	r5, [r0, #8]
	value->w[1] =	value->w[0];
 8000e90:	6046      	str	r6, [r0, #4]
	value->w[0] = 	(value->gain*Input) + (value->a1*value->w[1]) + (value->a2*value->w[2]);
 8000e92:	4608      	mov	r0, r1
 8000e94:	6c21      	ldr	r1, [r4, #64]	; 0x40
 8000e96:	f006 fd0d 	bl	80078b4 <__aeabi_fmul>
 8000e9a:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 8000e9c:	4607      	mov	r7, r0
 8000e9e:	4630      	mov	r0, r6
 8000ea0:	f006 fd08 	bl	80078b4 <__aeabi_fmul>
 8000ea4:	4601      	mov	r1, r0
 8000ea6:	4638      	mov	r0, r7
 8000ea8:	f006 fbfc 	bl	80076a4 <__addsf3>
 8000eac:	6b21      	ldr	r1, [r4, #48]	; 0x30
 8000eae:	4607      	mov	r7, r0
 8000eb0:	4628      	mov	r0, r5
 8000eb2:	f006 fcff 	bl	80078b4 <__aeabi_fmul>
 8000eb6:	4601      	mov	r1, r0
 8000eb8:	4638      	mov	r0, r7
 8000eba:	f006 fbf3 	bl	80076a4 <__addsf3>
	return 		(value->b1*value->w[0]) + (value->b2*value->w[1]) + (value->b3*value->w[2]);
 8000ebe:	6b61      	ldr	r1, [r4, #52]	; 0x34
/* Fehler */
float CalcVirtualPlant_xxx(SmitPredictor_Control *value, float Input){
	/* shift */
	value->w[2] = 	value->w[1];
	value->w[1] =	value->w[0];
	value->w[0] = 	(value->gain*Input) + (value->a1*value->w[1]) + (value->a2*value->w[2]);
 8000ec0:	6020      	str	r0, [r4, #0]
	return 		(value->b1*value->w[0]) + (value->b2*value->w[1]) + (value->b3*value->w[2]);
 8000ec2:	f006 fcf7 	bl	80078b4 <__aeabi_fmul>
 8000ec6:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 8000ec8:	4607      	mov	r7, r0
 8000eca:	4630      	mov	r0, r6
 8000ecc:	f006 fcf2 	bl	80078b4 <__aeabi_fmul>
 8000ed0:	4601      	mov	r1, r0
 8000ed2:	4638      	mov	r0, r7
 8000ed4:	f006 fbe6 	bl	80076a4 <__addsf3>
 8000ed8:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8000eda:	4606      	mov	r6, r0
 8000edc:	4628      	mov	r0, r5
 8000ede:	f006 fce9 	bl	80078b4 <__aeabi_fmul>
 8000ee2:	4601      	mov	r1, r0
 8000ee4:	4630      	mov	r0, r6
 8000ee6:	f006 fbdd 	bl	80076a4 <__addsf3>
}
 8000eea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08000eec <CalcDirektForm2>:

/* Fehler */
float CalcDirektForm2(float istwert, float sollwert, SmitPredictor_Control *value){
 8000eec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	/* shift */
	float E = sollwert - istwert;

	value->w[2] = 	value->w[1];
 8000eee:	6855      	ldr	r5, [r2, #4]
	value->w[1] =	value->w[0];
 8000ef0:	6816      	ldr	r6, [r2, #0]
	value->w[0] = 	(value->gain*Input) + (value->a1*value->w[1]) + (value->a2*value->w[2]);
	return 		(value->b1*value->w[0]) + (value->b2*value->w[1]) + (value->b3*value->w[2]);
}

/* Fehler */
float CalcDirektForm2(float istwert, float sollwert, SmitPredictor_Control *value){
 8000ef2:	4603      	mov	r3, r0
 8000ef4:	4614      	mov	r4, r2
	/* shift */
	float E = sollwert - istwert;

	value->w[2] = 	value->w[1];
	value->w[1] =	value->w[0];
 8000ef6:	6056      	str	r6, [r2, #4]
/* Fehler */
float CalcDirektForm2(float istwert, float sollwert, SmitPredictor_Control *value){
	/* shift */
	float E = sollwert - istwert;

	value->w[2] = 	value->w[1];
 8000ef8:	6095      	str	r5, [r2, #8]
}

/* Fehler */
float CalcDirektForm2(float istwert, float sollwert, SmitPredictor_Control *value){
	/* shift */
	float E = sollwert - istwert;
 8000efa:	4608      	mov	r0, r1
 8000efc:	4619      	mov	r1, r3
 8000efe:	f006 fbcf 	bl	80076a0 <__aeabi_fsub>

	value->w[2] = 	value->w[1];
	value->w[1] =	value->w[0];
	value->w[0] = 	(value->gain*E) + (-value->a1*value->w[1]) + (-value->a2*value->w[2]);
 8000f02:	6c21      	ldr	r1, [r4, #64]	; 0x40
 8000f04:	f006 fcd6 	bl	80078b4 <__aeabi_fmul>
 8000f08:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8000f0a:	4607      	mov	r7, r0
 8000f0c:	4631      	mov	r1, r6
 8000f0e:	f103 4000 	add.w	r0, r3, #2147483648	; 0x80000000
 8000f12:	f006 fccf 	bl	80078b4 <__aeabi_fmul>
 8000f16:	4601      	mov	r1, r0
 8000f18:	4638      	mov	r0, r7
 8000f1a:	f006 fbc3 	bl	80076a4 <__addsf3>
 8000f1e:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8000f20:	4607      	mov	r7, r0
 8000f22:	4629      	mov	r1, r5
 8000f24:	f103 4000 	add.w	r0, r3, #2147483648	; 0x80000000
 8000f28:	f006 fcc4 	bl	80078b4 <__aeabi_fmul>
 8000f2c:	4601      	mov	r1, r0
 8000f2e:	4638      	mov	r0, r7
 8000f30:	f006 fbb8 	bl	80076a4 <__addsf3>
	return 		(value->b1*value->w[0]) + (value->b2*value->w[1]) + (value->b3*value->w[2]);
 8000f34:	6b61      	ldr	r1, [r4, #52]	; 0x34
	/* shift */
	float E = sollwert - istwert;

	value->w[2] = 	value->w[1];
	value->w[1] =	value->w[0];
	value->w[0] = 	(value->gain*E) + (-value->a1*value->w[1]) + (-value->a2*value->w[2]);
 8000f36:	6020      	str	r0, [r4, #0]
	return 		(value->b1*value->w[0]) + (value->b2*value->w[1]) + (value->b3*value->w[2]);
 8000f38:	f006 fcbc 	bl	80078b4 <__aeabi_fmul>
 8000f3c:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 8000f3e:	4607      	mov	r7, r0
 8000f40:	4630      	mov	r0, r6
 8000f42:	f006 fcb7 	bl	80078b4 <__aeabi_fmul>
 8000f46:	4601      	mov	r1, r0
 8000f48:	4638      	mov	r0, r7
 8000f4a:	f006 fbab 	bl	80076a4 <__addsf3>
 8000f4e:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8000f50:	4606      	mov	r6, r0
 8000f52:	4628      	mov	r0, r5
 8000f54:	f006 fcae 	bl	80078b4 <__aeabi_fmul>
 8000f58:	4601      	mov	r1, r0
 8000f5a:	4630      	mov	r0, r6
 8000f5c:	f006 fba2 	bl	80076a4 <__addsf3>
}
 8000f60:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08000f62 <CalcDelay>:
/* Checked */
float CalcDelay(SmitPredictor_Control *value, float Input){

	static unsigned char dlyindex = 0;

	dlyindex++;
 8000f62:	4b09      	ldr	r3, [pc, #36]	; (8000f88 <CalcDelay+0x26>)
 8000f64:	781a      	ldrb	r2, [r3, #0]
 8000f66:	3201      	adds	r2, #1
 8000f68:	b2d2      	uxtb	r2, r2
	if ( dlyindex >= (sizeof(value->fifo)/sizeof(float))) dlyindex = 0;
 8000f6a:	2a07      	cmp	r2, #7
 8000f6c:	bf88      	it	hi
 8000f6e:	2200      	movhi	r2, #0
 8000f70:	701a      	strb	r2, [r3, #0]
	value->fifo[dlyindex] = Input;
 8000f72:	781b      	ldrb	r3, [r3, #0]
 8000f74:	eb00 0283 	add.w	r2, r0, r3, lsl #2
	if ( dlyindex < ( sizeof(value->fifo)/sizeof(float)-1 ) )
 8000f78:	2b06      	cmp	r3, #6

	static unsigned char dlyindex = 0;

	dlyindex++;
	if ( dlyindex >= (sizeof(value->fifo)/sizeof(float))) dlyindex = 0;
	value->fifo[dlyindex] = Input;
 8000f7a:	6451      	str	r1, [r2, #68]	; 0x44
	if ( dlyindex < ( sizeof(value->fifo)/sizeof(float)-1 ) )
 8000f7c:	d801      	bhi.n	8000f82 <CalcDelay+0x20>
		return value->fifo[(dlyindex + 1)];
 8000f7e:	6c90      	ldr	r0, [r2, #72]	; 0x48
 8000f80:	4770      	bx	lr
	else
		return value->fifo[0];
 8000f82:	6c40      	ldr	r0, [r0, #68]	; 0x44
}
 8000f84:	4770      	bx	lr
 8000f86:	bf00      	nop
 8000f88:	20000148 	.word	0x20000148

08000f8c <calc_PID_SmithPredictor>:
	PID_Values->y = P + I + D;
	
}

void calc_PID_SmithPredictor(float istwert, float sollwert, PID_Control *PID_Values, SmitPredictor_Control *Plant_Values)
{
 8000f8c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8000f90:	461e      	mov	r6, r3
	float P ,I ,D;

#define Isum_max 50.0f

	/* SmithPrdiktor */
	PID_Values->e = sollwert - ( S - E + istwert);
 8000f92:	4b2e      	ldr	r3, [pc, #184]	; (800104c <calc_PID_SmithPredictor+0xc0>)
	PID_Values->y = P + I + D;
	
}

void calc_PID_SmithPredictor(float istwert, float sollwert, PID_Control *PID_Values, SmitPredictor_Control *Plant_Values)
{
 8000f94:	4607      	mov	r7, r0
 8000f96:	460d      	mov	r5, r1
	float P ,I ,D;

#define Isum_max 50.0f

	/* SmithPrdiktor */
	PID_Values->e = sollwert - ( S - E + istwert);
 8000f98:	6858      	ldr	r0, [r3, #4]
 8000f9a:	6899      	ldr	r1, [r3, #8]
	PID_Values->y = P + I + D;
	
}

void calc_PID_SmithPredictor(float istwert, float sollwert, PID_Control *PID_Values, SmitPredictor_Control *Plant_Values)
{
 8000f9c:	4614      	mov	r4, r2
	float P ,I ,D;

#define Isum_max 50.0f

	/* SmithPrdiktor */
	PID_Values->e = sollwert - ( S - E + istwert);
 8000f9e:	f006 fb7f 	bl	80076a0 <__aeabi_fsub>
 8000fa2:	4639      	mov	r1, r7
 8000fa4:	f006 fb7e 	bl	80076a4 <__addsf3>
 8000fa8:	4601      	mov	r1, r0
 8000faa:	4628      	mov	r0, r5
 8000fac:	f006 fb78 	bl	80076a0 <__aeabi_fsub>

	// I-Anteil aufsummieren:
	PID_Values->Isum += (PID_Values->e*PID_Values->ki) * PID_Values->sampling_rate;
 8000fb0:	f8d4 8000 	ldr.w	r8, [r4]
 8000fb4:	68e1      	ldr	r1, [r4, #12]
	float P ,I ,D;

#define Isum_max 50.0f

	/* SmithPrdiktor */
	PID_Values->e = sollwert - ( S - E + istwert);
 8000fb6:	61a0      	str	r0, [r4, #24]
 8000fb8:	4605      	mov	r5, r0

	// I-Anteil aufsummieren:
	PID_Values->Isum += (PID_Values->e*PID_Values->ki) * PID_Values->sampling_rate;
 8000fba:	f006 fc7b 	bl	80078b4 <__aeabi_fmul>
 8000fbe:	4641      	mov	r1, r8
 8000fc0:	f006 fc78 	bl	80078b4 <__aeabi_fmul>
 8000fc4:	69e1      	ldr	r1, [r4, #28]
 8000fc6:	f006 fb6d 	bl	80076a4 <__addsf3>

	// Anti-Windup
	if (PID_Values->Isum > Isum_max) PID_Values->Isum = Isum_max;
 8000fca:	4f21      	ldr	r7, [pc, #132]	; (8001050 <calc_PID_SmithPredictor+0xc4>)

	/* SmithPrdiktor */
	PID_Values->e = sollwert - ( S - E + istwert);

	// I-Anteil aufsummieren:
	PID_Values->Isum += (PID_Values->e*PID_Values->ki) * PID_Values->sampling_rate;
 8000fcc:	4681      	mov	r9, r0

	// Anti-Windup
	if (PID_Values->Isum > Isum_max) PID_Values->Isum = Isum_max;
 8000fce:	4639      	mov	r1, r7
 8000fd0:	f006 fe2c 	bl	8007c2c <__aeabi_fcmpgt>
 8000fd4:	b910      	cbnz	r0, 8000fdc <calc_PID_SmithPredictor+0x50>

	/* SmithPrdiktor */
	PID_Values->e = sollwert - ( S - E + istwert);

	// I-Anteil aufsummieren:
	PID_Values->Isum += (PID_Values->e*PID_Values->ki) * PID_Values->sampling_rate;
 8000fd6:	f8c4 901c 	str.w	r9, [r4, #28]
 8000fda:	e000      	b.n	8000fde <calc_PID_SmithPredictor+0x52>

	// Anti-Windup
	if (PID_Values->Isum > Isum_max) PID_Values->Isum = Isum_max;
 8000fdc:	61e7      	str	r7, [r4, #28]
	if (PID_Values->Isum < -Isum_max) PID_Values->Isum = -Isum_max;
 8000fde:	4f1d      	ldr	r7, [pc, #116]	; (8001054 <calc_PID_SmithPredictor+0xc8>)
 8000fe0:	69e0      	ldr	r0, [r4, #28]
 8000fe2:	4639      	mov	r1, r7
 8000fe4:	f006 fe04 	bl	8007bf0 <__aeabi_fcmplt>
 8000fe8:	b100      	cbz	r0, 8000fec <calc_PID_SmithPredictor+0x60>
 8000fea:	61e7      	str	r7, [r4, #28]

	P = (PID_Values->kp * PID_Values->e);
 8000fec:	68a1      	ldr	r1, [r4, #8]
 8000fee:	4628      	mov	r0, r5
 8000ff0:	f006 fc60 	bl	80078b4 <__aeabi_fmul>
	//I = (PID_Values->Isum * PID_Values->ki);
	I = PID_Values->Isum;
	D = (PID_Values->kd * PID_Values->e - PID_Values->Dsum ) * PID_Values->kn;
 8000ff4:	6a27      	ldr	r7, [r4, #32]
 8000ff6:	6921      	ldr	r1, [r4, #16]

	// Anti-Windup
	if (PID_Values->Isum > Isum_max) PID_Values->Isum = Isum_max;
	if (PID_Values->Isum < -Isum_max) PID_Values->Isum = -Isum_max;

	P = (PID_Values->kp * PID_Values->e);
 8000ff8:	4682      	mov	sl, r0
	//I = (PID_Values->Isum * PID_Values->ki);
	I = PID_Values->Isum;
	D = (PID_Values->kd * PID_Values->e - PID_Values->Dsum ) * PID_Values->kn;
 8000ffa:	4628      	mov	r0, r5
 8000ffc:	f006 fc5a 	bl	80078b4 <__aeabi_fmul>
 8001000:	4639      	mov	r1, r7
 8001002:	f006 fb4d 	bl	80076a0 <__aeabi_fsub>
 8001006:	6961      	ldr	r1, [r4, #20]
 8001008:	f006 fc54 	bl	80078b4 <__aeabi_fmul>
	PID_Values->Dsum += D * PID_Values->sampling_rate;
 800100c:	4641      	mov	r1, r8
	if (PID_Values->Isum < -Isum_max) PID_Values->Isum = -Isum_max;

	P = (PID_Values->kp * PID_Values->e);
	//I = (PID_Values->Isum * PID_Values->ki);
	I = PID_Values->Isum;
	D = (PID_Values->kd * PID_Values->e - PID_Values->Dsum ) * PID_Values->kn;
 800100e:	4605      	mov	r5, r0
	PID_Values->Dsum += D * PID_Values->sampling_rate;
 8001010:	f006 fc50 	bl	80078b4 <__aeabi_fmul>
 8001014:	4601      	mov	r1, r0
 8001016:	4638      	mov	r0, r7
 8001018:	f006 fb44 	bl	80076a4 <__addsf3>
	if (PID_Values->Isum > Isum_max) PID_Values->Isum = Isum_max;
	if (PID_Values->Isum < -Isum_max) PID_Values->Isum = -Isum_max;

	P = (PID_Values->kp * PID_Values->e);
	//I = (PID_Values->Isum * PID_Values->ki);
	I = PID_Values->Isum;
 800101c:	f8d4 901c 	ldr.w	r9, [r4, #28]
	D = (PID_Values->kd * PID_Values->e - PID_Values->Dsum ) * PID_Values->kn;
	PID_Values->Dsum += D * PID_Values->sampling_rate;
 8001020:	6220      	str	r0, [r4, #32]

	// PID-Regler
	PID_Values->y = P + I + D;
 8001022:	4649      	mov	r1, r9
 8001024:	4650      	mov	r0, sl
 8001026:	f006 fb3d 	bl	80076a4 <__addsf3>
 800102a:	4629      	mov	r1, r5
 800102c:	f006 fb3a 	bl	80076a4 <__addsf3>
 8001030:	4601      	mov	r1, r0
 8001032:	6060      	str	r0, [r4, #4]

	/* Get Virtual Plant */
	S = CalcVirtualPlant(Plant_Values, PID_Values->y);
 8001034:	4630      	mov	r0, r6
 8001036:	f7ff ff07 	bl	8000e48 <CalcVirtualPlant>
 800103a:	4c04      	ldr	r4, [pc, #16]	; (800104c <calc_PID_SmithPredictor+0xc0>)
 800103c:	4601      	mov	r1, r0
 800103e:	6060      	str	r0, [r4, #4]

	/* Delay */
	E = CalcDelay(Plant_Values, S);
 8001040:	4630      	mov	r0, r6
 8001042:	f7ff ff8e 	bl	8000f62 <CalcDelay>
 8001046:	60a0      	str	r0, [r4, #8]
 8001048:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800104c:	20000148 	.word	0x20000148
 8001050:	42480000 	.word	0x42480000
 8001054:	c2480000 	.word	0xc2480000

08001058 <calc_PID_YAW>:
/*
 * The yaw PID calculation needs a special handling as the input value has
 * an integrating character
 * */
void calc_PID_YAW(float istwert, float sollwert, PID_Control *values)
{
 8001058:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800105c:	4614      	mov	r4, r2
	values->e = istwert - sollwert;
 800105e:	f006 fb1f 	bl	80076a0 <__aeabi_fsub>

	if(values->e >= 180) values->e -= 360;
 8001062:	4927      	ldr	r1, [pc, #156]	; (8001100 <calc_PID_YAW+0xa8>)
 * The yaw PID calculation needs a special handling as the input value has
 * an integrating character
 * */
void calc_PID_YAW(float istwert, float sollwert, PID_Control *values)
{
	values->e = istwert - sollwert;
 8001064:	4605      	mov	r5, r0

	if(values->e >= 180) values->e -= 360;
 8001066:	f006 fdd7 	bl	8007c18 <__aeabi_fcmpge>
 800106a:	b120      	cbz	r0, 8001076 <calc_PID_YAW+0x1e>
 800106c:	4628      	mov	r0, r5
 800106e:	4925      	ldr	r1, [pc, #148]	; (8001104 <calc_PID_YAW+0xac>)
 8001070:	f006 fb16 	bl	80076a0 <__aeabi_fsub>
 8001074:	e00a      	b.n	800108c <calc_PID_YAW+0x34>
	else if (values->e <= -180) values->e += 360;
 8001076:	4628      	mov	r0, r5
 8001078:	4923      	ldr	r1, [pc, #140]	; (8001108 <calc_PID_YAW+0xb0>)
 800107a:	f006 fdc3 	bl	8007c04 <__aeabi_fcmple>
 800107e:	b908      	cbnz	r0, 8001084 <calc_PID_YAW+0x2c>
 * The yaw PID calculation needs a special handling as the input value has
 * an integrating character
 * */
void calc_PID_YAW(float istwert, float sollwert, PID_Control *values)
{
	values->e = istwert - sollwert;
 8001080:	61a5      	str	r5, [r4, #24]
 8001082:	e004      	b.n	800108e <calc_PID_YAW+0x36>

	if(values->e >= 180) values->e -= 360;
	else if (values->e <= -180) values->e += 360;
 8001084:	4628      	mov	r0, r5
 8001086:	491f      	ldr	r1, [pc, #124]	; (8001104 <calc_PID_YAW+0xac>)
 8001088:	f006 fb0c 	bl	80076a4 <__addsf3>
 800108c:	61a0      	str	r0, [r4, #24]

	/* Keep the e-value in a maintainable range */
	if(values->e > 50) values->e = 50;
 800108e:	4d1f      	ldr	r5, [pc, #124]	; (800110c <calc_PID_YAW+0xb4>)
 8001090:	69a0      	ldr	r0, [r4, #24]
 8001092:	4629      	mov	r1, r5
 8001094:	f006 fdca 	bl	8007c2c <__aeabi_fcmpgt>
 8001098:	b100      	cbz	r0, 800109c <calc_PID_YAW+0x44>
 800109a:	61a5      	str	r5, [r4, #24]
	if(values->e < -50) values->e = -50;
 800109c:	4d1c      	ldr	r5, [pc, #112]	; (8001110 <calc_PID_YAW+0xb8>)
 800109e:	69a0      	ldr	r0, [r4, #24]
 80010a0:	4629      	mov	r1, r5
 80010a2:	f006 fda5 	bl	8007bf0 <__aeabi_fcmplt>
 80010a6:	b100      	cbz	r0, 80010aa <calc_PID_YAW+0x52>
 80010a8:	61a5      	str	r5, [r4, #24]

	//fr I-Anteil aufsummieren:
	values->Isum = values->Isum + (values->e);
 80010aa:	69a5      	ldr	r5, [r4, #24]
 80010ac:	69e1      	ldr	r1, [r4, #28]
 80010ae:	4628      	mov	r0, r5
 80010b0:	f006 faf8 	bl	80076a4 <__addsf3>

	//PID-Regler
	values->y = (values->kp*values->e) + (values->Isum*values->ki*values->sampling_rate) + (values->kd*(values->e - values->ealt)/values->sampling_rate);
 80010b4:	68a1      	ldr	r1, [r4, #8]
	/* Keep the e-value in a maintainable range */
	if(values->e > 50) values->e = 50;
	if(values->e < -50) values->e = -50;

	//fr I-Anteil aufsummieren:
	values->Isum = values->Isum + (values->e);
 80010b6:	4607      	mov	r7, r0
 80010b8:	61e0      	str	r0, [r4, #28]

	//PID-Regler
	values->y = (values->kp*values->e) + (values->Isum*values->ki*values->sampling_rate) + (values->kd*(values->e - values->ealt)/values->sampling_rate);
 80010ba:	4628      	mov	r0, r5
 80010bc:	f006 fbfa 	bl	80078b4 <__aeabi_fmul>
 80010c0:	6826      	ldr	r6, [r4, #0]
 80010c2:	4680      	mov	r8, r0
 80010c4:	68e1      	ldr	r1, [r4, #12]
 80010c6:	4638      	mov	r0, r7
 80010c8:	f006 fbf4 	bl	80078b4 <__aeabi_fmul>
 80010cc:	4631      	mov	r1, r6
 80010ce:	f006 fbf1 	bl	80078b4 <__aeabi_fmul>
 80010d2:	4601      	mov	r1, r0
 80010d4:	4640      	mov	r0, r8
 80010d6:	f006 fae5 	bl	80076a4 <__addsf3>
 80010da:	6a61      	ldr	r1, [r4, #36]	; 0x24
 80010dc:	4607      	mov	r7, r0
 80010de:	4628      	mov	r0, r5
 80010e0:	f006 fade 	bl	80076a0 <__aeabi_fsub>
 80010e4:	6921      	ldr	r1, [r4, #16]
 80010e6:	f006 fbe5 	bl	80078b4 <__aeabi_fmul>
 80010ea:	4631      	mov	r1, r6
 80010ec:	f006 fc96 	bl	8007a1c <__aeabi_fdiv>
 80010f0:	4601      	mov	r1, r0
 80010f2:	4638      	mov	r0, r7
 80010f4:	f006 fad6 	bl	80076a4 <__addsf3>

	//fr D-Anteil:
	values->ealt = values->e;
 80010f8:	6265      	str	r5, [r4, #36]	; 0x24

	//fr I-Anteil aufsummieren:
	values->Isum = values->Isum + (values->e);

	//PID-Regler
	values->y = (values->kp*values->e) + (values->Isum*values->ki*values->sampling_rate) + (values->kd*(values->e - values->ealt)/values->sampling_rate);
 80010fa:	6060      	str	r0, [r4, #4]

	//fr D-Anteil:
	values->ealt = values->e;
 80010fc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001100:	43340000 	.word	0x43340000
 8001104:	43b40000 	.word	0x43b40000
 8001108:	c3340000 	.word	0xc3340000
 800110c:	42480000 	.word	0x42480000
 8001110:	c2480000 	.word	0xc2480000
 8001114:	00000000 	.word	0x00000000

08001118 <Init_PositionController>:

PID_Control PID_Position;
SmitPredictor_Control Smith_Position;


void Init_PositionController(){
 8001118:	b51f      	push	{r0, r1, r2, r3, r4, lr}

	init_PID(DT_S, 	GlobalSettings.PID_rollPitch.PID_kp,
 800111a:	4c0d      	ldr	r4, [pc, #52]	; (8001150 <Init_PositionController+0x38>)
 800111c:	480d      	ldr	r0, [pc, #52]	; (8001154 <Init_PositionController+0x3c>)
 800111e:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8001120:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8001122:	9300      	str	r3, [sp, #0]
 8001124:	4b0c      	ldr	r3, [pc, #48]	; (8001158 <Init_PositionController+0x40>)
 8001126:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8001128:	9301      	str	r3, [sp, #4]
 800112a:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800112c:	f7ff fe24 	bl	8000d78 <init_PID>
					GlobalSettings.PID_rollPitch.PID_ki,
					GlobalSettings.PID_rollPitch.PID_kd,
					GlobalSettings.PID_rollPitch.PID_kn, &PID_Position);


	init_SmithPredictor(GlobalSettings.SmithPrediktor_rollPitch.a1, GlobalSettings.SmithPrediktor_rollPitch.a2,
 8001130:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8001132:	6d22      	ldr	r2, [r4, #80]	; 0x50
 8001134:	9300      	str	r3, [sp, #0]
 8001136:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8001138:	6ca0      	ldr	r0, [r4, #72]	; 0x48
 800113a:	9301      	str	r3, [sp, #4]
 800113c:	4b07      	ldr	r3, [pc, #28]	; (800115c <Init_PositionController+0x44>)
 800113e:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
 8001140:	9302      	str	r3, [sp, #8]
 8001142:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8001144:	f7ff fe21 	bl	8000d8a <init_SmithPredictor>
						GlobalSettings.SmithPrediktor_rollPitch.b1, GlobalSettings.SmithPrediktor_rollPitch.b2,
						GlobalSettings.SmithPrediktor_rollPitch.b3, GlobalSettings.SmithPrediktor_rollPitch.gain,
						&Smith_Position);

	CtrlStates.pitch = 0.0f;
 8001148:	4b05      	ldr	r3, [pc, #20]	; (8001160 <Init_PositionController+0x48>)
 800114a:	2200      	movs	r2, #0
 800114c:	601a      	str	r2, [r3, #0]

}
 800114e:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}
 8001150:	20002bbc 	.word	0x20002bbc
 8001154:	3b03126f 	.word	0x3b03126f
 8001158:	20002f28 	.word	0x20002f28
 800115c:	20003004 	.word	0x20003004
 8001160:	20002c1c 	.word	0x20002c1c

08001164 <Init_IMU>:

void Init_IMU(){
 8001164:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}


	memset(&xGyroFiltered_float, 0, sizeof(xGyroFiltered_float));
 8001168:	2100      	movs	r1, #0
 800116a:	222c      	movs	r2, #44	; 0x2c
 800116c:	4892      	ldr	r0, [pc, #584]	; (80013b8 <Init_IMU+0x254>)
 800116e:	f006 fe99 	bl	8007ea4 <memset>
	memset(&yGyroFiltered_float, 0, sizeof(yGyroFiltered_float));
 8001172:	2100      	movs	r1, #0
 8001174:	222c      	movs	r2, #44	; 0x2c
 8001176:	4891      	ldr	r0, [pc, #580]	; (80013bc <Init_IMU+0x258>)
 8001178:	f006 fe94 	bl	8007ea4 <memset>
	memset(&zGyroFiltered_float, 0, sizeof(zGyroFiltered_float));
 800117c:	2100      	movs	r1, #0
 800117e:	222c      	movs	r2, #44	; 0x2c
 8001180:	488f      	ldr	r0, [pc, #572]	; (80013c0 <Init_IMU+0x25c>)
 8001182:	f006 fe8f 	bl	8007ea4 <memset>


	memset(&xAccFiltered_float, 0, sizeof(xAccFiltered_float));
 8001186:	2100      	movs	r1, #0
 8001188:	222c      	movs	r2, #44	; 0x2c
 800118a:	488e      	ldr	r0, [pc, #568]	; (80013c4 <Init_IMU+0x260>)
 800118c:	f006 fe8a 	bl	8007ea4 <memset>
	memset(&yAccFiltered_float, 0, sizeof(yAccFiltered_float));
 8001190:	2100      	movs	r1, #0
 8001192:	222c      	movs	r2, #44	; 0x2c
 8001194:	488c      	ldr	r0, [pc, #560]	; (80013c8 <Init_IMU+0x264>)
 8001196:	f006 fe85 	bl	8007ea4 <memset>
	memset(&zAccFiltered_float, 0, sizeof(zAccFiltered_float));
 800119a:	2100      	movs	r1, #0
 800119c:	222c      	movs	r2, #44	; 0x2c
 800119e:	488b      	ldr	r0, [pc, #556]	; (80013cc <Init_IMU+0x268>)
 80011a0:	f006 fe80 	bl	8007ea4 <memset>


	/*Initialize the DCM-variables*/
	IMU_init(&IMU, DT_S);
 80011a4:	488a      	ldr	r0, [pc, #552]	; (80013d0 <Init_IMU+0x26c>)
 80011a6:	498b      	ldr	r1, [pc, #556]	; (80013d4 <Init_IMU+0x270>)
 80011a8:	f7fe ffee 	bl	8000188 <IMU_init>

	if(GlobalSettings.enableDriftCorrection)
 80011ac:	4b8a      	ldr	r3, [pc, #552]	; (80013d8 <Init_IMU+0x274>)
 80011ae:	7a9b      	ldrb	r3, [r3, #10]
 80011b0:	b11b      	cbz	r3, 80011ba <Init_IMU+0x56>
	{
		IMU_init_drift_correction(&IMU, 0.00040f);  //0.00020f/*kp-value*/);
 80011b2:	4887      	ldr	r0, [pc, #540]	; (80013d0 <Init_IMU+0x26c>)
 80011b4:	4989      	ldr	r1, [pc, #548]	; (80013dc <Init_IMU+0x278>)
 80011b6:	f7fe fff8 	bl	80001aa <IMU_init_drift_correction>
 80011ba:	2600      	movs	r6, #0
	}

	while(1)
	{
		Gyro_calibrate(&gyroOffset);
 80011bc:	4c88      	ldr	r4, [pc, #544]	; (80013e0 <Init_IMU+0x27c>)
 80011be:	4620      	mov	r0, r4
 80011c0:	f7ff fb3b 	bl	800083a <Gyro_calibrate>
		for (i = 0;i<5000;i++)
 80011c4:	2300      	movs	r3, #0
 80011c6:	e03b      	b.n	8001240 <Init_IMU+0xdc>
		{
			Gyro_readValues(&gyroXYZ);
 80011c8:	4886      	ldr	r0, [pc, #536]	; (80013e4 <Init_IMU+0x280>)
 80011ca:	f7ff fb00 	bl	80007ce <Gyro_readValues>
			gyroXYZ.gyroValueX = ((gyroXYZ.gyroValueX-gyroOffset.gyroValueX));
 80011ce:	8920      	ldrh	r0, [r4, #8]
 80011d0:	8823      	ldrh	r3, [r4, #0]
			gyroXYZ.gyroValueY = ((gyroXYZ.gyroValueY-gyroOffset.gyroValueY));
 80011d2:	8962      	ldrh	r2, [r4, #10]
	{
		Gyro_calibrate(&gyroOffset);
		for (i = 0;i<5000;i++)
		{
			Gyro_readValues(&gyroXYZ);
			gyroXYZ.gyroValueX = ((gyroXYZ.gyroValueX-gyroOffset.gyroValueX));
 80011d4:	1ac0      	subs	r0, r0, r3
			gyroXYZ.gyroValueY = ((gyroXYZ.gyroValueY-gyroOffset.gyroValueY));
 80011d6:	8863      	ldrh	r3, [r4, #2]
	{
		Gyro_calibrate(&gyroOffset);
		for (i = 0;i<5000;i++)
		{
			Gyro_readValues(&gyroXYZ);
			gyroXYZ.gyroValueX = ((gyroXYZ.gyroValueX-gyroOffset.gyroValueX));
 80011d8:	8120      	strh	r0, [r4, #8]
			gyroXYZ.gyroValueY = ((gyroXYZ.gyroValueY-gyroOffset.gyroValueY));
 80011da:	1ad3      	subs	r3, r2, r3
 80011dc:	8163      	strh	r3, [r4, #10]
			gyroXYZ.gyroValueZ = ((gyroXYZ.gyroValueZ-gyroOffset.gyroValueZ));
 80011de:	89a2      	ldrh	r2, [r4, #12]
 80011e0:	88a3      	ldrh	r3, [r4, #4]

			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] += ((float)gyroXYZ.gyroValueX*GYROCONVERT)*DT_S;
 80011e2:	b200      	sxth	r0, r0
		for (i = 0;i<5000;i++)
		{
			Gyro_readValues(&gyroXYZ);
			gyroXYZ.gyroValueX = ((gyroXYZ.gyroValueX-gyroOffset.gyroValueX));
			gyroXYZ.gyroValueY = ((gyroXYZ.gyroValueY-gyroOffset.gyroValueY));
			gyroXYZ.gyroValueZ = ((gyroXYZ.gyroValueZ-gyroOffset.gyroValueZ));
 80011e4:	1ad3      	subs	r3, r2, r3
 80011e6:	81a3      	strh	r3, [r4, #12]

			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] += ((float)gyroXYZ.gyroValueX*GYROCONVERT)*DT_S;
 80011e8:	f006 fb10 	bl	800780c <__aeabi_i2f>
 80011ec:	497e      	ldr	r1, [pc, #504]	; (80013e8 <Init_IMU+0x284>)
 80011ee:	f006 fb61 	bl	80078b4 <__aeabi_fmul>
 80011f2:	4978      	ldr	r1, [pc, #480]	; (80013d4 <Init_IMU+0x270>)
 80011f4:	f006 fb5e 	bl	80078b4 <__aeabi_fmul>
 80011f8:	4f77      	ldr	r7, [pc, #476]	; (80013d8 <Init_IMU+0x274>)
 80011fa:	4d75      	ldr	r5, [pc, #468]	; (80013d0 <Init_IMU+0x26c>)
 80011fc:	f897 9004 	ldrb.w	r9, [r7, #4]
 8001200:	4680      	mov	r8, r0
 8001202:	f109 090a 	add.w	r9, r9, #10
 8001206:	f855 0029 	ldr.w	r0, [r5, r9, lsl #2]
 800120a:	4641      	mov	r1, r8
 800120c:	f006 fa4a 	bl	80076a4 <__addsf3>
 8001210:	f845 0029 	str.w	r0, [r5, r9, lsl #2]
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] += ((float)gyroXYZ.gyroValueX*GYROCONVERT)*DT_S;
 8001214:	f897 9005 	ldrb.w	r9, [r7, #5]
 8001218:	4641      	mov	r1, r8
 800121a:	f109 090a 	add.w	r9, r9, #10
 800121e:	f855 0029 	ldr.w	r0, [r5, r9, lsl #2]
 8001222:	f006 fa3f 	bl	80076a4 <__addsf3>
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] += ((float)gyroXYZ.gyroValueX*GYROCONVERT)*DT_S;
 8001226:	79bf      	ldrb	r7, [r7, #6]
			gyroXYZ.gyroValueX = ((gyroXYZ.gyroValueX-gyroOffset.gyroValueX));
			gyroXYZ.gyroValueY = ((gyroXYZ.gyroValueY-gyroOffset.gyroValueY));
			gyroXYZ.gyroValueZ = ((gyroXYZ.gyroValueZ-gyroOffset.gyroValueZ));

			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] += ((float)gyroXYZ.gyroValueX*GYROCONVERT)*DT_S;
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] += ((float)gyroXYZ.gyroValueX*GYROCONVERT)*DT_S;
 8001228:	f845 0029 	str.w	r0, [r5, r9, lsl #2]
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] += ((float)gyroXYZ.gyroValueX*GYROCONVERT)*DT_S;
 800122c:	370a      	adds	r7, #10
 800122e:	f855 0027 	ldr.w	r0, [r5, r7, lsl #2]
 8001232:	4641      	mov	r1, r8
 8001234:	f006 fa36 	bl	80076a4 <__addsf3>
	}

	while(1)
	{
		Gyro_calibrate(&gyroOffset);
		for (i = 0;i<5000;i++)
 8001238:	88e3      	ldrh	r3, [r4, #6]
			gyroXYZ.gyroValueY = ((gyroXYZ.gyroValueY-gyroOffset.gyroValueY));
			gyroXYZ.gyroValueZ = ((gyroXYZ.gyroValueZ-gyroOffset.gyroValueZ));

			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] += ((float)gyroXYZ.gyroValueX*GYROCONVERT)*DT_S;
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] += ((float)gyroXYZ.gyroValueX*GYROCONVERT)*DT_S;
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] += ((float)gyroXYZ.gyroValueX*GYROCONVERT)*DT_S;
 800123a:	f845 0027 	str.w	r0, [r5, r7, lsl #2]
	}

	while(1)
	{
		Gyro_calibrate(&gyroOffset);
		for (i = 0;i<5000;i++)
 800123e:	3301      	adds	r3, #1
 8001240:	80e3      	strh	r3, [r4, #6]
 8001242:	88e2      	ldrh	r2, [r4, #6]
 8001244:	f241 3387 	movw	r3, #4999	; 0x1387
 8001248:	429a      	cmp	r2, r3
 800124a:	d9bd      	bls.n	80011c8 <Init_IMU+0x64>
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] += ((float)gyroXYZ.gyroValueX*GYROCONVERT)*DT_S;
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] += ((float)gyroXYZ.gyroValueX*GYROCONVERT)*DT_S;
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] += ((float)gyroXYZ.gyroValueX*GYROCONVERT)*DT_S;
		}
		//vTaskDelayUntil( &xNextWakeTime, DT );
		GPIOC->ODR ^= GPIO_Pin_11;
 800124c:	4b67      	ldr	r3, [pc, #412]	; (80013ec <Init_IMU+0x288>)
		vTaskDelay( 1000 );

		if((IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] > -MAX_GYRO_ERROR) && (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] < MAX_GYRO_ERROR) &&
 800124e:	4d62      	ldr	r5, [pc, #392]	; (80013d8 <Init_IMU+0x274>)
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] += ((float)gyroXYZ.gyroValueX*GYROCONVERT)*DT_S;
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] += ((float)gyroXYZ.gyroValueX*GYROCONVERT)*DT_S;
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] += ((float)gyroXYZ.gyroValueX*GYROCONVERT)*DT_S;
		}
		//vTaskDelayUntil( &xNextWakeTime, DT );
		GPIOC->ODR ^= GPIO_Pin_11;
 8001250:	8a9a      	ldrh	r2, [r3, #20]
		vTaskDelay( 1000 );
 8001252:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] += ((float)gyroXYZ.gyroValueX*GYROCONVERT)*DT_S;
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] += ((float)gyroXYZ.gyroValueX*GYROCONVERT)*DT_S;
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] += ((float)gyroXYZ.gyroValueX*GYROCONVERT)*DT_S;
		}
		//vTaskDelayUntil( &xNextWakeTime, DT );
		GPIOC->ODR ^= GPIO_Pin_11;
 8001256:	b292      	uxth	r2, r2
 8001258:	f482 6200 	eor.w	r2, r2, #2048	; 0x800
 800125c:	829a      	strh	r2, [r3, #20]
		vTaskDelay( 1000 );
 800125e:	f005 fbb7 	bl	80069d0 <vTaskDelay>

		if((IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] > -MAX_GYRO_ERROR) && (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] < MAX_GYRO_ERROR) &&
 8001262:	f895 8004 	ldrb.w	r8, [r5, #4]
 8001266:	4c5a      	ldr	r4, [pc, #360]	; (80013d0 <Init_IMU+0x26c>)
 8001268:	f108 0b0a 	add.w	fp, r8, #10
 800126c:	f854 902b 	ldr.w	r9, [r4, fp, lsl #2]
 8001270:	495f      	ldr	r1, [pc, #380]	; (80013f0 <Init_IMU+0x28c>)
 8001272:	4648      	mov	r0, r9
 8001274:	f006 fcda 	bl	8007c2c <__aeabi_fcmpgt>
 8001278:	2700      	movs	r7, #0
 800127a:	b378      	cbz	r0, 80012dc <Init_IMU+0x178>
 800127c:	4648      	mov	r0, r9
 800127e:	495d      	ldr	r1, [pc, #372]	; (80013f4 <Init_IMU+0x290>)
 8001280:	f006 fcb6 	bl	8007bf0 <__aeabi_fcmplt>
 8001284:	b350      	cbz	r0, 80012dc <Init_IMU+0x178>
		   (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] > -MAX_GYRO_ERROR) && (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] < MAX_GYRO_ERROR) &&
 8001286:	f895 a005 	ldrb.w	sl, [r5, #5]
		}
		//vTaskDelayUntil( &xNextWakeTime, DT );
		GPIOC->ODR ^= GPIO_Pin_11;
		vTaskDelay( 1000 );

		if((IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] > -MAX_GYRO_ERROR) && (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] < MAX_GYRO_ERROR) &&
 800128a:	4959      	ldr	r1, [pc, #356]	; (80013f0 <Init_IMU+0x28c>)
		   (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] > -MAX_GYRO_ERROR) && (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] < MAX_GYRO_ERROR) &&
 800128c:	f10a 0a0a 	add.w	sl, sl, #10
 8001290:	f854 902a 	ldr.w	r9, [r4, sl, lsl #2]
		}
		//vTaskDelayUntil( &xNextWakeTime, DT );
		GPIOC->ODR ^= GPIO_Pin_11;
		vTaskDelay( 1000 );

		if((IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] > -MAX_GYRO_ERROR) && (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] < MAX_GYRO_ERROR) &&
 8001294:	4648      	mov	r0, r9
 8001296:	f006 fcc9 	bl	8007c2c <__aeabi_fcmpgt>
 800129a:	b1f8      	cbz	r0, 80012dc <Init_IMU+0x178>
		   (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] > -MAX_GYRO_ERROR) && (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] < MAX_GYRO_ERROR) &&
 800129c:	4648      	mov	r0, r9
 800129e:	4955      	ldr	r1, [pc, #340]	; (80013f4 <Init_IMU+0x290>)
 80012a0:	f006 fca6 	bl	8007bf0 <__aeabi_fcmplt>
 80012a4:	b1d0      	cbz	r0, 80012dc <Init_IMU+0x178>
		   (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] > -MAX_GYRO_ERROR) && (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] < MAX_GYRO_ERROR))
 80012a6:	f895 9006 	ldrb.w	r9, [r5, #6]
		//vTaskDelayUntil( &xNextWakeTime, DT );
		GPIOC->ODR ^= GPIO_Pin_11;
		vTaskDelay( 1000 );

		if((IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] > -MAX_GYRO_ERROR) && (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] < MAX_GYRO_ERROR) &&
		   (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] > -MAX_GYRO_ERROR) && (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] < MAX_GYRO_ERROR) &&
 80012aa:	4951      	ldr	r1, [pc, #324]	; (80013f0 <Init_IMU+0x28c>)
		   (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] > -MAX_GYRO_ERROR) && (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] < MAX_GYRO_ERROR))
 80012ac:	f109 090a 	add.w	r9, r9, #10
 80012b0:	f854 3029 	ldr.w	r3, [r4, r9, lsl #2]
		//vTaskDelayUntil( &xNextWakeTime, DT );
		GPIOC->ODR ^= GPIO_Pin_11;
		vTaskDelay( 1000 );

		if((IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] > -MAX_GYRO_ERROR) && (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] < MAX_GYRO_ERROR) &&
		   (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] > -MAX_GYRO_ERROR) && (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] < MAX_GYRO_ERROR) &&
 80012b4:	4618      	mov	r0, r3
 80012b6:	9301      	str	r3, [sp, #4]
 80012b8:	f006 fcb8 	bl	8007c2c <__aeabi_fcmpgt>
 80012bc:	9b01      	ldr	r3, [sp, #4]
 80012be:	b168      	cbz	r0, 80012dc <Init_IMU+0x178>
		   (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] > -MAX_GYRO_ERROR) && (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] < MAX_GYRO_ERROR))
 80012c0:	4618      	mov	r0, r3
 80012c2:	494c      	ldr	r1, [pc, #304]	; (80013f4 <Init_IMU+0x290>)
 80012c4:	f006 fc94 	bl	8007bf0 <__aeabi_fcmplt>
 80012c8:	b140      	cbz	r0, 80012dc <Init_IMU+0x178>
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] = 0;
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] = 0;
		printf("Error Gyro Test!\n\r");
	}

	if(GlobalSettings.enableACC)
 80012ca:	7aeb      	ldrb	r3, [r5, #11]

		if((IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] > -MAX_GYRO_ERROR) && (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] < MAX_GYRO_ERROR) &&
		   (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] > -MAX_GYRO_ERROR) && (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] < MAX_GYRO_ERROR) &&
		   (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] > -MAX_GYRO_ERROR) && (IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] < MAX_GYRO_ERROR))
		{
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] = 0;
 80012cc:	f844 702b 	str.w	r7, [r4, fp, lsl #2]
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] = 0;
 80012d0:	f844 702a 	str.w	r7, [r4, sl, lsl #2]
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] = 0;
 80012d4:	f844 7029 	str.w	r7, [r4, r9, lsl #2]
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] = 0;
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] = 0;
		printf("Error Gyro Test!\n\r");
	}

	if(GlobalSettings.enableACC)
 80012d8:	b1b3      	cbz	r3, 8001308 <Init_IMU+0x1a4>
 80012da:	e011      	b.n	8001300 <Init_IMU+0x19c>
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] = 0;
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] = 0;
			break;
		}
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] = 0;
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] = 0;
 80012dc:	4a3e      	ldr	r2, [pc, #248]	; (80013d8 <Init_IMU+0x274>)
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] = 0;
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] = 0;
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] = 0;
			break;
		}
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] = 0;
 80012de:	4b3c      	ldr	r3, [pc, #240]	; (80013d0 <Init_IMU+0x26c>)
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] = 0;
 80012e0:	7951      	ldrb	r1, [r2, #5]
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] = 0;
 80012e2:	7992      	ldrb	r2, [r2, #6]
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] = 0;
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] = 0;
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] = 0;
			break;
		}
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] = 0;
 80012e4:	f108 080a 	add.w	r8, r8, #10
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] = 0;
 80012e8:	310a      	adds	r1, #10
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] = 0;
 80012ea:	320a      	adds	r2, #10
		printf("Error Gyro Test!\n\r");
 80012ec:	4842      	ldr	r0, [pc, #264]	; (80013f8 <Init_IMU+0x294>)
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] = 0;
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] = 0;
			IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] = 0;
			break;
		}
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] = 0;
 80012ee:	f843 6028 	str.w	r6, [r3, r8, lsl #2]
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] = 0;
 80012f2:	f843 6021 	str.w	r6, [r3, r1, lsl #2]
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] = 0;
 80012f6:	f843 6022 	str.w	r6, [r3, r2, lsl #2]
		printf("Error Gyro Test!\n\r");
 80012fa:	f000 ff83 	bl	8002204 <printf>
	}
 80012fe:	e75d      	b.n	80011bc <Init_IMU+0x58>

	if(GlobalSettings.enableACC)
	{
		//ADXL345_calibrate(GlobalSettings.accMaxGOverflow, &accXYZ);
		LSM303DLHC_ACC_calibrate(GlobalSettings.accMaxGOverflow, &accXYZ);
 8001300:	6968      	ldr	r0, [r5, #20]
 8001302:	493e      	ldr	r1, [pc, #248]	; (80013fc <Init_IMU+0x298>)
 8001304:	f7ff fc06 	bl	8000b14 <LSM303DLHC_ACC_calibrate>
	}

	if(GlobalSettings.enableMAG)
 8001308:	4b33      	ldr	r3, [pc, #204]	; (80013d8 <Init_IMU+0x274>)
 800130a:	7e1b      	ldrb	r3, [r3, #24]
 800130c:	2b00      	cmp	r3, #0
 800130e:	d048      	beq.n	80013a2 <Init_IMU+0x23e>
	{
		Mag_calibrate();
		vTaskDelay( 200 );
		Mag_readValues(&magXYZ);
 8001310:	4e33      	ldr	r6, [pc, #204]	; (80013e0 <Init_IMU+0x27c>)
		LSM303DLHC_ACC_calibrate(GlobalSettings.accMaxGOverflow, &accXYZ);
	}

	if(GlobalSettings.enableMAG)
	{
		Mag_calibrate();
 8001312:	f7ff fc5e 	bl	8000bd2 <Mag_calibrate>
		vTaskDelay( 200 );
 8001316:	20c8      	movs	r0, #200	; 0xc8
 8001318:	f005 fb5a 	bl	80069d0 <vTaskDelay>
		Mag_readValues(&magXYZ);
 800131c:	f106 001c 	add.w	r0, r6, #28
 8001320:	f7ff fc73 	bl	8000c0a <Mag_readValues>
		eulerTemp.yaw = atan2((float)(-magXYZ.magValueX),(float)(magXYZ.magValueY))-1.5707;
 8001324:	f9b6 001c 	ldrsh.w	r0, [r6, #28]
 8001328:	4240      	negs	r0, r0
 800132a:	f006 fa6f 	bl	800780c <__aeabi_i2f>
 800132e:	f006 f8e7 	bl	8007500 <__aeabi_f2d>
 8001332:	4604      	mov	r4, r0
 8001334:	f9b6 001e 	ldrsh.w	r0, [r6, #30]
 8001338:	460d      	mov	r5, r1
 800133a:	f006 fa67 	bl	800780c <__aeabi_i2f>
 800133e:	f006 f8df 	bl	8007500 <__aeabi_f2d>
 8001342:	4602      	mov	r2, r0
 8001344:	460b      	mov	r3, r1
 8001346:	4620      	mov	r0, r4
 8001348:	4629      	mov	r1, r5
 800134a:	f006 feb5 	bl	80080b8 <atan2>
 800134e:	a318      	add	r3, pc, #96	; (adr r3, 80013b0 <Init_IMU+0x24c>)
 8001350:	e9d3 2300 	ldrd	r2, r3, [r3]
 8001354:	f005 ff74 	bl	8007240 <__aeabi_dsub>
 8001358:	f006 f94e 	bl	80075f8 <__aeabi_d2f>
 800135c:	4b28      	ldr	r3, [pc, #160]	; (8001400 <Init_IMU+0x29c>)
		CtrlStates.yaw = -eulerTemp.yaw*(180/M_PI);
 800135e:	4929      	ldr	r1, [pc, #164]	; (8001404 <Init_IMU+0x2a0>)
	if(GlobalSettings.enableMAG)
	{
		Mag_calibrate();
		vTaskDelay( 200 );
		Mag_readValues(&magXYZ);
		eulerTemp.yaw = atan2((float)(-magXYZ.magValueX),(float)(magXYZ.magValueY))-1.5707;
 8001360:	6098      	str	r0, [r3, #8]
		CtrlStates.yaw = -eulerTemp.yaw*(180/M_PI);
 8001362:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
 8001366:	f006 faa5 	bl	80078b4 <__aeabi_fmul>
 800136a:	4c27      	ldr	r4, [pc, #156]	; (8001408 <Init_IMU+0x2a4>)
		/* The yaw value needs a special handling */
		if(CtrlStates.yaw > 180) CtrlStates.yaw -= 360;
 800136c:	4927      	ldr	r1, [pc, #156]	; (800140c <Init_IMU+0x2a8>)
	{
		Mag_calibrate();
		vTaskDelay( 200 );
		Mag_readValues(&magXYZ);
		eulerTemp.yaw = atan2((float)(-magXYZ.magValueX),(float)(magXYZ.magValueY))-1.5707;
		CtrlStates.yaw = -eulerTemp.yaw*(180/M_PI);
 800136e:	6060      	str	r0, [r4, #4]
 8001370:	4605      	mov	r5, r0
		/* The yaw value needs a special handling */
		if(CtrlStates.yaw > 180) CtrlStates.yaw -= 360;
 8001372:	f006 fc5b 	bl	8007c2c <__aeabi_fcmpgt>
 8001376:	b120      	cbz	r0, 8001382 <Init_IMU+0x21e>
 8001378:	4628      	mov	r0, r5
 800137a:	4925      	ldr	r1, [pc, #148]	; (8001410 <Init_IMU+0x2ac>)
 800137c:	f006 f990 	bl	80076a0 <__aeabi_fsub>
 8001380:	6060      	str	r0, [r4, #4]
		if(CtrlStates.yaw < -180) CtrlStates.yaw += 360;
 8001382:	6864      	ldr	r4, [r4, #4]
 8001384:	4923      	ldr	r1, [pc, #140]	; (8001414 <Init_IMU+0x2b0>)
 8001386:	4620      	mov	r0, r4
 8001388:	f006 fc32 	bl	8007bf0 <__aeabi_fcmplt>
 800138c:	b128      	cbz	r0, 800139a <Init_IMU+0x236>
 800138e:	4620      	mov	r0, r4
 8001390:	491f      	ldr	r1, [pc, #124]	; (8001410 <Init_IMU+0x2ac>)
 8001392:	f006 f987 	bl	80076a4 <__addsf3>
 8001396:	4b1c      	ldr	r3, [pc, #112]	; (8001408 <Init_IMU+0x2a4>)
 8001398:	6058      	str	r0, [r3, #4]
		IMU_Euler_to_DCM(&IMU, &eulerTemp);
 800139a:	480d      	ldr	r0, [pc, #52]	; (80013d0 <Init_IMU+0x26c>)
 800139c:	4918      	ldr	r1, [pc, #96]	; (8001400 <Init_IMU+0x29c>)
 800139e:	f7ff f8df 	bl	8000560 <IMU_Euler_to_DCM>
	CtrlStates.copterStatus |= IMU_READY_FLAG;

	//xNextWakeTime = xTaskGetTickCount();

	/* Set the DRIVE Flag! */
	CtrlStates.copterStatus |= ARMED_FLAG;
 80013a2:	4b19      	ldr	r3, [pc, #100]	; (8001408 <Init_IMU+0x2a4>)
 80013a4:	7a1a      	ldrb	r2, [r3, #8]
 80013a6:	f042 0203 	orr.w	r2, r2, #3
 80013aa:	721a      	strb	r2, [r3, #8]

}
 80013ac:	e8bd 8ffe 	ldmia.w	sp!, {r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80013b0:	60000000 	.word	0x60000000
 80013b4:	3ff92196 	.word	0x3ff92196
 80013b8:	20002fa8 	.word	0x20002fa8
 80013bc:	20002c28 	.word	0x20002c28
 80013c0:	20002f50 	.word	0x20002f50
 80013c4:	20002f7c 	.word	0x20002f7c
 80013c8:	20002fd8 	.word	0x20002fd8
 80013cc:	20002c60 	.word	0x20002c60
 80013d0:	20002eb0 	.word	0x20002eb0
 80013d4:	3b03126f 	.word	0x3b03126f
 80013d8:	20002bbc 	.word	0x20002bbc
 80013dc:	39d1b717 	.word	0x39d1b717
 80013e0:	20000154 	.word	0x20000154
 80013e4:	2000015c 	.word	0x2000015c
 80013e8:	3d8f5c29 	.word	0x3d8f5c29
 80013ec:	48000800 	.word	0x48000800
 80013f0:	be19999a 	.word	0xbe19999a
 80013f4:	3e19999a 	.word	0x3e19999a
 80013f8:	0800a9c8 	.word	0x0800a9c8
 80013fc:	20000164 	.word	0x20000164
 8001400:	20002c54 	.word	0x20002c54
 8001404:	42652ee0 	.word	0x42652ee0
 8001408:	20002c1c 	.word	0x20002c1c
 800140c:	43340000 	.word	0x43340000
 8001410:	43b40000 	.word	0x43b40000
 8001414:	c3340000 	.word	0xc3340000

08001418 <IMU_Calculation>:


void IMU_Calculation()
{
 8001418:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}

	/*!
	 *  IMU - Calculation Process
	 *
	 */
		Gyro_readValues(&gyroXYZ);
 800141c:	4c85      	ldr	r4, [pc, #532]	; (8001634 <IMU_Calculation+0x21c>)
 800141e:	f104 0008 	add.w	r0, r4, #8
 8001422:	f7ff f9d4 	bl	80007ce <Gyro_readValues>
		gyroXYZ.gyroValueX = ((gyroXYZ.gyroValueX-gyroOffset.gyroValueX));
 8001426:	8925      	ldrh	r5, [r4, #8]
 8001428:	8823      	ldrh	r3, [r4, #0]
		gyroXYZ.gyroValueY = ((gyroXYZ.gyroValueY-gyroOffset.gyroValueY));
 800142a:	8960      	ldrh	r0, [r4, #10]
	/*!
	 *  IMU - Calculation Process
	 *
	 */
		Gyro_readValues(&gyroXYZ);
		gyroXYZ.gyroValueX = ((gyroXYZ.gyroValueX-gyroOffset.gyroValueX));
 800142c:	1aed      	subs	r5, r5, r3
		gyroXYZ.gyroValueY = ((gyroXYZ.gyroValueY-gyroOffset.gyroValueY));
 800142e:	8863      	ldrh	r3, [r4, #2]
		gyroXYZ.gyroValueZ = ((gyroXYZ.gyroValueZ-gyroOffset.gyroValueZ));
 8001430:	89a1      	ldrh	r1, [r4, #12]
	 *  IMU - Calculation Process
	 *
	 */
		Gyro_readValues(&gyroXYZ);
		gyroXYZ.gyroValueX = ((gyroXYZ.gyroValueX-gyroOffset.gyroValueX));
		gyroXYZ.gyroValueY = ((gyroXYZ.gyroValueY-gyroOffset.gyroValueY));
 8001432:	1ac0      	subs	r0, r0, r3
		gyroXYZ.gyroValueZ = ((gyroXYZ.gyroValueZ-gyroOffset.gyroValueZ));
 8001434:	88a3      	ldrh	r3, [r4, #4]
	/*!
	 *  IMU - Calculation Process
	 *
	 */
		Gyro_readValues(&gyroXYZ);
		gyroXYZ.gyroValueX = ((gyroXYZ.gyroValueX-gyroOffset.gyroValueX));
 8001436:	8125      	strh	r5, [r4, #8]
		gyroXYZ.gyroValueY = ((gyroXYZ.gyroValueY-gyroOffset.gyroValueY));
		gyroXYZ.gyroValueZ = ((gyroXYZ.gyroValueZ-gyroOffset.gyroValueZ));
 8001438:	1ac9      	subs	r1, r1, r3

		/* Cut-off the lower values to reduce noise and fail-integration*/
		if(gyroXYZ.gyroValueX > -GlobalSettings.gyroSensTreshold && gyroXYZ.gyroValueX < GlobalSettings.gyroSensTreshold) gyroXYZ.gyroValueX = 0;
 800143a:	4b7f      	ldr	r3, [pc, #508]	; (8001638 <IMU_Calculation+0x220>)
 800143c:	b22d      	sxth	r5, r5
 800143e:	881b      	ldrh	r3, [r3, #0]
	 *  IMU - Calculation Process
	 *
	 */
		Gyro_readValues(&gyroXYZ);
		gyroXYZ.gyroValueX = ((gyroXYZ.gyroValueX-gyroOffset.gyroValueX));
		gyroXYZ.gyroValueY = ((gyroXYZ.gyroValueY-gyroOffset.gyroValueY));
 8001440:	8160      	strh	r0, [r4, #10]
		gyroXYZ.gyroValueZ = ((gyroXYZ.gyroValueZ-gyroOffset.gyroValueZ));

		/* Cut-off the lower values to reduce noise and fail-integration*/
		if(gyroXYZ.gyroValueX > -GlobalSettings.gyroSensTreshold && gyroXYZ.gyroValueX < GlobalSettings.gyroSensTreshold) gyroXYZ.gyroValueX = 0;
 8001442:	425a      	negs	r2, r3
 8001444:	4295      	cmp	r5, r2
	 *
	 */
		Gyro_readValues(&gyroXYZ);
		gyroXYZ.gyroValueX = ((gyroXYZ.gyroValueX-gyroOffset.gyroValueX));
		gyroXYZ.gyroValueY = ((gyroXYZ.gyroValueY-gyroOffset.gyroValueY));
		gyroXYZ.gyroValueZ = ((gyroXYZ.gyroValueZ-gyroOffset.gyroValueZ));
 8001446:	81a1      	strh	r1, [r4, #12]

		/* Cut-off the lower values to reduce noise and fail-integration*/
		if(gyroXYZ.gyroValueX > -GlobalSettings.gyroSensTreshold && gyroXYZ.gyroValueX < GlobalSettings.gyroSensTreshold) gyroXYZ.gyroValueX = 0;
 8001448:	dd03      	ble.n	8001452 <IMU_Calculation+0x3a>
 800144a:	429d      	cmp	r5, r3
 800144c:	da01      	bge.n	8001452 <IMU_Calculation+0x3a>
 800144e:	2500      	movs	r5, #0
 8001450:	8125      	strh	r5, [r4, #8]
		if(gyroXYZ.gyroValueY > -GlobalSettings.gyroSensTreshold && gyroXYZ.gyroValueY < GlobalSettings.gyroSensTreshold) gyroXYZ.gyroValueY = 0;
 8001452:	b200      	sxth	r0, r0
 8001454:	4290      	cmp	r0, r2
 8001456:	dd03      	ble.n	8001460 <IMU_Calculation+0x48>
 8001458:	4298      	cmp	r0, r3
 800145a:	da01      	bge.n	8001460 <IMU_Calculation+0x48>
 800145c:	2000      	movs	r0, #0
 800145e:	8160      	strh	r0, [r4, #10]
		if(gyroXYZ.gyroValueZ > -GlobalSettings.gyroSensTreshold && gyroXYZ.gyroValueZ < GlobalSettings.gyroSensTreshold) gyroXYZ.gyroValueZ = 0;
 8001460:	b209      	sxth	r1, r1
 8001462:	4291      	cmp	r1, r2
 8001464:	4c73      	ldr	r4, [pc, #460]	; (8001634 <IMU_Calculation+0x21c>)
 8001466:	dd03      	ble.n	8001470 <IMU_Calculation+0x58>
 8001468:	4299      	cmp	r1, r3
 800146a:	da01      	bge.n	8001470 <IMU_Calculation+0x58>
 800146c:	2300      	movs	r3, #0
 800146e:	81a3      	strh	r3, [r4, #12]

		floatFilterGyro(&xGyroFiltered_float, gyroXYZ.gyroValueX);
 8001470:	f8df 91ec 	ldr.w	r9, [pc, #492]	; 8001660 <IMU_Calculation+0x248>
		floatFilterGyro(&yGyroFiltered_float, gyroXYZ.gyroValueY);
 8001474:	f8df 81ec 	ldr.w	r8, [pc, #492]	; 8001664 <IMU_Calculation+0x24c>
		/* Cut-off the lower values to reduce noise and fail-integration*/
		if(gyroXYZ.gyroValueX > -GlobalSettings.gyroSensTreshold && gyroXYZ.gyroValueX < GlobalSettings.gyroSensTreshold) gyroXYZ.gyroValueX = 0;
		if(gyroXYZ.gyroValueY > -GlobalSettings.gyroSensTreshold && gyroXYZ.gyroValueY < GlobalSettings.gyroSensTreshold) gyroXYZ.gyroValueY = 0;
		if(gyroXYZ.gyroValueZ > -GlobalSettings.gyroSensTreshold && gyroXYZ.gyroValueZ < GlobalSettings.gyroSensTreshold) gyroXYZ.gyroValueZ = 0;

		floatFilterGyro(&xGyroFiltered_float, gyroXYZ.gyroValueX);
 8001478:	4648      	mov	r0, r9
 800147a:	f9b4 1008 	ldrsh.w	r1, [r4, #8]
 800147e:	f000 fc0d 	bl	8001c9c <floatFilterGyro>
		floatFilterGyro(&yGyroFiltered_float, gyroXYZ.gyroValueY);
		floatFilterGyro(&zGyroFiltered_float, gyroXYZ.gyroValueZ);
 8001482:	4f6e      	ldr	r7, [pc, #440]	; (800163c <IMU_Calculation+0x224>)
		if(gyroXYZ.gyroValueX > -GlobalSettings.gyroSensTreshold && gyroXYZ.gyroValueX < GlobalSettings.gyroSensTreshold) gyroXYZ.gyroValueX = 0;
		if(gyroXYZ.gyroValueY > -GlobalSettings.gyroSensTreshold && gyroXYZ.gyroValueY < GlobalSettings.gyroSensTreshold) gyroXYZ.gyroValueY = 0;
		if(gyroXYZ.gyroValueZ > -GlobalSettings.gyroSensTreshold && gyroXYZ.gyroValueZ < GlobalSettings.gyroSensTreshold) gyroXYZ.gyroValueZ = 0;

		floatFilterGyro(&xGyroFiltered_float, gyroXYZ.gyroValueX);
		floatFilterGyro(&yGyroFiltered_float, gyroXYZ.gyroValueY);
 8001484:	4640      	mov	r0, r8
 8001486:	f9b4 100a 	ldrsh.w	r1, [r4, #10]
 800148a:	f000 fc07 	bl	8001c9c <floatFilterGyro>
		floatFilterGyro(&zGyroFiltered_float, gyroXYZ.gyroValueZ);
 800148e:	f9b4 100c 	ldrsh.w	r1, [r4, #12]

		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] = GlobalSettings.gyroDir.sensDirection[sensX]*(xGyroFiltered_float.currentValue*GYROCONVERT)*DEG_TO_RAD;
 8001492:	4c69      	ldr	r4, [pc, #420]	; (8001638 <IMU_Calculation+0x220>)
		if(gyroXYZ.gyroValueY > -GlobalSettings.gyroSensTreshold && gyroXYZ.gyroValueY < GlobalSettings.gyroSensTreshold) gyroXYZ.gyroValueY = 0;
		if(gyroXYZ.gyroValueZ > -GlobalSettings.gyroSensTreshold && gyroXYZ.gyroValueZ < GlobalSettings.gyroSensTreshold) gyroXYZ.gyroValueZ = 0;

		floatFilterGyro(&xGyroFiltered_float, gyroXYZ.gyroValueX);
		floatFilterGyro(&yGyroFiltered_float, gyroXYZ.gyroValueY);
		floatFilterGyro(&zGyroFiltered_float, gyroXYZ.gyroValueZ);
 8001494:	4638      	mov	r0, r7
 8001496:	f000 fc01 	bl	8001c9c <floatFilterGyro>

		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] = GlobalSettings.gyroDir.sensDirection[sensX]*(xGyroFiltered_float.currentValue*GYROCONVERT)*DEG_TO_RAD;
 800149a:	f994 0007 	ldrsb.w	r0, [r4, #7]
 800149e:	f006 f9b5 	bl	800780c <__aeabi_i2f>
 80014a2:	4967      	ldr	r1, [pc, #412]	; (8001640 <IMU_Calculation+0x228>)
 80014a4:	4683      	mov	fp, r0
 80014a6:	f8d9 0028 	ldr.w	r0, [r9, #40]	; 0x28
 80014aa:	f006 fa03 	bl	80078b4 <__aeabi_fmul>
 80014ae:	4601      	mov	r1, r0
 80014b0:	4658      	mov	r0, fp
 80014b2:	f006 f9ff 	bl	80078b4 <__aeabi_fmul>
 80014b6:	4963      	ldr	r1, [pc, #396]	; (8001644 <IMU_Calculation+0x22c>)
 80014b8:	f006 f9fc 	bl	80078b4 <__aeabi_fmul>
 80014bc:	f894 a004 	ldrb.w	sl, [r4, #4]
 80014c0:	4d61      	ldr	r5, [pc, #388]	; (8001648 <IMU_Calculation+0x230>)
 80014c2:	f10a 0a0a 	add.w	sl, sl, #10
 80014c6:	f845 002a 	str.w	r0, [r5, sl, lsl #2]
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] = GlobalSettings.gyroDir.sensDirection[sensY]*(yGyroFiltered_float.currentValue*GYROCONVERT)*DEG_TO_RAD;
 80014ca:	f994 0008 	ldrsb.w	r0, [r4, #8]
 80014ce:	f006 f99d 	bl	800780c <__aeabi_i2f>
 80014d2:	495b      	ldr	r1, [pc, #364]	; (8001640 <IMU_Calculation+0x228>)
 80014d4:	4682      	mov	sl, r0
 80014d6:	f8d8 0028 	ldr.w	r0, [r8, #40]	; 0x28
 80014da:	f006 f9eb 	bl	80078b4 <__aeabi_fmul>
 80014de:	4601      	mov	r1, r0
 80014e0:	4650      	mov	r0, sl
 80014e2:	f006 f9e7 	bl	80078b4 <__aeabi_fmul>
 80014e6:	4957      	ldr	r1, [pc, #348]	; (8001644 <IMU_Calculation+0x22c>)
 80014e8:	f006 f9e4 	bl	80078b4 <__aeabi_fmul>
 80014ec:	f894 9005 	ldrb.w	r9, [r4, #5]
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] = GlobalSettings.gyroDir.sensDirection[sensZ]*(zGyroFiltered_float.currentValue*GYROCONVERT)*DEG_TO_RAD;
 80014f0:	f894 8006 	ldrb.w	r8, [r4, #6]
		floatFilterGyro(&xGyroFiltered_float, gyroXYZ.gyroValueX);
		floatFilterGyro(&yGyroFiltered_float, gyroXYZ.gyroValueY);
		floatFilterGyro(&zGyroFiltered_float, gyroXYZ.gyroValueZ);

		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] = GlobalSettings.gyroDir.sensDirection[sensX]*(xGyroFiltered_float.currentValue*GYROCONVERT)*DEG_TO_RAD;
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] = GlobalSettings.gyroDir.sensDirection[sensY]*(yGyroFiltered_float.currentValue*GYROCONVERT)*DEG_TO_RAD;
 80014f4:	f109 090a 	add.w	r9, r9, #10
 80014f8:	f845 0029 	str.w	r0, [r5, r9, lsl #2]
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] = GlobalSettings.gyroDir.sensDirection[sensZ]*(zGyroFiltered_float.currentValue*GYROCONVERT)*DEG_TO_RAD;
 80014fc:	f994 0009 	ldrsb.w	r0, [r4, #9]
 8001500:	f006 f984 	bl	800780c <__aeabi_i2f>
 8001504:	494e      	ldr	r1, [pc, #312]	; (8001640 <IMU_Calculation+0x228>)
 8001506:	4681      	mov	r9, r0
 8001508:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800150a:	f006 f9d3 	bl	80078b4 <__aeabi_fmul>
 800150e:	4601      	mov	r1, r0
 8001510:	4648      	mov	r0, r9
 8001512:	f006 f9cf 	bl	80078b4 <__aeabi_fmul>
 8001516:	494b      	ldr	r1, [pc, #300]	; (8001644 <IMU_Calculation+0x22c>)
 8001518:	f006 f9cc 	bl	80078b4 <__aeabi_fmul>

		/*Here the ACC-Compensation, we do this in every tenth round*/
		if(GlobalSettings.enableACC)
 800151c:	7ae3      	ldrb	r3, [r4, #11]
		floatFilterGyro(&yGyroFiltered_float, gyroXYZ.gyroValueY);
		floatFilterGyro(&zGyroFiltered_float, gyroXYZ.gyroValueZ);

		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] = GlobalSettings.gyroDir.sensDirection[sensX]*(xGyroFiltered_float.currentValue*GYROCONVERT)*DEG_TO_RAD;
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] = GlobalSettings.gyroDir.sensDirection[sensY]*(yGyroFiltered_float.currentValue*GYROCONVERT)*DEG_TO_RAD;
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] = GlobalSettings.gyroDir.sensDirection[sensZ]*(zGyroFiltered_float.currentValue*GYROCONVERT)*DEG_TO_RAD;
 800151e:	f108 080a 	add.w	r8, r8, #10
		/* Cut-off the lower values to reduce noise and fail-integration*/
		if(gyroXYZ.gyroValueX > -GlobalSettings.gyroSensTreshold && gyroXYZ.gyroValueX < GlobalSettings.gyroSensTreshold) gyroXYZ.gyroValueX = 0;
		if(gyroXYZ.gyroValueY > -GlobalSettings.gyroSensTreshold && gyroXYZ.gyroValueY < GlobalSettings.gyroSensTreshold) gyroXYZ.gyroValueY = 0;
		if(gyroXYZ.gyroValueZ > -GlobalSettings.gyroSensTreshold && gyroXYZ.gyroValueZ < GlobalSettings.gyroSensTreshold) gyroXYZ.gyroValueZ = 0;

		floatFilterGyro(&xGyroFiltered_float, gyroXYZ.gyroValueX);
 8001522:	4e44      	ldr	r6, [pc, #272]	; (8001634 <IMU_Calculation+0x21c>)
		floatFilterGyro(&yGyroFiltered_float, gyroXYZ.gyroValueY);
		floatFilterGyro(&zGyroFiltered_float, gyroXYZ.gyroValueZ);

		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensX]] = GlobalSettings.gyroDir.sensDirection[sensX]*(xGyroFiltered_float.currentValue*GYROCONVERT)*DEG_TO_RAD;
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensY]] = GlobalSettings.gyroDir.sensDirection[sensY]*(yGyroFiltered_float.currentValue*GYROCONVERT)*DEG_TO_RAD;
		IMU.velocity_vector[GlobalSettings.gyroDir.sensOrder[sensZ]] = GlobalSettings.gyroDir.sensDirection[sensZ]*(zGyroFiltered_float.currentValue*GYROCONVERT)*DEG_TO_RAD;
 8001524:	f845 0028 	str.w	r0, [r5, r8, lsl #2]

		/*Here the ACC-Compensation, we do this in every tenth round*/
		if(GlobalSettings.enableACC)
 8001528:	2b00      	cmp	r3, #0
 800152a:	f000 80bd 	beq.w	80016a8 <IMU_Calculation+0x290>
		{
			if(accCount >= 5)
 800152e:	f896 3022 	ldrb.w	r3, [r6, #34]	; 0x22
 8001532:	2b04      	cmp	r3, #4
 8001534:	f240 80b2 	bls.w	800169c <IMU_Calculation+0x284>
//
//				accXYZ.accValueX = ADC_GetInjectedConversionValue(ADC2,ADC_InjectedSequence_2)-1700;
//				accXYZ.accValueZ = ADC_GetInjectedConversionValue(ADC2,ADC_InjectedSequence_1)-1700;
//				accXYZ.accValueY = ADC_GetInjectedConversionValue(ADC2,ADC_InjectedSequence_3)-1700;

				floatFilterAcc(&xAccFiltered_float, accXYZ.accValueX);
 8001538:	f8df 912c 	ldr.w	r9, [pc, #300]	; 8001668 <IMU_Calculation+0x250>
		{
			if(accCount >= 5)
			{
				//ADXL345_readValues(&accXYZ);
				//LSM303DLHC_ACC_readValues(&accXYZ);
				LSM303DLHC_ACC_readValuesDMA(&accXYZ, &accBuffer[0]);
 800153c:	f106 0010 	add.w	r0, r6, #16
 8001540:	4942      	ldr	r1, [pc, #264]	; (800164c <IMU_Calculation+0x234>)
//				accXYZ.accValueX = ADC_GetInjectedConversionValue(ADC2,ADC_InjectedSequence_2)-1700;
//				accXYZ.accValueZ = ADC_GetInjectedConversionValue(ADC2,ADC_InjectedSequence_1)-1700;
//				accXYZ.accValueY = ADC_GetInjectedConversionValue(ADC2,ADC_InjectedSequence_3)-1700;

				floatFilterAcc(&xAccFiltered_float, accXYZ.accValueX);
				floatFilterAcc(&yAccFiltered_float, accXYZ.accValueY);
 8001542:	f8df 8128 	ldr.w	r8, [pc, #296]	; 800166c <IMU_Calculation+0x254>
		{
			if(accCount >= 5)
			{
				//ADXL345_readValues(&accXYZ);
				//LSM303DLHC_ACC_readValues(&accXYZ);
				LSM303DLHC_ACC_readValuesDMA(&accXYZ, &accBuffer[0]);
 8001546:	f7ff fb21 	bl	8000b8c <LSM303DLHC_ACC_readValuesDMA>
//				accXYZ.accValueZ = ADC_GetInjectedConversionValue(ADC2,ADC_InjectedSequence_1)-1700;
//				accXYZ.accValueY = ADC_GetInjectedConversionValue(ADC2,ADC_InjectedSequence_3)-1700;

				floatFilterAcc(&xAccFiltered_float, accXYZ.accValueX);
				floatFilterAcc(&yAccFiltered_float, accXYZ.accValueY);
				floatFilterAcc(&zAccFiltered_float, accXYZ.accValueZ);
 800154a:	4f41      	ldr	r7, [pc, #260]	; (8001650 <IMU_Calculation+0x238>)
//
//				accXYZ.accValueX = ADC_GetInjectedConversionValue(ADC2,ADC_InjectedSequence_2)-1700;
//				accXYZ.accValueZ = ADC_GetInjectedConversionValue(ADC2,ADC_InjectedSequence_1)-1700;
//				accXYZ.accValueY = ADC_GetInjectedConversionValue(ADC2,ADC_InjectedSequence_3)-1700;

				floatFilterAcc(&xAccFiltered_float, accXYZ.accValueX);
 800154c:	4648      	mov	r0, r9
 800154e:	f9b6 1010 	ldrsh.w	r1, [r6, #16]
 8001552:	f000 fb4d 	bl	8001bf0 <floatFilterAcc>
				floatFilterAcc(&yAccFiltered_float, accXYZ.accValueY);
 8001556:	f9b6 1012 	ldrsh.w	r1, [r6, #18]
 800155a:	4640      	mov	r0, r8
 800155c:	f000 fb48 	bl	8001bf0 <floatFilterAcc>
				floatFilterAcc(&zAccFiltered_float, accXYZ.accValueZ);
 8001560:	f9b6 1014 	ldrsh.w	r1, [r6, #20]
 8001564:	4638      	mov	r0, r7
 8001566:	f000 fb43 	bl	8001bf0 <floatFilterAcc>

				if((xAccFiltered_float.currentValue < accXYZ.accGValue) && (xAccFiltered_float.currentValue > -accXYZ.accGValue) &&
 800156a:	f8d9 9028 	ldr.w	r9, [r9, #40]	; 0x28
 800156e:	69b6      	ldr	r6, [r6, #24]
 8001570:	4648      	mov	r0, r9
 8001572:	4631      	mov	r1, r6
 8001574:	f006 fb3c 	bl	8007bf0 <__aeabi_fcmplt>
 8001578:	2800      	cmp	r0, #0
 800157a:	d079      	beq.n	8001670 <IMU_Calculation+0x258>
 800157c:	f106 4a00 	add.w	sl, r6, #2147483648	; 0x80000000
 8001580:	4648      	mov	r0, r9
 8001582:	4651      	mov	r1, sl
 8001584:	f006 fb52 	bl	8007c2c <__aeabi_fcmpgt>
 8001588:	2800      	cmp	r0, #0
 800158a:	d071      	beq.n	8001670 <IMU_Calculation+0x258>
				   (yAccFiltered_float.currentValue < accXYZ.accGValue) && (yAccFiltered_float.currentValue > -accXYZ.accGValue) &&
 800158c:	f8d8 8028 	ldr.w	r8, [r8, #40]	; 0x28

				floatFilterAcc(&xAccFiltered_float, accXYZ.accValueX);
				floatFilterAcc(&yAccFiltered_float, accXYZ.accValueY);
				floatFilterAcc(&zAccFiltered_float, accXYZ.accValueZ);

				if((xAccFiltered_float.currentValue < accXYZ.accGValue) && (xAccFiltered_float.currentValue > -accXYZ.accGValue) &&
 8001590:	4631      	mov	r1, r6
 8001592:	4640      	mov	r0, r8
 8001594:	f006 fb2c 	bl	8007bf0 <__aeabi_fcmplt>
 8001598:	2800      	cmp	r0, #0
 800159a:	d069      	beq.n	8001670 <IMU_Calculation+0x258>
				   (yAccFiltered_float.currentValue < accXYZ.accGValue) && (yAccFiltered_float.currentValue > -accXYZ.accGValue) &&
 800159c:	4640      	mov	r0, r8
 800159e:	4651      	mov	r1, sl
 80015a0:	f006 fb44 	bl	8007c2c <__aeabi_fcmpgt>
 80015a4:	2800      	cmp	r0, #0
 80015a6:	d063      	beq.n	8001670 <IMU_Calculation+0x258>
				   (zAccFiltered_float.currentValue < accXYZ.accGValue) && (zAccFiltered_float.currentValue > -accXYZ.accGValue))
 80015a8:	6abf      	ldr	r7, [r7, #40]	; 0x28
				floatFilterAcc(&xAccFiltered_float, accXYZ.accValueX);
				floatFilterAcc(&yAccFiltered_float, accXYZ.accValueY);
				floatFilterAcc(&zAccFiltered_float, accXYZ.accValueZ);

				if((xAccFiltered_float.currentValue < accXYZ.accGValue) && (xAccFiltered_float.currentValue > -accXYZ.accGValue) &&
				   (yAccFiltered_float.currentValue < accXYZ.accGValue) && (yAccFiltered_float.currentValue > -accXYZ.accGValue) &&
 80015aa:	4631      	mov	r1, r6
 80015ac:	4638      	mov	r0, r7
 80015ae:	f006 fb1f 	bl	8007bf0 <__aeabi_fcmplt>
 80015b2:	2800      	cmp	r0, #0
 80015b4:	d05c      	beq.n	8001670 <IMU_Calculation+0x258>
				   (zAccFiltered_float.currentValue < accXYZ.accGValue) && (zAccFiltered_float.currentValue > -accXYZ.accGValue))
 80015b6:	4638      	mov	r0, r7
 80015b8:	4651      	mov	r1, sl
 80015ba:	f006 fb37 	bl	8007c2c <__aeabi_fcmpgt>
 80015be:	2800      	cmp	r0, #0
 80015c0:	d056      	beq.n	8001670 <IMU_Calculation+0x258>
				{
					/*Direction setup is the same as above*/
					IMU.accel_vector[GlobalSettings.accDir.sensOrder[sensX]] = GlobalSettings.accDir.sensDirection[sensX]*xAccFiltered_float.currentValue;
 80015c2:	f994 000f 	ldrsb.w	r0, [r4, #15]
 80015c6:	f006 f921 	bl	800780c <__aeabi_i2f>
 80015ca:	4649      	mov	r1, r9
 80015cc:	f006 f972 	bl	80078b4 <__aeabi_fmul>
 80015d0:	f894 a00c 	ldrb.w	sl, [r4, #12]
					IMU.accel_vector[GlobalSettings.accDir.sensOrder[sensY]] = GlobalSettings.accDir.sensDirection[sensY]*yAccFiltered_float.currentValue;
 80015d4:	7b66      	ldrb	r6, [r4, #13]
				if((xAccFiltered_float.currentValue < accXYZ.accGValue) && (xAccFiltered_float.currentValue > -accXYZ.accGValue) &&
				   (yAccFiltered_float.currentValue < accXYZ.accGValue) && (yAccFiltered_float.currentValue > -accXYZ.accGValue) &&
				   (zAccFiltered_float.currentValue < accXYZ.accGValue) && (zAccFiltered_float.currentValue > -accXYZ.accGValue))
				{
					/*Direction setup is the same as above*/
					IMU.accel_vector[GlobalSettings.accDir.sensOrder[sensX]] = GlobalSettings.accDir.sensDirection[sensX]*xAccFiltered_float.currentValue;
 80015d6:	f10a 0a0c 	add.w	sl, sl, #12
 80015da:	eb05 0a8a 	add.w	sl, r5, sl, lsl #2
 80015de:	f8ca 0004 	str.w	r0, [sl, #4]
					IMU.accel_vector[GlobalSettings.accDir.sensOrder[sensY]] = GlobalSettings.accDir.sensDirection[sensY]*yAccFiltered_float.currentValue;
 80015e2:	f994 0010 	ldrsb.w	r0, [r4, #16]
 80015e6:	f006 f911 	bl	800780c <__aeabi_i2f>
 80015ea:	4641      	mov	r1, r8
 80015ec:	f006 f962 	bl	80078b4 <__aeabi_fmul>
 80015f0:	360c      	adds	r6, #12
 80015f2:	eb05 0686 	add.w	r6, r5, r6, lsl #2
 80015f6:	6070      	str	r0, [r6, #4]
					IMU.accel_vector[GlobalSettings.accDir.sensOrder[sensZ]] = GlobalSettings.accDir.sensDirection[sensZ]*zAccFiltered_float.currentValue;
 80015f8:	f994 0011 	ldrsb.w	r0, [r4, #17]
 80015fc:	f006 f906 	bl	800780c <__aeabi_i2f>
 8001600:	4639      	mov	r1, r7
 8001602:	f006 f957 	bl	80078b4 <__aeabi_fmul>
 8001606:	7ba3      	ldrb	r3, [r4, #14]
 8001608:	4607      	mov	r7, r0
 800160a:	eb05 0583 	add.w	r5, r5, r3, lsl #2
 800160e:	6368      	str	r0, [r5, #52]	; 0x34

					xTemp = (int)IMU.accel_vector[GlobalSettings.accDir.sensOrder[sensX]];
 8001610:	f8da 0004 	ldr.w	r0, [sl, #4]
 8001614:	f006 fb14 	bl	8007c40 <__aeabi_f2iz>
 8001618:	4b0e      	ldr	r3, [pc, #56]	; (8001654 <IMU_Calculation+0x23c>)
 800161a:	6018      	str	r0, [r3, #0]
					yTemp = (int)IMU.accel_vector[GlobalSettings.accDir.sensOrder[sensY]];
 800161c:	6870      	ldr	r0, [r6, #4]
 800161e:	f006 fb0f 	bl	8007c40 <__aeabi_f2iz>
 8001622:	4b0d      	ldr	r3, [pc, #52]	; (8001658 <IMU_Calculation+0x240>)
 8001624:	6018      	str	r0, [r3, #0]
					zTemp = (int)IMU.accel_vector[GlobalSettings.accDir.sensOrder[sensZ]];
 8001626:	4638      	mov	r0, r7
 8001628:	f006 fb0a 	bl	8007c40 <__aeabi_f2iz>
 800162c:	4b0b      	ldr	r3, [pc, #44]	; (800165c <IMU_Calculation+0x244>)
 800162e:	6018      	str	r0, [r3, #0]
 8001630:	e02a      	b.n	8001688 <IMU_Calculation+0x270>
 8001632:	bf00      	nop
 8001634:	20000154 	.word	0x20000154
 8001638:	20002bbc 	.word	0x20002bbc
 800163c:	20002f50 	.word	0x20002f50
 8001640:	3d8f5c29 	.word	0x3d8f5c29
 8001644:	3c8efa35 	.word	0x3c8efa35
 8001648:	20002eb0 	.word	0x20002eb0
 800164c:	20002c90 	.word	0x20002c90
 8001650:	20002c60 	.word	0x20002c60
 8001654:	20002eac 	.word	0x20002eac
 8001658:	20002c8c 	.word	0x20002c8c
 800165c:	20003068 	.word	0x20003068
 8001660:	20002fa8 	.word	0x20002fa8
 8001664:	20002c28 	.word	0x20002c28
 8001668:	20002f7c 	.word	0x20002f7c
 800166c:	20002fd8 	.word	0x20002fd8
				}
				else
				{
					IMU.kp_vector_ACC[0] = 0;
 8001670:	4b37      	ldr	r3, [pc, #220]	; (8001750 <IMU_Calculation+0x338>)
 8001672:	2200      	movs	r2, #0
 8001674:	661a      	str	r2, [r3, #96]	; 0x60
					IMU.kp_vector_ACC[1] = 0;
 8001676:	665a      	str	r2, [r3, #100]	; 0x64
					IMU.kp_vector_ACC[2] = 0;
 8001678:	669a      	str	r2, [r3, #104]	; 0x68

					xTemp = 0;
 800167a:	4a36      	ldr	r2, [pc, #216]	; (8001754 <IMU_Calculation+0x33c>)
 800167c:	2300      	movs	r3, #0
 800167e:	6013      	str	r3, [r2, #0]
					yTemp = 0;
 8001680:	4a35      	ldr	r2, [pc, #212]	; (8001758 <IMU_Calculation+0x340>)
 8001682:	6013      	str	r3, [r2, #0]
					zTemp = 0;
 8001684:	4a35      	ldr	r2, [pc, #212]	; (800175c <IMU_Calculation+0x344>)
 8001686:	6013      	str	r3, [r2, #0]
				}

				//printf("%d %d %d\n\r", (int)(IMU.accel_vector[0]*30),(int)(IMU.accel_vector[1]*30), (int)(IMU.accel_vector[2]*30));

				if(GlobalSettings.enableDriftCorrection)
 8001688:	4b35      	ldr	r3, [pc, #212]	; (8001760 <IMU_Calculation+0x348>)
 800168a:	7a9b      	ldrb	r3, [r3, #10]
 800168c:	b113      	cbz	r3, 8001694 <IMU_Calculation+0x27c>
				{
					IMU_drift_correction_ACC(&IMU);
 800168e:	4830      	ldr	r0, [pc, #192]	; (8001750 <IMU_Calculation+0x338>)
 8001690:	f7fe fe95 	bl	80003be <IMU_drift_correction_ACC>
				}
				accCount = 0;
 8001694:	4b33      	ldr	r3, [pc, #204]	; (8001764 <IMU_Calculation+0x34c>)
 8001696:	2200      	movs	r2, #0
 8001698:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
			}
			accCount++;
 800169c:	4b31      	ldr	r3, [pc, #196]	; (8001764 <IMU_Calculation+0x34c>)
 800169e:	f893 2022 	ldrb.w	r2, [r3, #34]	; 0x22
 80016a2:	3201      	adds	r2, #1
 80016a4:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
		}

		/*Here the Mag-Compensation, we do this in every 45 round*/
		if(GlobalSettings.enableMAG)
 80016a8:	4c2d      	ldr	r4, [pc, #180]	; (8001760 <IMU_Calculation+0x348>)
 80016aa:	7e23      	ldrb	r3, [r4, #24]
 80016ac:	2b00      	cmp	r3, #0
 80016ae:	d03f      	beq.n	8001730 <IMU_Calculation+0x318>
		{
			if(magCount >= 45)
 80016b0:	4d2c      	ldr	r5, [pc, #176]	; (8001764 <IMU_Calculation+0x34c>)
 80016b2:	f895 3023 	ldrb.w	r3, [r5, #35]	; 0x23
 80016b6:	2b2c      	cmp	r3, #44	; 0x2c
 80016b8:	d934      	bls.n	8001724 <IMU_Calculation+0x30c>
			{
				Mag_readValues(&magXYZ);
 80016ba:	f105 001c 	add.w	r0, r5, #28
 80016be:	f7ff faa4 	bl	8000c0a <Mag_readValues>
				update_intFilter(&xMagFiltered, GlobalSettings.magLowpassValue, (magXYZ.magValueX));
 80016c2:	f105 0024 	add.w	r0, r5, #36	; 0x24
 80016c6:	8c21      	ldrh	r1, [r4, #32]
 80016c8:	f9b5 201c 	ldrsh.w	r2, [r5, #28]
 80016cc:	f000 f96e 	bl	80019ac <update_intFilter>
				update_intFilter(&yMagFiltered, GlobalSettings.magLowpassValue, (magXYZ.magValueY));
 80016d0:	f9b5 201e 	ldrsh.w	r2, [r5, #30]
 80016d4:	8c21      	ldrh	r1, [r4, #32]
 80016d6:	f105 002c 	add.w	r0, r5, #44	; 0x2c
 80016da:	f000 f967 	bl	80019ac <update_intFilter>

				/*Direction setup is the same as above*/
				IMU.mag_vector[GlobalSettings.magDir.sensOrder[sensX]] = GlobalSettings.magDir.sensDirection[sensX]*xMagFiltered.filtered;
 80016de:	6aab      	ldr	r3, [r5, #40]	; 0x28
 80016e0:	f994 001c 	ldrsb.w	r0, [r4, #28]
 80016e4:	7e67      	ldrb	r7, [r4, #25]
 80016e6:	4358      	muls	r0, r3
 80016e8:	f006 f890 	bl	800780c <__aeabi_i2f>
 80016ec:	4e18      	ldr	r6, [pc, #96]	; (8001750 <IMU_Calculation+0x338>)
 80016ee:	3710      	adds	r7, #16
 80016f0:	f846 0027 	str.w	r0, [r6, r7, lsl #2]
				IMU.mag_vector[GlobalSettings.magDir.sensOrder[sensY]] = GlobalSettings.magDir.sensDirection[sensY]*yMagFiltered.filtered;
 80016f4:	f994 301d 	ldrsb.w	r3, [r4, #29]
 80016f8:	6b28      	ldr	r0, [r5, #48]	; 0x30
 80016fa:	7ea7      	ldrb	r7, [r4, #26]
 80016fc:	4358      	muls	r0, r3
 80016fe:	f006 f885 	bl	800780c <__aeabi_i2f>
				//IMU.mag_vector[GlobalSettings.magDir.sensOrder[sensZ]] = GlobalSettings.magDir.sensDirection[sensZ]*zMagFiltered;
				IMU.mag_vector[GlobalSettings.magDir.sensOrder[sensZ]] = 0;
 8001702:	7ee3      	ldrb	r3, [r4, #27]
				update_intFilter(&xMagFiltered, GlobalSettings.magLowpassValue, (magXYZ.magValueX));
				update_intFilter(&yMagFiltered, GlobalSettings.magLowpassValue, (magXYZ.magValueY));

				/*Direction setup is the same as above*/
				IMU.mag_vector[GlobalSettings.magDir.sensOrder[sensX]] = GlobalSettings.magDir.sensDirection[sensX]*xMagFiltered.filtered;
				IMU.mag_vector[GlobalSettings.magDir.sensOrder[sensY]] = GlobalSettings.magDir.sensDirection[sensY]*yMagFiltered.filtered;
 8001704:	3710      	adds	r7, #16
				//IMU.mag_vector[GlobalSettings.magDir.sensOrder[sensZ]] = GlobalSettings.magDir.sensDirection[sensZ]*zMagFiltered;
				IMU.mag_vector[GlobalSettings.magDir.sensOrder[sensZ]] = 0;
 8001706:	3310      	adds	r3, #16
 8001708:	2200      	movs	r2, #0
				update_intFilter(&xMagFiltered, GlobalSettings.magLowpassValue, (magXYZ.magValueX));
				update_intFilter(&yMagFiltered, GlobalSettings.magLowpassValue, (magXYZ.magValueY));

				/*Direction setup is the same as above*/
				IMU.mag_vector[GlobalSettings.magDir.sensOrder[sensX]] = GlobalSettings.magDir.sensDirection[sensX]*xMagFiltered.filtered;
				IMU.mag_vector[GlobalSettings.magDir.sensOrder[sensY]] = GlobalSettings.magDir.sensDirection[sensY]*yMagFiltered.filtered;
 800170a:	f846 0027 	str.w	r0, [r6, r7, lsl #2]
				//IMU.mag_vector[GlobalSettings.magDir.sensOrder[sensZ]] = GlobalSettings.magDir.sensDirection[sensZ]*zMagFiltered;
				IMU.mag_vector[GlobalSettings.magDir.sensOrder[sensZ]] = 0;
 800170e:	f846 2023 	str.w	r2, [r6, r3, lsl #2]

				if(GlobalSettings.enableDriftCorrection)
 8001712:	7aa3      	ldrb	r3, [r4, #10]
 8001714:	b113      	cbz	r3, 800171c <IMU_Calculation+0x304>
				{
					IMU_drift_correction_MAG(&IMU);
 8001716:	4630      	mov	r0, r6
 8001718:	f7fe feb7 	bl	800048a <IMU_drift_correction_MAG>
				}
				magCount = 0;
 800171c:	4b11      	ldr	r3, [pc, #68]	; (8001764 <IMU_Calculation+0x34c>)
 800171e:	2200      	movs	r2, #0
 8001720:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
				//printf("%d,%d\n\r", (int)xMagFiltered.filtered, (int)yMagFiltered.filtered);
			}
			magCount++;
 8001724:	4b0f      	ldr	r3, [pc, #60]	; (8001764 <IMU_Calculation+0x34c>)
 8001726:	f893 2023 	ldrb.w	r2, [r3, #35]	; 0x23
 800172a:	3201      	adds	r2, #1
 800172c:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
		}

		/*This functions here do the DCM-Algorithm stuff*/
		IMU_update(&IMU);
 8001730:	4807      	ldr	r0, [pc, #28]	; (8001750 <IMU_Calculation+0x338>)
 8001732:	f7fe fd4d 	bl	80001d0 <IMU_update>
		IMU_ortho_adjust(&IMU);
 8001736:	4806      	ldr	r0, [pc, #24]	; (8001750 <IMU_Calculation+0x338>)
 8001738:	f7fe fe14 	bl	8000364 <IMU_ortho_adjust>
		IMU_normalize(&IMU);
 800173c:	4804      	ldr	r0, [pc, #16]	; (8001750 <IMU_Calculation+0x338>)
 800173e:	f7fe fd90 	bl	8000262 <IMU_normalize>
		//Euler_angles(&DCM);
		//IMU_DCM_to_Euler_deg(&IMU, &euler);
		IMU_DCM_to_XYZ(&IMU, &XYZ);
 8001742:	4803      	ldr	r0, [pc, #12]	; (8001750 <IMU_Calculation+0x338>)
 8001744:	4908      	ldr	r1, [pc, #32]	; (8001768 <IMU_Calculation+0x350>)


}
 8001746:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
		IMU_update(&IMU);
		IMU_ortho_adjust(&IMU);
		IMU_normalize(&IMU);
		//Euler_angles(&DCM);
		//IMU_DCM_to_Euler_deg(&IMU, &euler);
		IMU_DCM_to_XYZ(&IMU, &XYZ);
 800174a:	f7fe bf8a 	b.w	8000662 <IMU_DCM_to_XYZ>
 800174e:	bf00      	nop
 8001750:	20002eb0 	.word	0x20002eb0
 8001754:	20002eac 	.word	0x20002eac
 8001758:	20002c8c 	.word	0x20002c8c
 800175c:	20003068 	.word	0x20003068
 8001760:	20002bbc 	.word	0x20002bbc
 8001764:	20000154 	.word	0x20000154
 8001768:	20002bb0 	.word	0x20002bb0

0800176c <PositionController>:


}

void PositionController(){
 800176c:	b530      	push	{r4, r5, lr}

	//** PID Calculation Test

	if(CtrlStates.copterStatus & ARMED_FLAG )
 800176e:	4a37      	ldr	r2, [pc, #220]	; (800184c <PositionController+0xe0>)
		IMU_DCM_to_XYZ(&IMU, &XYZ);


}

void PositionController(){
 8001770:	b085      	sub	sp, #20

	//** PID Calculation Test

	if(CtrlStates.copterStatus & ARMED_FLAG )
 8001772:	7a10      	ldrb	r0, [r2, #8]
 8001774:	f010 0501 	ands.w	r5, r0, #1
 8001778:	d048      	beq.n	800180c <PositionController+0xa0>
		float MiddelPos = 4.8f;
		float Setpoint;


		/* Get Controll Values */
		if(It_Com.rxready == 1)
 800177a:	4b35      	ldr	r3, [pc, #212]	; (8001850 <PositionController+0xe4>)
 800177c:	f8d3 1200 	ldr.w	r1, [r3, #512]	; 0x200
 8001780:	2901      	cmp	r1, #1
 8001782:	d106      	bne.n	8001792 <PositionController+0x26>
		{
			It_Com.rxready = 0;
 8001784:	2100      	movs	r1, #0
 8001786:	f8c3 1200 	str.w	r1, [r3, #512]	; 0x200
			memcpy(&CtrlStates.pitch, &It_Com.rxbuffer[4], 4);
 800178a:	6859      	ldr	r1, [r3, #4]
			memcpy(&CtrlStates.yaw, &It_Com.rxbuffer[8], 4);
 800178c:	689b      	ldr	r3, [r3, #8]

		/* Get Controll Values */
		if(It_Com.rxready == 1)
		{
			It_Com.rxready = 0;
			memcpy(&CtrlStates.pitch, &It_Com.rxbuffer[4], 4);
 800178e:	6011      	str	r1, [r2, #0]
			memcpy(&CtrlStates.yaw, &It_Com.rxbuffer[8], 4);
 8001790:	6053      	str	r3, [r2, #4]

#ifdef PIDSmithPredictor-Controller

		//calc_PID_SmithPredictor(XYZ.y, 4.8f, &PID_Position, &Smith_Position);

		calc_PID(XYZ.y, 4.8f, &PID_Position);
 8001792:	4b30      	ldr	r3, [pc, #192]	; (8001854 <PositionController+0xe8>)
 8001794:	4d30      	ldr	r5, [pc, #192]	; (8001858 <PositionController+0xec>)

		//if  (PID_Position.y > -5.0f && PID_Position.y < 5.0f )
		//	NotLinear = 0.0f;


		MOT0 = GlobalSettings.stopSpeed - PID_Position.y;
 8001796:	4c31      	ldr	r4, [pc, #196]	; (800185c <PositionController+0xf0>)

#ifdef PIDSmithPredictor-Controller

		//calc_PID_SmithPredictor(XYZ.y, 4.8f, &PID_Position, &Smith_Position);

		calc_PID(XYZ.y, 4.8f, &PID_Position);
 8001798:	6858      	ldr	r0, [r3, #4]
 800179a:	462a      	mov	r2, r5
 800179c:	4930      	ldr	r1, [pc, #192]	; (8001860 <PositionController+0xf4>)
 800179e:	f7ff fb05 	bl	8000dac <calc_PID>

		//if  (PID_Position.y > -5.0f && PID_Position.y < 5.0f )
		//	NotLinear = 0.0f;


		MOT0 = GlobalSettings.stopSpeed - PID_Position.y;
 80017a2:	8c60      	ldrh	r0, [r4, #34]	; 0x22
 80017a4:	f006 f832 	bl	800780c <__aeabi_i2f>
 80017a8:	6869      	ldr	r1, [r5, #4]
 80017aa:	f005 ff79 	bl	80076a0 <__aeabi_fsub>
 80017ae:	f006 fa6d 	bl	8007c8c <__aeabi_f2uiz>
		MOT1 = GlobalSettings.stopSpeed - PID_Position.y;

		if(MOT0 < GlobalSettings.minSpeed) MOT0 = GlobalSettings.minSpeed;
 80017b2:	8ca3      	ldrh	r3, [r4, #36]	; 0x24

		//if  (PID_Position.y > -5.0f && PID_Position.y < 5.0f )
		//	NotLinear = 0.0f;


		MOT0 = GlobalSettings.stopSpeed - PID_Position.y;
 80017b4:	4a2b      	ldr	r2, [pc, #172]	; (8001864 <PositionController+0xf8>)
 80017b6:	b281      	uxth	r1, r0
		MOT1 = GlobalSettings.stopSpeed - PID_Position.y;

		if(MOT0 < GlobalSettings.minSpeed) MOT0 = GlobalSettings.minSpeed;
 80017b8:	4299      	cmp	r1, r3

		//if  (PID_Position.y > -5.0f && PID_Position.y < 5.0f )
		//	NotLinear = 0.0f;


		MOT0 = GlobalSettings.stopSpeed - PID_Position.y;
 80017ba:	8690      	strh	r0, [r2, #52]	; 0x34
		MOT1 = GlobalSettings.stopSpeed - PID_Position.y;

		if(MOT0 < GlobalSettings.minSpeed) MOT0 = GlobalSettings.minSpeed;
 80017bc:	bf38      	it	cc
 80017be:	8693      	strhcc	r3, [r2, #52]	; 0x34
		//if  (PID_Position.y > -5.0f && PID_Position.y < 5.0f )
		//	NotLinear = 0.0f;


		MOT0 = GlobalSettings.stopSpeed - PID_Position.y;
		MOT1 = GlobalSettings.stopSpeed - PID_Position.y;
 80017c0:	86d0      	strh	r0, [r2, #54]	; 0x36

		if(MOT0 < GlobalSettings.minSpeed) MOT0 = GlobalSettings.minSpeed;
		if(MOT0 > GlobalSettings.maxSpeed) MOT0 = GlobalSettings.maxSpeed;
 80017c2:	8e92      	ldrh	r2, [r2, #52]	; 0x34
 80017c4:	8ce0      	ldrh	r0, [r4, #38]	; 0x26
 80017c6:	4282      	cmp	r2, r0
 80017c8:	bf84      	itt	hi
 80017ca:	4a26      	ldrhi	r2, [pc, #152]	; (8001864 <PositionController+0xf8>)
 80017cc:	8690      	strhhi	r0, [r2, #52]	; 0x34
 80017ce:	4a25      	ldr	r2, [pc, #148]	; (8001864 <PositionController+0xf8>)

		if(MOT1 < GlobalSettings.minSpeed) MOT1 = GlobalSettings.minSpeed;
 80017d0:	4299      	cmp	r1, r3
 80017d2:	bf38      	it	cc
 80017d4:	86d3      	strhcc	r3, [r2, #54]	; 0x36
		if(MOT1 > GlobalSettings.maxSpeed) MOT1 = GlobalSettings.maxSpeed;


		if ( MOT0 < 100 ) MOT0 -= 10;
 80017d6:	8e93      	ldrh	r3, [r2, #52]	; 0x34
 80017d8:	2b63      	cmp	r3, #99	; 0x63
 80017da:	d802      	bhi.n	80017e2 <PositionController+0x76>
 80017dc:	4a21      	ldr	r2, [pc, #132]	; (8001864 <PositionController+0xf8>)
 80017de:	3b0a      	subs	r3, #10
 80017e0:	8693      	strh	r3, [r2, #52]	; 0x34
		if ( MOT0 > 100 ) MOT0 += 10;
 80017e2:	4c20      	ldr	r4, [pc, #128]	; (8001864 <PositionController+0xf8>)
 80017e4:	8ea3      	ldrh	r3, [r4, #52]	; 0x34
 80017e6:	2b64      	cmp	r3, #100	; 0x64
 80017e8:	d901      	bls.n	80017ee <PositionController+0x82>
 80017ea:	330a      	adds	r3, #10
 80017ec:	86a3      	strh	r3, [r4, #52]	; 0x34

		MOT1 = MOT0;
 80017ee:	8ea3      	ldrh	r3, [r4, #52]	; 0x34
 80017f0:	86e3      	strh	r3, [r4, #54]	; 0x36

		// Disable Interrupts
		taskENTER_CRITICAL();
 80017f2:	f004 f843 	bl	800587c <vPortEnterCritical>

		PWM_Motor(0, MOT0);
 80017f6:	2000      	movs	r0, #0
 80017f8:	8ea1      	ldrh	r1, [r4, #52]	; 0x34
 80017fa:	f7ff fa89 	bl	8000d10 <PWM_Motor>
		PWM_Motor(1, MOT1);
 80017fe:	2001      	movs	r0, #1
 8001800:	8ee1      	ldrh	r1, [r4, #54]	; 0x36
 8001802:	f7ff fa85 	bl	8000d10 <PWM_Motor>

		taskEXIT_CRITICAL();
 8001806:	f004 f84a 	bl	800589e <vPortExitCritical>
 800180a:	e00b      	b.n	8001824 <PositionController+0xb8>
	}
	else
	{
		resetIntegralValues_PID(&PID_Position);

		PWM_Motor(0, (uint16_t)GlobalSettings.stopSpeed);
 800180c:	4c13      	ldr	r4, [pc, #76]	; (800185c <PositionController+0xf0>)
#endif

	}
	else
	{
		resetIntegralValues_PID(&PID_Position);
 800180e:	4812      	ldr	r0, [pc, #72]	; (8001858 <PositionController+0xec>)
 8001810:	f7ff fac6 	bl	8000da0 <resetIntegralValues_PID>

		PWM_Motor(0, (uint16_t)GlobalSettings.stopSpeed);
 8001814:	4628      	mov	r0, r5
 8001816:	8c61      	ldrh	r1, [r4, #34]	; 0x22
 8001818:	f7ff fa7a 	bl	8000d10 <PWM_Motor>
		PWM_Motor(1, (uint16_t)GlobalSettings.stopSpeed);
 800181c:	2001      	movs	r0, #1
 800181e:	8c61      	ldrh	r1, [r4, #34]	; 0x22
 8001820:	f7ff fa76 	bl	8000d10 <PWM_Motor>
	}



	uint32_t Header = 0xFF7F3F1F;
 8001824:	4b10      	ldr	r3, [pc, #64]	; (8001868 <PositionController+0xfc>)
	foo++;

	uint32_t foobar = MOT0;

	// SendBufferedDataFrame(&It_Com ,&Header, &XYZ.y, &PID_Position.Isum, &foobar, 12);
	SendBufferedDataFrame(&It_Com ,&Header, &XYZ.y, &PID_Position.e, &foobar, 12);
 8001826:	480a      	ldr	r0, [pc, #40]	; (8001850 <PositionController+0xe4>)
		PWM_Motor(1, (uint16_t)GlobalSettings.stopSpeed);
	}



	uint32_t Header = 0xFF7F3F1F;
 8001828:	9302      	str	r3, [sp, #8]

	static uint16_t foo = 0;
	foo++;
 800182a:	4b0e      	ldr	r3, [pc, #56]	; (8001864 <PositionController+0xf8>)

	uint32_t foobar = MOT0;

	// SendBufferedDataFrame(&It_Com ,&Header, &XYZ.y, &PID_Position.Isum, &foobar, 12);
	SendBufferedDataFrame(&It_Com ,&Header, &XYZ.y, &PID_Position.e, &foobar, 12);
 800182c:	a902      	add	r1, sp, #8


	uint32_t Header = 0xFF7F3F1F;

	static uint16_t foo = 0;
	foo++;
 800182e:	8f1a      	ldrh	r2, [r3, #56]	; 0x38
 8001830:	3201      	adds	r2, #1
 8001832:	871a      	strh	r2, [r3, #56]	; 0x38

	uint32_t foobar = MOT0;
 8001834:	8e9b      	ldrh	r3, [r3, #52]	; 0x34

	// SendBufferedDataFrame(&It_Com ,&Header, &XYZ.y, &PID_Position.Isum, &foobar, 12);
	SendBufferedDataFrame(&It_Com ,&Header, &XYZ.y, &PID_Position.e, &foobar, 12);
 8001836:	4a0d      	ldr	r2, [pc, #52]	; (800186c <PositionController+0x100>)
	uint32_t Header = 0xFF7F3F1F;

	static uint16_t foo = 0;
	foo++;

	uint32_t foobar = MOT0;
 8001838:	9303      	str	r3, [sp, #12]

	// SendBufferedDataFrame(&It_Com ,&Header, &XYZ.y, &PID_Position.Isum, &foobar, 12);
	SendBufferedDataFrame(&It_Com ,&Header, &XYZ.y, &PID_Position.e, &foobar, 12);
 800183a:	ab03      	add	r3, sp, #12
 800183c:	9300      	str	r3, [sp, #0]
 800183e:	230c      	movs	r3, #12
 8001840:	9301      	str	r3, [sp, #4]
 8001842:	4b0b      	ldr	r3, [pc, #44]	; (8001870 <PositionController+0x104>)
 8001844:	f001 f9de 	bl	8002c04 <SendBufferedDataFrame>
	//}

	//float delayoutvalue = CalcDelay(&Smith_Position, 1.0f);

	// **** End Test
}
 8001848:	b005      	add	sp, #20
 800184a:	bd30      	pop	{r4, r5, pc}
 800184c:	20002c1c 	.word	0x20002c1c
 8001850:	20002c98 	.word	0x20002c98
 8001854:	20002bb0 	.word	0x20002bb0
 8001858:	20002f28 	.word	0x20002f28
 800185c:	20002bbc 	.word	0x20002bbc
 8001860:	4099999a 	.word	0x4099999a
 8001864:	20000154 	.word	0x20000154
 8001868:	ff7f3f1f 	.word	0xff7f3f1f
 800186c:	20002bb4 	.word	0x20002bb4
 8001870:	20002f40 	.word	0x20002f40
 8001874:	f3af 8000 	nop.w

08001878 <VectorDotProduct>:
#include <Vector_math.h>


//Computes the dot product of two vectors 
float VectorDotProduct(float vector1[3],float vector2[3]) 
{   
 8001878:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800187a:	4607      	mov	r7, r0
 800187c:	460e      	mov	r6, r1
 800187e:	2400      	movs	r4, #0
	int c = 0;
	float op=0;      
 8001880:	2500      	movs	r5, #0
	for( c = 0 ; c < 3 ; c++ )   
	{   
		op += vector1[c] * vector2[c];   
 8001882:	5931      	ldr	r1, [r6, r4]
 8001884:	5938      	ldr	r0, [r7, r4]
 8001886:	f006 f815 	bl	80078b4 <__aeabi_fmul>
 800188a:	4601      	mov	r1, r0
 800188c:	4628      	mov	r0, r5
 800188e:	f005 ff09 	bl	80076a4 <__addsf3>
 8001892:	3404      	adds	r4, #4
//Computes the dot product of two vectors 
float VectorDotProduct(float vector1[3],float vector2[3]) 
{   
	int c = 0;
	float op=0;      
	for( c = 0 ; c < 3 ; c++ )   
 8001894:	2c0c      	cmp	r4, #12
	{   
		op += vector1[c] * vector2[c];   
 8001896:	4605      	mov	r5, r0
//Computes the dot product of two vectors 
float VectorDotProduct(float vector1[3],float vector2[3]) 
{   
	int c = 0;
	float op=0;      
	for( c = 0 ; c < 3 ; c++ )   
 8001898:	d1f3      	bne.n	8001882 <VectorDotProduct+0xa>
	{   
		op += vector1[c] * vector2[c];   
	}      
	return op;  
}  
 800189a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0800189c <VectorCrossProduct>:

//Computes the cross product of two vectors 
void VectorCrossProduct(float vectorOut[3], float v1[3],float v2[3]) 
{   
 800189c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800189e:	460d      	mov	r5, r1
 80018a0:	4606      	mov	r6, r0
	vectorOut[0] = (v1[1]*v2[2]) - (v1[2]*v2[1]);   
 80018a2:	6848      	ldr	r0, [r1, #4]
 80018a4:	6891      	ldr	r1, [r2, #8]
	return op;  
}  

//Computes the cross product of two vectors 
void VectorCrossProduct(float vectorOut[3], float v1[3],float v2[3]) 
{   
 80018a6:	4614      	mov	r4, r2
	vectorOut[0] = (v1[1]*v2[2]) - (v1[2]*v2[1]);   
 80018a8:	f006 f804 	bl	80078b4 <__aeabi_fmul>
 80018ac:	6861      	ldr	r1, [r4, #4]
 80018ae:	4607      	mov	r7, r0
 80018b0:	68a8      	ldr	r0, [r5, #8]
 80018b2:	f005 ffff 	bl	80078b4 <__aeabi_fmul>
 80018b6:	4601      	mov	r1, r0
 80018b8:	4638      	mov	r0, r7
 80018ba:	f005 fef1 	bl	80076a0 <__aeabi_fsub>
 80018be:	6030      	str	r0, [r6, #0]
	vectorOut[1] = (v1[2]*v2[0]) - (v1[0]*v2[2]);   
 80018c0:	6821      	ldr	r1, [r4, #0]
 80018c2:	68a8      	ldr	r0, [r5, #8]
 80018c4:	f005 fff6 	bl	80078b4 <__aeabi_fmul>
 80018c8:	68a1      	ldr	r1, [r4, #8]
 80018ca:	4607      	mov	r7, r0
 80018cc:	6828      	ldr	r0, [r5, #0]
 80018ce:	f005 fff1 	bl	80078b4 <__aeabi_fmul>
 80018d2:	4601      	mov	r1, r0
 80018d4:	4638      	mov	r0, r7
 80018d6:	f005 fee3 	bl	80076a0 <__aeabi_fsub>
 80018da:	6070      	str	r0, [r6, #4]
	vectorOut[2] = (v1[0]*v2[1]) - (v1[1]*v2[0]); 
 80018dc:	6861      	ldr	r1, [r4, #4]
 80018de:	6828      	ldr	r0, [r5, #0]
 80018e0:	f005 ffe8 	bl	80078b4 <__aeabi_fmul>
 80018e4:	6821      	ldr	r1, [r4, #0]
 80018e6:	4607      	mov	r7, r0
 80018e8:	6868      	ldr	r0, [r5, #4]
 80018ea:	f005 ffe3 	bl	80078b4 <__aeabi_fmul>
 80018ee:	4601      	mov	r1, r0
 80018f0:	4638      	mov	r0, r7
 80018f2:	f005 fed5 	bl	80076a0 <__aeabi_fsub>
 80018f6:	60b0      	str	r0, [r6, #8]
 80018f8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080018fa <VectorScale>:
}  

//Multiply the vector by a scalar.  
void VectorScale(float vectorOut[3],float vectorIn[3], float scale2) 
{   
 80018fa:	b570      	push	{r4, r5, r6, lr}
 80018fc:	4604      	mov	r4, r0
 80018fe:	460d      	mov	r5, r1
	int c = 0;
	for( c = 0 ; c < 3 ; c++ )   
	{    
		vectorOut[c] = vectorIn[c] * scale2;    
 8001900:	6808      	ldr	r0, [r1, #0]
 8001902:	4611      	mov	r1, r2
	vectorOut[2] = (v1[0]*v2[1]) - (v1[1]*v2[0]); 
}  

//Multiply the vector by a scalar.  
void VectorScale(float vectorOut[3],float vectorIn[3], float scale2) 
{   
 8001904:	4616      	mov	r6, r2
	int c = 0;
	for( c = 0 ; c < 3 ; c++ )   
	{    
		vectorOut[c] = vectorIn[c] * scale2;    
 8001906:	f005 ffd5 	bl	80078b4 <__aeabi_fmul>
 800190a:	6020      	str	r0, [r4, #0]
 800190c:	6868      	ldr	r0, [r5, #4]
 800190e:	4631      	mov	r1, r6
 8001910:	f005 ffd0 	bl	80078b4 <__aeabi_fmul>
 8001914:	6060      	str	r0, [r4, #4]
 8001916:	68a8      	ldr	r0, [r5, #8]
 8001918:	4631      	mov	r1, r6
 800191a:	f005 ffcb 	bl	80078b4 <__aeabi_fmul>
 800191e:	60a0      	str	r0, [r4, #8]
 8001920:	bd70      	pop	{r4, r5, r6, pc}

08001922 <VectorAdd>:
	} 
}  

void VectorAdd(float vectorOut[3],float vectorIn1[3], float vectorIn2[3]) 
{
 8001922:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001924:	4605      	mov	r5, r0
 8001926:	460e      	mov	r6, r1
 8001928:	4617      	mov	r7, r2
 800192a:	2400      	movs	r4, #0
	int c = 0;
   
	for(c = 0 ; c < 3 ; c++ )   
	{      
		vectorOut[c] = vectorIn1[c] + vectorIn2[c];   
 800192c:	5930      	ldr	r0, [r6, r4]
 800192e:	5939      	ldr	r1, [r7, r4]
 8001930:	f005 feb8 	bl	80076a4 <__addsf3>
 8001934:	5128      	str	r0, [r5, r4]
 8001936:	3404      	adds	r4, #4

void VectorAdd(float vectorOut[3],float vectorIn1[3], float vectorIn2[3]) 
{
	int c = 0;
   
	for(c = 0 ; c < 3 ; c++ )   
 8001938:	2c0c      	cmp	r4, #12
 800193a:	d1f7      	bne.n	800192c <VectorAdd+0xa>
	{      
		vectorOut[c] = vectorIn1[c] + vectorIn2[c];   
	} 
} 
 800193c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0800193e <MatrixMultiply>:



//Multiply two 3x3 matrices. 
void MatrixMultiply(float a[3][3], float b[3][3],float mat[3][3]) 
{   
 800193e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001942:	4681      	mov	r9, r0
 8001944:	b087      	sub	sp, #28
 8001946:	4688      	mov	r8, r1
 8001948:	4607      	mov	r7, r0
} 



//Multiply two 3x3 matrices. 
void MatrixMultiply(float a[3][3], float b[3][3],float mat[3][3]) 
 800194a:	2500      	movs	r5, #0
 800194c:	e025      	b.n	800199a <MatrixMultiply+0x5c>
	{     
		for(  y = 0 ; y < 3 ; y++ )     
		{       
			for(  w = 0 ; w < 3 ; w++ )       
			{        
				op[w] = a[x][w]*b[w][y];       
 800194e:	f858 1004 	ldr.w	r1, [r8, r4]
 8001952:	f859 0005 	ldr.w	r0, [r9, r5]
 8001956:	9201      	str	r2, [sp, #4]
 8001958:	f005 ffac 	bl	80078b4 <__aeabi_fmul>
 800195c:	68f1      	ldr	r1, [r6, #12]
 800195e:	4682      	mov	sl, r0
 8001960:	9003      	str	r0, [sp, #12]
 8001962:	6878      	ldr	r0, [r7, #4]
 8001964:	f005 ffa6 	bl	80078b4 <__aeabi_fmul>
 8001968:	4601      	mov	r1, r0
 800196a:	9004      	str	r0, [sp, #16]
			}        
			mat[x][y] = 0;       
			mat[x][y] = op[0] + op[1] + op[2];              
 800196c:	4650      	mov	r0, sl
 800196e:	f005 fe99 	bl	80076a4 <__addsf3>
	{     
		for(  y = 0 ; y < 3 ; y++ )     
		{       
			for(  w = 0 ; w < 3 ; w++ )       
			{        
				op[w] = a[x][w]*b[w][y];       
 8001972:	69b1      	ldr	r1, [r6, #24]
			}        
			mat[x][y] = 0;       
			mat[x][y] = op[0] + op[1] + op[2];              
 8001974:	4682      	mov	sl, r0
	{     
		for(  y = 0 ; y < 3 ; y++ )     
		{       
			for(  w = 0 ; w < 3 ; w++ )       
			{        
				op[w] = a[x][w]*b[w][y];       
 8001976:	68b8      	ldr	r0, [r7, #8]
 8001978:	f005 ff9c 	bl	80078b4 <__aeabi_fmul>
 800197c:	4601      	mov	r1, r0
			}        
			mat[x][y] = 0;       
			mat[x][y] = op[0] + op[1] + op[2];              
 800197e:	4650      	mov	r0, sl
 8001980:	f005 fe90 	bl	80076a4 <__addsf3>
 8001984:	f84b 0004 	str.w	r0, [fp, r4]
 8001988:	3404      	adds	r4, #4
 800198a:	3604      	adds	r6, #4
	int w = 0;
	//float test = 0;
	
	for(  x = 0 ; x < 3 ; x++ )   
	{     
		for(  y = 0 ; y < 3 ; y++ )     
 800198c:	2c0c      	cmp	r4, #12
 800198e:	9a01      	ldr	r2, [sp, #4]
 8001990:	d1dd      	bne.n	800194e <MatrixMultiply+0x10>
 8001992:	350c      	adds	r5, #12
 8001994:	370c      	adds	r7, #12
	int x = 0;
	int y = 0;
	int w = 0;
	//float test = 0;
	
	for(  x = 0 ; x < 3 ; x++ )   
 8001996:	2d24      	cmp	r5, #36	; 0x24
 8001998:	d004      	beq.n	80019a4 <MatrixMultiply+0x66>
} 



//Multiply two 3x3 matrices. 
void MatrixMultiply(float a[3][3], float b[3][3],float mat[3][3]) 
 800199a:	eb02 0b05 	add.w	fp, r2, r5
 800199e:	4646      	mov	r6, r8
 80019a0:	2400      	movs	r4, #0
 80019a2:	e7d4      	b.n	800194e <MatrixMultiply+0x10>
			mat[x][y] = 0;       
			mat[x][y] = op[0] + op[1] + op[2];              
			//test=mat[x][y];     
		}   
	} 
} 
 80019a4:	b007      	add	sp, #28
 80019a6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

080019ac <update_intFilter>:
#include <math.h>


void update_intFilter(intFilter *filter, int lowpassValue, int newMeasurement)
{
	filter->r = newMeasurement + filter->r - filter->filtered;
 80019ac:	6803      	ldr	r3, [r0, #0]
#include <filter_Lib.h>
#include <math.h>


void update_intFilter(intFilter *filter, int lowpassValue, int newMeasurement)
{
 80019ae:	b510      	push	{r4, lr}
	filter->r = newMeasurement + filter->r - filter->filtered;
 80019b0:	6844      	ldr	r4, [r0, #4]
 80019b2:	18d2      	adds	r2, r2, r3
 80019b4:	1b12      	subs	r2, r2, r4
	filter->filtered = filter->r>>lowpassValue;
 80019b6:	fa42 f101 	asr.w	r1, r2, r1
#include <math.h>


void update_intFilter(intFilter *filter, int lowpassValue, int newMeasurement)
{
	filter->r = newMeasurement + filter->r - filter->filtered;
 80019ba:	6002      	str	r2, [r0, #0]
	filter->filtered = filter->r>>lowpassValue;
 80019bc:	6041      	str	r1, [r0, #4]
 80019be:	bd10      	pop	{r4, pc}

080019c0 <initAvgValues>:
}

void initAvgValues(struct movingAverageValues *avg)
{
	int i = 0;
	avg->countValue = 0;
 80019c0:	2300      	movs	r3, #0
 80019c2:	6143      	str	r3, [r0, #20]
	for(i = 0;i<MA_VALUE;i++)
	{
		avg->avgArray[i] = 0;
 80019c4:	6003      	str	r3, [r0, #0]
 80019c6:	6043      	str	r3, [r0, #4]
 80019c8:	6083      	str	r3, [r0, #8]
 80019ca:	60c3      	str	r3, [r0, #12]
 80019cc:	6103      	str	r3, [r0, #16]
 80019ce:	4770      	bx	lr

080019d0 <calcMovingAvg>:

int calcMovingAvg(struct movingAverageValues *avg, int newValue)
{
	int i = 0, result = 0;

	avg->avgArray[avg->countValue] = newValue;
 80019d0:	6943      	ldr	r3, [r0, #20]
 80019d2:	f840 1023 	str.w	r1, [r0, r3, lsl #2]
	for(i = 0;i<MA_VALUE;i++)
	{
		result += avg->avgArray[i];
 80019d6:	e890 0006 	ldmia.w	r0, {r1, r2}
 80019da:	1889      	adds	r1, r1, r2
 80019dc:	6882      	ldr	r2, [r0, #8]
	}
	avg->countValue++;
 80019de:	3301      	adds	r3, #1
	int i = 0, result = 0;

	avg->avgArray[avg->countValue] = newValue;
	for(i = 0;i<MA_VALUE;i++)
	{
		result += avg->avgArray[i];
 80019e0:	1889      	adds	r1, r1, r2
 80019e2:	68c2      	ldr	r2, [r0, #12]
	}
	avg->countValue++;
	if (avg->countValue >= MA_VALUE)
 80019e4:	2b04      	cmp	r3, #4
	int i = 0, result = 0;

	avg->avgArray[avg->countValue] = newValue;
	for(i = 0;i<MA_VALUE;i++)
	{
		result += avg->avgArray[i];
 80019e6:	4411      	add	r1, r2
 80019e8:	6902      	ldr	r2, [r0, #16]
	}
	avg->countValue++;
	if (avg->countValue >= MA_VALUE)
	{
		avg->countValue = 0;
 80019ea:	bfc8      	it	gt
 80019ec:	2300      	movgt	r3, #0
	int i = 0, result = 0;

	avg->avgArray[avg->countValue] = newValue;
	for(i = 0;i<MA_VALUE;i++)
	{
		result += avg->avgArray[i];
 80019ee:	188a      	adds	r2, r1, r2
	}
	avg->countValue++;
	if (avg->countValue >= MA_VALUE)
	{
		avg->countValue = 0;
 80019f0:	6143      	str	r3, [r0, #20]
	}
	return result/MA_VALUE;
}
 80019f2:	2005      	movs	r0, #5
 80019f4:	fb92 f0f0 	sdiv	r0, r2, r0
 80019f8:	4770      	bx	lr

080019fa <quickSort>:


void quickSort (int a[], int lo, int hi)
{
 80019fa:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80019fe:	4605      	mov	r5, r0
 8001a00:	4616      	mov	r6, r2
//  lo is the lower index, hi is the upper index
//  of the region of array a that is to be sorted
    int i=lo, j=hi, h;
    int x=a[(lo+hi)/2];
 8001a02:	f04f 0802 	mov.w	r8, #2
 8001a06:	198b      	adds	r3, r1, r6
 8001a08:	fb93 f3f8 	sdiv	r3, r3, r8
 8001a0c:	f855 a023 	ldr.w	sl, [r5, r3, lsl #2]
	}
	return result/MA_VALUE;
}


void quickSort (int a[], int lo, int hi)
 8001a10:	eb05 0281 	add.w	r2, r5, r1, lsl #2
 8001a14:	1c4c      	adds	r4, r1, #1
{
//  lo is the lower index, hi is the upper index
//  of the region of array a that is to be sorted
    int i=lo, j=hi, h;
 8001a16:	4633      	mov	r3, r6
 8001a18:	e000      	b.n	8001a1c <quickSort+0x22>
 8001a1a:	3401      	adds	r4, #1
    int x=a[(lo+hi)/2];

    //  partition
    do
    {
        while (a[i]<x) i++;
 8001a1c:	f852 cb04 	ldr.w	ip, [r2], #4
	}
	return result/MA_VALUE;
}


void quickSort (int a[], int lo, int hi)
 8001a20:	1e67      	subs	r7, r4, #1
    int x=a[(lo+hi)/2];

    //  partition
    do
    {
        while (a[i]<x) i++;
 8001a22:	45d4      	cmp	ip, sl
 8001a24:	dbf9      	blt.n	8001a1a <quickSort+0x20>
	}
	return result/MA_VALUE;
}


void quickSort (int a[], int lo, int hi)
 8001a26:	eb05 0083 	add.w	r0, r5, r3, lsl #2
 8001a2a:	e000      	b.n	8001a2e <quickSort+0x34>

    //  partition
    do
    {
        while (a[i]<x) i++;
        while (a[j]>x) j--;
 8001a2c:	3b01      	subs	r3, #1
 8001a2e:	4683      	mov	fp, r0
 8001a30:	f850 9904 	ldr.w	r9, [r0], #-4
 8001a34:	45d1      	cmp	r9, sl
 8001a36:	dcf9      	bgt.n	8001a2c <quickSort+0x32>
        if (i<=j)
 8001a38:	429f      	cmp	r7, r3
 8001a3a:	dc07      	bgt.n	8001a4c <quickSort+0x52>
        {
            h=a[i]; a[i]=a[j]; a[j]=h;
            i++; j--;
 8001a3c:	3b01      	subs	r3, #1
        }
    } while (i<=j);
 8001a3e:	429c      	cmp	r4, r3
    {
        while (a[i]<x) i++;
        while (a[j]>x) j--;
        if (i<=j)
        {
            h=a[i]; a[i]=a[j]; a[j]=h;
 8001a40:	f842 9c04 	str.w	r9, [r2, #-4]
            i++; j--;
 8001a44:	4627      	mov	r7, r4
    {
        while (a[i]<x) i++;
        while (a[j]>x) j--;
        if (i<=j)
        {
            h=a[i]; a[i]=a[j]; a[j]=h;
 8001a46:	f8cb c000 	str.w	ip, [fp]
            i++; j--;
        }
    } while (i<=j);
 8001a4a:	dde6      	ble.n	8001a1a <quickSort+0x20>

    //  recursion
    if (lo<j) quickSort(a, lo, j);
 8001a4c:	4299      	cmp	r1, r3
 8001a4e:	da03      	bge.n	8001a58 <quickSort+0x5e>
 8001a50:	4628      	mov	r0, r5
 8001a52:	461a      	mov	r2, r3
 8001a54:	f7ff ffd1 	bl	80019fa <quickSort>
    if (i<hi) quickSort(a, i, hi);
 8001a58:	42b7      	cmp	r7, r6
 8001a5a:	4639      	mov	r1, r7
 8001a5c:	dbd3      	blt.n	8001a06 <quickSort+0xc>
}
 8001a5e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

08001a62 <calcStdDev>:

int calcStdDev (int a[], int index, int avgVal)
{
	int sum = 0, i = 0;

	for(i = 0; i<index;i++)
 8001a62:	2300      	movs	r3, #0
}



int calcStdDev (int a[], int index, int avgVal)
{
 8001a64:	b510      	push	{r4, lr}
	int sum = 0, i = 0;
 8001a66:	461c      	mov	r4, r3

	for(i = 0; i<index;i++)
 8001a68:	e004      	b.n	8001a74 <calcStdDev+0x12>
	{
		sum = (a[i]-avgVal)*(a[i]-avgVal);
 8001a6a:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]

int calcStdDev (int a[], int index, int avgVal)
{
	int sum = 0, i = 0;

	for(i = 0; i<index;i++)
 8001a6e:	3301      	adds	r3, #1
	{
		sum = (a[i]-avgVal)*(a[i]-avgVal);
 8001a70:	1aa4      	subs	r4, r4, r2
 8001a72:	4364      	muls	r4, r4

int calcStdDev (int a[], int index, int avgVal)
{
	int sum = 0, i = 0;

	for(i = 0; i<index;i++)
 8001a74:	428b      	cmp	r3, r1
 8001a76:	dbf8      	blt.n	8001a6a <calcStdDev+0x8>
	{
		sum = (a[i]-avgVal)*(a[i]-avgVal);
	}
	return (sqrt(sum/(index-1)));
 8001a78:	1e48      	subs	r0, r1, #1
 8001a7a:	fb94 f0f0 	sdiv	r0, r4, r0
 8001a7e:	f005 fd2d 	bl	80074dc <__aeabi_i2d>
 8001a82:	f006 fb1b 	bl	80080bc <sqrt>
 8001a86:	f005 fd8f 	bl	80075a8 <__aeabi_d2iz>
}
 8001a8a:	bd10      	pop	{r4, pc}

08001a8c <floatFilterAcc1>:
/*
 * SampleRate 250Hz cutoff: 5Hz 4th order Butterworth
 * http://www-users.cs.york.ac.uk/~fisher/mkfilter/trad.html
 */
void floatFilterAcc1(floatFilter *value, int newValue)
{
 8001a8c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];
	xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4];
 8001a90:	6843      	ldr	r3, [r0, #4]
 8001a92:	f8d0 900c 	ldr.w	r9, [r0, #12]
 8001a96:	f8d0 b008 	ldr.w	fp, [r0, #8]
 8001a9a:	f8d0 a010 	ldr.w	sl, [r0, #16]
/*
 * SampleRate 250Hz cutoff: 5Hz 4th order Butterworth
 * http://www-users.cs.york.ac.uk/~fisher/mkfilter/trad.html
 */
void floatFilterAcc1(floatFilter *value, int newValue)
{
 8001a9e:	4604      	mov	r4, r0
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];
	xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4];
 8001aa0:	6003      	str	r3, [r0, #0]
 8001aa2:	f8c0 9008 	str.w	r9, [r0, #8]
 8001aa6:	f8c0 a00c 	str.w	sl, [r0, #12]
 8001aaa:	f8c0 b004 	str.w	fp, [r0, #4]
	xv[4] = (float)newValue / 2.674241096e+06 /*GAIN*/;
 8001aae:	4608      	mov	r0, r1
 8001ab0:	9301      	str	r3, [sp, #4]
 8001ab2:	f005 feab 	bl	800780c <__aeabi_i2f>
 8001ab6:	4929      	ldr	r1, [pc, #164]	; (8001b5c <floatFilterAcc1+0xd0>)
 8001ab8:	f005 ffb0 	bl	8007a1c <__aeabi_fdiv>
	yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3]; yv[3] = yv[4];
 8001abc:	f8d4 8018 	ldr.w	r8, [r4, #24]
 8001ac0:	69e7      	ldr	r7, [r4, #28]
 8001ac2:	6a26      	ldr	r6, [r4, #32]
	yv[4] =   (xv[0] + xv[4]) + 4 * (xv[1] + xv[3]) + 6 * xv[2]
 8001ac4:	9b01      	ldr	r3, [sp, #4]
{
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];
	xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4];
	xv[4] = (float)newValue / 2.674241096e+06 /*GAIN*/;
	yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3]; yv[3] = yv[4];
 8001ac6:	6a65      	ldr	r5, [r4, #36]	; 0x24
void floatFilterAcc1(floatFilter *value, int newValue)
{
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];
	xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4];
	xv[4] = (float)newValue / 2.674241096e+06 /*GAIN*/;
 8001ac8:	4601      	mov	r1, r0
 8001aca:	6120      	str	r0, [r4, #16]
	yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3]; yv[3] = yv[4];
 8001acc:	f8c4 8014 	str.w	r8, [r4, #20]
 8001ad0:	61a7      	str	r7, [r4, #24]
 8001ad2:	61e6      	str	r6, [r4, #28]
	yv[4] =   (xv[0] + xv[4]) + 4 * (xv[1] + xv[3]) + 6 * xv[2]
 8001ad4:	4618      	mov	r0, r3
{
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];
	xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4];
	xv[4] = (float)newValue / 2.674241096e+06 /*GAIN*/;
	yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3]; yv[3] = yv[4];
 8001ad6:	6225      	str	r5, [r4, #32]
	yv[4] =   (xv[0] + xv[4]) + 4 * (xv[1] + xv[3]) + 6 * xv[2]
 8001ad8:	f005 fde4 	bl	80076a4 <__addsf3>
 8001adc:	4651      	mov	r1, sl
 8001ade:	4603      	mov	r3, r0
 8001ae0:	4658      	mov	r0, fp
 8001ae2:	9301      	str	r3, [sp, #4]
 8001ae4:	f005 fdde 	bl	80076a4 <__addsf3>
 8001ae8:	f04f 4181 	mov.w	r1, #1082130432	; 0x40800000
 8001aec:	f005 fee2 	bl	80078b4 <__aeabi_fmul>
 8001af0:	9b01      	ldr	r3, [sp, #4]
 8001af2:	4601      	mov	r1, r0
 8001af4:	4618      	mov	r0, r3
 8001af6:	f005 fdd5 	bl	80076a4 <__addsf3>
 8001afa:	4919      	ldr	r1, [pc, #100]	; (8001b60 <floatFilterAcc1+0xd4>)
 8001afc:	4682      	mov	sl, r0
 8001afe:	4648      	mov	r0, r9
 8001b00:	f005 fed8 	bl	80078b4 <__aeabi_fmul>
 8001b04:	4601      	mov	r1, r0
 8001b06:	4650      	mov	r0, sl
 8001b08:	f005 fdcc 	bl	80076a4 <__addsf3>
				 + ( -0.8768965608 * yv[0]) + (  3.6227607596 * yv[1])
 8001b0c:	4915      	ldr	r1, [pc, #84]	; (8001b64 <floatFilterAcc1+0xd8>)
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];
	xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4];
	xv[4] = (float)newValue / 2.674241096e+06 /*GAIN*/;
	yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3]; yv[3] = yv[4];
	yv[4] =   (xv[0] + xv[4]) + 4 * (xv[1] + xv[3]) + 6 * xv[2]
 8001b0e:	4681      	mov	r9, r0
				 + ( -0.8768965608 * yv[0]) + (  3.6227607596 * yv[1])
 8001b10:	4640      	mov	r0, r8
 8001b12:	f005 fecf 	bl	80078b4 <__aeabi_fmul>
 8001b16:	4601      	mov	r1, r0
 8001b18:	4648      	mov	r0, r9
 8001b1a:	f005 fdc3 	bl	80076a4 <__addsf3>
 8001b1e:	4912      	ldr	r1, [pc, #72]	; (8001b68 <floatFilterAcc1+0xdc>)
 8001b20:	4680      	mov	r8, r0
 8001b22:	4638      	mov	r0, r7
 8001b24:	f005 fec6 	bl	80078b4 <__aeabi_fmul>
 8001b28:	4601      	mov	r1, r0
 8001b2a:	4640      	mov	r0, r8
 8001b2c:	f005 fdba 	bl	80076a4 <__addsf3>
				 + ( -5.6145268496 * yv[2]) + (  3.8686566679 * yv[3]);
 8001b30:	490e      	ldr	r1, [pc, #56]	; (8001b6c <floatFilterAcc1+0xe0>)
	float *yv = &value->filter_yv[0];
	xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4];
	xv[4] = (float)newValue / 2.674241096e+06 /*GAIN*/;
	yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3]; yv[3] = yv[4];
	yv[4] =   (xv[0] + xv[4]) + 4 * (xv[1] + xv[3]) + 6 * xv[2]
				 + ( -0.8768965608 * yv[0]) + (  3.6227607596 * yv[1])
 8001b32:	4607      	mov	r7, r0
				 + ( -5.6145268496 * yv[2]) + (  3.8686566679 * yv[3]);
 8001b34:	4630      	mov	r0, r6
 8001b36:	f005 febd 	bl	80078b4 <__aeabi_fmul>
 8001b3a:	4601      	mov	r1, r0
 8001b3c:	4638      	mov	r0, r7
 8001b3e:	f005 fdb1 	bl	80076a4 <__addsf3>
 8001b42:	490b      	ldr	r1, [pc, #44]	; (8001b70 <floatFilterAcc1+0xe4>)
 8001b44:	4606      	mov	r6, r0
 8001b46:	4628      	mov	r0, r5
 8001b48:	f005 feb4 	bl	80078b4 <__aeabi_fmul>
 8001b4c:	4601      	mov	r1, r0
 8001b4e:	4630      	mov	r0, r6
 8001b50:	f005 fda8 	bl	80076a4 <__addsf3>
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];
	xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4];
	xv[4] = (float)newValue / 2.674241096e+06 /*GAIN*/;
	yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3]; yv[3] = yv[4];
	yv[4] =   (xv[0] + xv[4]) + 4 * (xv[1] + xv[3]) + 6 * xv[2]
 8001b54:	6260      	str	r0, [r4, #36]	; 0x24
				 + ( -0.8768965608 * yv[0]) + (  3.6227607596 * yv[1])
				 + ( -5.6145268496 * yv[2]) + (  3.8686566679 * yv[3]);
	value->currentValue = yv[4];
 8001b56:	62a0      	str	r0, [r4, #40]	; 0x28
}
 8001b58:	e8bd 8ffe 	ldmia.w	sp!, {r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8001b5c:	4a233904 	.word	0x4a233904
 8001b60:	40c00000 	.word	0x40c00000
 8001b64:	bf607c4b 	.word	0xbf607c4b
 8001b68:	4067db50 	.word	0x4067db50
 8001b6c:	c0b3aa34 	.word	0xc0b3aa34
 8001b70:	40779812 	.word	0x40779812

08001b74 <floatFilterAcc2>:

void floatFilterAcc2(floatFilter *value, int newValue)
{
 8001b74:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];
	xv[0] = xv[1]; xv[1] = xv[2];
 8001b78:	f8d0 8004 	ldr.w	r8, [r0, #4]
 8001b7c:	6887      	ldr	r7, [r0, #8]
				 + ( -5.6145268496 * yv[2]) + (  3.8686566679 * yv[3]);
	value->currentValue = yv[4];
}

void floatFilterAcc2(floatFilter *value, int newValue)
{
 8001b7e:	4604      	mov	r4, r0
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];
	xv[0] = xv[1]; xv[1] = xv[2];
 8001b80:	f8c0 8000 	str.w	r8, [r0]
 8001b84:	6047      	str	r7, [r0, #4]
	xv[2] = (float)newValue / 2.555570536e+04 /*GAIN*/;
 8001b86:	4608      	mov	r0, r1
 8001b88:	f005 fe40 	bl	800780c <__aeabi_i2f>
 8001b8c:	4915      	ldr	r1, [pc, #84]	; (8001be4 <floatFilterAcc2+0x70>)
 8001b8e:	f005 ff45 	bl	8007a1c <__aeabi_fdiv>
    yv[0] = yv[1]; yv[1] = yv[2];
 8001b92:	69a6      	ldr	r6, [r4, #24]
 8001b94:	69e5      	ldr	r5, [r4, #28]
void floatFilterAcc2(floatFilter *value, int newValue)
{
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];
	xv[0] = xv[1]; xv[1] = xv[2];
	xv[2] = (float)newValue / 2.555570536e+04 /*GAIN*/;
 8001b96:	4601      	mov	r1, r0
 8001b98:	60a0      	str	r0, [r4, #8]
    yv[0] = yv[1]; yv[1] = yv[2];
 8001b9a:	6166      	str	r6, [r4, #20]
    yv[2] =   (xv[0] + xv[2]) + 2 * xv[1]
 8001b9c:	4640      	mov	r0, r8
{
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];
	xv[0] = xv[1]; xv[1] = xv[2];
	xv[2] = (float)newValue / 2.555570536e+04 /*GAIN*/;
    yv[0] = yv[1]; yv[1] = yv[2];
 8001b9e:	61a5      	str	r5, [r4, #24]
    yv[2] =   (xv[0] + xv[2]) + 2 * xv[1]
 8001ba0:	f005 fd80 	bl	80076a4 <__addsf3>
 8001ba4:	4639      	mov	r1, r7
 8001ba6:	4680      	mov	r8, r0
 8001ba8:	4638      	mov	r0, r7
 8001baa:	f005 fd7b 	bl	80076a4 <__addsf3>
 8001bae:	4601      	mov	r1, r0
 8001bb0:	4640      	mov	r0, r8
 8001bb2:	f005 fd77 	bl	80076a4 <__addsf3>
                 + ( -0.9823854506 * yv[0]) + (  1.9822289298 * yv[1]);
 8001bb6:	490c      	ldr	r1, [pc, #48]	; (8001be8 <floatFilterAcc2+0x74>)
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];
	xv[0] = xv[1]; xv[1] = xv[2];
	xv[2] = (float)newValue / 2.555570536e+04 /*GAIN*/;
    yv[0] = yv[1]; yv[1] = yv[2];
    yv[2] =   (xv[0] + xv[2]) + 2 * xv[1]
 8001bb8:	4607      	mov	r7, r0
                 + ( -0.9823854506 * yv[0]) + (  1.9822289298 * yv[1]);
 8001bba:	4630      	mov	r0, r6
 8001bbc:	f005 fe7a 	bl	80078b4 <__aeabi_fmul>
 8001bc0:	4601      	mov	r1, r0
 8001bc2:	4638      	mov	r0, r7
 8001bc4:	f005 fd6e 	bl	80076a4 <__addsf3>
 8001bc8:	4908      	ldr	r1, [pc, #32]	; (8001bec <floatFilterAcc2+0x78>)
 8001bca:	4606      	mov	r6, r0
 8001bcc:	4628      	mov	r0, r5
 8001bce:	f005 fe71 	bl	80078b4 <__aeabi_fmul>
 8001bd2:	4601      	mov	r1, r0
 8001bd4:	4630      	mov	r0, r6
 8001bd6:	f005 fd65 	bl	80076a4 <__addsf3>
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];
	xv[0] = xv[1]; xv[1] = xv[2];
	xv[2] = (float)newValue / 2.555570536e+04 /*GAIN*/;
    yv[0] = yv[1]; yv[1] = yv[2];
    yv[2] =   (xv[0] + xv[2]) + 2 * xv[1]
 8001bda:	61e0      	str	r0, [r4, #28]
                 + ( -0.9823854506 * yv[0]) + (  1.9822289298 * yv[1]);
    value->currentValue = yv[2];
 8001bdc:	62a0      	str	r0, [r4, #40]	; 0x28
 8001bde:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001be2:	bf00      	nop
 8001be4:	46c7a769 	.word	0x46c7a769
 8001be8:	bf7b7d9d 	.word	0xbf7b7d9d
 8001bec:	3ffdb9ad 	.word	0x3ffdb9ad

08001bf0 <floatFilterAcc>:
 * Sample 100Hz
 * Eckfrequenz 8Hz
 *
 *  Command line: /www/usr/fisher/helpers/mkfilter -Bu -Lp -o 3 -a 1.0000000000e-02 0.0000000000e+00 -l */
void floatFilterAcc(floatFilter *value, int newValue)
{
 8001bf0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
//	yv[3] =   (xv[0] + xv[3]) + 3 * (xv[1] + xv[2])
//	                 + (  0.3617959282 * yv[0]) + ( -1.4470540195 * yv[1])
//	                 + (  2.0037974774 * yv[2]);
//	value->currentValue = yv[3];

    xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3];
 8001bf4:	f8d0 a004 	ldr.w	sl, [r0, #4]
 8001bf8:	f8d0 9008 	ldr.w	r9, [r0, #8]
 8001bfc:	f8d0 800c 	ldr.w	r8, [r0, #12]
 * Sample 100Hz
 * Eckfrequenz 8Hz
 *
 *  Command line: /www/usr/fisher/helpers/mkfilter -Bu -Lp -o 3 -a 1.0000000000e-02 0.0000000000e+00 -l */
void floatFilterAcc(floatFilter *value, int newValue)
{
 8001c00:	4604      	mov	r4, r0
//	yv[3] =   (xv[0] + xv[3]) + 3 * (xv[1] + xv[2])
//	                 + (  0.3617959282 * yv[0]) + ( -1.4470540195 * yv[1])
//	                 + (  2.0037974774 * yv[2]);
//	value->currentValue = yv[3];

    xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3];
 8001c02:	f8c0 a000 	str.w	sl, [r0]
 8001c06:	f8c0 8008 	str.w	r8, [r0, #8]
 8001c0a:	f8c0 9004 	str.w	r9, [r0, #4]
    xv[3] = newValue / 1.429899908e+03;
 8001c0e:	4608      	mov	r0, r1
 8001c10:	f005 fdfc 	bl	800780c <__aeabi_i2f>
 8001c14:	491c      	ldr	r1, [pc, #112]	; (8001c88 <floatFilterAcc+0x98>)
 8001c16:	f005 ff01 	bl	8007a1c <__aeabi_fdiv>
    yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3];
 8001c1a:	69a7      	ldr	r7, [r4, #24]
 8001c1c:	69e6      	ldr	r6, [r4, #28]
 8001c1e:	6a25      	ldr	r5, [r4, #32]
//	                 + (  0.3617959282 * yv[0]) + ( -1.4470540195 * yv[1])
//	                 + (  2.0037974774 * yv[2]);
//	value->currentValue = yv[3];

    xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3];
    xv[3] = newValue / 1.429899908e+03;
 8001c20:	4601      	mov	r1, r0
 8001c22:	60e0      	str	r0, [r4, #12]
    yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3];
 8001c24:	6167      	str	r7, [r4, #20]
 8001c26:	61a6      	str	r6, [r4, #24]
    yv[3] =   (xv[0] + xv[3]) + 3 * (xv[1] + xv[2])
 8001c28:	4650      	mov	r0, sl
//	                 + (  2.0037974774 * yv[2]);
//	value->currentValue = yv[3];

    xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3];
    xv[3] = newValue / 1.429899908e+03;
    yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3];
 8001c2a:	61e5      	str	r5, [r4, #28]
    yv[3] =   (xv[0] + xv[3]) + 3 * (xv[1] + xv[2])
 8001c2c:	f005 fd3a 	bl	80076a4 <__addsf3>
 8001c30:	4641      	mov	r1, r8
 8001c32:	4682      	mov	sl, r0
 8001c34:	4648      	mov	r0, r9
 8001c36:	f005 fd35 	bl	80076a4 <__addsf3>
 8001c3a:	4914      	ldr	r1, [pc, #80]	; (8001c8c <floatFilterAcc+0x9c>)
 8001c3c:	f005 fe3a 	bl	80078b4 <__aeabi_fmul>
 8001c40:	4601      	mov	r1, r0
 8001c42:	4650      	mov	r0, sl
 8001c44:	f005 fd2e 	bl	80076a4 <__addsf3>
                     + (  0.6855359773 * yv[0]) + ( -2.3146825811 * yv[1])
 8001c48:	4911      	ldr	r1, [pc, #68]	; (8001c90 <floatFilterAcc+0xa0>)
//	value->currentValue = yv[3];

    xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3];
    xv[3] = newValue / 1.429899908e+03;
    yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3];
    yv[3] =   (xv[0] + xv[3]) + 3 * (xv[1] + xv[2])
 8001c4a:	4680      	mov	r8, r0
                     + (  0.6855359773 * yv[0]) + ( -2.3146825811 * yv[1])
 8001c4c:	4638      	mov	r0, r7
 8001c4e:	f005 fe31 	bl	80078b4 <__aeabi_fmul>
 8001c52:	4601      	mov	r1, r0
 8001c54:	4640      	mov	r0, r8
 8001c56:	f005 fd25 	bl	80076a4 <__addsf3>
 8001c5a:	490e      	ldr	r1, [pc, #56]	; (8001c94 <floatFilterAcc+0xa4>)
 8001c5c:	4607      	mov	r7, r0
 8001c5e:	4630      	mov	r0, r6
 8001c60:	f005 fe28 	bl	80078b4 <__aeabi_fmul>
 8001c64:	4601      	mov	r1, r0
 8001c66:	4638      	mov	r0, r7
 8001c68:	f005 fd1c 	bl	80076a4 <__addsf3>
                     + (  2.6235518066 * yv[2]);
 8001c6c:	490a      	ldr	r1, [pc, #40]	; (8001c98 <floatFilterAcc+0xa8>)

    xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3];
    xv[3] = newValue / 1.429899908e+03;
    yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3];
    yv[3] =   (xv[0] + xv[3]) + 3 * (xv[1] + xv[2])
                     + (  0.6855359773 * yv[0]) + ( -2.3146825811 * yv[1])
 8001c6e:	4606      	mov	r6, r0
                     + (  2.6235518066 * yv[2]);
 8001c70:	4628      	mov	r0, r5
 8001c72:	f005 fe1f 	bl	80078b4 <__aeabi_fmul>
 8001c76:	4601      	mov	r1, r0
 8001c78:	4630      	mov	r0, r6
 8001c7a:	f005 fd13 	bl	80076a4 <__addsf3>
//	value->currentValue = yv[3];

    xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3];
    xv[3] = newValue / 1.429899908e+03;
    yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3];
    yv[3] =   (xv[0] + xv[3]) + 3 * (xv[1] + xv[2])
 8001c7e:	6220      	str	r0, [r4, #32]
                     + (  0.6855359773 * yv[0]) + ( -2.3146825811 * yv[1])
                     + (  2.6235518066 * yv[2]);
    value->currentValue = yv[3];
 8001c80:	62a0      	str	r0, [r4, #40]	; 0x28
 8001c82:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8001c86:	bf00      	nop
 8001c88:	44b2bccc 	.word	0x44b2bccc
 8001c8c:	40400000 	.word	0x40400000
 8001c90:	3f2f7f49 	.word	0x3f2f7f49
 8001c94:	c01423c2 	.word	0xc01423c2
 8001c98:	4027e846 	.word	0x4027e846

08001c9c <floatFilterGyro>:
/*
 * SampleRate 500Hz, cutoff 200Hz, 4th order Butterworth
 * http://www-users.cs.york.ac.uk/~fisher/mkfilter/trad.html
 */
void floatFilterGyro(floatFilter *value, int newValue)
{
 8001c9c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];

	xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4];
 8001ca0:	6843      	ldr	r3, [r0, #4]
 8001ca2:	f8d0 900c 	ldr.w	r9, [r0, #12]
 8001ca6:	f8d0 b008 	ldr.w	fp, [r0, #8]
 8001caa:	f8d0 a010 	ldr.w	sl, [r0, #16]
/*
 * SampleRate 500Hz, cutoff 200Hz, 4th order Butterworth
 * http://www-users.cs.york.ac.uk/~fisher/mkfilter/trad.html
 */
void floatFilterGyro(floatFilter *value, int newValue)
{
 8001cae:	4604      	mov	r4, r0
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];

	xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4];
 8001cb0:	6003      	str	r3, [r0, #0]
 8001cb2:	f8c0 9008 	str.w	r9, [r0, #8]
 8001cb6:	f8c0 a00c 	str.w	sl, [r0, #12]
 8001cba:	f8c0 b004 	str.w	fp, [r0, #4]
	xv[4] = (float)newValue / 2.310287053e+00;
 8001cbe:	4608      	mov	r0, r1
 8001cc0:	9301      	str	r3, [sp, #4]
 8001cc2:	f005 fda3 	bl	800780c <__aeabi_i2f>
 8001cc6:	4929      	ldr	r1, [pc, #164]	; (8001d6c <floatFilterGyro+0xd0>)
 8001cc8:	f005 fea8 	bl	8007a1c <__aeabi_fdiv>
	yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3]; yv[3] = yv[4];
 8001ccc:	f8d4 8018 	ldr.w	r8, [r4, #24]
 8001cd0:	69e7      	ldr	r7, [r4, #28]
 8001cd2:	6a26      	ldr	r6, [r4, #32]
	yv[4] =   (xv[0] + xv[4]) + 4 * (xv[1] + xv[3]) + 6 * xv[2]
 8001cd4:	9b01      	ldr	r3, [sp, #4]
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];

	xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4];
	xv[4] = (float)newValue / 2.310287053e+00;
	yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3]; yv[3] = yv[4];
 8001cd6:	6a65      	ldr	r5, [r4, #36]	; 0x24
{
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];

	xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4];
	xv[4] = (float)newValue / 2.310287053e+00;
 8001cd8:	4601      	mov	r1, r0
 8001cda:	6120      	str	r0, [r4, #16]
	yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3]; yv[3] = yv[4];
 8001cdc:	f8c4 8014 	str.w	r8, [r4, #20]
 8001ce0:	61a7      	str	r7, [r4, #24]
 8001ce2:	61e6      	str	r6, [r4, #28]
	yv[4] =   (xv[0] + xv[4]) + 4 * (xv[1] + xv[3]) + 6 * xv[2]
 8001ce4:	4618      	mov	r0, r3
	float *xv = &value->filter_xv[0];
	float *yv = &value->filter_yv[0];

	xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4];
	xv[4] = (float)newValue / 2.310287053e+00;
	yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3]; yv[3] = yv[4];
 8001ce6:	6225      	str	r5, [r4, #32]
	yv[4] =   (xv[0] + xv[4]) + 4 * (xv[1] + xv[3]) + 6 * xv[2]
 8001ce8:	f005 fcdc 	bl	80076a4 <__addsf3>
 8001cec:	4651      	mov	r1, sl
 8001cee:	4603      	mov	r3, r0
 8001cf0:	4658      	mov	r0, fp
 8001cf2:	9301      	str	r3, [sp, #4]
 8001cf4:	f005 fcd6 	bl	80076a4 <__addsf3>
 8001cf8:	f04f 4181 	mov.w	r1, #1082130432	; 0x40800000
 8001cfc:	f005 fdda 	bl	80078b4 <__aeabi_fmul>
 8001d00:	9b01      	ldr	r3, [sp, #4]
 8001d02:	4601      	mov	r1, r0
 8001d04:	4618      	mov	r0, r3
 8001d06:	f005 fccd 	bl	80076a4 <__addsf3>
 8001d0a:	4919      	ldr	r1, [pc, #100]	; (8001d70 <floatFilterGyro+0xd4>)
 8001d0c:	4682      	mov	sl, r0
 8001d0e:	4648      	mov	r0, r9
 8001d10:	f005 fdd0 	bl	80078b4 <__aeabi_fmul>
 8001d14:	4601      	mov	r1, r0
 8001d16:	4650      	mov	r0, sl
 8001d18:	f005 fcc4 	bl	80076a4 <__addsf3>
				 + ( -0.1873794924 * yv[0]) + ( -1.0546654059 * yv[1])
 8001d1c:	4915      	ldr	r1, [pc, #84]	; (8001d74 <floatFilterGyro+0xd8>)
	float *yv = &value->filter_yv[0];

	xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4];
	xv[4] = (float)newValue / 2.310287053e+00;
	yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3]; yv[3] = yv[4];
	yv[4] =   (xv[0] + xv[4]) + 4 * (xv[1] + xv[3]) + 6 * xv[2]
 8001d1e:	4681      	mov	r9, r0
				 + ( -0.1873794924 * yv[0]) + ( -1.0546654059 * yv[1])
 8001d20:	4640      	mov	r0, r8
 8001d22:	f005 fdc7 	bl	80078b4 <__aeabi_fmul>
 8001d26:	4601      	mov	r1, r0
 8001d28:	4648      	mov	r0, r9
 8001d2a:	f005 fcbb 	bl	80076a4 <__addsf3>
 8001d2e:	4912      	ldr	r1, [pc, #72]	; (8001d78 <floatFilterGyro+0xdc>)
 8001d30:	4680      	mov	r8, r0
 8001d32:	4638      	mov	r0, r7
 8001d34:	f005 fdbe 	bl	80078b4 <__aeabi_fmul>
 8001d38:	4601      	mov	r1, r0
 8001d3a:	4640      	mov	r0, r8
 8001d3c:	f005 fcb2 	bl	80076a4 <__addsf3>
				 + ( -2.3139884144 * yv[2]) + ( -2.3695130072 * yv[3]);
 8001d40:	490e      	ldr	r1, [pc, #56]	; (8001d7c <floatFilterGyro+0xe0>)

	xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4];
	xv[4] = (float)newValue / 2.310287053e+00;
	yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3]; yv[3] = yv[4];
	yv[4] =   (xv[0] + xv[4]) + 4 * (xv[1] + xv[3]) + 6 * xv[2]
				 + ( -0.1873794924 * yv[0]) + ( -1.0546654059 * yv[1])
 8001d42:	4607      	mov	r7, r0
				 + ( -2.3139884144 * yv[2]) + ( -2.3695130072 * yv[3]);
 8001d44:	4630      	mov	r0, r6
 8001d46:	f005 fdb5 	bl	80078b4 <__aeabi_fmul>
 8001d4a:	4601      	mov	r1, r0
 8001d4c:	4638      	mov	r0, r7
 8001d4e:	f005 fca9 	bl	80076a4 <__addsf3>
 8001d52:	490b      	ldr	r1, [pc, #44]	; (8001d80 <floatFilterGyro+0xe4>)
 8001d54:	4606      	mov	r6, r0
 8001d56:	4628      	mov	r0, r5
 8001d58:	f005 fdac 	bl	80078b4 <__aeabi_fmul>
 8001d5c:	4601      	mov	r1, r0
 8001d5e:	4630      	mov	r0, r6
 8001d60:	f005 fca0 	bl	80076a4 <__addsf3>
	float *yv = &value->filter_yv[0];

	xv[0] = xv[1]; xv[1] = xv[2]; xv[2] = xv[3]; xv[3] = xv[4];
	xv[4] = (float)newValue / 2.310287053e+00;
	yv[0] = yv[1]; yv[1] = yv[2]; yv[2] = yv[3]; yv[3] = yv[4];
	yv[4] =   (xv[0] + xv[4]) + 4 * (xv[1] + xv[3]) + 6 * xv[2]
 8001d64:	6260      	str	r0, [r4, #36]	; 0x24
				 + ( -0.1873794924 * yv[0]) + ( -1.0546654059 * yv[1])
				 + ( -2.3139884144 * yv[2]) + ( -2.3695130072 * yv[3]);
	value->currentValue = yv[4];
 8001d66:	62a0      	str	r0, [r4, #40]	; 0x28
}
 8001d68:	e8bd 8ffe 	ldmia.w	sp!, {r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8001d6c:	4013dbbe 	.word	0x4013dbbe
 8001d70:	40c00000 	.word	0x40c00000
 8001d74:	be3fe069 	.word	0xbe3fe069
 8001d78:	bf86ff47 	.word	0xbf86ff47
 8001d7c:	c0141863 	.word	0xc0141863
 8001d80:	c017a61a 	.word	0xc017a61a

08001d84 <Delay>:
#include <helperFunctions.h>


void Delay(volatile uint32_t delayCount)
{
 8001d84:	b082      	sub	sp, #8
 8001d86:	9001      	str	r0, [sp, #4]
	while (delayCount > 0)
 8001d88:	e002      	b.n	8001d90 <Delay+0xc>
	{
		delayCount--;
 8001d8a:	9b01      	ldr	r3, [sp, #4]
 8001d8c:	3b01      	subs	r3, #1
 8001d8e:	9301      	str	r3, [sp, #4]
#include <helperFunctions.h>


void Delay(volatile uint32_t delayCount)
{
	while (delayCount > 0)
 8001d90:	9b01      	ldr	r3, [sp, #4]
 8001d92:	2b00      	cmp	r3, #0
 8001d94:	d1f9      	bne.n	8001d8a <Delay+0x6>
	{
		delayCount--;
	}
}
 8001d96:	b002      	add	sp, #8
 8001d98:	4770      	bx	lr
	...

08001d9c <IMU_Print_Values>:
}
*/

/*For debug purposes - the print task*/
static void IMU_Print_Values( void *pvParameters )
{
 8001d9c:	b570      	push	{r4, r5, r6, lr}
	const portTickType xDelay = 40 / portTICK_RATE_MS;

	while(1)
	{
		//printf("%d,%d,%d,%d %d  ",CtrlStates.gas, CtrlStates.nick, CtrlStates.roll, CtrlStates.yaw, CtrlStates.copterStatus);
		printf("%d,%d,%d\r\n",(int)XYZ.y, (int)XYZ.x, (int)XYZ.z);
 8001d9e:	4c0b      	ldr	r4, [pc, #44]	; (8001dcc <IMU_Print_Values+0x30>)
 8001da0:	6860      	ldr	r0, [r4, #4]
 8001da2:	f005 ff4d 	bl	8007c40 <__aeabi_f2iz>
 8001da6:	4606      	mov	r6, r0
 8001da8:	6820      	ldr	r0, [r4, #0]
 8001daa:	f005 ff49 	bl	8007c40 <__aeabi_f2iz>
 8001dae:	4605      	mov	r5, r0
 8001db0:	68a0      	ldr	r0, [r4, #8]
 8001db2:	f005 ff45 	bl	8007c40 <__aeabi_f2iz>
 8001db6:	4631      	mov	r1, r6
 8001db8:	4603      	mov	r3, r0
 8001dba:	462a      	mov	r2, r5
 8001dbc:	4804      	ldr	r0, [pc, #16]	; (8001dd0 <IMU_Print_Values+0x34>)
 8001dbe:	f000 fa21 	bl	8002204 <printf>
		//printf("test:%d,%d,%d\r\n", (int)(XYZ.y), (int)(CtrlStates.roll) ,(int)(yTemp));

		// XYZ.y ?
		// XYZ.x roll
		// XYZ.z
		vTaskDelay( xDelay );
 8001dc2:	2028      	movs	r0, #40	; 0x28
 8001dc4:	f004 fe04 	bl	80069d0 <vTaskDelay>
 8001dc8:	e7ea      	b.n	8001da0 <IMU_Print_Values+0x4>
 8001dca:	bf00      	nop
 8001dcc:	20002bb0 	.word	0x20002bb0
 8001dd0:	0800a9db 	.word	0x0800a9db

08001dd4 <Position_Controller>:

	while(1);
}

static void Position_Controller( void *pvParameters )
{
 8001dd4:	b513      	push	{r0, r1, r4, lr}
	portTickType xNextWakeTime;

	Disable_Motor();
 8001dd6:	f7fe ffc7 	bl	8000d68 <Disable_Motor>
	/*
	 * Wait here 2 Seconds to ensure,
	 * that all capacitors are charged
	 * and VCC is stable
	 * */
	vTaskDelay( 2000 );
 8001dda:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 8001dde:	f004 fdf7 	bl	80069d0 <vTaskDelay>

	Init_IMU();
 8001de2:	f7ff f9bf 	bl	8001164 <Init_IMU>

	Init_PositionController();
 8001de6:	f7ff f997 	bl	8001118 <Init_PositionController>

	Enable_Motor();
 8001dea:	f7fe ffad 	bl	8000d48 <Enable_Motor>

	while(1)
	{
		xNextWakeTime = xTaskGetTickCount();

		GPIOC->ODR |= GPIO_Pin_11;	// Set Debug Pin
 8001dee:	4c0c      	ldr	r4, [pc, #48]	; (8001e20 <Position_Controller+0x4c>)

	Enable_Motor();

	while(1)
	{
		xNextWakeTime = xTaskGetTickCount();
 8001df0:	f004 fcd2 	bl	8006798 <xTaskGetTickCount>

		GPIOC->ODR |= GPIO_Pin_11;	// Set Debug Pin
 8001df4:	8aa3      	ldrh	r3, [r4, #20]

	Enable_Motor();

	while(1)
	{
		xNextWakeTime = xTaskGetTickCount();
 8001df6:	9001      	str	r0, [sp, #4]

		GPIOC->ODR |= GPIO_Pin_11;	// Set Debug Pin
 8001df8:	b29b      	uxth	r3, r3
 8001dfa:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8001dfe:	82a3      	strh	r3, [r4, #20]

		IMU_Calculation();
 8001e00:	f7ff fb0a 	bl	8001418 <IMU_Calculation>

		PositionController();
 8001e04:	f7ff fcb2 	bl	800176c <PositionController>

		GPIOC->ODR &= ~GPIO_Pin_11; // Clear Debug Pin
 8001e08:	8aa3      	ldrh	r3, [r4, #20]

		vTaskDelayUntil( &xNextWakeTime, DT );
 8001e0a:	a801      	add	r0, sp, #4

		IMU_Calculation();

		PositionController();

		GPIOC->ODR &= ~GPIO_Pin_11; // Clear Debug Pin
 8001e0c:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8001e10:	041b      	lsls	r3, r3, #16
 8001e12:	0c1b      	lsrs	r3, r3, #16
 8001e14:	82a3      	strh	r3, [r4, #20]

		vTaskDelayUntil( &xNextWakeTime, DT );
 8001e16:	2102      	movs	r1, #2
 8001e18:	f004 fdf4 	bl	8006a04 <vTaskDelayUntil>
 8001e1c:	e7e8      	b.n	8001df0 <Position_Controller+0x1c>
 8001e1e:	bf00      	nop
 8001e20:	48000800 	.word	0x48000800

08001e24 <LED_TOGGLE_NOT_READY>:



void LED_TOGGLE_NOT_READY(void)
{
	GPIOE->ODR ^= GPIO_Pin_8;
 8001e24:	4b0a      	ldr	r3, [pc, #40]	; (8001e50 <LED_TOGGLE_NOT_READY+0x2c>)
 8001e26:	8a9a      	ldrh	r2, [r3, #20]
 8001e28:	b292      	uxth	r2, r2
 8001e2a:	f482 7280 	eor.w	r2, r2, #256	; 0x100
 8001e2e:	829a      	strh	r2, [r3, #20]
	GPIOE->ODR ^= GPIO_Pin_10;
 8001e30:	8a9a      	ldrh	r2, [r3, #20]
 8001e32:	b292      	uxth	r2, r2
 8001e34:	f482 6280 	eor.w	r2, r2, #1024	; 0x400
 8001e38:	829a      	strh	r2, [r3, #20]
	GPIOE->ODR ^= GPIO_Pin_12;
 8001e3a:	8a9a      	ldrh	r2, [r3, #20]
 8001e3c:	b292      	uxth	r2, r2
 8001e3e:	f482 5280 	eor.w	r2, r2, #4096	; 0x1000
 8001e42:	829a      	strh	r2, [r3, #20]
	GPIOE->ODR ^= GPIO_Pin_14;
 8001e44:	8a9a      	ldrh	r2, [r3, #20]
 8001e46:	b292      	uxth	r2, r2
 8001e48:	f482 4280 	eor.w	r2, r2, #16384	; 0x4000
 8001e4c:	829a      	strh	r2, [r3, #20]
 8001e4e:	4770      	bx	lr
 8001e50:	48001000 	.word	0x48001000

08001e54 <LED_TOGGLE_READY>:
}

void LED_TOGGLE_READY(void)
{
	GPIOE->ODR ^= GPIO_Pin_9;
 8001e54:	4b0a      	ldr	r3, [pc, #40]	; (8001e80 <LED_TOGGLE_READY+0x2c>)
 8001e56:	8a9a      	ldrh	r2, [r3, #20]
 8001e58:	b292      	uxth	r2, r2
 8001e5a:	f482 7200 	eor.w	r2, r2, #512	; 0x200
 8001e5e:	829a      	strh	r2, [r3, #20]
	GPIOE->ODR ^= GPIO_Pin_11;
 8001e60:	8a9a      	ldrh	r2, [r3, #20]
 8001e62:	b292      	uxth	r2, r2
 8001e64:	f482 6200 	eor.w	r2, r2, #2048	; 0x800
 8001e68:	829a      	strh	r2, [r3, #20]
	GPIOE->ODR ^= GPIO_Pin_13;
 8001e6a:	8a9a      	ldrh	r2, [r3, #20]
 8001e6c:	b292      	uxth	r2, r2
 8001e6e:	f482 5200 	eor.w	r2, r2, #8192	; 0x2000
 8001e72:	829a      	strh	r2, [r3, #20]
	GPIOE->ODR ^= GPIO_Pin_15;
 8001e74:	8a9a      	ldrh	r2, [r3, #20]
 8001e76:	b292      	uxth	r2, r2
 8001e78:	f482 4200 	eor.w	r2, r2, #32768	; 0x8000
 8001e7c:	829a      	strh	r2, [r3, #20]
 8001e7e:	4770      	bx	lr
 8001e80:	48001000 	.word	0x48001000

08001e84 <LED_TOGGLE_ALL>:
}

void LED_TOGGLE_ALL(void)
{
	if(GPIOE->ODR & GPIO_Pin_9)
 8001e84:	4b2e      	ldr	r3, [pc, #184]	; (8001f40 <LED_TOGGLE_ALL+0xbc>)
 8001e86:	8a9a      	ldrh	r2, [r3, #20]
 8001e88:	f402 7200 	and.w	r2, r2, #512	; 0x200
 8001e8c:	b292      	uxth	r2, r2
 8001e8e:	b34a      	cbz	r2, 8001ee4 <LED_TOGGLE_ALL+0x60>
	{
		GPIOE->ODR &= ~GPIO_Pin_9;
 8001e90:	8a9a      	ldrh	r2, [r3, #20]
 8001e92:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 8001e96:	0412      	lsls	r2, r2, #16
 8001e98:	0c12      	lsrs	r2, r2, #16
 8001e9a:	829a      	strh	r2, [r3, #20]
		GPIOE->ODR &= ~GPIO_Pin_11;
 8001e9c:	8a9a      	ldrh	r2, [r3, #20]
 8001e9e:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 8001ea2:	0412      	lsls	r2, r2, #16
 8001ea4:	0c12      	lsrs	r2, r2, #16
 8001ea6:	829a      	strh	r2, [r3, #20]
		GPIOE->ODR &= ~GPIO_Pin_13;
 8001ea8:	8a9a      	ldrh	r2, [r3, #20]
 8001eaa:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 8001eae:	0412      	lsls	r2, r2, #16
 8001eb0:	0c12      	lsrs	r2, r2, #16
 8001eb2:	829a      	strh	r2, [r3, #20]
		GPIOE->ODR &= ~GPIO_Pin_15;
 8001eb4:	8a9a      	ldrh	r2, [r3, #20]
 8001eb6:	0452      	lsls	r2, r2, #17
 8001eb8:	0c52      	lsrs	r2, r2, #17
 8001eba:	829a      	strh	r2, [r3, #20]
		GPIOE->ODR |= GPIO_Pin_8;
 8001ebc:	8a9a      	ldrh	r2, [r3, #20]
 8001ebe:	b292      	uxth	r2, r2
 8001ec0:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8001ec4:	829a      	strh	r2, [r3, #20]
		GPIOE->ODR |= GPIO_Pin_10;
 8001ec6:	8a9a      	ldrh	r2, [r3, #20]
 8001ec8:	b292      	uxth	r2, r2
 8001eca:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8001ece:	829a      	strh	r2, [r3, #20]
		GPIOE->ODR |= GPIO_Pin_12;
 8001ed0:	8a9a      	ldrh	r2, [r3, #20]
 8001ed2:	b292      	uxth	r2, r2
 8001ed4:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8001ed8:	829a      	strh	r2, [r3, #20]
		GPIOE->ODR |= GPIO_Pin_14;
 8001eda:	8a9a      	ldrh	r2, [r3, #20]
 8001edc:	b292      	uxth	r2, r2
 8001ede:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8001ee2:	e02b      	b.n	8001f3c <LED_TOGGLE_ALL+0xb8>
	}
	else
	{
		GPIOE->ODR |= GPIO_Pin_9;
 8001ee4:	8a9a      	ldrh	r2, [r3, #20]
 8001ee6:	b292      	uxth	r2, r2
 8001ee8:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8001eec:	829a      	strh	r2, [r3, #20]
		GPIOE->ODR |= GPIO_Pin_11;
 8001eee:	8a9a      	ldrh	r2, [r3, #20]
 8001ef0:	b292      	uxth	r2, r2
 8001ef2:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 8001ef6:	829a      	strh	r2, [r3, #20]
		GPIOE->ODR |= GPIO_Pin_13;
 8001ef8:	8a9a      	ldrh	r2, [r3, #20]
 8001efa:	b292      	uxth	r2, r2
 8001efc:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8001f00:	829a      	strh	r2, [r3, #20]
		GPIOE->ODR |= GPIO_Pin_15;
 8001f02:	8a9a      	ldrh	r2, [r3, #20]
 8001f04:	ea6f 4242 	mvn.w	r2, r2, lsl #17
 8001f08:	ea6f 4252 	mvn.w	r2, r2, lsr #17
 8001f0c:	829a      	strh	r2, [r3, #20]
		GPIOE->ODR &= ~GPIO_Pin_8;
 8001f0e:	8a9a      	ldrh	r2, [r3, #20]
 8001f10:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8001f14:	0412      	lsls	r2, r2, #16
 8001f16:	0c12      	lsrs	r2, r2, #16
 8001f18:	829a      	strh	r2, [r3, #20]
		GPIOE->ODR &= ~GPIO_Pin_10;
 8001f1a:	8a9a      	ldrh	r2, [r3, #20]
 8001f1c:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8001f20:	0412      	lsls	r2, r2, #16
 8001f22:	0c12      	lsrs	r2, r2, #16
 8001f24:	829a      	strh	r2, [r3, #20]
		GPIOE->ODR &= ~GPIO_Pin_12;
 8001f26:	8a9a      	ldrh	r2, [r3, #20]
 8001f28:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 8001f2c:	0412      	lsls	r2, r2, #16
 8001f2e:	0c12      	lsrs	r2, r2, #16
 8001f30:	829a      	strh	r2, [r3, #20]
		GPIOE->ODR &= ~GPIO_Pin_14;
 8001f32:	8a9a      	ldrh	r2, [r3, #20]
 8001f34:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 8001f38:	0412      	lsls	r2, r2, #16
 8001f3a:	0c12      	lsrs	r2, r2, #16
 8001f3c:	829a      	strh	r2, [r3, #20]
 8001f3e:	4770      	bx	lr
 8001f40:	48001000 	.word	0x48001000

08001f44 <vLedCtrlCoRoutine>:

void vLedCtrlCoRoutine( xCoRoutineHandle xHandle,
                         unsigned portBASE_TYPE uxIndex )
{
   // Co-routines must start with a call to crSTART().
   crSTART( xHandle );
 8001f44:	8e83      	ldrh	r3, [r0, #52]	; 0x34
	}
}

void vLedCtrlCoRoutine( xCoRoutineHandle xHandle,
                         unsigned portBASE_TYPE uxIndex )
{
 8001f46:	b510      	push	{r4, lr}
 8001f48:	4604      	mov	r4, r0
   // Co-routines must start with a call to crSTART().
   crSTART( xHandle );
 8001f4a:	b123      	cbz	r3, 8001f56 <vLedCtrlCoRoutine+0x12>
 8001f4c:	f240 2232 	movw	r2, #562	; 0x232
 8001f50:	4293      	cmp	r3, r2
 8001f52:	d117      	bne.n	8001f84 <vLedCtrlCoRoutine+0x40>
 8001f54:	e007      	b.n	8001f66 <vLedCtrlCoRoutine+0x22>

   for( ;; )
   {
	   // Delay for a fixed period.
	   crDELAY( xHandle, 200 );
 8001f56:	20c8      	movs	r0, #200	; 0xc8
 8001f58:	2100      	movs	r1, #0
 8001f5a:	f003 fd57 	bl	8005a0c <vCoRoutineAddToDelayedList>
 8001f5e:	f240 2332 	movw	r3, #562	; 0x232
 8001f62:	86a3      	strh	r3, [r4, #52]	; 0x34
 8001f64:	bd10      	pop	{r4, pc}

	   if(CtrlStates.copterStatus == IMU_READY_FLAG)
 8001f66:	4b08      	ldr	r3, [pc, #32]	; (8001f88 <vLedCtrlCoRoutine+0x44>)
 8001f68:	7a1b      	ldrb	r3, [r3, #8]
 8001f6a:	2b02      	cmp	r3, #2
 8001f6c:	d102      	bne.n	8001f74 <vLedCtrlCoRoutine+0x30>
	   {
		   LED_TOGGLE_READY();
 8001f6e:	f7ff ff71 	bl	8001e54 <LED_TOGGLE_READY>
 8001f72:	e7f0      	b.n	8001f56 <vLedCtrlCoRoutine+0x12>
	   }
	   else if (CtrlStates.copterStatus & ARMED_FLAG)
 8001f74:	07db      	lsls	r3, r3, #31
 8001f76:	d502      	bpl.n	8001f7e <vLedCtrlCoRoutine+0x3a>
	   {
		   LED_TOGGLE_ALL();
 8001f78:	f7ff ff84 	bl	8001e84 <LED_TOGGLE_ALL>
 8001f7c:	e7eb      	b.n	8001f56 <vLedCtrlCoRoutine+0x12>
	   }
	   else
	   {
		   LED_TOGGLE_NOT_READY();
 8001f7e:	f7ff ff51 	bl	8001e24 <LED_TOGGLE_NOT_READY>
 8001f82:	e7e8      	b.n	8001f56 <vLedCtrlCoRoutine+0x12>
 8001f84:	bd10      	pop	{r4, pc}
 8001f86:	bf00      	nop
 8001f88:	20002c1c 	.word	0x20002c1c

08001f8c <vApplicationMallocFailedHook>:




void vApplicationMallocFailedHook( void )
{
 8001f8c:	e7fe      	b.n	8001f8c <vApplicationMallocFailedHook>

08001f8e <vApplicationStackOverflowHook>:
	for( ;; );
}
/*-----------------------------------------------------------*/

void vApplicationStackOverflowHook( xTaskHandle *pxTask, signed char *pcTaskName )
{
 8001f8e:	e7fe      	b.n	8001f8e <vApplicationStackOverflowHook>

08001f90 <vApplicationIdleHook>:
{

	/* This function is called on each cycle of the idle task.  In this case it
	does nothing useful, other than report the amout of FreeRTOS heap that
	remains unallocated. */
	vCoRoutineSchedule();
 8001f90:	f003 bd5a 	b.w	8005a48 <vCoRoutineSchedule>

08001f94 <vApplicationTickHook>:
}


void vApplicationTickHook( void )
{
 8001f94:	4770      	bx	lr
 8001f96:	bf00      	nop

08001f98 <printchar>:

static void printchar(char **str, int c)
{
    //extern int putchar(int c);

    if (str) {
 8001f98:	b128      	cbz	r0, 8001fa6 <printchar+0xe>
        **str = c;
 8001f9a:	6803      	ldr	r3, [r0, #0]
 8001f9c:	7019      	strb	r1, [r3, #0]
        ++(*str);
 8001f9e:	6803      	ldr	r3, [r0, #0]
 8001fa0:	3301      	adds	r3, #1
 8001fa2:	6003      	str	r3, [r0, #0]
 8001fa4:	4770      	bx	lr
    }
    else (void)putchar(c);
 8001fa6:	b2c8      	uxtb	r0, r1
 8001fa8:	f000 be02 	b.w	8002bb0 <Usart2Put>

08001fac <prints>:

#define PAD_RIGHT 1
#define PAD_ZERO 2

static int prints(char **out, const char *string, int width, int pad)
{
 8001fac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    register int pc = 0, padchar = ' ';

    if (width > 0) {
 8001fb0:	1e14      	subs	r4, r2, #0

#define PAD_RIGHT 1
#define PAD_ZERO 2

static int prints(char **out, const char *string, int width, int pad)
{
 8001fb2:	4607      	mov	r7, r0
 8001fb4:	4688      	mov	r8, r1
    register int pc = 0, padchar = ' ';

    if (width > 0) {
 8001fb6:	dc03      	bgt.n	8001fc0 <prints+0x14>
#define PAD_RIGHT 1
#define PAD_ZERO 2

static int prints(char **out, const char *string, int width, int pad)
{
    register int pc = 0, padchar = ' ';
 8001fb8:	2620      	movs	r6, #32
 8001fba:	e010      	b.n	8001fde <prints+0x32>

    if (width > 0) {
        register int len = 0;
        register const char *ptr;
        for (ptr = string; *ptr; ++ptr) ++len;
 8001fbc:	3201      	adds	r2, #1
 8001fbe:	e000      	b.n	8001fc2 <prints+0x16>

static int prints(char **out, const char *string, int width, int pad)
{
    register int pc = 0, padchar = ' ';

    if (width > 0) {
 8001fc0:	2200      	movs	r2, #0
        register int len = 0;
        register const char *ptr;
        for (ptr = string; *ptr; ++ptr) ++len;
 8001fc2:	f818 1002 	ldrb.w	r1, [r8, r2]
 8001fc6:	2900      	cmp	r1, #0
 8001fc8:	d1f8      	bne.n	8001fbc <prints+0x10>
        if (len >= width) width = 0;
 8001fca:	42a2      	cmp	r2, r4
        else width -= len;
 8001fcc:	bfb4      	ite	lt
 8001fce:	ebc2 0404 	rsblt	r4, r2, r4

    if (width > 0) {
        register int len = 0;
        register const char *ptr;
        for (ptr = string; *ptr; ++ptr) ++len;
        if (len >= width) width = 0;
 8001fd2:	460c      	movge	r4, r1
        else width -= len;
        if (pad & PAD_ZERO) padchar = '0';
 8001fd4:	f013 0f02 	tst.w	r3, #2
 8001fd8:	bf0c      	ite	eq
 8001fda:	2620      	moveq	r6, #32
 8001fdc:	2630      	movne	r6, #48	; 0x30
    }
    if (!(pad & PAD_RIGHT)) {
 8001fde:	07db      	lsls	r3, r3, #31
 8001fe0:	d40c      	bmi.n	8001ffc <prints+0x50>
 8001fe2:	4625      	mov	r5, r4
 8001fe4:	e004      	b.n	8001ff0 <prints+0x44>
        for ( ; width > 0; --width) {
            printchar (out, padchar);
 8001fe6:	4638      	mov	r0, r7
 8001fe8:	4631      	mov	r1, r6
 8001fea:	f7ff ffd5 	bl	8001f98 <printchar>
        if (len >= width) width = 0;
        else width -= len;
        if (pad & PAD_ZERO) padchar = '0';
    }
    if (!(pad & PAD_RIGHT)) {
        for ( ; width > 0; --width) {
 8001fee:	3d01      	subs	r5, #1
 8001ff0:	2d00      	cmp	r5, #0
 8001ff2:	dcf8      	bgt.n	8001fe6 <prints+0x3a>
}

#define PAD_RIGHT 1
#define PAD_ZERO 2

static int prints(char **out, const char *string, int width, int pad)
 8001ff4:	ea24 75e4 	bic.w	r5, r4, r4, asr #31
 8001ff8:	1b64      	subs	r4, r4, r5
 8001ffa:	e000      	b.n	8001ffe <prints+0x52>
{
    register int pc = 0, padchar = ' ';
 8001ffc:	2500      	movs	r5, #0
}

#define PAD_RIGHT 1
#define PAD_ZERO 2

static int prints(char **out, const char *string, int width, int pad)
 8001ffe:	ebc5 0808 	rsb	r8, r5, r8
 8002002:	e003      	b.n	800200c <prints+0x60>
            printchar (out, padchar);
            ++pc;
        }
    }
    for ( ; *string ; ++string) {
        printchar (out, *string);
 8002004:	4638      	mov	r0, r7
 8002006:	f7ff ffc7 	bl	8001f98 <printchar>
        ++pc;
 800200a:	3501      	adds	r5, #1
        for ( ; width > 0; --width) {
            printchar (out, padchar);
            ++pc;
        }
    }
    for ( ; *string ; ++string) {
 800200c:	f818 1005 	ldrb.w	r1, [r8, r5]
 8002010:	2900      	cmp	r1, #0
 8002012:	d1f7      	bne.n	8002004 <prints+0x58>
 8002014:	46a0      	mov	r8, r4
 8002016:	e005      	b.n	8002024 <prints+0x78>
        printchar (out, *string);
        ++pc;
    }
    for ( ; width > 0; --width) {
        printchar (out, padchar);
 8002018:	4638      	mov	r0, r7
 800201a:	4631      	mov	r1, r6
 800201c:	f7ff ffbc 	bl	8001f98 <printchar>
    }
    for ( ; *string ; ++string) {
        printchar (out, *string);
        ++pc;
    }
    for ( ; width > 0; --width) {
 8002020:	f108 38ff 	add.w	r8, r8, #4294967295
 8002024:	f1b8 0f00 	cmp.w	r8, #0
 8002028:	dcf6      	bgt.n	8002018 <prints+0x6c>
        printchar (out, padchar);
        ++pc;
    }

    return pc;
}
 800202a:	2c00      	cmp	r4, #0
 800202c:	bfac      	ite	ge
 800202e:	1928      	addge	r0, r5, r4
 8002030:	1c28      	addlt	r0, r5, #0
 8002032:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08002036 <printi>:

/* the following should be enough for 32 bit int */
#define PRINT_BUF_LEN 12

static int printi(char **out, int i, int b, int sg, int width, int pad, int letbase)
{
 8002036:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 800203a:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 800203c:	4681      	mov	r9, r0
 800203e:	f8dd 8034 	ldr.w	r8, [sp, #52]	; 0x34
    char print_buf[PRINT_BUF_LEN];
    register char *s;
    register int t, neg = 0, pc = 0;
    register unsigned int u = i;
 8002042:	460c      	mov	r4, r1

    if (i == 0) {
 8002044:	b951      	cbnz	r1, 800205c <printi+0x26>
        print_buf[0] = '0';
 8002046:	2330      	movs	r3, #48	; 0x30
 8002048:	f88d 3004 	strb.w	r3, [sp, #4]
        print_buf[1] = '\0';
 800204c:	f88d 1005 	strb.w	r1, [sp, #5]
        return prints (out, print_buf, width, pad);
 8002050:	4632      	mov	r2, r6
 8002052:	a901      	add	r1, sp, #4
 8002054:	4643      	mov	r3, r8
 8002056:	f7ff ffa9 	bl	8001fac <prints>
 800205a:	e037      	b.n	80020cc <printi+0x96>
    }

    if (sg && b == 10 && i < 0) {
 800205c:	b133      	cbz	r3, 800206c <printi+0x36>
 800205e:	2a0a      	cmp	r2, #10
 8002060:	d104      	bne.n	800206c <printi+0x36>
 8002062:	2900      	cmp	r1, #0
 8002064:	da02      	bge.n	800206c <printi+0x36>
        neg = 1;
        u = -i;
 8002066:	424c      	negs	r4, r1
        print_buf[1] = '\0';
        return prints (out, print_buf, width, pad);
    }

    if (sg && b == 10 && i < 0) {
        neg = 1;
 8002068:	2701      	movs	r7, #1
 800206a:	e000      	b.n	800206e <printi+0x38>

static int printi(char **out, int i, int b, int sg, int width, int pad, int letbase)
{
    char print_buf[PRINT_BUF_LEN];
    register char *s;
    register int t, neg = 0, pc = 0;
 800206c:	2700      	movs	r7, #0
        neg = 1;
        u = -i;
    }

    s = print_buf + PRINT_BUF_LEN-1;
    *s = '\0';
 800206e:	2300      	movs	r3, #0
 8002070:	ad04      	add	r5, sp, #16
 8002072:	f805 3d01 	strb.w	r3, [r5, #-1]!

    while (u) {
        t = u % b;
        if( t >= 10 )
            t += letbase - '0' - 10;
 8002076:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8002078:	f1a3 013a 	sub.w	r1, r3, #58	; 0x3a
    }

    s = print_buf + PRINT_BUF_LEN-1;
    *s = '\0';

    while (u) {
 800207c:	e00a      	b.n	8002094 <printi+0x5e>
        t = u % b;
 800207e:	fbb4 f3f2 	udiv	r3, r4, r2
 8002082:	fb02 4413 	mls	r4, r2, r3, r4
        if( t >= 10 )
 8002086:	2c09      	cmp	r4, #9
            t += letbase - '0' - 10;
 8002088:	bfc8      	it	gt
 800208a:	1864      	addgt	r4, r4, r1
        *--s = t + '0';
 800208c:	3430      	adds	r4, #48	; 0x30
 800208e:	f805 4d01 	strb.w	r4, [r5, #-1]!
        u /= b;
 8002092:	461c      	mov	r4, r3
 8002094:	46aa      	mov	sl, r5
    }

    s = print_buf + PRINT_BUF_LEN-1;
    *s = '\0';

    while (u) {
 8002096:	2c00      	cmp	r4, #0
 8002098:	d1f1      	bne.n	800207e <printi+0x48>
            t += letbase - '0' - 10;
        *--s = t + '0';
        u /= b;
    }

    if (neg) {
 800209a:	b187      	cbz	r7, 80020be <printi+0x88>
        if( width && (pad & PAD_ZERO) ) {
 800209c:	b14e      	cbz	r6, 80020b2 <printi+0x7c>
 800209e:	f018 0f02 	tst.w	r8, #2
 80020a2:	d006      	beq.n	80020b2 <printi+0x7c>
            printchar (out, '-');
 80020a4:	4648      	mov	r0, r9
 80020a6:	212d      	movs	r1, #45	; 0x2d
 80020a8:	f7ff ff76 	bl	8001f98 <printchar>
            ++pc;
            --width;
 80020ac:	3e01      	subs	r6, #1
    }

    if (neg) {
        if( width && (pad & PAD_ZERO) ) {
            printchar (out, '-');
            ++pc;
 80020ae:	2701      	movs	r7, #1
            --width;
 80020b0:	e005      	b.n	80020be <printi+0x88>
        }
        else {
            *--s = '-';
 80020b2:	232d      	movs	r3, #45	; 0x2d
 80020b4:	f105 3aff 	add.w	sl, r5, #4294967295
 80020b8:	f805 3c01 	strb.w	r3, [r5, #-1]

static int printi(char **out, int i, int b, int sg, int width, int pad, int letbase)
{
    char print_buf[PRINT_BUF_LEN];
    register char *s;
    register int t, neg = 0, pc = 0;
 80020bc:	2700      	movs	r7, #0
        else {
            *--s = '-';
        }
    }

    return pc + prints (out, s, width, pad);
 80020be:	4648      	mov	r0, r9
 80020c0:	4651      	mov	r1, sl
 80020c2:	4632      	mov	r2, r6
 80020c4:	4643      	mov	r3, r8
 80020c6:	f7ff ff71 	bl	8001fac <prints>
 80020ca:	1838      	adds	r0, r7, r0
}
 80020cc:	b004      	add	sp, #16
 80020ce:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

080020d2 <print>:

static int print( char **out, const char *format, va_list args )
{
 80020d2:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    register int width, pad;
    register int pc = 0;
 80020d6:	2400      	movs	r4, #0

    return pc + prints (out, s, width, pad);
}

static int print( char **out, const char *format, va_list args )
{
 80020d8:	b088      	sub	sp, #32
 80020da:	4606      	mov	r6, r0
 80020dc:	460d      	mov	r5, r1
 80020de:	9205      	str	r2, [sp, #20]
            if (*format == '%') goto out;
            if (*format == '-') {
                ++format;
                pad = PAD_RIGHT;
            }
            while (*format == '0') {
 80020e0:	4627      	mov	r7, r4
                width *= 10;
                width += *format - '0';
            }
            if( *format == 's' ) {
                register char *s = (char *)va_arg( args, int );
                pc += prints (out, s?s:"(null)", width, pad);
 80020e2:	f8df 811c 	ldr.w	r8, [pc, #284]	; 8002200 <print+0x12e>
{
    register int width, pad;
    register int pc = 0;
    char scr[2];

    for (; *format != 0; ++format) {
 80020e6:	e07f      	b.n	80021e8 <print+0x116>
        if (*format == '%') {
 80020e8:	2b25      	cmp	r3, #37	; 0x25
 80020ea:	d177      	bne.n	80021dc <print+0x10a>
            ++format;
            width = pad = 0;
            if (*format == '\0') break;
 80020ec:	786b      	ldrb	r3, [r5, #1]
    register int pc = 0;
    char scr[2];

    for (; *format != 0; ++format) {
        if (*format == '%') {
            ++format;
 80020ee:	1c6a      	adds	r2, r5, #1
            width = pad = 0;
            if (*format == '\0') break;
 80020f0:	b913      	cbnz	r3, 80020f8 <print+0x26>
        out:
            printchar (out, *format);
            ++pc;
        }
    }
    if (out) **out = '\0';
 80020f2:	2e00      	cmp	r6, #0
 80020f4:	d17d      	bne.n	80021f2 <print+0x120>
 80020f6:	e07f      	b.n	80021f8 <print+0x126>
    for (; *format != 0; ++format) {
        if (*format == '%') {
            ++format;
            width = pad = 0;
            if (*format == '\0') break;
            if (*format == '%') goto out;
 80020f8:	2b25      	cmp	r3, #37	; 0x25
 80020fa:	d06e      	beq.n	80021da <print+0x108>
            if (*format == '-') {
 80020fc:	2b2d      	cmp	r3, #45	; 0x2d
 80020fe:	d102      	bne.n	8002106 <print+0x34>
                ++format;
 8002100:	1caa      	adds	r2, r5, #2
                pad = PAD_RIGHT;
 8002102:	2301      	movs	r3, #1
 8002104:	e003      	b.n	800210e <print+0x3c>
    char scr[2];

    for (; *format != 0; ++format) {
        if (*format == '%') {
            ++format;
            width = pad = 0;
 8002106:	2300      	movs	r3, #0
 8002108:	e001      	b.n	800210e <print+0x3c>
                ++format;
                pad = PAD_RIGHT;
            }
            while (*format == '0') {
                ++format;
                pad |= PAD_ZERO;
 800210a:	f043 0302 	orr.w	r3, r3, #2
 800210e:	4611      	mov	r1, r2
            if (*format == '%') goto out;
            if (*format == '-') {
                ++format;
                pad = PAD_RIGHT;
            }
            while (*format == '0') {
 8002110:	7808      	ldrb	r0, [r1, #0]
 8002112:	3201      	adds	r2, #1
 8002114:	2830      	cmp	r0, #48	; 0x30
 8002116:	d0f8      	beq.n	800210a <print+0x38>
 8002118:	468c      	mov	ip, r1
 800211a:	2200      	movs	r2, #0
                ++format;
                pad |= PAD_ZERO;
            }
            for ( ; *format >= '0' && *format <= '9'; ++format) {
                width *= 10;
 800211c:	f04f 0a0a 	mov.w	sl, #10
 8002120:	e001      	b.n	8002126 <print+0x54>
                width += *format - '0';
 8002122:	fb0a 0202 	mla	r2, sl, r2, r0
 8002126:	4665      	mov	r5, ip
            }
            while (*format == '0') {
                ++format;
                pad |= PAD_ZERO;
            }
            for ( ; *format >= '0' && *format <= '9'; ++format) {
 8002128:	7829      	ldrb	r1, [r5, #0]
 800212a:	f10c 0c01 	add.w	ip, ip, #1
 800212e:	f1a1 0030 	sub.w	r0, r1, #48	; 0x30
 8002132:	fa5f f980 	uxtb.w	r9, r0
 8002136:	f1b9 0f09 	cmp.w	r9, #9
 800213a:	d9f2      	bls.n	8002122 <print+0x50>
                width *= 10;
                width += *format - '0';
            }
            if( *format == 's' ) {
 800213c:	2973      	cmp	r1, #115	; 0x73
 800213e:	d108      	bne.n	8002152 <print+0x80>
                register char *s = (char *)va_arg( args, int );
 8002140:	9905      	ldr	r1, [sp, #20]
 8002142:	1d08      	adds	r0, r1, #4
 8002144:	6809      	ldr	r1, [r1, #0]
 8002146:	9005      	str	r0, [sp, #20]
                pc += prints (out, s?s:"(null)", width, pad);
 8002148:	2900      	cmp	r1, #0
 800214a:	bf08      	it	eq
 800214c:	4641      	moveq	r1, r8
 800214e:	4630      	mov	r0, r6
 8002150:	e040      	b.n	80021d4 <print+0x102>
                continue;
            }
            if( *format == 'd' ) {
 8002152:	2964      	cmp	r1, #100	; 0x64
 8002154:	d10e      	bne.n	8002174 <print+0xa2>
                pc += printi (out, va_arg( args, int ), 10, 1, width, pad, 'a');
 8002156:	e88d 000c 	stmia.w	sp, {r2, r3}
 800215a:	9905      	ldr	r1, [sp, #20]
 800215c:	2361      	movs	r3, #97	; 0x61
 800215e:	9302      	str	r3, [sp, #8]
 8002160:	1d08      	adds	r0, r1, #4
 8002162:	6809      	ldr	r1, [r1, #0]
 8002164:	9005      	str	r0, [sp, #20]
 8002166:	220a      	movs	r2, #10
 8002168:	4630      	mov	r0, r6
 800216a:	2301      	movs	r3, #1
 800216c:	f7ff ff63 	bl	8002036 <printi>
 8002170:	1824      	adds	r4, r4, r0
                continue;
 8002172:	e038      	b.n	80021e6 <print+0x114>
            }
            if( *format == 'x' ) {
 8002174:	2978      	cmp	r1, #120	; 0x78
 8002176:	d106      	bne.n	8002186 <print+0xb4>
                pc += printi (out, va_arg( args, int ), 16, 0, width, pad, 'a');
 8002178:	9905      	ldr	r1, [sp, #20]
 800217a:	e88d 000c 	stmia.w	sp, {r2, r3}
 800217e:	1d08      	adds	r0, r1, #4
 8002180:	9005      	str	r0, [sp, #20]
 8002182:	2361      	movs	r3, #97	; 0x61
 8002184:	e007      	b.n	8002196 <print+0xc4>
                continue;
            }
            if( *format == 'X' ) {
 8002186:	2958      	cmp	r1, #88	; 0x58
 8002188:	d10a      	bne.n	80021a0 <print+0xce>
                pc += printi (out, va_arg( args, int ), 16, 0, width, pad, 'A');
 800218a:	9905      	ldr	r1, [sp, #20]
 800218c:	e88d 000c 	stmia.w	sp, {r2, r3}
 8002190:	1d08      	adds	r0, r1, #4
 8002192:	9005      	str	r0, [sp, #20]
 8002194:	2341      	movs	r3, #65	; 0x41
 8002196:	9302      	str	r3, [sp, #8]
 8002198:	4630      	mov	r0, r6
 800219a:	6809      	ldr	r1, [r1, #0]
 800219c:	2210      	movs	r2, #16
 800219e:	e00b      	b.n	80021b8 <print+0xe6>
                continue;
            }
            if( *format == 'u' ) {
 80021a0:	2975      	cmp	r1, #117	; 0x75
 80021a2:	d10b      	bne.n	80021bc <print+0xea>
                pc += printi (out, va_arg( args, int ), 10, 0, width, pad, 'a');
 80021a4:	e88d 000c 	stmia.w	sp, {r2, r3}
 80021a8:	9905      	ldr	r1, [sp, #20]
 80021aa:	2361      	movs	r3, #97	; 0x61
 80021ac:	9302      	str	r3, [sp, #8]
 80021ae:	1d08      	adds	r0, r1, #4
 80021b0:	6809      	ldr	r1, [r1, #0]
 80021b2:	9005      	str	r0, [sp, #20]
 80021b4:	220a      	movs	r2, #10
 80021b6:	4630      	mov	r0, r6
 80021b8:	2300      	movs	r3, #0
 80021ba:	e7d7      	b.n	800216c <print+0x9a>
                continue;
            }
            if( *format == 'c' ) {
 80021bc:	2963      	cmp	r1, #99	; 0x63
 80021be:	d112      	bne.n	80021e6 <print+0x114>
                /* char are converted to int then pushed on the stack */
                scr[0] = (char)va_arg( args, int );
 80021c0:	9905      	ldr	r1, [sp, #20]
                scr[1] = '\0';
 80021c2:	f88d 701d 	strb.w	r7, [sp, #29]
                pc += printi (out, va_arg( args, int ), 10, 0, width, pad, 'a');
                continue;
            }
            if( *format == 'c' ) {
                /* char are converted to int then pushed on the stack */
                scr[0] = (char)va_arg( args, int );
 80021c6:	1d08      	adds	r0, r1, #4
 80021c8:	6809      	ldr	r1, [r1, #0]
 80021ca:	9005      	str	r0, [sp, #20]
 80021cc:	f88d 101c 	strb.w	r1, [sp, #28]
                scr[1] = '\0';
                pc += prints (out, scr, width, pad);
 80021d0:	4630      	mov	r0, r6
 80021d2:	a907      	add	r1, sp, #28
 80021d4:	f7ff feea 	bl	8001fac <prints>
 80021d8:	e7ca      	b.n	8002170 <print+0x9e>
    register int pc = 0;
    char scr[2];

    for (; *format != 0; ++format) {
        if (*format == '%') {
            ++format;
 80021da:	4615      	mov	r5, r2
                continue;
            }
        }
        else {
        out:
            printchar (out, *format);
 80021dc:	4630      	mov	r0, r6
 80021de:	7829      	ldrb	r1, [r5, #0]
 80021e0:	f7ff feda 	bl	8001f98 <printchar>
            ++pc;
 80021e4:	3401      	adds	r4, #1
{
    register int width, pad;
    register int pc = 0;
    char scr[2];

    for (; *format != 0; ++format) {
 80021e6:	3501      	adds	r5, #1
 80021e8:	782b      	ldrb	r3, [r5, #0]
 80021ea:	2b00      	cmp	r3, #0
 80021ec:	f47f af7c 	bne.w	80020e8 <print+0x16>
 80021f0:	e77f      	b.n	80020f2 <print+0x20>
        out:
            printchar (out, *format);
            ++pc;
        }
    }
    if (out) **out = '\0';
 80021f2:	6833      	ldr	r3, [r6, #0]
 80021f4:	2200      	movs	r2, #0
 80021f6:	701a      	strb	r2, [r3, #0]
    va_end( args );
    return pc;
}
 80021f8:	4620      	mov	r0, r4
 80021fa:	b008      	add	sp, #32
 80021fc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8002200:	0800a9fb 	.word	0x0800a9fb

08002204 <printf>:

int printf(const char *format, ...)
{
 8002204:	b40f      	push	{r0, r1, r2, r3}
 8002206:	b507      	push	{r0, r1, r2, lr}
 8002208:	aa04      	add	r2, sp, #16
 800220a:	f852 1b04 	ldr.w	r1, [r2], #4
        va_list args;

        va_start( args, format );
        return print( 0, format, args );
 800220e:	2000      	movs	r0, #0

int printf(const char *format, ...)
{
        va_list args;

        va_start( args, format );
 8002210:	9201      	str	r2, [sp, #4]
        return print( 0, format, args );
 8002212:	f7ff ff5e 	bl	80020d2 <print>
}
 8002216:	e8bd 400e 	ldmia.w	sp!, {r1, r2, r3, lr}
 800221a:	b004      	add	sp, #16
 800221c:	4770      	bx	lr

0800221e <sprintf>:

int sprintf(char *out, const char *format, ...)
{
 800221e:	b40e      	push	{r1, r2, r3}
 8002220:	b50f      	push	{r0, r1, r2, r3, lr}
 8002222:	aa05      	add	r2, sp, #20
 8002224:	f852 1b04 	ldr.w	r1, [r2], #4
 8002228:	9001      	str	r0, [sp, #4]
        va_list args;

        va_start( args, format );
        return print( &out, format, args );
 800222a:	a801      	add	r0, sp, #4

int sprintf(char *out, const char *format, ...)
{
        va_list args;

        va_start( args, format );
 800222c:	9203      	str	r2, [sp, #12]
        return print( &out, format, args );
 800222e:	f7ff ff50 	bl	80020d2 <print>
}
 8002232:	b004      	add	sp, #16
 8002234:	f85d eb04 	ldr.w	lr, [sp], #4
 8002238:	b003      	add	sp, #12
 800223a:	4770      	bx	lr

0800223c <snprintf>:


int snprintf( char *buf, unsigned int count, const char *format, ... )
{
 800223c:	b40c      	push	{r2, r3}
 800223e:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 8002240:	aa06      	add	r2, sp, #24
 8002242:	f852 1b04 	ldr.w	r1, [r2], #4
 8002246:	9001      	str	r0, [sp, #4]
        va_list args;

        ( void ) count;

        va_start( args, format );
        return print( &buf, format, args );
 8002248:	a801      	add	r0, sp, #4
{
        va_list args;

        ( void ) count;

        va_start( args, format );
 800224a:	9203      	str	r2, [sp, #12]
        return print( &buf, format, args );
 800224c:	f7ff ff41 	bl	80020d2 <print>
}
 8002250:	b005      	add	sp, #20
 8002252:	f85d eb04 	ldr.w	lr, [sp], #4
 8002256:	b002      	add	sp, #8
 8002258:	4770      	bx	lr
 800225a:	bf00      	nop

0800225c <CalcRXValues>:
#include <filter_Lib.h>
#include <remote_control.h>
#include <vertibot_settings.h>

void CalcRXValues(unsigned char *msgPointer, int16_t adjValue)
{
 800225c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	static intFilter pitchFiltered = {0,0};
	static intFilter yawFiltered = {0,0};
	static int16_t currentYaw = 0;

	/*Reset the Watchdog Timer value*/
	CtrlStates.watchDogTimVal = 0;
 800225e:	4d48      	ldr	r5, [pc, #288]	; (8002380 <CalcRXValues+0x124>)
 8002260:	2300      	movs	r3, #0
 8002262:	726b      	strb	r3, [r5, #9]

	currentYaw = ((uint8_t)msgPointer[4]-adjValue);
 8002264:	7903      	ldrb	r3, [r0, #4]
 8002266:	4c47      	ldr	r4, [pc, #284]	; (8002384 <CalcRXValues+0x128>)
#include <filter_Lib.h>
#include <remote_control.h>
#include <vertibot_settings.h>

void CalcRXValues(unsigned char *msgPointer, int16_t adjValue)
{
 8002268:	4607      	mov	r7, r0
	/*Reset the Watchdog Timer value*/
	CtrlStates.watchDogTimVal = 0;

	currentYaw = ((uint8_t)msgPointer[4]-adjValue);

	update_intFilter(&gasFiltered, 1, (((uint8_t)msgPointer[5]-adjValue)*7.5f)+60);
 800226a:	7940      	ldrb	r0, [r0, #5]
	static int16_t currentYaw = 0;

	/*Reset the Watchdog Timer value*/
	CtrlStates.watchDogTimVal = 0;

	currentYaw = ((uint8_t)msgPointer[4]-adjValue);
 800226c:	1a5b      	subs	r3, r3, r1
 800226e:	8023      	strh	r3, [r4, #0]

	update_intFilter(&gasFiltered, 1, (((uint8_t)msgPointer[5]-adjValue)*7.5f)+60);
 8002270:	1a40      	subs	r0, r0, r1
#include <filter_Lib.h>
#include <remote_control.h>
#include <vertibot_settings.h>

void CalcRXValues(unsigned char *msgPointer, int16_t adjValue)
{
 8002272:	460e      	mov	r6, r1
	/*Reset the Watchdog Timer value*/
	CtrlStates.watchDogTimVal = 0;

	currentYaw = ((uint8_t)msgPointer[4]-adjValue);

	update_intFilter(&gasFiltered, 1, (((uint8_t)msgPointer[5]-adjValue)*7.5f)+60);
 8002274:	f005 faca 	bl	800780c <__aeabi_i2f>
 8002278:	4943      	ldr	r1, [pc, #268]	; (8002388 <CalcRXValues+0x12c>)
 800227a:	f005 fb1b 	bl	80078b4 <__aeabi_fmul>
 800227e:	4943      	ldr	r1, [pc, #268]	; (800238c <CalcRXValues+0x130>)
 8002280:	f005 fa10 	bl	80076a4 <__addsf3>
 8002284:	f005 fcdc 	bl	8007c40 <__aeabi_f2iz>
 8002288:	2101      	movs	r1, #1
 800228a:	4602      	mov	r2, r0
 800228c:	1d20      	adds	r0, r4, #4
 800228e:	f7ff fb8d 	bl	80019ac <update_intFilter>
	update_intFilter(&pitchFiltered, 1, ((uint8_t)msgPointer[3]-adjValue)*2.0f);
 8002292:	78f8      	ldrb	r0, [r7, #3]
 8002294:	1b80      	subs	r0, r0, r6
 8002296:	f005 fab9 	bl	800780c <__aeabi_i2f>
 800229a:	4601      	mov	r1, r0
 800229c:	f005 fa02 	bl	80076a4 <__addsf3>
 80022a0:	f005 fcce 	bl	8007c40 <__aeabi_f2iz>
 80022a4:	2101      	movs	r1, #1
 80022a6:	4602      	mov	r2, r0
 80022a8:	f104 000c 	add.w	r0, r4, #12
 80022ac:	f7ff fb7e 	bl	80019ac <update_intFilter>
	update_intFilter(&rollFiltered, 1, ((uint8_t)msgPointer[2]-adjValue)*2.0f);
 80022b0:	78b8      	ldrb	r0, [r7, #2]
 80022b2:	1b80      	subs	r0, r0, r6
 80022b4:	f005 faaa 	bl	800780c <__aeabi_i2f>
 80022b8:	4601      	mov	r1, r0
 80022ba:	f005 f9f3 	bl	80076a4 <__addsf3>
 80022be:	f005 fcbf 	bl	8007c40 <__aeabi_f2iz>
 80022c2:	2101      	movs	r1, #1
 80022c4:	4602      	mov	r2, r0
 80022c6:	f104 0014 	add.w	r0, r4, #20
 80022ca:	f7ff fb6f 	bl	80019ac <update_intFilter>
	update_intFilter(&yawFiltered, 1, currentYaw*0.3f);
 80022ce:	f9b4 0000 	ldrsh.w	r0, [r4]
 80022d2:	f005 fa9b 	bl	800780c <__aeabi_i2f>
 80022d6:	492e      	ldr	r1, [pc, #184]	; (8002390 <CalcRXValues+0x134>)
 80022d8:	f005 faec 	bl	80078b4 <__aeabi_fmul>
 80022dc:	f005 fcb0 	bl	8007c40 <__aeabi_f2iz>
 80022e0:	2101      	movs	r1, #1
 80022e2:	4602      	mov	r2, r0
 80022e4:	f104 001c 	add.w	r0, r4, #28
 80022e8:	f7ff fb60 	bl	80019ac <update_intFilter>

	//CtrlStates.gas = gasFiltered.filtered;
	//CtrlStates.roll = rollFiltered.filtered;
	CtrlStates.pitch = pitchFiltered.filtered;
 80022ec:	6920      	ldr	r0, [r4, #16]
 80022ee:	f005 fa8d 	bl	800780c <__aeabi_i2f>

	/* integrating the yaw value */
	if(CtrlStates.copterStatus & ARMED_FLAG)
 80022f2:	7a2b      	ldrb	r3, [r5, #8]
	update_intFilter(&rollFiltered, 1, ((uint8_t)msgPointer[2]-adjValue)*2.0f);
	update_intFilter(&yawFiltered, 1, currentYaw*0.3f);

	//CtrlStates.gas = gasFiltered.filtered;
	//CtrlStates.roll = rollFiltered.filtered;
	CtrlStates.pitch = pitchFiltered.filtered;
 80022f4:	4606      	mov	r6, r0

	/* integrating the yaw value */
	if(CtrlStates.copterStatus & ARMED_FLAG)
 80022f6:	07db      	lsls	r3, r3, #31
	update_intFilter(&rollFiltered, 1, ((uint8_t)msgPointer[2]-adjValue)*2.0f);
	update_intFilter(&yawFiltered, 1, currentYaw*0.3f);

	//CtrlStates.gas = gasFiltered.filtered;
	//CtrlStates.roll = rollFiltered.filtered;
	CtrlStates.pitch = pitchFiltered.filtered;
 80022f8:	6028      	str	r0, [r5, #0]

	/* integrating the yaw value */
	if(CtrlStates.copterStatus & ARMED_FLAG)
 80022fa:	d508      	bpl.n	800230e <CalcRXValues+0xb2>
	{
		CtrlStates.yaw -= yawFiltered.filtered;
 80022fc:	6a20      	ldr	r0, [r4, #32]
 80022fe:	f005 fa85 	bl	800780c <__aeabi_i2f>
 8002302:	4601      	mov	r1, r0
 8002304:	6868      	ldr	r0, [r5, #4]
 8002306:	f005 f9cb 	bl	80076a0 <__aeabi_fsub>
 800230a:	6068      	str	r0, [r5, #4]
 800230c:	e002      	b.n	8002314 <CalcRXValues+0xb8>
	}
	else
	{
		CtrlStates.yaw = XYZ.z;
 800230e:	4b21      	ldr	r3, [pc, #132]	; (8002394 <CalcRXValues+0x138>)
 8002310:	689b      	ldr	r3, [r3, #8]
 8002312:	606b      	str	r3, [r5, #4]
	//if(CtrlStates.roll > -ROLL_PITCH_TRSHLD && CtrlStates.roll < ROLL_PITCH_TRSHLD) CtrlStates.roll = 0;
	//if(CtrlStates.roll > MAX_ROLL) CtrlStates.roll = MAX_ROLL;
	//if(CtrlStates.roll < -MAX_ROLL) CtrlStates.roll = -MAX_ROLL;

    */
	if(CtrlStates.pitch > -ROLL_PITCH_TRSHLD && CtrlStates.pitch < ROLL_PITCH_TRSHLD) CtrlStates.pitch = 0;
 8002314:	4630      	mov	r0, r6
 8002316:	4920      	ldr	r1, [pc, #128]	; (8002398 <CalcRXValues+0x13c>)
 8002318:	f005 fc88 	bl	8007c2c <__aeabi_fcmpgt>
 800231c:	b138      	cbz	r0, 800232e <CalcRXValues+0xd2>
 800231e:	4630      	mov	r0, r6
 8002320:	491e      	ldr	r1, [pc, #120]	; (800239c <CalcRXValues+0x140>)
 8002322:	f005 fc65 	bl	8007bf0 <__aeabi_fcmplt>
 8002326:	b110      	cbz	r0, 800232e <CalcRXValues+0xd2>
 8002328:	4b15      	ldr	r3, [pc, #84]	; (8002380 <CalcRXValues+0x124>)
 800232a:	2200      	movs	r2, #0
 800232c:	601a      	str	r2, [r3, #0]
	if(CtrlStates.pitch > MAX_PITCH) CtrlStates.pitch = MAX_PITCH;
 800232e:	4d14      	ldr	r5, [pc, #80]	; (8002380 <CalcRXValues+0x124>)
 8002330:	4c1b      	ldr	r4, [pc, #108]	; (80023a0 <CalcRXValues+0x144>)
 8002332:	6828      	ldr	r0, [r5, #0]
 8002334:	4621      	mov	r1, r4
 8002336:	f005 fc79 	bl	8007c2c <__aeabi_fcmpgt>
 800233a:	b100      	cbz	r0, 800233e <CalcRXValues+0xe2>
 800233c:	602c      	str	r4, [r5, #0]
	if(CtrlStates.pitch < -MAX_PITCH) CtrlStates.pitch = -MAX_PITCH;
 800233e:	4c19      	ldr	r4, [pc, #100]	; (80023a4 <CalcRXValues+0x148>)
 8002340:	6828      	ldr	r0, [r5, #0]
 8002342:	4621      	mov	r1, r4
 8002344:	f005 fc54 	bl	8007bf0 <__aeabi_fcmplt>
 8002348:	b108      	cbz	r0, 800234e <CalcRXValues+0xf2>
 800234a:	4b0d      	ldr	r3, [pc, #52]	; (8002380 <CalcRXValues+0x124>)
 800234c:	601c      	str	r4, [r3, #0]

	/* The yaw value needs a special handling */
	if(CtrlStates.yaw > 180) CtrlStates.yaw -= 360;
 800234e:	4c0c      	ldr	r4, [pc, #48]	; (8002380 <CalcRXValues+0x124>)
 8002350:	4915      	ldr	r1, [pc, #84]	; (80023a8 <CalcRXValues+0x14c>)
 8002352:	6865      	ldr	r5, [r4, #4]
 8002354:	4628      	mov	r0, r5
 8002356:	f005 fc69 	bl	8007c2c <__aeabi_fcmpgt>
 800235a:	b120      	cbz	r0, 8002366 <CalcRXValues+0x10a>
 800235c:	4628      	mov	r0, r5
 800235e:	4913      	ldr	r1, [pc, #76]	; (80023ac <CalcRXValues+0x150>)
 8002360:	f005 f99e 	bl	80076a0 <__aeabi_fsub>
 8002364:	6060      	str	r0, [r4, #4]
	if(CtrlStates.yaw < -180) CtrlStates.yaw += 360;
 8002366:	6864      	ldr	r4, [r4, #4]
 8002368:	4911      	ldr	r1, [pc, #68]	; (80023b0 <CalcRXValues+0x154>)
 800236a:	4620      	mov	r0, r4
 800236c:	f005 fc40 	bl	8007bf0 <__aeabi_fcmplt>
 8002370:	b128      	cbz	r0, 800237e <CalcRXValues+0x122>
 8002372:	4620      	mov	r0, r4
 8002374:	490d      	ldr	r1, [pc, #52]	; (80023ac <CalcRXValues+0x150>)
 8002376:	f005 f995 	bl	80076a4 <__addsf3>
 800237a:	4b01      	ldr	r3, [pc, #4]	; (8002380 <CalcRXValues+0x124>)
 800237c:	6058      	str	r0, [r3, #4]
 800237e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002380:	20002c1c 	.word	0x20002c1c
 8002384:	20000190 	.word	0x20000190
 8002388:	40f00000 	.word	0x40f00000
 800238c:	42700000 	.word	0x42700000
 8002390:	3e99999a 	.word	0x3e99999a
 8002394:	20002bb0 	.word	0x20002bb0
 8002398:	c0400000 	.word	0xc0400000
 800239c:	40400000 	.word	0x40400000
 80023a0:	420c0000 	.word	0x420c0000
 80023a4:	c20c0000 	.word	0xc20c0000
 80023a8:	43340000 	.word	0x43340000
 80023ac:	43b40000 	.word	0x43b40000
 80023b0:	c3340000 	.word	0xc3340000

080023b4 <RCC_Configuration>:

//! Print Debugmessages
#define DEBUG 0

void RCC_Configuration(void)
{
 80023b4:	b508      	push	{r3, lr}
	/* Enable I2C1 periph */
	RCC_APB1PeriphClockCmd( RCC_APB1Periph_I2C1 |
 80023b6:	2101      	movs	r1, #1
 80023b8:	4808      	ldr	r0, [pc, #32]	; (80023dc <RCC_Configuration+0x28>)
 80023ba:	f001 ff6b 	bl	8004294 <RCC_APB1PeriphClockCmd>
							RCC_APB1Periph_USART3 |
							RCC_APB1Periph_TIM2 |
							RCC_APB1Periph_TIM3 |
							RCC_APB1Periph_TIM4, ENABLE);
	/* Enable the SPI periph */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1 |
 80023be:	2101      	movs	r1, #1
 80023c0:	f241 0001 	movw	r0, #4097	; 0x1001
 80023c4:	f001 ff5a 	bl	800427c <RCC_APB2PeriphClockCmd>
						   RCC_APB2Periph_SYSCFG, ENABLE);

	/* Enable Periph clock enable, SPI, GPIOs */
	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA |
 80023c8:	4805      	ldr	r0, [pc, #20]	; (80023e0 <RCC_Configuration+0x2c>)
 80023ca:	2101      	movs	r1, #1
 80023cc:	f001 ff4a 	bl	8004264 <RCC_AHBPeriphClockCmd>
						  RCC_AHBPeriph_GPIOE |
						  RCC_AHBPeriph_ADC12 |
						  RCC_AHBPeriph_DMA1, ENABLE);

	/* Configure the ADC clock */
	RCC_ADCCLKConfig(RCC_ADC12PLLCLK_Div2);
 80023d0:	f44f 7088 	mov.w	r0, #272	; 0x110
}
 80023d4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
						  RCC_AHBPeriph_GPIOE |
						  RCC_AHBPeriph_ADC12 |
						  RCC_AHBPeriph_DMA1, ENABLE);

	/* Configure the ADC clock */
	RCC_ADCCLKConfig(RCC_ADC12PLLCLK_Div2);
 80023d8:	f001 bed0 	b.w	800417c <RCC_ADCCLKConfig>
 80023dc:	00260007 	.word	0x00260007
 80023e0:	103e0001 	.word	0x103e0001

080023e4 <NVIC_Configuration>:




void NVIC_Configuration(void)
{
 80023e4:	b537      	push	{r0, r1, r2, r4, r5, lr}
	#ifdef  VECT_TAB_RAM
	  /* Set the Vector Table base location at 0x20000000 */
	  NVIC_SetVectorTable(NVIC_VectTab_RAM, 0x0);
	#else  /* VECT_TAB_FLASH  */
	  /* Set the Vector Table base location at 0x08000000 */
	  NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x0);
 80023e6:	2100      	movs	r1, #0
 80023e8:	f04f 6000 	mov.w	r0, #134217728	; 0x8000000
 80023ec:	f001 fcb6 	bl	8003d5c <NVIC_SetVectorTable>
	#endif

	NVIC_PriorityGroupConfig( NVIC_PriorityGroup_4 );
 80023f0:	f44f 7040 	mov.w	r0, #768	; 0x300
 80023f4:	f001 fc74 	bl	8003ce0 <NVIC_PriorityGroupConfig>

	/* Enable the USARTx Interrupt */
	NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn;
 80023f8:	2326      	movs	r3, #38	; 0x26
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 14;	// Je hher desto niedriger
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;			// FreeRtos desto hher desto hher
 80023fa:	2500      	movs	r5, #0
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 80023fc:	2401      	movs	r4, #1
	#endif

	NVIC_PriorityGroupConfig( NVIC_PriorityGroup_4 );

	/* Enable the USARTx Interrupt */
	NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn;
 80023fe:	f88d 3004 	strb.w	r3, [sp, #4]
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 14;	// Je hher desto niedriger
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;			// FreeRtos desto hher desto hher
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);
 8002402:	a801      	add	r0, sp, #4

	NVIC_PriorityGroupConfig( NVIC_PriorityGroup_4 );

	/* Enable the USARTx Interrupt */
	NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 14;	// Je hher desto niedriger
 8002404:	230e      	movs	r3, #14
 8002406:	f88d 3005 	strb.w	r3, [sp, #5]
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;			// FreeRtos desto hher desto hher
 800240a:	f88d 5006 	strb.w	r5, [sp, #6]
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 800240e:	f88d 4007 	strb.w	r4, [sp, #7]
	NVIC_Init(&NVIC_InitStructure);
 8002412:	f001 fc6f 	bl	8003cf4 <NVIC_Init>

	/* Config the USART3 Interrupt*/
	NVIC_InitStructure.NVIC_IRQChannel = USART3_IRQn;
 8002416:	2327      	movs	r3, #39	; 0x27
 8002418:	f88d 3004 	strb.w	r3, [sp, #4]
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 10;  // wie war das noch mal mit den Interrupt prioritten??
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);
 800241c:	a801      	add	r0, sp, #4
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);

	/* Config the USART3 Interrupt*/
	NVIC_InitStructure.NVIC_IRQChannel = USART3_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 10;  // wie war das noch mal mit den Interrupt prioritten??
 800241e:	230a      	movs	r3, #10
 8002420:	f88d 3005 	strb.w	r3, [sp, #5]
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
 8002424:	f88d 5006 	strb.w	r5, [sp, #6]
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 8002428:	f88d 4007 	strb.w	r4, [sp, #7]
	NVIC_Init(&NVIC_InitStructure);
 800242c:	f001 fc62 	bl	8003cf4 <NVIC_Init>

	/* Enable and set EXTI0 Interrupt to the lowest priority */
	NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;
 8002430:	2328      	movs	r3, #40	; 0x28
 8002432:	f88d 3004 	strb.w	r3, [sp, #4]
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 13;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);
 8002436:	a801      	add	r0, sp, #4
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);

	/* Enable and set EXTI0 Interrupt to the lowest priority */
	NVIC_InitStructure.NVIC_IRQChannel = EXTI15_10_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 13;
 8002438:	230d      	movs	r3, #13
 800243a:	f88d 3005 	strb.w	r3, [sp, #5]
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
 800243e:	f88d 5006 	strb.w	r5, [sp, #6]
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 8002442:	f88d 4007 	strb.w	r4, [sp, #7]
	NVIC_Init(&NVIC_InitStructure);
 8002446:	f001 fc55 	bl	8003cf4 <NVIC_Init>
}
 800244a:	bd3e      	pop	{r1, r2, r3, r4, r5, pc}

0800244c <GPIO_Configuration>:



void GPIO_Configuration(void)
{
 800244c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	/************************GPIO***************************/
	GPIO_InitTypeDef GPIO_InitStructure;
	/* Configure PE14 and PE15 in output pushpull mode */

	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8 | GPIO_Pin_9 |
 8002450:	f44f 437f 	mov.w	r3, #65280	; 0xff00
}



void GPIO_Configuration(void)
{
 8002454:	b085      	sub	sp, #20
	/************************GPIO***************************/
	GPIO_InitTypeDef GPIO_InitStructure;
	/* Configure PE14 and PE15 in output pushpull mode */

	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8 | GPIO_Pin_9 |
 8002456:	9302      	str	r3, [sp, #8]
								  GPIO_Pin_14 | GPIO_Pin_15;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOE, &GPIO_InitStructure);
 8002458:	4b7a      	ldr	r3, [pc, #488]	; (8002644 <GPIO_Configuration+0x1f8>)
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOC, &GPIO_InitStructure);
 800245a:	f8df 91f0 	ldr.w	r9, [pc, #496]	; 800264c <GPIO_Configuration+0x200>
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8 | GPIO_Pin_9 |
								  GPIO_Pin_10 | GPIO_Pin_11 |
								  GPIO_Pin_12 | GPIO_Pin_13 |
								  GPIO_Pin_14 | GPIO_Pin_15;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 800245e:	2400      	movs	r4, #0
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOE, &GPIO_InitStructure);
 8002460:	4618      	mov	r0, r3
								  GPIO_Pin_10 | GPIO_Pin_11 |
								  GPIO_Pin_12 | GPIO_Pin_13 |
								  GPIO_Pin_14 | GPIO_Pin_15;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8002462:	2503      	movs	r5, #3
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 8002464:	4f78      	ldr	r7, [pc, #480]	; (8002648 <GPIO_Configuration+0x1fc>)

	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8 | GPIO_Pin_9 |
								  GPIO_Pin_10 | GPIO_Pin_11 |
								  GPIO_Pin_12 | GPIO_Pin_13 |
								  GPIO_Pin_14 | GPIO_Pin_15;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8002466:	f04f 0801 	mov.w	r8, #1
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOE, &GPIO_InitStructure);
 800246a:	a902      	add	r1, sp, #8
 800246c:	9301      	str	r3, [sp, #4]

	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8 | GPIO_Pin_9 |
								  GPIO_Pin_10 | GPIO_Pin_11 |
								  GPIO_Pin_12 | GPIO_Pin_13 |
								  GPIO_Pin_14 | GPIO_Pin_15;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 800246e:	f88d 800c 	strb.w	r8, [sp, #12]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8002472:	f88d 400e 	strb.w	r4, [sp, #14]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8002476:	f88d 500d 	strb.w	r5, [sp, #13]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 800247a:	f88d 400f 	strb.w	r4, [sp, #15]
	GPIO_Init(GPIOE, &GPIO_InitStructure);
 800247e:	f001 f9eb 	bl	8003858 <GPIO_Init>



	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
 8002482:	f44f 6200 	mov.w	r2, #2048	; 0x800
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOC, &GPIO_InitStructure);
 8002486:	4648      	mov	r0, r9
 8002488:	a902      	add	r1, sp, #8
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOE, &GPIO_InitStructure);



	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
 800248a:	9202      	str	r2, [sp, #8]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 800248c:	f88d 800c 	strb.w	r8, [sp, #12]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8002490:	f88d 400e 	strb.w	r4, [sp, #14]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8002494:	f88d 500d 	strb.w	r5, [sp, #13]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 8002498:	f88d 400f 	strb.w	r4, [sp, #15]
	GPIO_Init(GPIOC, &GPIO_InitStructure);
 800249c:	f001 f9dc 	bl	8003858 <GPIO_Init>
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 80024a0:	4638      	mov	r0, r7
 80024a2:	a902      	add	r1, sp, #8
	/************************END GPIO***************************/

	/****************************USART****************************/
	/* GPIOA Configuration:  USART2 TX on PA2 */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2 | GPIO_Pin_3;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 80024a4:	2602      	movs	r6, #2
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOC, &GPIO_InitStructure);


	/* Enable Motor PWM */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1;
 80024a6:	9502      	str	r5, [sp, #8]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 80024a8:	f88d 800c 	strb.w	r8, [sp, #12]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 80024ac:	f88d 400e 	strb.w	r4, [sp, #14]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 80024b0:	f88d 500d 	strb.w	r5, [sp, #13]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
 80024b4:	f88d 400f 	strb.w	r4, [sp, #15]
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 80024b8:	f001 f9ce 	bl	8003858 <GPIO_Init>

	/************************END GPIO***************************/

	/****************************USART****************************/
	/* GPIOA Configuration:  USART2 TX on PA2 */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2 | GPIO_Pin_3;
 80024bc:	220c      	movs	r2, #12
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP ;
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 80024be:	a902      	add	r1, sp, #8
 80024c0:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000

	/************************END GPIO***************************/

	/****************************USART****************************/
	/* GPIOA Configuration:  USART2 TX on PA2 */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2 | GPIO_Pin_3;
 80024c4:	9202      	str	r2, [sp, #8]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 80024c6:	f88d 600c 	strb.w	r6, [sp, #12]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 80024ca:	f88d 500d 	strb.w	r5, [sp, #13]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 80024ce:	f88d 400e 	strb.w	r4, [sp, #14]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP ;
 80024d2:	f88d 800f 	strb.w	r8, [sp, #15]
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 80024d6:	f001 f9bf 	bl	8003858 <GPIO_Init>

	/* Connect USART2 pins to AF2 */
	// TX = PA2
	// RX = PA3
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource2, GPIO_AF_7);
 80024da:	4631      	mov	r1, r6
 80024dc:	2207      	movs	r2, #7
 80024de:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 80024e2:	f001 fa3c 	bl	800395e <GPIO_PinAFConfig>
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource3, GPIO_AF_7);
 80024e6:	4629      	mov	r1, r5
 80024e8:	2207      	movs	r2, #7
 80024ea:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 80024ee:	f001 fa36 	bl	800395e <GPIO_PinAFConfig>


	/* GPIOB Configuration:  USART3 RX on PB11 and TX on PB10 */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10 | GPIO_Pin_11;
 80024f2:	f44f 6240 	mov.w	r2, #3072	; 0xc00
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP ;
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 80024f6:	4638      	mov	r0, r7
 80024f8:	a902      	add	r1, sp, #8
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource2, GPIO_AF_7);
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource3, GPIO_AF_7);


	/* GPIOB Configuration:  USART3 RX on PB11 and TX on PB10 */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10 | GPIO_Pin_11;
 80024fa:	9202      	str	r2, [sp, #8]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 80024fc:	f88d 600c 	strb.w	r6, [sp, #12]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8002500:	f88d 500d 	strb.w	r5, [sp, #13]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 8002504:	f88d 400e 	strb.w	r4, [sp, #14]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP ;
 8002508:	f88d 800f 	strb.w	r8, [sp, #15]
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 800250c:	f001 f9a4 	bl	8003858 <GPIO_Init>

	/* Connect USART3 pins to AF7  */
	GPIO_PinAFConfig(GPIOB, GPIO_PinSource10, GPIO_AF_7);
 8002510:	4638      	mov	r0, r7
 8002512:	210a      	movs	r1, #10
 8002514:	2207      	movs	r2, #7
 8002516:	f001 fa22 	bl	800395e <GPIO_PinAFConfig>
	GPIO_PinAFConfig(GPIOB, GPIO_PinSource11, GPIO_AF_7);
 800251a:	4638      	mov	r0, r7
 800251c:	210b      	movs	r1, #11
 800251e:	2207      	movs	r2, #7
 8002520:	f001 fa1d 	bl	800395e <GPIO_PinAFConfig>


	/*************************END USART***************************/

	/******************************* SPI config ********************************/
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource5, GPIO_AF_5);
 8002524:	2105      	movs	r1, #5
 8002526:	460a      	mov	r2, r1
 8002528:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 800252c:	f001 fa17 	bl	800395e <GPIO_PinAFConfig>
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource6, GPIO_AF_5);
 8002530:	2106      	movs	r1, #6
 8002532:	2205      	movs	r2, #5
 8002534:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8002538:	f001 fa11 	bl	800395e <GPIO_PinAFConfig>
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource7, GPIO_AF_5);
 800253c:	2107      	movs	r1, #7
 800253e:	2205      	movs	r2, #5
 8002540:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8002544:	f001 fa0b 	bl	800395e <GPIO_PinAFConfig>
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;//GPIO_PuPd_DOWN;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;

	/* SPI SCK pin configuration */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
 8002548:	2220      	movs	r2, #32
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 800254a:	a902      	add	r1, sp, #8
 800254c:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;//GPIO_PuPd_DOWN;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;

	/* SPI SCK pin configuration */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
 8002550:	9202      	str	r2, [sp, #8]
	GPIO_Init(GPIOA, &GPIO_InitStructure);

	/* SPI MISO pin configuration */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
 8002552:	f04f 0b40 	mov.w	fp, #64	; 0x40
	/******************************* SPI config ********************************/
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource5, GPIO_AF_5);
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource6, GPIO_AF_5);
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource7, GPIO_AF_5);

	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 8002556:	f88d 600c 	strb.w	r6, [sp, #12]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 800255a:	f88d 400e 	strb.w	r4, [sp, #14]
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;//GPIO_PuPd_DOWN;
 800255e:	f88d 400f 	strb.w	r4, [sp, #15]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8002562:	f88d 500d 	strb.w	r5, [sp, #13]

	/* SPI SCK pin configuration */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 8002566:	f001 f977 	bl	8003858 <GPIO_Init>

	/* SPI MISO pin configuration */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 800256a:	a902      	add	r1, sp, #8
 800256c:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000

	/* SPI  MOSI pin configuration */
	GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_7;
 8002570:	f04f 0a80 	mov.w	sl, #128	; 0x80
	/* SPI SCK pin configuration */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
	GPIO_Init(GPIOA, &GPIO_InitStructure);

	/* SPI MISO pin configuration */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
 8002574:	f8cd b008 	str.w	fp, [sp, #8]
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 8002578:	f001 f96e 	bl	8003858 <GPIO_Init>

	/* SPI  MOSI pin configuration */
	GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_7;
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 800257c:	a902      	add	r1, sp, #8
 800257e:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
	/* SPI MISO pin configuration */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
	GPIO_Init(GPIOA, &GPIO_InitStructure);

	/* SPI  MOSI pin configuration */
	GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_7;
 8002582:	f8cd a008 	str.w	sl, [sp, #8]
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 8002586:	f001 f967 	bl	8003858 <GPIO_Init>
	/* Configure GPIO PIN for Lis Chip select */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3 ;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOE, &GPIO_InitStructure);
 800258a:	9b01      	ldr	r3, [sp, #4]
	/* SPI  MOSI pin configuration */
	GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_7;
	GPIO_Init(GPIOA, &GPIO_InitStructure);

	/* Configure GPIO PIN for Lis Chip select */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3 ;
 800258c:	2208      	movs	r2, #8
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOE, &GPIO_InitStructure);
 800258e:	4618      	mov	r0, r3
 8002590:	eb0d 0102 	add.w	r1, sp, r2
	/* SPI  MOSI pin configuration */
	GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_7;
	GPIO_Init(GPIOA, &GPIO_InitStructure);

	/* Configure GPIO PIN for Lis Chip select */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3 ;
 8002594:	9202      	str	r2, [sp, #8]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
 8002596:	f88d 800c 	strb.w	r8, [sp, #12]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 800259a:	f88d 400e 	strb.w	r4, [sp, #14]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 800259e:	f88d 500d 	strb.w	r5, [sp, #13]
	GPIO_Init(GPIOE, &GPIO_InitStructure);
 80025a2:	f001 f959 	bl	8003858 <GPIO_Init>
	/******************************* END SPI ********************************/

	/****************************** I2C *************************************/
	GPIO_PinAFConfig(GPIOB, GPIO_PinSource6 , GPIO_AF_4 );
 80025a6:	2106      	movs	r1, #6
 80025a8:	4638      	mov	r0, r7
 80025aa:	2204      	movs	r2, #4
 80025ac:	f001 f9d7 	bl	800395e <GPIO_PinAFConfig>
	GPIO_PinAFConfig(GPIOB, GPIO_PinSource7 , GPIO_AF_4 );
 80025b0:	2204      	movs	r2, #4
 80025b2:	4638      	mov	r0, r7
 80025b4:	2107      	movs	r1, #7
 80025b6:	f001 f9d2 	bl	800395e <GPIO_PinAFConfig>
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_DOWN;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;

	/* I2C SCK pin configuration */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 80025ba:	4638      	mov	r0, r7
 80025bc:	a902      	add	r1, sp, #8

	/****************************** I2C *************************************/
	GPIO_PinAFConfig(GPIOB, GPIO_PinSource6 , GPIO_AF_4 );
	GPIO_PinAFConfig(GPIOB, GPIO_PinSource7 , GPIO_AF_4 );

	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 80025be:	f88d 600c 	strb.w	r6, [sp, #12]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 80025c2:	f88d 400e 	strb.w	r4, [sp, #14]
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_DOWN;
 80025c6:	f88d 600f 	strb.w	r6, [sp, #15]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 80025ca:	f88d 500d 	strb.w	r5, [sp, #13]

	/* I2C SCK pin configuration */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
 80025ce:	f8cd b008 	str.w	fp, [sp, #8]
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 80025d2:	f001 f941 	bl	8003858 <GPIO_Init>

	/* I2C SDA pin configuration */
	GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_7;
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 80025d6:	4638      	mov	r0, r7
 80025d8:	a902      	add	r1, sp, #8
	/* I2C SCK pin configuration */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
	GPIO_Init(GPIOB, &GPIO_InitStructure);

	/* I2C SDA pin configuration */
	GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_7;
 80025da:	f8cd a008 	str.w	sl, [sp, #8]
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 80025de:	f001 f93b 	bl	8003858 <GPIO_Init>
	/****************************** END I2C **********************************/

	/****************************** TIM3 PWM OUT *****************************/
	/* GPIOA Configuration: Channel 1, 2, 3 and 4 as alternate function push-pull */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7; //| GPIO_Pin_8 | GPIO_Pin_9;
 80025e2:	23c0      	movs	r3, #192	; 0xc0
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
	GPIO_Init(GPIOC, &GPIO_InitStructure);
 80025e4:	4648      	mov	r0, r9
 80025e6:	a902      	add	r1, sp, #8
	GPIO_Init(GPIOB, &GPIO_InitStructure);
	/****************************** END I2C **********************************/

	/****************************** TIM3 PWM OUT *****************************/
	/* GPIOA Configuration: Channel 1, 2, 3 and 4 as alternate function push-pull */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7; //| GPIO_Pin_8 | GPIO_Pin_9;
 80025e8:	9302      	str	r3, [sp, #8]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
 80025ea:	f88d 600c 	strb.w	r6, [sp, #12]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 80025ee:	f88d 500d 	strb.w	r5, [sp, #13]
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
 80025f2:	f88d 400e 	strb.w	r4, [sp, #14]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
 80025f6:	f88d 800f 	strb.w	r8, [sp, #15]
	GPIO_Init(GPIOC, &GPIO_InitStructure);
 80025fa:	f001 f92d 	bl	8003858 <GPIO_Init>

	GPIO_PinAFConfig(GPIOC, GPIO_PinSource6, GPIO_AF_2);
 80025fe:	4648      	mov	r0, r9
 8002600:	2106      	movs	r1, #6
 8002602:	4632      	mov	r2, r6
 8002604:	f001 f9ab 	bl	800395e <GPIO_PinAFConfig>
	GPIO_PinAFConfig(GPIOC, GPIO_PinSource7, GPIO_AF_2);
 8002608:	4648      	mov	r0, r9
 800260a:	2107      	movs	r1, #7
 800260c:	4632      	mov	r2, r6
 800260e:	f001 f9a6 	bl	800395e <GPIO_PinAFConfig>
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOD, &GPIO_InitStructure); */

	/* ADC Config */
	/* Configure ADC Channels as analog input */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_5 ;
 8002612:	2330      	movs	r3, #48	; 0x30
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
	GPIO_Init(GPIOC, &GPIO_InitStructure);
 8002614:	4648      	mov	r0, r9
 8002616:	a902      	add	r1, sp, #8
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
	GPIO_Init(GPIOD, &GPIO_InitStructure); */

	/* ADC Config */
	/* Configure ADC Channels as analog input */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_5 ;
 8002618:	9302      	str	r3, [sp, #8]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
 800261a:	f88d 500c 	strb.w	r5, [sp, #12]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
 800261e:	f88d 400f 	strb.w	r4, [sp, #15]
	GPIO_Init(GPIOC, &GPIO_InitStructure);
 8002622:	f001 f919 	bl	8003858 <GPIO_Init>

	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 ;
 8002626:	2310      	movs	r3, #16
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 8002628:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 800262c:	a902      	add	r1, sp, #8
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_5 ;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
	GPIO_Init(GPIOC, &GPIO_InitStructure);

	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 ;
 800262e:	9302      	str	r3, [sp, #8]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
 8002630:	f88d 500c 	strb.w	r5, [sp, #12]
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
 8002634:	f88d 400f 	strb.w	r4, [sp, #15]
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 8002638:	f001 f90e 	bl	8003858 <GPIO_Init>
}
 800263c:	b005      	add	sp, #20
 800263e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8002642:	bf00      	nop
 8002644:	48001000 	.word	0x48001000
 8002648:	48000400 	.word	0x48000400
 800264c:	48000800 	.word	0x48000800

08002650 <USART_Configuration>:


void USART_Configuration(void)
{
 8002650:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
	USART_InitStructure.USART_StopBits = USART_StopBits_1;
	USART_InitStructure.USART_Parity = USART_Parity_No;
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
	USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;
	USART_Init(USART2, &USART_InitStructure);
 8002654:	4d1c      	ldr	r5, [pc, #112]	; (80026c8 <USART_Configuration+0x78>)
	GPIO_Init(GPIOA, &GPIO_InitStructure);
}


void USART_Configuration(void)
{
 8002656:	b086      	sub	sp, #24
	USART_InitStructure.USART_Parity = USART_Parity_No;
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
	USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;
	USART_Init(USART2, &USART_InitStructure);

	USART_ITConfig(USART2, USART_IT_RXNE, ENABLE); // enable the USART1 receive interrupt
 8002658:	4e1c      	ldr	r6, [pc, #112]	; (80026cc <USART_Configuration+0x7c>)
void USART_Configuration(void)
{
	USART_InitTypeDef USART_InitStructure;

	USART_InitStructure.USART_BaudRate = 115200;
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 800265a:	2400      	movs	r4, #0

void USART_Configuration(void)
{
	USART_InitTypeDef USART_InitStructure;

	USART_InitStructure.USART_BaudRate = 115200;
 800265c:	f44f 38e1 	mov.w	r8, #115200	; 0x1c200
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
	USART_InitStructure.USART_StopBits = USART_StopBits_1;
	USART_InitStructure.USART_Parity = USART_Parity_No;
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
	USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;
 8002660:	270c      	movs	r7, #12
	USART_Init(USART2, &USART_InitStructure);
 8002662:	4628      	mov	r0, r5
 8002664:	4669      	mov	r1, sp

void USART_Configuration(void)
{
	USART_InitTypeDef USART_InitStructure;

	USART_InitStructure.USART_BaudRate = 115200;
 8002666:	f8cd 8000 	str.w	r8, [sp]
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 800266a:	9401      	str	r4, [sp, #4]
	USART_InitStructure.USART_StopBits = USART_StopBits_1;
 800266c:	9402      	str	r4, [sp, #8]
	USART_InitStructure.USART_Parity = USART_Parity_No;
 800266e:	9403      	str	r4, [sp, #12]
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
 8002670:	9405      	str	r4, [sp, #20]
	USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;
 8002672:	9704      	str	r7, [sp, #16]
	USART_Init(USART2, &USART_InitStructure);
 8002674:	f002 fe80 	bl	8005378 <USART_Init>

	USART_ITConfig(USART2, USART_IT_RXNE, ENABLE); // enable the USART1 receive interrupt
 8002678:	2201      	movs	r2, #1
 800267a:	4628      	mov	r0, r5
 800267c:	4631      	mov	r1, r6
 800267e:	f003 f82d 	bl	80056dc <USART_ITConfig>

	USART_Cmd(USART2, ENABLE); // enable USART2
 8002682:	4628      	mov	r0, r5
 8002684:	2101      	movs	r1, #1
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
	USART_InitStructure.USART_StopBits = USART_StopBits_1;
	USART_InitStructure.USART_Parity = USART_Parity_No;
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
	USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;
	USART_Init(USART3, &USART_InitStructure);
 8002686:	f505 6580 	add.w	r5, r5, #1024	; 0x400
	USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;
	USART_Init(USART2, &USART_InitStructure);

	USART_ITConfig(USART2, USART_IT_RXNE, ENABLE); // enable the USART1 receive interrupt

	USART_Cmd(USART2, ENABLE); // enable USART2
 800268a:	f002 fef0 	bl	800546e <USART_Cmd>
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
	USART_InitStructure.USART_StopBits = USART_StopBits_1;
	USART_InitStructure.USART_Parity = USART_Parity_No;
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
	USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;
	USART_Init(USART3, &USART_InitStructure);
 800268e:	4628      	mov	r0, r5
 8002690:	4669      	mov	r1, sp

	/*
	 * Configure USART 3
	 * */
	//USART_InitTypeDef USART_InitStructure;
	USART_InitStructure.USART_BaudRate = 115200;
 8002692:	f8cd 8000 	str.w	r8, [sp]
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 8002696:	9401      	str	r4, [sp, #4]
	USART_InitStructure.USART_StopBits = USART_StopBits_1;
 8002698:	9402      	str	r4, [sp, #8]
	USART_InitStructure.USART_Parity = USART_Parity_No;
 800269a:	9403      	str	r4, [sp, #12]
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
 800269c:	9405      	str	r4, [sp, #20]
	USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;
 800269e:	9704      	str	r7, [sp, #16]
	USART_Init(USART3, &USART_InitStructure);
 80026a0:	f002 fe6a 	bl	8005378 <USART_Init>

	USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);
 80026a4:	4628      	mov	r0, r5
 80026a6:	4631      	mov	r1, r6
 80026a8:	2201      	movs	r2, #1
 80026aa:	f003 f817 	bl	80056dc <USART_ITConfig>
	USART_ITConfig(USART3, USART_IT_TXE, DISABLE);
 80026ae:	4628      	mov	r0, r5
 80026b0:	4907      	ldr	r1, [pc, #28]	; (80026d0 <USART_Configuration+0x80>)
 80026b2:	4622      	mov	r2, r4
 80026b4:	f003 f812 	bl	80056dc <USART_ITConfig>

	USART_Cmd(USART3, ENABLE); // enable USART3
 80026b8:	4628      	mov	r0, r5
 80026ba:	2101      	movs	r1, #1
 80026bc:	f002 fed7 	bl	800546e <USART_Cmd>
}
 80026c0:	b006      	add	sp, #24
 80026c2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80026c6:	bf00      	nop
 80026c8:	40004400 	.word	0x40004400
 80026cc:	00050105 	.word	0x00050105
 80026d0:	00070107 	.word	0x00070107

080026d4 <SPI_Configuration>:


void SPI_Configuration(void)
{
 80026d4:	b510      	push	{r4, lr}
	SPI_InitTypeDef  SPI_InitStructure;
	/* SPI configuration -------------------------------------------------------*/
	SPI_I2S_DeInit(SPI1);
 80026d6:	4c17      	ldr	r4, [pc, #92]	; (8002734 <SPI_Configuration+0x60>)
	USART_Cmd(USART3, ENABLE); // enable USART3
}


void SPI_Configuration(void)
{
 80026d8:	b086      	sub	sp, #24
	SPI_InitTypeDef  SPI_InitStructure;
	/* SPI configuration -------------------------------------------------------*/
	SPI_I2S_DeInit(SPI1);
 80026da:	4620      	mov	r0, r4
 80026dc:	f001 fe5a 	bl	8004394 <SPI_I2S_DeInit>
	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
 80026e0:	2300      	movs	r3, #0
	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;
 80026e2:	f44f 62e0 	mov.w	r2, #1792	; 0x700
void SPI_Configuration(void)
{
	SPI_InitTypeDef  SPI_InitStructure;
	/* SPI configuration -------------------------------------------------------*/
	SPI_I2S_DeInit(SPI1);
	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
 80026e6:	f8ad 3004 	strh.w	r3, [sp, #4]
	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;
 80026ea:	f8ad 2008 	strh.w	r2, [sp, #8]
	SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;
 80026ee:	f8ad 300a 	strh.w	r3, [sp, #10]
	SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
 80026f2:	f8ad 300c 	strh.w	r3, [sp, #12]
	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;
	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_8;
	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
 80026f6:	f8ad 3012 	strh.w	r3, [sp, #18]
	SPI_I2S_DeInit(SPI1);
	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;
	SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;
	SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;
 80026fa:	f44f 7200 	mov.w	r2, #512	; 0x200
	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_8;
	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
	SPI_InitStructure.SPI_CRCPolynomial = 7;
 80026fe:	2307      	movs	r3, #7
	SPI_I2S_DeInit(SPI1);
	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;
	SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;
	SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;
 8002700:	f8ad 200e 	strh.w	r2, [sp, #14]
	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_8;
	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
	SPI_InitStructure.SPI_CRCPolynomial = 7;
 8002704:	f8ad 3014 	strh.w	r3, [sp, #20]
	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;
	SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;
	SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;
	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_8;
 8002708:	2210      	movs	r2, #16
	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
	SPI_InitStructure.SPI_CRCPolynomial = 7;
	SPI_InitStructure.SPI_Mode = SPI_Mode_Master;
 800270a:	f44f 7382 	mov.w	r3, #260	; 0x104
	SPI_Init(SPI1, &SPI_InitStructure);
 800270e:	4620      	mov	r0, r4
 8002710:	a901      	add	r1, sp, #4
	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;
	SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;
	SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;
	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_8;
 8002712:	f8ad 2010 	strh.w	r2, [sp, #16]
	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
	SPI_InitStructure.SPI_CRCPolynomial = 7;
	SPI_InitStructure.SPI_Mode = SPI_Mode_Master;
 8002716:	f8ad 3006 	strh.w	r3, [sp, #6]
	SPI_Init(SPI1, &SPI_InitStructure);
 800271a:	f001 fe7b 	bl	8004414 <SPI_Init>

	/* Configure the RX FIFO Threshold */
	SPI_RxFIFOThresholdConfig(SPI1, SPI_RxFIFOThreshold_QF);
 800271e:	4620      	mov	r0, r4
 8002720:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8002724:	f001 ff3c 	bl	80045a0 <SPI_RxFIFOThresholdConfig>
	/* Enable SPI1  */
	SPI_Cmd(SPI1, ENABLE);
 8002728:	4620      	mov	r0, r4
 800272a:	2101      	movs	r1, #1
 800272c:	f001 ff0c 	bl	8004548 <SPI_Cmd>
}
 8002730:	b006      	add	sp, #24
 8002732:	bd10      	pop	{r4, pc}
 8002734:	40013000 	.word	0x40013000

08002738 <I2C_Configuration>:


void I2C_Configuration(void)
{
 8002738:	b510      	push	{r4, lr}
	I2C_InitTypeDef  I2C_InitStructure;

	I2C_DeInit(I2C1);
 800273a:	4c0c      	ldr	r4, [pc, #48]	; (800276c <I2C_Configuration+0x34>)
	SPI_Cmd(SPI1, ENABLE);
}


void I2C_Configuration(void)
{
 800273c:	b088      	sub	sp, #32
	I2C_InitTypeDef  I2C_InitStructure;

	I2C_DeInit(I2C1);
 800273e:	4620      	mov	r0, r4
 8002740:	f001 f924 	bl	800398c <I2C_DeInit>

    /* I2C configuration -------------------------------------------------------*/
    I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
 8002744:	2300      	movs	r3, #0
 8002746:	9304      	str	r3, [sp, #16]
    I2C_InitStructure.I2C_AnalogFilter = I2C_AnalogFilter_Enable;
 8002748:	9302      	str	r3, [sp, #8]
    I2C_InitStructure.I2C_DigitalFilter = 0x00;
 800274a:	9303      	str	r3, [sp, #12]
    I2C_InitStructure.I2C_OwnAddress1 = 0x00;
 800274c:	9305      	str	r3, [sp, #20]
    I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
 800274e:	9306      	str	r3, [sp, #24]
    I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 8002750:	9307      	str	r3, [sp, #28]
    I2C_InitStructure.I2C_Timing = 0x00902025;
 8002752:	4b07      	ldr	r3, [pc, #28]	; (8002770 <I2C_Configuration+0x38>)
 8002754:	a908      	add	r1, sp, #32
 8002756:	f841 3d1c 	str.w	r3, [r1, #-28]!

    /* Apply LSM303DLHC_I2C configuration after enabling it */
    I2C_Init(I2C1, &I2C_InitStructure);
 800275a:	4620      	mov	r0, r4
 800275c:	f001 f930 	bl	80039c0 <I2C_Init>

    /* LSM303DLHC_I2C Peripheral Enable */
    I2C_Cmd(I2C1, ENABLE);
 8002760:	4620      	mov	r0, r4
 8002762:	2101      	movs	r1, #1
 8002764:	f001 f967 	bl	8003a36 <I2C_Cmd>
}
 8002768:	b008      	add	sp, #32
 800276a:	bd10      	pop	{r4, pc}
 800276c:	40005400 	.word	0x40005400
 8002770:	00902025 	.word	0x00902025

08002774 <DMA_Configuration>:


void DMA_Configuration(uint8_t *buffer)
{
 8002774:	b530      	push	{r4, r5, lr}
	DMA_DeInit(DMA1_Channel7);
 8002776:	4c0f      	ldr	r4, [pc, #60]	; (80027b4 <DMA_Configuration+0x40>)
    I2C_Cmd(I2C1, ENABLE);
}


void DMA_Configuration(uint8_t *buffer)
{
 8002778:	b08d      	sub	sp, #52	; 0x34
 800277a:	4605      	mov	r5, r0
	DMA_DeInit(DMA1_Channel7);
 800277c:	4620      	mov	r0, r4
 800277e:	f000 fe37 	bl	80033f0 <DMA_DeInit>
    DMA_InitTypeDef DMA_InitStructure;
    DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&I2C1->RXDR;
 8002782:	4b0d      	ldr	r3, [pc, #52]	; (80027b8 <DMA_Configuration+0x44>)
    DMA_InitStructure.DMA_MemoryBaseAddr     = (uint32_t)buffer;
    DMA_InitStructure.DMA_BufferSize         = 6;
    DMA_InitStructure.DMA_DIR                = DMA_DIR_PeripheralSRC;
    DMA_InitStructure.DMA_PeripheralInc      = DMA_PeripheralInc_Disable;
    DMA_InitStructure.DMA_MemoryInc          = DMA_MemoryInc_Enable;
 8002784:	2280      	movs	r2, #128	; 0x80

void DMA_Configuration(uint8_t *buffer)
{
	DMA_DeInit(DMA1_Channel7);
    DMA_InitTypeDef DMA_InitStructure;
    DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&I2C1->RXDR;
 8002786:	9301      	str	r3, [sp, #4]
    DMA_InitStructure.DMA_MemoryBaseAddr     = (uint32_t)buffer;
    DMA_InitStructure.DMA_BufferSize         = 6;
    DMA_InitStructure.DMA_DIR                = DMA_DIR_PeripheralSRC;
    DMA_InitStructure.DMA_PeripheralInc      = DMA_PeripheralInc_Disable;
    DMA_InitStructure.DMA_MemoryInc          = DMA_MemoryInc_Enable;
 8002788:	9206      	str	r2, [sp, #24]
{
	DMA_DeInit(DMA1_Channel7);
    DMA_InitTypeDef DMA_InitStructure;
    DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&I2C1->RXDR;
    DMA_InitStructure.DMA_MemoryBaseAddr     = (uint32_t)buffer;
    DMA_InitStructure.DMA_BufferSize         = 6;
 800278a:	2306      	movs	r3, #6
    DMA_InitStructure.DMA_DIR                = DMA_DIR_PeripheralSRC;
    DMA_InitStructure.DMA_PeripheralInc      = DMA_PeripheralInc_Disable;
    DMA_InitStructure.DMA_MemoryInc          = DMA_MemoryInc_Enable;
    DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
    DMA_InitStructure.DMA_MemoryDataSize     = DMA_MemoryDataSize_Byte;
    DMA_InitStructure.DMA_Mode               = DMA_Mode_Circular;
 800278c:	2220      	movs	r2, #32
{
	DMA_DeInit(DMA1_Channel7);
    DMA_InitTypeDef DMA_InitStructure;
    DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&I2C1->RXDR;
    DMA_InitStructure.DMA_MemoryBaseAddr     = (uint32_t)buffer;
    DMA_InitStructure.DMA_BufferSize         = 6;
 800278e:	f8ad 3010 	strh.w	r3, [sp, #16]
    DMA_InitStructure.DMA_DIR                = DMA_DIR_PeripheralSRC;
    DMA_InitStructure.DMA_PeripheralInc      = DMA_PeripheralInc_Disable;
    DMA_InitStructure.DMA_MemoryInc          = DMA_MemoryInc_Enable;
    DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
    DMA_InitStructure.DMA_MemoryDataSize     = DMA_MemoryDataSize_Byte;
    DMA_InitStructure.DMA_Mode               = DMA_Mode_Circular;
 8002792:	9209      	str	r2, [sp, #36]	; 0x24
	DMA_DeInit(DMA1_Channel7);
    DMA_InitTypeDef DMA_InitStructure;
    DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&I2C1->RXDR;
    DMA_InitStructure.DMA_MemoryBaseAddr     = (uint32_t)buffer;
    DMA_InitStructure.DMA_BufferSize         = 6;
    DMA_InitStructure.DMA_DIR                = DMA_DIR_PeripheralSRC;
 8002794:	2300      	movs	r3, #0
    DMA_InitStructure.DMA_PeripheralInc      = DMA_PeripheralInc_Disable;
    DMA_InitStructure.DMA_MemoryInc          = DMA_MemoryInc_Enable;
    DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
    DMA_InitStructure.DMA_MemoryDataSize     = DMA_MemoryDataSize_Byte;
    DMA_InitStructure.DMA_Mode               = DMA_Mode_Circular;
    DMA_InitStructure.DMA_Priority           = DMA_Priority_VeryHigh;
 8002796:	f44f 5240 	mov.w	r2, #12288	; 0x3000
    DMA_InitStructure.DMA_M2M                = DMA_M2M_Disable;
    DMA_Init(DMA1_Channel7, &DMA_InitStructure);
 800279a:	4620      	mov	r0, r4
 800279c:	a901      	add	r1, sp, #4
void DMA_Configuration(uint8_t *buffer)
{
	DMA_DeInit(DMA1_Channel7);
    DMA_InitTypeDef DMA_InitStructure;
    DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&I2C1->RXDR;
    DMA_InitStructure.DMA_MemoryBaseAddr     = (uint32_t)buffer;
 800279e:	9502      	str	r5, [sp, #8]
    DMA_InitStructure.DMA_BufferSize         = 6;
    DMA_InitStructure.DMA_DIR                = DMA_DIR_PeripheralSRC;
 80027a0:	9303      	str	r3, [sp, #12]
    DMA_InitStructure.DMA_PeripheralInc      = DMA_PeripheralInc_Disable;
 80027a2:	9305      	str	r3, [sp, #20]
    DMA_InitStructure.DMA_MemoryInc          = DMA_MemoryInc_Enable;
    DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
 80027a4:	9307      	str	r3, [sp, #28]
    DMA_InitStructure.DMA_MemoryDataSize     = DMA_MemoryDataSize_Byte;
 80027a6:	9308      	str	r3, [sp, #32]
    DMA_InitStructure.DMA_Mode               = DMA_Mode_Circular;
    DMA_InitStructure.DMA_Priority           = DMA_Priority_VeryHigh;
 80027a8:	920a      	str	r2, [sp, #40]	; 0x28
    DMA_InitStructure.DMA_M2M                = DMA_M2M_Disable;
 80027aa:	930b      	str	r3, [sp, #44]	; 0x2c
    DMA_Init(DMA1_Channel7, &DMA_InitStructure);
 80027ac:	f000 fe9c 	bl	80034e8 <DMA_Init>

    //DMA_Cmd(DMA1_Channel1, ENABLE);
}
 80027b0:	b00d      	add	sp, #52	; 0x34
 80027b2:	bd30      	pop	{r4, r5, pc}
 80027b4:	40020080 	.word	0x40020080
 80027b8:	40005424 	.word	0x40005424

080027bc <TIM2_PWM_Configuration>:


void TIM2_PWM_Configuration(void)
{
 80027bc:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint16_t PrescalerValue = 0;
	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
	static TIM_OCInitTypeDef  TIM_OCInitStructure;

	/* Compute the prescaler value */
	PrescalerValue = (uint16_t) (SystemCoreClock / (50000*PRESCALEVALUE)) - 1;
 80027be:	4b30      	ldr	r3, [pc, #192]	; (8002880 <TIM2_PWM_Configuration+0xc4>)
    //DMA_Cmd(DMA1_Channel1, ENABLE);
}


void TIM2_PWM_Configuration(void)
{
 80027c0:	b085      	sub	sp, #20
	uint16_t PrescalerValue = 0;
	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
	static TIM_OCInitTypeDef  TIM_OCInitStructure;

	/* Compute the prescaler value */
	PrescalerValue = (uint16_t) (SystemCoreClock / (50000*PRESCALEVALUE)) - 1;
 80027c2:	681c      	ldr	r4, [r3, #0]
 80027c4:	4b2f      	ldr	r3, [pc, #188]	; (8002884 <TIM2_PWM_Configuration+0xc8>)

	/* Time base configuration */
	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
 80027c6:	a801      	add	r0, sp, #4
	uint16_t PrescalerValue = 0;
	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
	static TIM_OCInitTypeDef  TIM_OCInitStructure;

	/* Compute the prescaler value */
	PrescalerValue = (uint16_t) (SystemCoreClock / (50000*PRESCALEVALUE)) - 1;
 80027c8:	fbb4 f4f3 	udiv	r4, r4, r3
 80027cc:	3c01      	subs	r4, #1

	/* Time base configuration */
	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
 80027ce:	f002 f8b5 	bl	800493c <TIM_TimeBaseStructInit>
	TIM_TimeBaseStructure.TIM_Period = 1000;
	TIM_TimeBaseStructure.TIM_Prescaler = PrescalerValue;
 80027d2:	f8ad 4004 	strh.w	r4, [sp, #4]
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);

	/* PWM1 Mode configuration: Channel1 */
	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
 80027d6:	4c2c      	ldr	r4, [pc, #176]	; (8002888 <TIM2_PWM_Configuration+0xcc>)

	/* Time base configuration */
	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
	TIM_TimeBaseStructure.TIM_Period = 1000;
	TIM_TimeBaseStructure.TIM_Prescaler = PrescalerValue;
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
 80027d8:	2700      	movs	r7, #0
	/* Compute the prescaler value */
	PrescalerValue = (uint16_t) (SystemCoreClock / (50000*PRESCALEVALUE)) - 1;

	/* Time base configuration */
	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
	TIM_TimeBaseStructure.TIM_Period = 1000;
 80027da:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
	TIM_TimeBaseStructure.TIM_Prescaler = PrescalerValue;
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);
 80027de:	a901      	add	r1, sp, #4
 80027e0:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000

	/* PWM1 Mode configuration: Channel1 */
	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
 80027e4:	2501      	movs	r5, #1
	TIM_OCInitStructure.TIM_Pulse = 50*PRESCALEVALUE;
 80027e6:	f44f 7696 	mov.w	r6, #300	; 0x12c
	/* Compute the prescaler value */
	PrescalerValue = (uint16_t) (SystemCoreClock / (50000*PRESCALEVALUE)) - 1;

	/* Time base configuration */
	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
	TIM_TimeBaseStructure.TIM_Period = 1000;
 80027ea:	9302      	str	r3, [sp, #8]
	TIM_TimeBaseStructure.TIM_Prescaler = PrescalerValue;
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
 80027ec:	f8ad 700c 	strh.w	r7, [sp, #12]
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
 80027f0:	f8ad 7006 	strh.w	r7, [sp, #6]
	TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);
 80027f4:	f002 f85c 	bl	80048b0 <TIM_TimeBaseInit>

	/* PWM1 Mode configuration: Channel1 */
	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
 80027f8:	2360      	movs	r3, #96	; 0x60
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
	TIM_OCInitStructure.TIM_Pulse = 50*PRESCALEVALUE;
	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
	TIM_OC1Init(TIM2, &TIM_OCInitStructure);
 80027fa:	4621      	mov	r1, r4
 80027fc:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);

	/* PWM1 Mode configuration: Channel1 */
	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
 8002800:	6023      	str	r3, [r4, #0]
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
 8002802:	80a5      	strh	r5, [r4, #4]
	TIM_OCInitStructure.TIM_Pulse = 50*PRESCALEVALUE;
 8002804:	60a6      	str	r6, [r4, #8]
	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
 8002806:	81a7      	strh	r7, [r4, #12]
	TIM_OC1Init(TIM2, &TIM_OCInitStructure);
 8002808:	f002 f907 	bl	8004a1a <TIM_OC1Init>
	TIM_OC1PreloadConfig(TIM2, TIM_OCPreload_Enable);
 800280c:	2108      	movs	r1, #8
 800280e:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8002812:	f002 faa0 	bl	8004d56 <TIM_OC1PreloadConfig>

	/* PWM1 Mode configuration: Channel2 */
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
	TIM_OCInitStructure.TIM_Pulse = 50*PRESCALEVALUE;
	TIM_OC2Init(TIM2, &TIM_OCInitStructure);
 8002816:	4621      	mov	r1, r4
 8002818:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
	TIM_OC1Init(TIM2, &TIM_OCInitStructure);
	TIM_OC1PreloadConfig(TIM2, TIM_OCPreload_Enable);

	/* PWM1 Mode configuration: Channel2 */
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
 800281c:	80a5      	strh	r5, [r4, #4]
	TIM_OCInitStructure.TIM_Pulse = 50*PRESCALEVALUE;
 800281e:	60a6      	str	r6, [r4, #8]
	TIM_OC2Init(TIM2, &TIM_OCInitStructure);
 8002820:	f002 f938 	bl	8004a94 <TIM_OC2Init>
	TIM_OC2PreloadConfig(TIM2, TIM_OCPreload_Enable);
 8002824:	2108      	movs	r1, #8
 8002826:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 800282a:	f002 fa9a 	bl	8004d62 <TIM_OC2PreloadConfig>

	/* PWM1 Mode configuration: Channel3 */
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
	TIM_OCInitStructure.TIM_Pulse = 50*PRESCALEVALUE;
	TIM_OC3Init(TIM2, &TIM_OCInitStructure);
 800282e:	4621      	mov	r1, r4
 8002830:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
	TIM_OCInitStructure.TIM_Pulse = 50*PRESCALEVALUE;
	TIM_OC2Init(TIM2, &TIM_OCInitStructure);
	TIM_OC2PreloadConfig(TIM2, TIM_OCPreload_Enable);

	/* PWM1 Mode configuration: Channel3 */
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
 8002834:	80a5      	strh	r5, [r4, #4]
	TIM_OCInitStructure.TIM_Pulse = 50*PRESCALEVALUE;
 8002836:	60a6      	str	r6, [r4, #8]
	TIM_OC3Init(TIM2, &TIM_OCInitStructure);
 8002838:	f002 f962 	bl	8004b00 <TIM_OC3Init>
	TIM_OC3PreloadConfig(TIM2, TIM_OCPreload_Enable);
 800283c:	2108      	movs	r1, #8
 800283e:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8002842:	f002 fa95 	bl	8004d70 <TIM_OC3PreloadConfig>

	/* PWM1 Mode configuration: Channel4 */
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
	TIM_OCInitStructure.TIM_Pulse = 50*PRESCALEVALUE;
	TIM_OC4Init(TIM2, &TIM_OCInitStructure);
 8002846:	4621      	mov	r1, r4
 8002848:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
	TIM_OCInitStructure.TIM_Pulse = 50*PRESCALEVALUE;
	TIM_OC3Init(TIM2, &TIM_OCInitStructure);
	TIM_OC3PreloadConfig(TIM2, TIM_OCPreload_Enable);

	/* PWM1 Mode configuration: Channel4 */
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
 800284c:	80a5      	strh	r5, [r4, #4]
	TIM_OCInitStructure.TIM_Pulse = 50*PRESCALEVALUE;
 800284e:	60a6      	str	r6, [r4, #8]
	TIM_OC4Init(TIM2, &TIM_OCInitStructure);
 8002850:	f002 f98a 	bl	8004b68 <TIM_OC4Init>
	TIM_OC4PreloadConfig(TIM2, TIM_OCPreload_Enable);
 8002854:	2108      	movs	r1, #8
 8002856:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 800285a:	f002 fa8f 	bl	8004d7c <TIM_OC4PreloadConfig>

	TIM_ARRPreloadConfig(TIM2, ENABLE);
 800285e:	4629      	mov	r1, r5
 8002860:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8002864:	f002 f8ab 	bl	80049be <TIM_ARRPreloadConfig>
	TIM_CtrlPWMOutputs(TIM2, ENABLE);
 8002868:	4629      	mov	r1, r5
 800286a:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 800286e:	f002 fc42 	bl	80050f6 <TIM_CtrlPWMOutputs>

	/* TIM3 enable counter */
	TIM_Cmd(TIM2, ENABLE);
 8002872:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 8002876:	4629      	mov	r1, r5
 8002878:	f002 f8c3 	bl	8004a02 <TIM_Cmd>
}
 800287c:	b005      	add	sp, #20
 800287e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002880:	20000034 	.word	0x20000034
 8002884:	000493e0 	.word	0x000493e0
 8002888:	200001b4 	.word	0x200001b4

0800288c <TIM3_PWM_Configuration>:


void TIM3_PWM_Configuration(void)
{
 800288c:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	uint16_t PrescalerValue = 0;
	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
	static TIM_OCInitTypeDef  TIM_OCInitStructure;

	/* Compute the prescaler value */
	PrescalerValue = (uint16_t) (SystemCoreClock / (600000*PRESCALEVALUE)) - 1;//(60000*PRESCALEVALUE)) - 1;
 8002890:	4b21      	ldr	r3, [pc, #132]	; (8002918 <TIM3_PWM_Configuration+0x8c>)

	/* Time base configuration */
	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
 8002892:	a801      	add	r0, sp, #4
	uint16_t PrescalerValue = 0;
	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
	static TIM_OCInitTypeDef  TIM_OCInitStructure;

	/* Compute the prescaler value */
	PrescalerValue = (uint16_t) (SystemCoreClock / (600000*PRESCALEVALUE)) - 1;//(60000*PRESCALEVALUE)) - 1;
 8002894:	681c      	ldr	r4, [r3, #0]
 8002896:	4b21      	ldr	r3, [pc, #132]	; (800291c <TIM3_PWM_Configuration+0x90>)
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure);

	/* PWM1 Mode configuration: Channel1 */
	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
 8002898:	4d21      	ldr	r5, [pc, #132]	; (8002920 <TIM3_PWM_Configuration+0x94>)
	uint16_t PrescalerValue = 0;
	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
	static TIM_OCInitTypeDef  TIM_OCInitStructure;

	/* Compute the prescaler value */
	PrescalerValue = (uint16_t) (SystemCoreClock / (600000*PRESCALEVALUE)) - 1;//(60000*PRESCALEVALUE)) - 1;
 800289a:	fbb4 f4f3 	udiv	r4, r4, r3
 800289e:	3c01      	subs	r4, #1

	/* Time base configuration */
	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
 80028a0:	f002 f84c 	bl	800493c <TIM_TimeBaseStructInit>
	TIM_TimeBaseStructure.TIM_Period = 200;
	TIM_TimeBaseStructure.TIM_Prescaler = PrescalerValue;
 80028a4:	f8ad 4004 	strh.w	r4, [sp, #4]
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure);
 80028a8:	4c1e      	ldr	r4, [pc, #120]	; (8002924 <TIM3_PWM_Configuration+0x98>)

	/* Time base configuration */
	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
	TIM_TimeBaseStructure.TIM_Period = 200;
	TIM_TimeBaseStructure.TIM_Prescaler = PrescalerValue;
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
 80028aa:	2700      	movs	r7, #0
	/* Compute the prescaler value */
	PrescalerValue = (uint16_t) (SystemCoreClock / (600000*PRESCALEVALUE)) - 1;//(60000*PRESCALEVALUE)) - 1;

	/* Time base configuration */
	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
	TIM_TimeBaseStructure.TIM_Period = 200;
 80028ac:	23c8      	movs	r3, #200	; 0xc8
	TIM_TimeBaseStructure.TIM_Prescaler = PrescalerValue;
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure);
 80028ae:	4620      	mov	r0, r4
 80028b0:	a901      	add	r1, sp, #4
	/* Compute the prescaler value */
	PrescalerValue = (uint16_t) (SystemCoreClock / (600000*PRESCALEVALUE)) - 1;//(60000*PRESCALEVALUE)) - 1;

	/* Time base configuration */
	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
	TIM_TimeBaseStructure.TIM_Period = 200;
 80028b2:	9302      	str	r3, [sp, #8]
	TIM_TimeBaseStructure.TIM_Prescaler = PrescalerValue;
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
 80028b4:	f8ad 700c 	strh.w	r7, [sp, #12]
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
 80028b8:	f8ad 7006 	strh.w	r7, [sp, #6]
	TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure);
 80028bc:	f001 fff8 	bl	80048b0 <TIM_TimeBaseInit>

	/* PWM1 Mode configuration: Channel1 */
	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
	TIM_OCInitStructure.TIM_Pulse = 100;
	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
 80028c0:	842f      	strh	r7, [r5, #32]
	TIM_OC1Init(TIM3, &TIM_OCInitStructure);
 80028c2:	f105 0714 	add.w	r7, r5, #20
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure);

	/* PWM1 Mode configuration: Channel1 */
	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
 80028c6:	2360      	movs	r3, #96	; 0x60
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
 80028c8:	2601      	movs	r6, #1
	TIM_OCInitStructure.TIM_Pulse = 100;
 80028ca:	f04f 0864 	mov.w	r8, #100	; 0x64
	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
	TIM_OC1Init(TIM3, &TIM_OCInitStructure);
 80028ce:	4620      	mov	r0, r4
 80028d0:	4639      	mov	r1, r7
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure);

	/* PWM1 Mode configuration: Channel1 */
	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
 80028d2:	616b      	str	r3, [r5, #20]
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
 80028d4:	832e      	strh	r6, [r5, #24]
	TIM_OCInitStructure.TIM_Pulse = 100;
 80028d6:	f8c5 801c 	str.w	r8, [r5, #28]
	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
	TIM_OC1Init(TIM3, &TIM_OCInitStructure);
 80028da:	f002 f89e 	bl	8004a1a <TIM_OC1Init>
	TIM_OC1PreloadConfig(TIM3, TIM_OCPreload_Enable);
 80028de:	4620      	mov	r0, r4
 80028e0:	2108      	movs	r1, #8
 80028e2:	f002 fa38 	bl	8004d56 <TIM_OC1PreloadConfig>

	/* PWM1 Mode configuration: Channel2 */
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
	TIM_OCInitStructure.TIM_Pulse = 100;
	TIM_OC2Init(TIM3, &TIM_OCInitStructure);
 80028e6:	4620      	mov	r0, r4
 80028e8:	4639      	mov	r1, r7
	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
	TIM_OC1Init(TIM3, &TIM_OCInitStructure);
	TIM_OC1PreloadConfig(TIM3, TIM_OCPreload_Enable);

	/* PWM1 Mode configuration: Channel2 */
	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
 80028ea:	832e      	strh	r6, [r5, #24]
	TIM_OCInitStructure.TIM_Pulse = 100;
 80028ec:	f8c5 801c 	str.w	r8, [r5, #28]
	TIM_OC2Init(TIM3, &TIM_OCInitStructure);
 80028f0:	f002 f8d0 	bl	8004a94 <TIM_OC2Init>
	TIM_OC2PreloadConfig(TIM3, TIM_OCPreload_Enable);
 80028f4:	4620      	mov	r0, r4
 80028f6:	2108      	movs	r1, #8
 80028f8:	f002 fa33 	bl	8004d62 <TIM_OC2PreloadConfig>
	//TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
	//TIM_OCInitStructure.TIM_Pulse = 50*PRESCALEVALUE;
	//TIM_OC4Init(TIM3, &TIM_OCInitStructure);
	//TIM_OC4PreloadConfig(TIM3, TIM_OCPreload_Enable);

	TIM_ARRPreloadConfig(TIM3, ENABLE);
 80028fc:	4620      	mov	r0, r4
 80028fe:	4631      	mov	r1, r6
 8002900:	f002 f85d 	bl	80049be <TIM_ARRPreloadConfig>
	TIM_CtrlPWMOutputs(TIM3, ENABLE);
 8002904:	4620      	mov	r0, r4
 8002906:	4631      	mov	r1, r6
 8002908:	f002 fbf5 	bl	80050f6 <TIM_CtrlPWMOutputs>

	/* TIM3 enable counter */
	TIM_Cmd(TIM3, ENABLE);
 800290c:	4620      	mov	r0, r4
 800290e:	4631      	mov	r1, r6
 8002910:	f002 f877 	bl	8004a02 <TIM_Cmd>
}
 8002914:	e8bd 81ff 	ldmia.w	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, pc}
 8002918:	20000034 	.word	0x20000034
 800291c:	0036ee80 	.word	0x0036ee80
 8002920:	200001b4 	.word	0x200001b4
 8002924:	40000400 	.word	0x40000400

08002928 <TIM4_Configuration>:


void TIM4_Configuration(void)
{
 8002928:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	uint16_t PrescalerValue = 0;
	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;

	/* Compute the prescaler value */
	PrescalerValue = (uint16_t) (SystemCoreClock / (50000)) - 1;
 800292a:	4b0f      	ldr	r3, [pc, #60]	; (8002968 <TIM4_Configuration+0x40>)
	/* Time base configuration */
	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
 800292c:	a801      	add	r0, sp, #4
{
	uint16_t PrescalerValue = 0;
	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;

	/* Compute the prescaler value */
	PrescalerValue = (uint16_t) (SystemCoreClock / (50000)) - 1;
 800292e:	681c      	ldr	r4, [r3, #0]
 8002930:	f24c 3350 	movw	r3, #50000	; 0xc350
 8002934:	fbb4 f4f3 	udiv	r4, r4, r3
 8002938:	3c01      	subs	r4, #1
	/* Time base configuration */
	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
 800293a:	f001 ffff 	bl	800493c <TIM_TimeBaseStructInit>
	TIM_TimeBaseStructure.TIM_Period = 1000;
	TIM_TimeBaseStructure.TIM_Prescaler = PrescalerValue;
 800293e:	f8ad 4004 	strh.w	r4, [sp, #4]
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseInit(TIM4, &TIM_TimeBaseStructure);
 8002942:	4c0a      	ldr	r4, [pc, #40]	; (800296c <TIM4_Configuration+0x44>)

	/* Compute the prescaler value */
	PrescalerValue = (uint16_t) (SystemCoreClock / (50000)) - 1;
	/* Time base configuration */
	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
	TIM_TimeBaseStructure.TIM_Period = 1000;
 8002944:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8002948:	9302      	str	r3, [sp, #8]
	TIM_TimeBaseStructure.TIM_Prescaler = PrescalerValue;
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseInit(TIM4, &TIM_TimeBaseStructure);
 800294a:	4620      	mov	r0, r4
	PrescalerValue = (uint16_t) (SystemCoreClock / (50000)) - 1;
	/* Time base configuration */
	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
	TIM_TimeBaseStructure.TIM_Period = 1000;
	TIM_TimeBaseStructure.TIM_Prescaler = PrescalerValue;
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
 800294c:	2300      	movs	r3, #0
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseInit(TIM4, &TIM_TimeBaseStructure);
 800294e:	a901      	add	r1, sp, #4
	PrescalerValue = (uint16_t) (SystemCoreClock / (50000)) - 1;
	/* Time base configuration */
	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
	TIM_TimeBaseStructure.TIM_Period = 1000;
	TIM_TimeBaseStructure.TIM_Prescaler = PrescalerValue;
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
 8002950:	f8ad 300c 	strh.w	r3, [sp, #12]
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
 8002954:	f8ad 3006 	strh.w	r3, [sp, #6]
	TIM_TimeBaseInit(TIM4, &TIM_TimeBaseStructure);
 8002958:	f001 ffaa 	bl	80048b0 <TIM_TimeBaseInit>

	/* TIM3 enable counter */
	TIM_Cmd(TIM4, ENABLE);
 800295c:	4620      	mov	r0, r4
 800295e:	2101      	movs	r1, #1
 8002960:	f002 f84f 	bl	8004a02 <TIM_Cmd>
}
 8002964:	bd1f      	pop	{r0, r1, r2, r3, r4, pc}
 8002966:	bf00      	nop
 8002968:	20000034 	.word	0x20000034
 800296c:	40000800 	.word	0x40000800

08002970 <getEXTI_Config>:

EXTI_InitTypeDef *getEXTI_Config(void)
{
	static EXTI_InitTypeDef   EXTI_InitStructure;
	return &EXTI_InitStructure;
}
 8002970:	4800      	ldr	r0, [pc, #0]	; (8002974 <getEXTI_Config+0x4>)
 8002972:	4770      	bx	lr
 8002974:	200001dc 	.word	0x200001dc

08002978 <EXTI_Configuration>:

void EXTI_Configuration(void)
{
 8002978:	4770      	bx	lr

0800297a <ADC_Configuration>:
}



void ADC_Configuration(void)
{
 800297a:	b5f0      	push	{r4, r5, r6, r7, lr}
 800297c:	b095      	sub	sp, #84	; 0x54

	ADC_InitTypeDef       ADC_InitStructure;
	ADC_CommonInitTypeDef ADC_CommonInitStructure;
	ADC_InjectedInitTypeDef ADC_InjInitStructure;

	ADC_StructInit(&ADC_InitStructure);
 800297e:	a80c      	add	r0, sp, #48	; 0x30
 8002980:	f000 fa14 	bl	8002dac <ADC_StructInit>

	/* Calibration procedure */
	ADC_VoltageRegulatorCmd(ADC2, ENABLE);
 8002984:	2101      	movs	r1, #1
 8002986:	482d      	ldr	r0, [pc, #180]	; (8002a3c <ADC_Configuration+0xc2>)
 8002988:	f000 fa99 	bl	8002ebe <ADC_VoltageRegulatorCmd>

	/* Insert delay equal to 10 s */
	Delay(10);
 800298c:	200a      	movs	r0, #10
 800298e:	f7ff f9f9 	bl	8001d84 <Delay>

	ADC_SelectCalibrationMode(ADC2, ADC_CalibrationMode_Single);
 8002992:	482a      	ldr	r0, [pc, #168]	; (8002a3c <ADC_Configuration+0xc2>)
 8002994:	2100      	movs	r1, #0
 8002996:	f000 fa7e 	bl	8002e96 <ADC_SelectCalibrationMode>
	ADC_StartCalibration(ADC2);
 800299a:	4828      	ldr	r0, [pc, #160]	; (8002a3c <ADC_Configuration+0xc2>)
 800299c:	f000 fa70 	bl	8002e80 <ADC_StartCalibration>

	for (; ADC_GetCalibrationStatus(ADC2) != RESET ;);
 80029a0:	4826      	ldr	r0, [pc, #152]	; (8002a3c <ADC_Configuration+0xc2>)
 80029a2:	f000 fa80 	bl	8002ea6 <ADC_GetCalibrationStatus>
 80029a6:	4604      	mov	r4, r0
 80029a8:	2800      	cmp	r0, #0
 80029aa:	d1f9      	bne.n	80029a0 <ADC_Configuration+0x26>

	#if DEBUG
	calibration_value = ADC_GetCalibrationValue(ADC2);
	#endif

	ADC_CommonInitStructure.ADC_Mode = ADC_Mode_InjSimul;
 80029ac:	2605      	movs	r6, #5
	ADC_CommonInitStructure.ADC_Clock = ADC_Clock_AsynClkMode;
 80029ae:	9001      	str	r0, [sp, #4]
	ADC_CommonInitStructure.ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;
 80029b0:	9002      	str	r0, [sp, #8]
	ADC_CommonInitStructure.ADC_DMAMode = ADC_DMAMode_OneShot;
 80029b2:	9003      	str	r0, [sp, #12]
	ADC_CommonInitStructure.ADC_TwoSamplingDelay = 0;
 80029b4:	f88d 0010 	strb.w	r0, [sp, #16]
	ADC_CommonInit(ADC2, &ADC_CommonInitStructure);
 80029b8:	4669      	mov	r1, sp
 80029ba:	4820      	ldr	r0, [pc, #128]	; (8002a3c <ADC_Configuration+0xc2>)

	#if DEBUG
	calibration_value = ADC_GetCalibrationValue(ADC2);
	#endif

	ADC_CommonInitStructure.ADC_Mode = ADC_Mode_InjSimul;
 80029bc:	9600      	str	r6, [sp, #0]
	ADC_CommonInitStructure.ADC_Clock = ADC_Clock_AsynClkMode;
	ADC_CommonInitStructure.ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;
	ADC_CommonInitStructure.ADC_DMAMode = ADC_DMAMode_OneShot;
	ADC_CommonInitStructure.ADC_TwoSamplingDelay = 0;
	ADC_CommonInit(ADC2, &ADC_CommonInitStructure);
 80029be:	f000 fa1f 	bl	8002e00 <ADC_CommonInit>

	ADC_InitStructure.ADC_ContinuousConvMode = ADC_ContinuousConvMode_Enable;
 80029c2:	f44f 5300 	mov.w	r3, #8192	; 0x2000
	ADC_InitStructure.ADC_ExternalTrigConvEvent = ADC_ExternalTrigConvEvent_0;
	ADC_InitStructure.ADC_ExternalTrigEventEdge = ADC_ExternalTrigEventEdge_None;
	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
	ADC_InitStructure.ADC_OverrunMode = ADC_OverrunMode_Disable;
	ADC_InitStructure.ADC_AutoInjMode = ADC_AutoInjec_Enable;
	ADC_InitStructure.ADC_NbrOfRegChannel = 3;
 80029c6:	2503      	movs	r5, #3
	ADC_CommonInitStructure.ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;
	ADC_CommonInitStructure.ADC_DMAMode = ADC_DMAMode_OneShot;
	ADC_CommonInitStructure.ADC_TwoSamplingDelay = 0;
	ADC_CommonInit(ADC2, &ADC_CommonInitStructure);

	ADC_InitStructure.ADC_ContinuousConvMode = ADC_ContinuousConvMode_Enable;
 80029c8:	930c      	str	r3, [sp, #48]	; 0x30
	ADC_InitStructure.ADC_ExternalTrigEventEdge = ADC_ExternalTrigEventEdge_None;
	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
	ADC_InitStructure.ADC_OverrunMode = ADC_OverrunMode_Disable;
	ADC_InitStructure.ADC_AutoInjMode = ADC_AutoInjec_Enable;
	ADC_InitStructure.ADC_NbrOfRegChannel = 3;
	ADC_Init(ADC2, &ADC_InitStructure);
 80029ca:	481c      	ldr	r0, [pc, #112]	; (8002a3c <ADC_Configuration+0xc2>)
	ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b;
	ADC_InitStructure.ADC_ExternalTrigConvEvent = ADC_ExternalTrigConvEvent_0;
	ADC_InitStructure.ADC_ExternalTrigEventEdge = ADC_ExternalTrigEventEdge_None;
	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
	ADC_InitStructure.ADC_OverrunMode = ADC_OverrunMode_Disable;
	ADC_InitStructure.ADC_AutoInjMode = ADC_AutoInjec_Enable;
 80029cc:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
	ADC_InitStructure.ADC_NbrOfRegChannel = 3;
	ADC_Init(ADC2, &ADC_InitStructure);
 80029d0:	a90c      	add	r1, sp, #48	; 0x30
	ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b;
	ADC_InitStructure.ADC_ExternalTrigConvEvent = ADC_ExternalTrigConvEvent_0;
	ADC_InitStructure.ADC_ExternalTrigEventEdge = ADC_ExternalTrigEventEdge_None;
	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
	ADC_InitStructure.ADC_OverrunMode = ADC_OverrunMode_Disable;
	ADC_InitStructure.ADC_AutoInjMode = ADC_AutoInjec_Enable;
 80029d2:	9312      	str	r3, [sp, #72]	; 0x48
	ADC_CommonInitStructure.ADC_DMAMode = ADC_DMAMode_OneShot;
	ADC_CommonInitStructure.ADC_TwoSamplingDelay = 0;
	ADC_CommonInit(ADC2, &ADC_CommonInitStructure);

	ADC_InitStructure.ADC_ContinuousConvMode = ADC_ContinuousConvMode_Enable;
	ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b;
 80029d4:	940d      	str	r4, [sp, #52]	; 0x34
	ADC_InitStructure.ADC_ExternalTrigConvEvent = ADC_ExternalTrigConvEvent_0;
 80029d6:	940e      	str	r4, [sp, #56]	; 0x38
	ADC_InitStructure.ADC_ExternalTrigEventEdge = ADC_ExternalTrigEventEdge_None;
 80029d8:	940f      	str	r4, [sp, #60]	; 0x3c
	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
 80029da:	9410      	str	r4, [sp, #64]	; 0x40
	ADC_InitStructure.ADC_OverrunMode = ADC_OverrunMode_Disable;
 80029dc:	9411      	str	r4, [sp, #68]	; 0x44

	ADC_InjInitStructure.ADC_ExternalTrigInjecConvEvent = ADC_ExternalTrigInjecConvEvent_0;
	ADC_InjInitStructure.ADC_ExternalTrigInjecEventEdge = ADC_ExternalTrigInjecEventEdge_None;
	ADC_InjInitStructure.ADC_NbrOfInjecChannel = 3;
	ADC_InjInitStructure.ADC_InjecSequence1 = ADC_Channel_5;
	ADC_InjInitStructure.ADC_InjecSequence2 = ADC_Channel_11;
 80029de:	270b      	movs	r7, #11
	ADC_InitStructure.ADC_ExternalTrigConvEvent = ADC_ExternalTrigConvEvent_0;
	ADC_InitStructure.ADC_ExternalTrigEventEdge = ADC_ExternalTrigEventEdge_None;
	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
	ADC_InitStructure.ADC_OverrunMode = ADC_OverrunMode_Disable;
	ADC_InitStructure.ADC_AutoInjMode = ADC_AutoInjec_Enable;
	ADC_InitStructure.ADC_NbrOfRegChannel = 3;
 80029e0:	f88d 504c 	strb.w	r5, [sp, #76]	; 0x4c
	ADC_Init(ADC2, &ADC_InitStructure);
 80029e4:	f000 f9c4 	bl	8002d70 <ADC_Init>

	ADC_InjInitStructure.ADC_ExternalTrigInjecConvEvent = ADC_ExternalTrigInjecConvEvent_0;
 80029e8:	9405      	str	r4, [sp, #20]
	ADC_InjInitStructure.ADC_ExternalTrigInjecEventEdge = ADC_ExternalTrigInjecEventEdge_None;
 80029ea:	9406      	str	r4, [sp, #24]
	ADC_InjInitStructure.ADC_NbrOfInjecChannel = 3;
	ADC_InjInitStructure.ADC_InjecSequence1 = ADC_Channel_5;
	ADC_InjInitStructure.ADC_InjecSequence2 = ADC_Channel_11;
	ADC_InjInitStructure.ADC_InjecSequence3 = ADC_Channel_12;
	ADC_InjectedInit(ADC2, &ADC_InjInitStructure);
 80029ec:	4813      	ldr	r0, [pc, #76]	; (8002a3c <ADC_Configuration+0xc2>)
	ADC_InjInitStructure.ADC_ExternalTrigInjecConvEvent = ADC_ExternalTrigInjecConvEvent_0;
	ADC_InjInitStructure.ADC_ExternalTrigInjecEventEdge = ADC_ExternalTrigInjecEventEdge_None;
	ADC_InjInitStructure.ADC_NbrOfInjecChannel = 3;
	ADC_InjInitStructure.ADC_InjecSequence1 = ADC_Channel_5;
	ADC_InjInitStructure.ADC_InjecSequence2 = ADC_Channel_11;
	ADC_InjInitStructure.ADC_InjecSequence3 = ADC_Channel_12;
 80029ee:	240c      	movs	r4, #12
	ADC_InjectedInit(ADC2, &ADC_InjInitStructure);
 80029f0:	a905      	add	r1, sp, #20
	ADC_InitStructure.ADC_NbrOfRegChannel = 3;
	ADC_Init(ADC2, &ADC_InitStructure);

	ADC_InjInitStructure.ADC_ExternalTrigInjecConvEvent = ADC_ExternalTrigInjecConvEvent_0;
	ADC_InjInitStructure.ADC_ExternalTrigInjecEventEdge = ADC_ExternalTrigInjecEventEdge_None;
	ADC_InjInitStructure.ADC_NbrOfInjecChannel = 3;
 80029f2:	f88d 501c 	strb.w	r5, [sp, #28]
	ADC_InjInitStructure.ADC_InjecSequence1 = ADC_Channel_5;
 80029f6:	9608      	str	r6, [sp, #32]
	ADC_InjInitStructure.ADC_InjecSequence2 = ADC_Channel_11;
 80029f8:	9709      	str	r7, [sp, #36]	; 0x24
	ADC_InjInitStructure.ADC_InjecSequence3 = ADC_Channel_12;
 80029fa:	940a      	str	r4, [sp, #40]	; 0x28
	ADC_InjectedInit(ADC2, &ADC_InjInitStructure);
 80029fc:	f000 f9e1 	bl	8002dc2 <ADC_InjectedInit>

	/* ADC1 regular channel7 configuration */
	//ADC_RegularChannelConfig(ADC2, ADC_Channel_5, 1, ADC_SampleTime_7Cycles5);
	ADC_InjectedChannelSampleTimeConfig(ADC2, ADC_Channel_5, ADC_SampleTime_7Cycles5);
 8002a00:	480e      	ldr	r0, [pc, #56]	; (8002a3c <ADC_Configuration+0xc2>)
 8002a02:	4631      	mov	r1, r6
 8002a04:	462a      	mov	r2, r5
 8002a06:	f000 fc56 	bl	80032b6 <ADC_InjectedChannelSampleTimeConfig>
	ADC_InjectedChannelSampleTimeConfig(ADC2, ADC_Channel_11,ADC_SampleTime_7Cycles5);
 8002a0a:	480c      	ldr	r0, [pc, #48]	; (8002a3c <ADC_Configuration+0xc2>)
 8002a0c:	4639      	mov	r1, r7
 8002a0e:	462a      	mov	r2, r5
 8002a10:	f000 fc51 	bl	80032b6 <ADC_InjectedChannelSampleTimeConfig>
	ADC_InjectedChannelSampleTimeConfig(ADC2, ADC_Channel_12,ADC_SampleTime_7Cycles5);
 8002a14:	4809      	ldr	r0, [pc, #36]	; (8002a3c <ADC_Configuration+0xc2>)
 8002a16:	4621      	mov	r1, r4
 8002a18:	462a      	mov	r2, r5
 8002a1a:	f000 fc4c 	bl	80032b6 <ADC_InjectedChannelSampleTimeConfig>

	/* Enable ADC1 */
	ADC_Cmd(ADC2, ENABLE);
 8002a1e:	4807      	ldr	r0, [pc, #28]	; (8002a3c <ADC_Configuration+0xc2>)
 8002a20:	2101      	movs	r1, #1
 8002a22:	f000 fa24 	bl	8002e6e <ADC_Cmd>

	/* wait for ADRDY */
	while(!ADC_GetFlagStatus(ADC2, ADC_FLAG_RDY));
 8002a26:	4805      	ldr	r0, [pc, #20]	; (8002a3c <ADC_Configuration+0xc2>)
 8002a28:	2101      	movs	r1, #1
 8002a2a:	f000 fc9f 	bl	800336c <ADC_GetFlagStatus>
 8002a2e:	2800      	cmp	r0, #0
 8002a30:	d0f9      	beq.n	8002a26 <ADC_Configuration+0xac>

	/* Start ADC1 Software Conversion */
	ADC_StartConversion(ADC2);
 8002a32:	4802      	ldr	r0, [pc, #8]	; (8002a3c <ADC_Configuration+0xc2>)
 8002a34:	f000 fb8e 	bl	8003154 <ADC_StartConversion>

}
 8002a38:	b015      	add	sp, #84	; 0x54
 8002a3a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002a3c:	50000100 	.word	0x50000100

08002a40 <NMI_Handler>:
  * @brief  This function handles NMI exception.
  * @param  None
  * @retval None
  */
void NMI_Handler(void)
{
 8002a40:	4770      	bx	lr

08002a42 <HardFault_Handler>:
  * @brief  This function handles Hard Fault exception.
  * @param  None
  * @retval None
  */
void HardFault_Handler(void)
{
 8002a42:	e7fe      	b.n	8002a42 <HardFault_Handler>

08002a44 <MemManage_Handler>:
  * @brief  This function handles Memory Manage exception.
  * @param  None
  * @retval None
  */
void MemManage_Handler(void)
{
 8002a44:	e7fe      	b.n	8002a44 <MemManage_Handler>

08002a46 <BusFault_Handler>:
  * @brief  This function handles Bus Fault exception.
  * @param  None
  * @retval None
  */
void BusFault_Handler(void)
{
 8002a46:	e7fe      	b.n	8002a46 <BusFault_Handler>

08002a48 <UsageFault_Handler>:
  * @brief  This function handles Usage Fault exception.
  * @param  None
  * @retval None
  */
void UsageFault_Handler(void)
{
 8002a48:	e7fe      	b.n	8002a48 <UsageFault_Handler>

08002a4a <DebugMon_Handler>:
  * @brief  This function handles Debug Monitor exception.
  * @param  None
  * @retval None
  */
void DebugMon_Handler(void)
{
 8002a4a:	4770      	bx	lr

08002a4c <USART3_IRQHandler>:
/*! ***************************************************************************
 *    USART3 Interrupt
 *   Dient zur schnellen bertragung der aktuellen Telemetriedaten
 *  ************************************************************************ */
void USART3_IRQHandler(void)
{
 8002a4c:	b508      	push	{r3, lr}
	// TODO: Timeout for Receive-Datas
	/* Receive Data register not empty interrupt */
	if(USART_GetITStatus(USART3, USART_IT_RXNE) != RESET)
 8002a4e:	482a      	ldr	r0, [pc, #168]	; (8002af8 <USART3_IRQHandler+0xac>)
 8002a50:	492a      	ldr	r1, [pc, #168]	; (8002afc <USART3_IRQHandler+0xb0>)
 8002a52:	f002 fe72 	bl	800573a <USART_GetITStatus>
 8002a56:	b328      	cbz	r0, 8002aa4 <USART3_IRQHandler+0x58>
	{
		char Data = USART_ReceiveData(USART3);
 8002a58:	4827      	ldr	r0, [pc, #156]	; (8002af8 <USART3_IRQHandler+0xac>)
 8002a5a:	f002 fd8e 	bl	800557a <USART_ReceiveData>

		if (It_Com.rxready == 0) {
 8002a5e:	4b28      	ldr	r3, [pc, #160]	; (8002b00 <USART3_IRQHandler+0xb4>)
 8002a60:	f8d3 1200 	ldr.w	r1, [r3, #512]	; 0x200
 8002a64:	b9d1      	cbnz	r1, 8002a9c <USART3_IRQHandler+0x50>
			It_Com.rxbuffer[It_Com.rxcnt] = Data;
 8002a66:	f8d3 2208 	ldr.w	r2, [r3, #520]	; 0x208
{
	// TODO: Timeout for Receive-Datas
	/* Receive Data register not empty interrupt */
	if(USART_GetITStatus(USART3, USART_IT_RXNE) != RESET)
	{
		char Data = USART_ReceiveData(USART3);
 8002a6a:	b2c0      	uxtb	r0, r0

		if (It_Com.rxready == 0) {
			It_Com.rxbuffer[It_Com.rxcnt] = Data;
			switch (It_Com.rxcnt) {
 8002a6c:	2a01      	cmp	r2, #1
	if(USART_GetITStatus(USART3, USART_IT_RXNE) != RESET)
	{
		char Data = USART_ReceiveData(USART3);

		if (It_Com.rxready == 0) {
			It_Com.rxbuffer[It_Com.rxcnt] = Data;
 8002a6e:	5498      	strb	r0, [r3, r2]
			switch (It_Com.rxcnt) {
 8002a70:	d007      	beq.n	8002a82 <USART3_IRQHandler+0x36>
 8002a72:	d302      	bcc.n	8002a7a <USART3_IRQHandler+0x2e>
 8002a74:	2a0f      	cmp	r2, #15
 8002a76:	d10e      	bne.n	8002a96 <USART3_IRQHandler+0x4a>
 8002a78:	e007      	b.n	8002a8a <USART3_IRQHandler+0x3e>
				/* Header LOW */
				case 0:
					if (It_Com.rxbuffer[It_Com.rxcnt] == 0xff) It_Com.rxcnt++;
 8002a7a:	28ff      	cmp	r0, #255	; 0xff
 8002a7c:	d108      	bne.n	8002a90 <USART3_IRQHandler+0x44>
 8002a7e:	2201      	movs	r2, #1
 8002a80:	e00a      	b.n	8002a98 <USART3_IRQHandler+0x4c>
					else It_Com.rxcnt = 0;
					break;
				/* Header High */
				case 1:
					if (It_Com.rxbuffer[It_Com.rxcnt] == 0x7F) It_Com.rxcnt++;
 8002a82:	287f      	cmp	r0, #127	; 0x7f
 8002a84:	d104      	bne.n	8002a90 <USART3_IRQHandler+0x44>
 8002a86:	2202      	movs	r2, #2
 8002a88:	e006      	b.n	8002a98 <USART3_IRQHandler+0x4c>
					else It_Com.rxcnt = 0;
					break;
				case 15:
					It_Com.rxready = 1;
 8002a8a:	2201      	movs	r2, #1
 8002a8c:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
					It_Com.rxcnt = 0;
 8002a90:	f8c3 1208 	str.w	r1, [r3, #520]	; 0x208
					break;
 8002a94:	e002      	b.n	8002a9c <USART3_IRQHandler+0x50>
				default:
					It_Com.rxcnt ++;
 8002a96:	3201      	adds	r2, #1
 8002a98:	f8c3 2208 	str.w	r2, [r3, #520]	; 0x208
					break;
			}
		}
	    USART_ClearFlag(USART3, USART_IT_RXNE);
 8002a9c:	4816      	ldr	r0, [pc, #88]	; (8002af8 <USART3_IRQHandler+0xac>)
 8002a9e:	4917      	ldr	r1, [pc, #92]	; (8002afc <USART3_IRQHandler+0xb0>)
 8002aa0:	f002 fe49 	bl	8005736 <USART_ClearFlag>
	}

	// Transmit Data Register empty interrupt
    if(USART_GetITStatus(USART3, USART_IT_TXE) != RESET)
 8002aa4:	4814      	ldr	r0, [pc, #80]	; (8002af8 <USART3_IRQHandler+0xac>)
 8002aa6:	4917      	ldr	r1, [pc, #92]	; (8002b04 <USART3_IRQHandler+0xb8>)
 8002aa8:	f002 fe47 	bl	800573a <USART_GetITStatus>
 8002aac:	b1f0      	cbz	r0, 8002aec <USART3_IRQHandler+0xa0>
  	{
  		USART_ClearITPendingBit(USART3, USART_IT_TXE);
 8002aae:	4915      	ldr	r1, [pc, #84]	; (8002b04 <USART3_IRQHandler+0xb8>)
 8002ab0:	4811      	ldr	r0, [pc, #68]	; (8002af8 <USART3_IRQHandler+0xac>)
 8002ab2:	f002 fe5f 	bl	8005774 <USART_ClearITPendingBit>

  		//if(ModbusData.txcnt <= ModbusData.txlen)
  		if(It_Com.txcnt <= (It_Com.txlen-1))
 8002ab6:	4b12      	ldr	r3, [pc, #72]	; (8002b00 <USART3_IRQHandler+0xb4>)
 8002ab8:	f8d3 1210 	ldr.w	r1, [r3, #528]	; 0x210
 8002abc:	f8d3 220c 	ldr.w	r2, [r3, #524]	; 0x20c
 8002ac0:	3901      	subs	r1, #1
 8002ac2:	428a      	cmp	r2, r1
 8002ac4:	d809      	bhi.n	8002ada <USART3_IRQHandler+0x8e>
  		{
            USART_SendData(USART3,It_Com.txbuffer[It_Com.txcnt++]);
 8002ac6:	1899      	adds	r1, r3, r2
 8002ac8:	f891 1100 	ldrb.w	r1, [r1, #256]	; 0x100
 8002acc:	3201      	adds	r2, #1
 8002ace:	480a      	ldr	r0, [pc, #40]	; (8002af8 <USART3_IRQHandler+0xac>)
 8002ad0:	f8c3 220c 	str.w	r2, [r3, #524]	; 0x20c
 8002ad4:	f002 fd4d 	bl	8005572 <USART_SendData>
 8002ad8:	e008      	b.n	8002aec <USART3_IRQHandler+0xa0>
  		}
  		else
  		{
  			It_Com.txcnt = 0;
 8002ada:	2200      	movs	r2, #0
  			It_Com.txready = 0;
  		    //USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);
  		    USART_ITConfig(USART3, USART_IT_TXE, DISABLE);
 8002adc:	4806      	ldr	r0, [pc, #24]	; (8002af8 <USART3_IRQHandler+0xac>)
 8002ade:	4909      	ldr	r1, [pc, #36]	; (8002b04 <USART3_IRQHandler+0xb8>)
  		{
            USART_SendData(USART3,It_Com.txbuffer[It_Com.txcnt++]);
  		}
  		else
  		{
  			It_Com.txcnt = 0;
 8002ae0:	f8c3 220c 	str.w	r2, [r3, #524]	; 0x20c
  			It_Com.txready = 0;
 8002ae4:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
  		    //USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);
  		    USART_ITConfig(USART3, USART_IT_TXE, DISABLE);
 8002ae8:	f002 fdf8 	bl	80056dc <USART_ITConfig>
  		}
  	}
	USART_ClearITPendingBit(USART3, USART_IT_RXNE);
 8002aec:	4802      	ldr	r0, [pc, #8]	; (8002af8 <USART3_IRQHandler+0xac>)
 8002aee:	4903      	ldr	r1, [pc, #12]	; (8002afc <USART3_IRQHandler+0xb0>)
}
 8002af0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  			It_Com.txready = 0;
  		    //USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);
  		    USART_ITConfig(USART3, USART_IT_TXE, DISABLE);
  		}
  	}
	USART_ClearITPendingBit(USART3, USART_IT_RXNE);
 8002af4:	f002 be3e 	b.w	8005774 <USART_ClearITPendingBit>
 8002af8:	40004800 	.word	0x40004800
 8002afc:	00050105 	.word	0x00050105
 8002b00:	20002c98 	.word	0x20002c98
 8002b04:	00070107 	.word	0x00070107

08002b08 <USART2_IRQHandler>:
}

/*USART Reception*/
void USART2_IRQHandler(void)
{
 8002b08:	b538      	push	{r3, r4, r5, lr}
	static unsigned char rxBuffer[5];
	static uint8_t i = 0;

	if(USART_GetITStatus(USART2, USART_IT_RXNE) != RESET)
 8002b0a:	4816      	ldr	r0, [pc, #88]	; (8002b64 <USART2_IRQHandler+0x5c>)
 8002b0c:	4916      	ldr	r1, [pc, #88]	; (8002b68 <USART2_IRQHandler+0x60>)
 8002b0e:	f002 fe14 	bl	800573a <USART_GetITStatus>
 8002b12:	b1e0      	cbz	r0, 8002b4e <USART2_IRQHandler+0x46>
	{
		/* Read one byte from the receive data register */
		rxBuffer[i] = USART_ReceiveData(USART2);
 8002b14:	4c15      	ldr	r4, [pc, #84]	; (8002b6c <USART2_IRQHandler+0x64>)
 8002b16:	4813      	ldr	r0, [pc, #76]	; (8002b64 <USART2_IRQHandler+0x5c>)
 8002b18:	7825      	ldrb	r5, [r4, #0]
 8002b1a:	f002 fd2e 	bl	800557a <USART_ReceiveData>
		if(i >= 4)
 8002b1e:	7823      	ldrb	r3, [r4, #0]
	static uint8_t i = 0;

	if(USART_GetITStatus(USART2, USART_IT_RXNE) != RESET)
	{
		/* Read one byte from the receive data register */
		rxBuffer[i] = USART_ReceiveData(USART2);
 8002b20:	1965      	adds	r5, r4, r5
		if(i >= 4)
 8002b22:	2b03      	cmp	r3, #3
	static uint8_t i = 0;

	if(USART_GetITStatus(USART2, USART_IT_RXNE) != RESET)
	{
		/* Read one byte from the receive data register */
		rxBuffer[i] = USART_ReceiveData(USART2);
 8002b24:	7068      	strb	r0, [r5, #1]
		if(i >= 4)
 8002b26:	d905      	bls.n	8002b34 <USART2_IRQHandler+0x2c>
		{
			//xQueueSendFromISR( usartRxQueue, &msgPointer, &xYieldRequired );
			CalcRXValues(&rxBuffer[0], 55);
 8002b28:	1c60      	adds	r0, r4, #1
 8002b2a:	2137      	movs	r1, #55	; 0x37
 8002b2c:	f7ff fb96 	bl	800225c <CalcRXValues>
			i = 0;
 8002b30:	2300      	movs	r3, #0
 8002b32:	e003      	b.n	8002b3c <USART2_IRQHandler+0x34>
		}
		else
		{
			if(rxBuffer[0] == 'A')
 8002b34:	7862      	ldrb	r2, [r4, #1]
 8002b36:	2a41      	cmp	r2, #65	; 0x41
 8002b38:	d102      	bne.n	8002b40 <USART2_IRQHandler+0x38>
			{
				i++;
 8002b3a:	3301      	adds	r3, #1
 8002b3c:	7023      	strb	r3, [r4, #0]
 8002b3e:	e006      	b.n	8002b4e <USART2_IRQHandler+0x46>
			}
			else
			{
				i = 0;
 8002b40:	2300      	movs	r3, #0
 8002b42:	7023      	strb	r3, [r4, #0]
				rxBuffer[0] = 0;
 8002b44:	7063      	strb	r3, [r4, #1]
				rxBuffer[1] = 0;
 8002b46:	70a3      	strb	r3, [r4, #2]
				rxBuffer[2] = 0;
 8002b48:	70e3      	strb	r3, [r4, #3]
				rxBuffer[3] = 0;
 8002b4a:	7123      	strb	r3, [r4, #4]
				rxBuffer[4] = 0;
 8002b4c:	7163      	strb	r3, [r4, #5]
			}
		}
	}
	USART_ClearITPendingBit(USART2, USART_IT_RXNE);
 8002b4e:	4805      	ldr	r0, [pc, #20]	; (8002b64 <USART2_IRQHandler+0x5c>)
 8002b50:	4905      	ldr	r1, [pc, #20]	; (8002b68 <USART2_IRQHandler+0x60>)
 8002b52:	f002 fe0f 	bl	8005774 <USART_ClearITPendingBit>
	USART_ClearFlag(USART2, USART_IT_RXNE);
 8002b56:	4803      	ldr	r0, [pc, #12]	; (8002b64 <USART2_IRQHandler+0x5c>)
 8002b58:	4903      	ldr	r1, [pc, #12]	; (8002b68 <USART2_IRQHandler+0x60>)
}
 8002b5a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
				rxBuffer[4] = 0;
			}
		}
	}
	USART_ClearITPendingBit(USART2, USART_IT_RXNE);
	USART_ClearFlag(USART2, USART_IT_RXNE);
 8002b5e:	f002 bdea 	b.w	8005736 <USART_ClearFlag>
 8002b62:	bf00      	nop
 8002b64:	40004400 	.word	0x40004400
 8002b68:	00050105 	.word	0x00050105
 8002b6c:	200001e4 	.word	0x200001e4

08002b70 <disableEXTI>:
}

void disableEXTI(uint32_t EXTINr)
{
 8002b70:	b510      	push	{r4, lr}
 8002b72:	4604      	mov	r4, r0
	getEXTI_Config()->EXTI_Line = EXTINr;
 8002b74:	f7ff fefc 	bl	8002970 <getEXTI_Config>
 8002b78:	6004      	str	r4, [r0, #0]
	getEXTI_Config()->EXTI_LineCmd = DISABLE;
 8002b7a:	f7ff fef9 	bl	8002970 <getEXTI_Config>
 8002b7e:	2300      	movs	r3, #0
 8002b80:	7183      	strb	r3, [r0, #6]
	EXTI_Init(getEXTI_Config());
 8002b82:	f7ff fef5 	bl	8002970 <getEXTI_Config>
}
 8002b86:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

void disableEXTI(uint32_t EXTINr)
{
	getEXTI_Config()->EXTI_Line = EXTINr;
	getEXTI_Config()->EXTI_LineCmd = DISABLE;
	EXTI_Init(getEXTI_Config());
 8002b8a:	f000 bd39 	b.w	8003600 <EXTI_Init>

08002b8e <enableEXTI>:
}

void enableEXTI(uint32_t EXTINr)
{
 8002b8e:	b510      	push	{r4, lr}
 8002b90:	4604      	mov	r4, r0
	getEXTI_Config()->EXTI_Line = EXTINr;
 8002b92:	f7ff feed 	bl	8002970 <getEXTI_Config>
 8002b96:	6004      	str	r4, [r0, #0]
	getEXTI_Config()->EXTI_LineCmd = ENABLE;
 8002b98:	f7ff feea 	bl	8002970 <getEXTI_Config>
 8002b9c:	2301      	movs	r3, #1
 8002b9e:	7183      	strb	r3, [r0, #6]
	EXTI_Init(getEXTI_Config());
 8002ba0:	f7ff fee6 	bl	8002970 <getEXTI_Config>
}
 8002ba4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

void enableEXTI(uint32_t EXTINr)
{
	getEXTI_Config()->EXTI_Line = EXTINr;
	getEXTI_Config()->EXTI_LineCmd = ENABLE;
	EXTI_Init(getEXTI_Config());
 8002ba8:	f000 bd2a 	b.w	8003600 <EXTI_Init>

08002bac <EXTI15_10_IRQHandler>:
}

/* Interupt Handlers */
void EXTI15_10_IRQHandler(void)
{
 8002bac:	4770      	bx	lr
 8002bae:	bf00      	nop

08002bb0 <Usart2Put>:
#include <stm32f30x.h>
#include <stm32f30x_conf.h>
#include <usart.h>

void Usart2Put(uint8_t ch)
{
 8002bb0:	4601      	mov	r1, r0
 8002bb2:	b508      	push	{r3, lr}
      USART_SendData(USART2, (uint8_t) ch);
 8002bb4:	4804      	ldr	r0, [pc, #16]	; (8002bc8 <Usart2Put+0x18>)
 8002bb6:	f002 fcdc 	bl	8005572 <USART_SendData>
      //Loop until the end of transmission
      while(USART_GetFlagStatus(USART2, USART_FLAG_TC) == RESET)
 8002bba:	4803      	ldr	r0, [pc, #12]	; (8002bc8 <Usart2Put+0x18>)
 8002bbc:	2140      	movs	r1, #64	; 0x40
 8002bbe:	f002 fdb4 	bl	800572a <USART_GetFlagStatus>
 8002bc2:	2800      	cmp	r0, #0
 8002bc4:	d0f9      	beq.n	8002bba <Usart2Put+0xa>
      {
      }
}
 8002bc6:	bd08      	pop	{r3, pc}
 8002bc8:	40004400 	.word	0x40004400

08002bcc <Usart3Put>:
/*
 * USART3 use Interrupt
 * */

void Usart3Put(uint8_t ch)
{
 8002bcc:	4601      	mov	r1, r0
 8002bce:	b508      	push	{r3, lr}
      USART_SendData(USART3, (uint8_t) ch);
 8002bd0:	4804      	ldr	r0, [pc, #16]	; (8002be4 <Usart3Put+0x18>)
 8002bd2:	f002 fcce 	bl	8005572 <USART_SendData>
      //Loop until the end of transmission
      while(USART_GetFlagStatus(USART3, USART_FLAG_TC) == RESET)
 8002bd6:	4803      	ldr	r0, [pc, #12]	; (8002be4 <Usart3Put+0x18>)
 8002bd8:	2140      	movs	r1, #64	; 0x40
 8002bda:	f002 fda6 	bl	800572a <USART_GetFlagStatus>
 8002bde:	2800      	cmp	r0, #0
 8002be0:	d0f9      	beq.n	8002bd6 <Usart3Put+0xa>
      {
      }
}
 8002be2:	bd08      	pop	{r3, pc}
 8002be4:	40004800 	.word	0x40004800

08002be8 <Usart3Get>:

uint8_t Usart3Get(){
 8002be8:	b508      	push	{r3, lr}
	uint8_t ch;
	while(USART_GetFlagStatus(USART3, USART_FLAG_RXNE) == RESET)
 8002bea:	4805      	ldr	r0, [pc, #20]	; (8002c00 <Usart3Get+0x18>)
 8002bec:	2120      	movs	r1, #32
 8002bee:	f002 fd9c 	bl	800572a <USART_GetFlagStatus>
 8002bf2:	2800      	cmp	r0, #0
 8002bf4:	d0f9      	beq.n	8002bea <Usart3Get+0x2>
	{
	}
	ch = USART_ReceiveData(USART3);
 8002bf6:	4802      	ldr	r0, [pc, #8]	; (8002c00 <Usart3Get+0x18>)
 8002bf8:	f002 fcbf 	bl	800557a <USART_ReceiveData>
	return ch;
}
 8002bfc:	b2c0      	uxtb	r0, r0
 8002bfe:	bd08      	pop	{r3, pc}
 8002c00:	40004800 	.word	0x40004800

08002c04 <SendBufferedDataFrame>:

void SendBufferedDataFrame(USART_OBJ* It_Data ,void* Header, void* Value1, void* Value2, void* Value3, uint32_t Bufferdeep){
 8002c04:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002c06:	9c06      	ldr	r4, [sp, #24]

	if (Bufferdeep < 1) {
		Bufferdeep = 1;
	}

	if (loopcnt < (Bufferdeep-1)) {
 8002c08:	4e15      	ldr	r6, [pc, #84]	; (8002c60 <SendBufferedDataFrame+0x5c>)
void SendBufferedDataFrame(USART_OBJ* It_Data ,void* Header, void* Value1, void* Value2, void* Value3, uint32_t Bufferdeep){
	uint32_t offset;
	static uint32_t loopcnt = 0;

	if (Bufferdeep < 1) {
		Bufferdeep = 1;
 8002c0a:	2c00      	cmp	r4, #0
 8002c0c:	bf08      	it	eq
 8002c0e:	2401      	moveq	r4, #1
	}

	if (loopcnt < (Bufferdeep-1)) {
 8002c10:	6835      	ldr	r5, [r6, #0]
 8002c12:	3c01      	subs	r4, #1
 8002c14:	6809      	ldr	r1, [r1, #0]
 8002c16:	42a5      	cmp	r5, r4
 8002c18:	ea4f 1405 	mov.w	r4, r5, lsl #4
		offset = loopcnt * 16;
		memcpy(&It_Data->txbuffer[offset + 0], Header, 4); // 0xFF7F3F1F => 4286529311 => [255][127][63][31]Header
 8002c1c:	f504 7c80 	add.w	ip, r4, #256	; 0x100
 8002c20:	f840 100c 	str.w	r1, [r0, ip]
		memcpy(&It_Data->txbuffer[offset + 4], Value1, 4);
 8002c24:	6812      	ldr	r2, [r2, #0]
 8002c26:	f504 7182 	add.w	r1, r4, #260	; 0x104
 8002c2a:	5042      	str	r2, [r0, r1]
		memcpy(&It_Data->txbuffer[offset + 8], Value2, 4);
 8002c2c:	681b      	ldr	r3, [r3, #0]
 8002c2e:	f504 7284 	add.w	r2, r4, #264	; 0x108
	}
	ch = USART_ReceiveData(USART3);
	return ch;
}

void SendBufferedDataFrame(USART_OBJ* It_Data ,void* Header, void* Value1, void* Value2, void* Value3, uint32_t Bufferdeep){
 8002c32:	9f05      	ldr	r7, [sp, #20]

	if (loopcnt < (Bufferdeep-1)) {
		offset = loopcnt * 16;
		memcpy(&It_Data->txbuffer[offset + 0], Header, 4); // 0xFF7F3F1F => 4286529311 => [255][127][63][31]Header
		memcpy(&It_Data->txbuffer[offset + 4], Value1, 4);
		memcpy(&It_Data->txbuffer[offset + 8], Value2, 4);
 8002c34:	5083      	str	r3, [r0, r2]
		memcpy(&It_Data->txbuffer[offset + 12], Value3, 4);
 8002c36:	683b      	ldr	r3, [r7, #0]
 8002c38:	f504 7486 	add.w	r4, r4, #268	; 0x10c
 8002c3c:	5103      	str	r3, [r0, r4]
		loopcnt++;
 8002c3e:	f105 0501 	add.w	r5, r5, #1

	if (Bufferdeep < 1) {
		Bufferdeep = 1;
	}

	if (loopcnt < (Bufferdeep-1)) {
 8002c42:	d201      	bcs.n	8002c48 <SendBufferedDataFrame+0x44>
		offset = loopcnt * 16;
		memcpy(&It_Data->txbuffer[offset + 0], Header, 4); // 0xFF7F3F1F => 4286529311 => [255][127][63][31]Header
		memcpy(&It_Data->txbuffer[offset + 4], Value1, 4);
		memcpy(&It_Data->txbuffer[offset + 8], Value2, 4);
		memcpy(&It_Data->txbuffer[offset + 12], Value3, 4);
		loopcnt++;
 8002c44:	6035      	str	r5, [r6, #0]
 8002c46:	bdf0      	pop	{r4, r5, r6, r7, pc}
		offset = loopcnt * 16;
		memcpy(&It_Data->txbuffer[offset + 0], Header, 4); // 0xFF7F3F1F => 4286529311 => [255][127][63][31]Header
		memcpy(&It_Data->txbuffer[offset + 4], Value1, 4);
		memcpy(&It_Data->txbuffer[offset + 8], Value2, 4);
		memcpy(&It_Data->txbuffer[offset + 12], Value3, 4);
		It_Data->txlen = (loopcnt+1)*16;
 8002c48:	012d      	lsls	r5, r5, #4
 8002c4a:	f8c0 5210 	str.w	r5, [r0, #528]	; 0x210
		loopcnt = 0;
		USART_ITConfig(USART3, USART_IT_TXE, ENABLE);
 8002c4e:	4905      	ldr	r1, [pc, #20]	; (8002c64 <SendBufferedDataFrame+0x60>)
 8002c50:	4805      	ldr	r0, [pc, #20]	; (8002c68 <SendBufferedDataFrame+0x64>)
		memcpy(&It_Data->txbuffer[offset + 0], Header, 4); // 0xFF7F3F1F => 4286529311 => [255][127][63][31]Header
		memcpy(&It_Data->txbuffer[offset + 4], Value1, 4);
		memcpy(&It_Data->txbuffer[offset + 8], Value2, 4);
		memcpy(&It_Data->txbuffer[offset + 12], Value3, 4);
		It_Data->txlen = (loopcnt+1)*16;
		loopcnt = 0;
 8002c52:	2300      	movs	r3, #0
		USART_ITConfig(USART3, USART_IT_TXE, ENABLE);
 8002c54:	2201      	movs	r2, #1
		memcpy(&It_Data->txbuffer[offset + 0], Header, 4); // 0xFF7F3F1F => 4286529311 => [255][127][63][31]Header
		memcpy(&It_Data->txbuffer[offset + 4], Value1, 4);
		memcpy(&It_Data->txbuffer[offset + 8], Value2, 4);
		memcpy(&It_Data->txbuffer[offset + 12], Value3, 4);
		It_Data->txlen = (loopcnt+1)*16;
		loopcnt = 0;
 8002c56:	6033      	str	r3, [r6, #0]
		USART_ITConfig(USART3, USART_IT_TXE, ENABLE);
	}
}
 8002c58:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		memcpy(&It_Data->txbuffer[offset + 4], Value1, 4);
		memcpy(&It_Data->txbuffer[offset + 8], Value2, 4);
		memcpy(&It_Data->txbuffer[offset + 12], Value3, 4);
		It_Data->txlen = (loopcnt+1)*16;
		loopcnt = 0;
		USART_ITConfig(USART3, USART_IT_TXE, ENABLE);
 8002c5c:	f002 bd3e 	b.w	80056dc <USART_ITConfig>
 8002c60:	200001ec 	.word	0x200001ec
 8002c64:	00070107 	.word	0x00070107
 8002c68:	40004800 	.word	0x40004800

08002c6c <SETTINGS_init>:
{
	settings->gyroSensTreshold = 20;
	settings->gyroDir.sensDirection[sensX] = -1;
	settings->gyroDir.sensDirection[sensY] = -1;
	settings->gyroDir.sensDirection[sensZ] = 1;
	settings->gyroDir.sensOrder[sensX] = 0;
 8002c6c:	2200      	movs	r2, #0
 8002c6e:	7102      	strb	r2, [r0, #4]
	settings->enableACC = 1;
	settings->accDir.sensDirection[sensX] = -1;
	settings->accDir.sensDirection[sensY] = -1;
	settings->accDir.sensDirection[sensZ] = 1;
	settings->accDir.sensOrder[sensX] = 2;
	settings->accDir.sensOrder[sensY] = 0;
 8002c70:	7342      	strb	r2, [r0, #13]
	settings->accDir.sensOrder[sensZ] = 1;
	settings->accMaxGOverflow = 1.3;

	settings->enableMAG = 0;
 8002c72:	7602      	strb	r2, [r0, #24]
	settings->magLowpassValue = 5;//20;
	settings->magDir.sensDirection[sensX] = 1;
	settings->magDir.sensDirection[sensY] = -1;
	settings->magDir.sensDirection[sensZ] = 1;
	settings->magDir.sensOrder[sensX] = 0;
 8002c74:	7642      	strb	r2, [r0, #25]
	settings->magDir.sensOrder[sensY] = 1;
	settings->magDir.sensOrder[sensZ] = 2;

	settings->stopSpeed = 100;	//*PRESCALEVALUE; 	//PRESCALEVALUE=6
	settings->minSpeed = 0; 	//*PRESCALEVALUE;
 8002c76:	8482      	strh	r2, [r0, #36]	; 0x24
	settings->maxSpeed = 200;	//*PRESCALEVALUE;

	settings->PID_yaw.PID_kp = 1.0f;
	settings->PID_yaw.PID_ki = 0.0f;
 8002c78:	2200      	movs	r2, #0
 8002c7a:	63c2      	str	r2, [r0, #60]	; 0x3c
	settings->PID_yaw.PID_kd = 0.0f;
 8002c7c:	6402      	str	r2, [r0, #64]	; 0x40


#ifdef PIDSmithPredictor-Controller

	/* PID */
	settings->PID_rollPitch.PID_kp = 21.115707268541f; //14.5478771127435f;    	//22.7f;
 8002c7e:	4a1b      	ldr	r2, [pc, #108]	; (8002cec <SETTINGS_init+0x80>)
#include <string.h>


void SETTINGS_init(GlobalSettings_s *settings)
{
	settings->gyroSensTreshold = 20;
 8002c80:	2314      	movs	r3, #20
 8002c82:	8003      	strh	r3, [r0, #0]


#ifdef PIDSmithPredictor-Controller

	/* PID */
	settings->PID_rollPitch.PID_kp = 21.115707268541f; //14.5478771127435f;    	//22.7f;
 8002c84:	6282      	str	r2, [r0, #40]	; 0x28
void SETTINGS_init(GlobalSettings_s *settings)
{
	settings->gyroSensTreshold = 20;
	settings->gyroDir.sensDirection[sensX] = -1;
	settings->gyroDir.sensDirection[sensY] = -1;
	settings->gyroDir.sensDirection[sensZ] = 1;
 8002c86:	2301      	movs	r3, #1

#ifdef PIDSmithPredictor-Controller

	/* PID */
	settings->PID_rollPitch.PID_kp = 21.115707268541f; //14.5478771127435f;    	//22.7f;
	settings->PID_rollPitch.PID_ki = 0.8405091086306f; //28.1211353951591f;  	//0.8f;
 8002c88:	4a19      	ldr	r2, [pc, #100]	; (8002cf0 <SETTINGS_init+0x84>)
#include <stm32_configuration.h>
#include <string.h>


void SETTINGS_init(GlobalSettings_s *settings)
{
 8002c8a:	b530      	push	{r4, r5, lr}
	settings->gyroSensTreshold = 20;
	settings->gyroDir.sensDirection[sensX] = -1;
	settings->gyroDir.sensDirection[sensY] = -1;
	settings->gyroDir.sensDirection[sensZ] = 1;
 8002c8c:	7243      	strb	r3, [r0, #9]
	settings->gyroDir.sensOrder[sensX] = 0;
	settings->gyroDir.sensOrder[sensY] = 2;
	settings->gyroDir.sensOrder[sensZ] = 1;
 8002c8e:	7183      	strb	r3, [r0, #6]

	settings->enableDriftCorrection = 1;
 8002c90:	7283      	strb	r3, [r0, #10]

	settings->enableACC = 1;
 8002c92:	72c3      	strb	r3, [r0, #11]
	settings->accDir.sensDirection[sensX] = -1;
	settings->accDir.sensDirection[sensY] = -1;
	settings->accDir.sensDirection[sensZ] = 1;
 8002c94:	7443      	strb	r3, [r0, #17]
	settings->accDir.sensOrder[sensX] = 2;
	settings->accDir.sensOrder[sensY] = 0;
	settings->accDir.sensOrder[sensZ] = 1;
 8002c96:	7383      	strb	r3, [r0, #14]
	settings->accMaxGOverflow = 1.3;
 8002c98:	4d16      	ldr	r5, [pc, #88]	; (8002cf4 <SETTINGS_init+0x88>)

	settings->enableMAG = 0;
	settings->magLowpassValue = 5;//20;
	settings->magDir.sensDirection[sensX] = 1;
 8002c9a:	7703      	strb	r3, [r0, #28]
	settings->magDir.sensDirection[sensY] = -1;
	settings->magDir.sensDirection[sensZ] = 1;
 8002c9c:	7783      	strb	r3, [r0, #30]
	settings->magDir.sensOrder[sensX] = 0;
	settings->magDir.sensOrder[sensY] = 1;
 8002c9e:	7683      	strb	r3, [r0, #26]
	settings->magDir.sensOrder[sensZ] = 2;

	settings->stopSpeed = 100;	//*PRESCALEVALUE; 	//PRESCALEVALUE=6
 8002ca0:	2364      	movs	r3, #100	; 0x64
 8002ca2:	8443      	strh	r3, [r0, #34]	; 0x22

#ifdef PIDSmithPredictor-Controller

	/* PID */
	settings->PID_rollPitch.PID_kp = 21.115707268541f; //14.5478771127435f;    	//22.7f;
	settings->PID_rollPitch.PID_ki = 0.8405091086306f; //28.1211353951591f;  	//0.8f;
 8002ca4:	62c2      	str	r2, [r0, #44]	; 0x2c
	settings->magDir.sensOrder[sensY] = 1;
	settings->magDir.sensOrder[sensZ] = 2;

	settings->stopSpeed = 100;	//*PRESCALEVALUE; 	//PRESCALEVALUE=6
	settings->minSpeed = 0; 	//*PRESCALEVALUE;
	settings->maxSpeed = 200;	//*PRESCALEVALUE;
 8002ca6:	23c8      	movs	r3, #200	; 0xc8
#ifdef PIDSmithPredictor-Controller

	/* PID */
	settings->PID_rollPitch.PID_kp = 21.115707268541f; //14.5478771127435f;    	//22.7f;
	settings->PID_rollPitch.PID_ki = 0.8405091086306f; //28.1211353951591f;  	//0.8f;
	settings->PID_rollPitch.PID_kd = 0.4392517058174756f; //1.84575662912126f; 	//0.40f;
 8002ca8:	4a13      	ldr	r2, [pc, #76]	; (8002cf8 <SETTINGS_init+0x8c>)


void SETTINGS_init(GlobalSettings_s *settings)
{
	settings->gyroSensTreshold = 20;
	settings->gyroDir.sensDirection[sensX] = -1;
 8002caa:	21ff      	movs	r1, #255	; 0xff
	settings->gyroDir.sensDirection[sensY] = -1;
	settings->gyroDir.sensDirection[sensZ] = 1;
	settings->gyroDir.sensOrder[sensX] = 0;
	settings->gyroDir.sensOrder[sensY] = 2;
 8002cac:	2402      	movs	r4, #2
	settings->accDir.sensDirection[sensY] = -1;
	settings->accDir.sensDirection[sensZ] = 1;
	settings->accDir.sensOrder[sensX] = 2;
	settings->accDir.sensOrder[sensY] = 0;
	settings->accDir.sensOrder[sensZ] = 1;
	settings->accMaxGOverflow = 1.3;
 8002cae:	6145      	str	r5, [r0, #20]
	settings->magDir.sensOrder[sensY] = 1;
	settings->magDir.sensOrder[sensZ] = 2;

	settings->stopSpeed = 100;	//*PRESCALEVALUE; 	//PRESCALEVALUE=6
	settings->minSpeed = 0; 	//*PRESCALEVALUE;
	settings->maxSpeed = 200;	//*PRESCALEVALUE;
 8002cb0:	84c3      	strh	r3, [r0, #38]	; 0x26
	settings->accDir.sensOrder[sensY] = 0;
	settings->accDir.sensOrder[sensZ] = 1;
	settings->accMaxGOverflow = 1.3;

	settings->enableMAG = 0;
	settings->magLowpassValue = 5;//20;
 8002cb2:	2505      	movs	r5, #5

	settings->stopSpeed = 100;	//*PRESCALEVALUE; 	//PRESCALEVALUE=6
	settings->minSpeed = 0; 	//*PRESCALEVALUE;
	settings->maxSpeed = 200;	//*PRESCALEVALUE;

	settings->PID_yaw.PID_kp = 1.0f;
 8002cb4:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 8002cb8:	6383      	str	r3, [r0, #56]	; 0x38


void SETTINGS_init(GlobalSettings_s *settings)
{
	settings->gyroSensTreshold = 20;
	settings->gyroDir.sensDirection[sensX] = -1;
 8002cba:	71c1      	strb	r1, [r0, #7]
	settings->gyroDir.sensDirection[sensY] = -1;
 8002cbc:	7201      	strb	r1, [r0, #8]
	settings->gyroDir.sensDirection[sensZ] = 1;
	settings->gyroDir.sensOrder[sensX] = 0;
	settings->gyroDir.sensOrder[sensY] = 2;
 8002cbe:	7144      	strb	r4, [r0, #5]
	settings->gyroDir.sensOrder[sensZ] = 1;

	settings->enableDriftCorrection = 1;

	settings->enableACC = 1;
	settings->accDir.sensDirection[sensX] = -1;
 8002cc0:	73c1      	strb	r1, [r0, #15]
	settings->accDir.sensDirection[sensY] = -1;
 8002cc2:	7401      	strb	r1, [r0, #16]
	settings->accDir.sensDirection[sensZ] = 1;
	settings->accDir.sensOrder[sensX] = 2;
 8002cc4:	7304      	strb	r4, [r0, #12]
	settings->accDir.sensOrder[sensY] = 0;
	settings->accDir.sensOrder[sensZ] = 1;
	settings->accMaxGOverflow = 1.3;

	settings->enableMAG = 0;
	settings->magLowpassValue = 5;//20;
 8002cc6:	8405      	strh	r5, [r0, #32]
	settings->magDir.sensDirection[sensX] = 1;
	settings->magDir.sensDirection[sensY] = -1;
 8002cc8:	7741      	strb	r1, [r0, #29]
	settings->magDir.sensDirection[sensZ] = 1;
	settings->magDir.sensOrder[sensX] = 0;
	settings->magDir.sensOrder[sensY] = 1;
	settings->magDir.sensOrder[sensZ] = 2;
 8002cca:	76c4      	strb	r4, [r0, #27]
#ifdef PIDSmithPredictor-Controller

	/* PID */
	settings->PID_rollPitch.PID_kp = 21.115707268541f; //14.5478771127435f;    	//22.7f;
	settings->PID_rollPitch.PID_ki = 0.8405091086306f; //28.1211353951591f;  	//0.8f;
	settings->PID_rollPitch.PID_kd = 0.4392517058174756f; //1.84575662912126f; 	//0.40f;
 8002ccc:	6302      	str	r2, [r0, #48]	; 0x30
	settings->PID_rollPitch.PID_kn = 80.8259704631948f; //683.74924793257f;

	/* Smith Predictor */
	settings->SmithPrediktor_rollPitch.b1 = 1.0f;						//0.9753f;	// T1b
 8002cce:	6503      	str	r3, [r0, #80]	; 0x50
    settings->SmithPrediktor_rollPitch.b2 = 0.024690087971871f;			//0.0f;
 8002cd0:	4b0a      	ldr	r3, [pc, #40]	; (8002cfc <SETTINGS_init+0x90>)

	/* PID */
	settings->PID_rollPitch.PID_kp = 21.115707268541f; //14.5478771127435f;    	//22.7f;
	settings->PID_rollPitch.PID_ki = 0.8405091086306f; //28.1211353951591f;  	//0.8f;
	settings->PID_rollPitch.PID_kd = 0.4392517058174756f; //1.84575662912126f; 	//0.40f;
	settings->PID_rollPitch.PID_kn = 80.8259704631948f; //683.74924793257f;
 8002cd2:	4a0b      	ldr	r2, [pc, #44]	; (8002d00 <SETTINGS_init+0x94>)

	/* Smith Predictor */
	settings->SmithPrediktor_rollPitch.b1 = 1.0f;						//0.9753f;	// T1b
    settings->SmithPrediktor_rollPitch.b2 = 0.024690087971871f;			//0.0f;
 8002cd4:	6543      	str	r3, [r0, #84]	; 0x54
	settings->SmithPrediktor_rollPitch.b3 = -0.975309912028128f;		//0.0f;
 8002cd6:	4b0b      	ldr	r3, [pc, #44]	; (8002d04 <SETTINGS_init+0x98>)

	/* PID */
	settings->PID_rollPitch.PID_kp = 21.115707268541f; //14.5478771127435f;    	//22.7f;
	settings->PID_rollPitch.PID_ki = 0.8405091086306f; //28.1211353951591f;  	//0.8f;
	settings->PID_rollPitch.PID_kd = 0.4392517058174756f; //1.84575662912126f; 	//0.40f;
	settings->PID_rollPitch.PID_kn = 80.8259704631948f; //683.74924793257f;
 8002cd8:	6342      	str	r2, [r0, #52]	; 0x34

	/* Smith Predictor */
	settings->SmithPrediktor_rollPitch.b1 = 1.0f;						//0.9753f;	// T1b
    settings->SmithPrediktor_rollPitch.b2 = 0.024690087971871f;			//0.0f;
	settings->SmithPrediktor_rollPitch.b3 = -0.975309912028128f;		//0.0f;
 8002cda:	6583      	str	r3, [r0, #88]	; 0x58
	settings->SmithPrediktor_rollPitch.a1 = 0.995023590034886f;			//0.02469f;	// T1a
 8002cdc:	4b0a      	ldr	r3, [pc, #40]	; (8002d08 <SETTINGS_init+0x9c>)
 8002cde:	6483      	str	r3, [r0, #72]	; 0x48
	settings->SmithPrediktor_rollPitch.a2 = 0.003294688806972f;			//0.007f;		// T2a
 8002ce0:	4b0a      	ldr	r3, [pc, #40]	; (8002d0c <SETTINGS_init+0xa0>)
 8002ce2:	64c3      	str	r3, [r0, #76]	; 0x4c
	settings->SmithPrediktor_rollPitch.gain =  38.285739551944431f;		//0.0f;
 8002ce4:	4b0a      	ldr	r3, [pc, #40]	; (8002d10 <SETTINGS_init+0xa4>)
 8002ce6:	65c3      	str	r3, [r0, #92]	; 0x5c
 8002ce8:	bd30      	pop	{r4, r5, pc}
 8002cea:	bf00      	nop
 8002cec:	41a8ecf8 	.word	0x41a8ecf8
 8002cf0:	3f572b9b 	.word	0x3f572b9b
 8002cf4:	3fa66666 	.word	0x3fa66666
 8002cf8:	3ee0e599 	.word	0x3ee0e599
 8002cfc:	3cca42de 	.word	0x3cca42de
 8002d00:	42a1a6e6 	.word	0x42a1a6e6
 8002d04:	bf79ade9 	.word	0xbf79ade9
 8002d08:	3f7eb9de 	.word	0x3f7eb9de
 8002d0c:	3b57ebb5 	.word	0x3b57ebb5
 8002d10:	42192499 	.word	0x42192499

08002d14 <CTRLSTATES_init>:

}

void CTRLSTATES_init(CtrlStates_s *states)
{
	memset(states, 0, sizeof(CtrlStates_s));
 8002d14:	2100      	movs	r1, #0
 8002d16:	220c      	movs	r2, #12
 8002d18:	f005 b8c4 	b.w	8007ea4 <memset>

08002d1c <setup_xBeeS6>:




	return 0;
}
 8002d1c:	2000      	movs	r0, #0
 8002d1e:	4770      	bx	lr

08002d20 <ADC_DeInit>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));


  if((ADCx == ADC1) || (ADCx == ADC2))
 8002d20:	f1b0 4fa0 	cmp.w	r0, #1342177280	; 0x50000000
  * @brief  Deinitializes the ADCx peripheral registers to their default reset values.
  * @param  ADCx: where x can be 1, 2,3 or 4 to select the ADC peripheral.
  * @retval None
  */
void ADC_DeInit(ADC_TypeDef* ADCx)
{
 8002d24:	b508      	push	{r3, lr}
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));


  if((ADCx == ADC1) || (ADCx == ADC2))
 8002d26:	d002      	beq.n	8002d2e <ADC_DeInit+0xe>
 8002d28:	4b0f      	ldr	r3, [pc, #60]	; (8002d68 <ADC_DeInit+0x48>)
 8002d2a:	4298      	cmp	r0, r3
 8002d2c:	d107      	bne.n	8002d3e <ADC_DeInit+0x1e>
  {
    /* Enable ADC1/ADC2 reset state */
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_ADC12, ENABLE);
 8002d2e:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
 8002d32:	2101      	movs	r1, #1
 8002d34:	f001 faba 	bl	80042ac <RCC_AHBPeriphResetCmd>
    /* Release ADC1/ADC2 from reset state */
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_ADC12, DISABLE);
 8002d38:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
 8002d3c:	e00d      	b.n	8002d5a <ADC_DeInit+0x3a>
  }
  else if((ADCx == ADC3) || (ADCx == ADC4))
 8002d3e:	4b0b      	ldr	r3, [pc, #44]	; (8002d6c <ADC_DeInit+0x4c>)
 8002d40:	4298      	cmp	r0, r3
 8002d42:	d003      	beq.n	8002d4c <ADC_DeInit+0x2c>
 8002d44:	f503 7380 	add.w	r3, r3, #256	; 0x100
 8002d48:	4298      	cmp	r0, r3
 8002d4a:	d10b      	bne.n	8002d64 <ADC_DeInit+0x44>
  {
    /* Enable ADC3/ADC4 reset state */
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_ADC34, ENABLE);
 8002d4c:	f04f 5000 	mov.w	r0, #536870912	; 0x20000000
 8002d50:	2101      	movs	r1, #1
 8002d52:	f001 faab 	bl	80042ac <RCC_AHBPeriphResetCmd>
    /* Release ADC3/ADC4 from reset state */
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_ADC34, DISABLE);
 8002d56:	f04f 5000 	mov.w	r0, #536870912	; 0x20000000
 8002d5a:	2100      	movs	r1, #0
  }
}
 8002d5c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  else if((ADCx == ADC3) || (ADCx == ADC4))
  {
    /* Enable ADC3/ADC4 reset state */
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_ADC34, ENABLE);
    /* Release ADC3/ADC4 from reset state */
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_ADC34, DISABLE);
 8002d60:	f001 baa4 	b.w	80042ac <RCC_AHBPeriphResetCmd>
 8002d64:	bd08      	pop	{r3, pc}
 8002d66:	bf00      	nop
 8002d68:	50000100 	.word	0x50000100
 8002d6c:	50000400 	.word	0x50000400

08002d70 <ADC_Init>:
  assert_param(IS_ADC_AUTOINJECMODE(ADC_InitStruct->ADC_AutoInjMode));
  assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfRegChannel));

  /*---------------------------- ADCx CFGR Configuration -----------------*/
  /* Get the ADCx CFGR value */
  tmpreg1 = ADCx->CFGR;
 8002d70:	68c2      	ldr	r2, [r0, #12]
  /* Clear SCAN bit */
  tmpreg1 &= CFGR_CLEAR_Mask; 
 8002d72:	4b0d      	ldr	r3, [pc, #52]	; (8002da8 <ADC_Init+0x38>)
  * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure that contains
  *         the configuration information for the specified ADC peripheral.
  * @retval None
  */
void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)
{
 8002d74:	b510      	push	{r4, lr}

  /*---------------------------- ADCx CFGR Configuration -----------------*/
  /* Get the ADCx CFGR value */
  tmpreg1 = ADCx->CFGR;
  /* Clear SCAN bit */
  tmpreg1 &= CFGR_CLEAR_Mask; 
 8002d76:	4013      	ands	r3, r2
  /* Configure ADCx: scan conversion mode */
  /* Set SCAN bit according to ADC_ScanConvMode value */
  tmpreg1 |= (uint32_t)ADC_InitStruct->ADC_ContinuousConvMode | 
 8002d78:	e891 0014 	ldmia.w	r1, {r2, r4}
 8002d7c:	4314      	orrs	r4, r2
  ADC_InitStruct->ADC_Resolution|                 
 8002d7e:	688a      	ldr	r2, [r1, #8]
 8002d80:	4314      	orrs	r4, r2
  ADC_InitStruct->ADC_ExternalTrigConvEvent|         
 8002d82:	68ca      	ldr	r2, [r1, #12]
 8002d84:	4314      	orrs	r4, r2
  ADC_InitStruct->ADC_ExternalTrigEventEdge|     
 8002d86:	690a      	ldr	r2, [r1, #16]
 8002d88:	4314      	orrs	r4, r2
  ADC_InitStruct->ADC_DataAlign|                 
 8002d8a:	694a      	ldr	r2, [r1, #20]
 8002d8c:	4314      	orrs	r4, r2
  ADC_InitStruct->ADC_OverrunMode|        
 8002d8e:	698a      	ldr	r2, [r1, #24]
 8002d90:	4322      	orrs	r2, r4
  tmpreg1 = ADCx->CFGR;
  /* Clear SCAN bit */
  tmpreg1 &= CFGR_CLEAR_Mask; 
  /* Configure ADCx: scan conversion mode */
  /* Set SCAN bit according to ADC_ScanConvMode value */
  tmpreg1 |= (uint32_t)ADC_InitStruct->ADC_ContinuousConvMode | 
 8002d92:	4313      	orrs	r3, r2
  ADC_InitStruct->ADC_DataAlign|                 
  ADC_InitStruct->ADC_OverrunMode|        
  ADC_InitStruct->ADC_AutoInjMode;
  
  /* Write to ADCx CFGR */
  ADCx->CFGR = tmpreg1;
 8002d94:	60c3      	str	r3, [r0, #12]
  
  /*---------------------------- ADCx SQR1 Configuration -----------------*/
  /* Get the ADCx SQR1 value */
  tmpreg1 = ADCx->SQR1;
 8002d96:	6b02      	ldr	r2, [r0, #48]	; 0x30
  /* Clear L bits */
  tmpreg1 &= ~(uint32_t)(ADC_SQR1_L);
  /* Configure ADCx: regular channel sequence length */
  /* Set L bits according to ADC_NbrOfRegChannel value */
  tmpreg1 |= (uint32_t) (ADC_InitStruct->ADC_NbrOfRegChannel - 1);
 8002d98:	7f0b      	ldrb	r3, [r1, #28]
  
  /*---------------------------- ADCx SQR1 Configuration -----------------*/
  /* Get the ADCx SQR1 value */
  tmpreg1 = ADCx->SQR1;
  /* Clear L bits */
  tmpreg1 &= ~(uint32_t)(ADC_SQR1_L);
 8002d9a:	f022 020f 	bic.w	r2, r2, #15
  /* Configure ADCx: regular channel sequence length */
  /* Set L bits according to ADC_NbrOfRegChannel value */
  tmpreg1 |= (uint32_t) (ADC_InitStruct->ADC_NbrOfRegChannel - 1);
 8002d9e:	3b01      	subs	r3, #1
 8002da0:	4313      	orrs	r3, r2
  /* Write to ADCx SQR1 */
  ADCx->SQR1 = tmpreg1; 
 8002da2:	6303      	str	r3, [r0, #48]	; 0x30
 8002da4:	bd10      	pop	{r4, pc}
 8002da6:	bf00      	nop
 8002da8:	fdffc007 	.word	0xfdffc007

08002dac <ADC_StructInit>:
  * @retval None
  */
void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
{
  /* Reset ADC init structure parameters values */
  ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
 8002dac:	2300      	movs	r3, #0
 8002dae:	6003      	str	r3, [r0, #0]
  ADC_InitStruct->ADC_Resolution = ADC_Resolution_12b;                 
 8002db0:	6043      	str	r3, [r0, #4]
  ADC_InitStruct->ADC_ExternalTrigConvEvent = ADC_ExternalTrigConvEvent_0;         
 8002db2:	6083      	str	r3, [r0, #8]
  ADC_InitStruct->ADC_ExternalTrigEventEdge = ADC_ExternalTrigEventEdge_None;
 8002db4:	60c3      	str	r3, [r0, #12]
  ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;                 
 8002db6:	6103      	str	r3, [r0, #16]
  ADC_InitStruct->ADC_OverrunMode = DISABLE;   
 8002db8:	6143      	str	r3, [r0, #20]
  ADC_InitStruct->ADC_AutoInjMode = DISABLE;  
 8002dba:	6183      	str	r3, [r0, #24]
  ADC_InitStruct->ADC_NbrOfRegChannel = 1; 
 8002dbc:	2301      	movs	r3, #1
 8002dbe:	7703      	strb	r3, [r0, #28]
 8002dc0:	4770      	bx	lr

08002dc2 <ADC_InjectedInit>:
  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedInitStruct->ADC_InjecSequence3));
  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedInitStruct->ADC_InjecSequence4));
  
  /*---------------------------- ADCx JSQR Configuration -----------------*/
  /* Get the ADCx JSQR value */
  tmpreg1 = ADCx->JSQR;
 8002dc2:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
  /* Clear L bits */
  tmpreg1 &= JSQR_CLEAR_Mask;
  /* Configure ADCx: Injected channel sequence length, external trigger, 
     external trigger edge and sequences
  */
  tmpreg1 = (uint32_t) ((ADC_InjectedInitStruct->ADC_NbrOfInjecChannel - (uint8_t)1) |
 8002dc4:	684a      	ldr	r2, [r1, #4]
 8002dc6:	680b      	ldr	r3, [r1, #0]
 8002dc8:	431a      	orrs	r2, r3
                         ADC_InjectedInitStruct->ADC_ExternalTrigInjecConvEvent |         
                         ADC_InjectedInitStruct->ADC_ExternalTrigInjecEventEdge |
                         (uint32_t)((ADC_InjectedInitStruct->ADC_InjecSequence1) << 8) |
 8002dca:	68cb      	ldr	r3, [r1, #12]
  tmpreg1 &= JSQR_CLEAR_Mask;
  /* Configure ADCx: Injected channel sequence length, external trigger, 
     external trigger edge and sequences
  */
  tmpreg1 = (uint32_t) ((ADC_InjectedInitStruct->ADC_NbrOfInjecChannel - (uint8_t)1) |
                         ADC_InjectedInitStruct->ADC_ExternalTrigInjecConvEvent |         
 8002dcc:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
                         ADC_InjectedInitStruct->ADC_ExternalTrigInjecEventEdge |
                         (uint32_t)((ADC_InjectedInitStruct->ADC_InjecSequence1) << 8) |
                         (uint32_t)((ADC_InjectedInitStruct->ADC_InjecSequence2) << 14) |
 8002dd0:	690b      	ldr	r3, [r1, #16]
  /* Configure ADCx: Injected channel sequence length, external trigger, 
     external trigger edge and sequences
  */
  tmpreg1 = (uint32_t) ((ADC_InjectedInitStruct->ADC_NbrOfInjecChannel - (uint8_t)1) |
                         ADC_InjectedInitStruct->ADC_ExternalTrigInjecConvEvent |         
                         ADC_InjectedInitStruct->ADC_ExternalTrigInjecEventEdge |
 8002dd2:	ea42 3283 	orr.w	r2, r2, r3, lsl #14
                         (uint32_t)((ADC_InjectedInitStruct->ADC_InjecSequence1) << 8) |
                         (uint32_t)((ADC_InjectedInitStruct->ADC_InjecSequence2) << 14) |
                         (uint32_t)((ADC_InjectedInitStruct->ADC_InjecSequence3) << 20) |
 8002dd6:	694b      	ldr	r3, [r1, #20]
     external trigger edge and sequences
  */
  tmpreg1 = (uint32_t) ((ADC_InjectedInitStruct->ADC_NbrOfInjecChannel - (uint8_t)1) |
                         ADC_InjectedInitStruct->ADC_ExternalTrigInjecConvEvent |         
                         ADC_InjectedInitStruct->ADC_ExternalTrigInjecEventEdge |
                         (uint32_t)((ADC_InjectedInitStruct->ADC_InjecSequence1) << 8) |
 8002dd8:	ea42 5203 	orr.w	r2, r2, r3, lsl #20
                         (uint32_t)((ADC_InjectedInitStruct->ADC_InjecSequence2) << 14) |
                         (uint32_t)((ADC_InjectedInitStruct->ADC_InjecSequence3) << 20) |
                         (uint32_t)((ADC_InjectedInitStruct->ADC_InjecSequence4) << 26));
 8002ddc:	698b      	ldr	r3, [r1, #24]
  */
  tmpreg1 = (uint32_t) ((ADC_InjectedInitStruct->ADC_NbrOfInjecChannel - (uint8_t)1) |
                         ADC_InjectedInitStruct->ADC_ExternalTrigInjecConvEvent |         
                         ADC_InjectedInitStruct->ADC_ExternalTrigInjecEventEdge |
                         (uint32_t)((ADC_InjectedInitStruct->ADC_InjecSequence1) << 8) |
                         (uint32_t)((ADC_InjectedInitStruct->ADC_InjecSequence2) << 14) |
 8002dde:	ea42 6383 	orr.w	r3, r2, r3, lsl #26
  /* Clear L bits */
  tmpreg1 &= JSQR_CLEAR_Mask;
  /* Configure ADCx: Injected channel sequence length, external trigger, 
     external trigger edge and sequences
  */
  tmpreg1 = (uint32_t) ((ADC_InjectedInitStruct->ADC_NbrOfInjecChannel - (uint8_t)1) |
 8002de2:	7a0a      	ldrb	r2, [r1, #8]
 8002de4:	3a01      	subs	r2, #1
 8002de6:	4313      	orrs	r3, r2
                         (uint32_t)((ADC_InjectedInitStruct->ADC_InjecSequence1) << 8) |
                         (uint32_t)((ADC_InjectedInitStruct->ADC_InjecSequence2) << 14) |
                         (uint32_t)((ADC_InjectedInitStruct->ADC_InjecSequence3) << 20) |
                         (uint32_t)((ADC_InjectedInitStruct->ADC_InjecSequence4) << 26));
  /* Write to ADCx SQR1 */
  ADCx->JSQR = tmpreg1;  
 8002de8:	64c3      	str	r3, [r0, #76]	; 0x4c
 8002dea:	4770      	bx	lr

08002dec <ADC_InjectedStructInit>:
  * @param  ADC_InjectedInitStruct : pointer to an ADC_InjectedInitTypeDef structure which will be initialized.
  * @retval None
  */
void ADC_InjectedStructInit(ADC_InjectedInitTypeDef* ADC_InjectedInitStruct)
{
  ADC_InjectedInitStruct->ADC_ExternalTrigInjecConvEvent = ADC_ExternalTrigInjecConvEvent_0;    
 8002dec:	2300      	movs	r3, #0
 8002dee:	6003      	str	r3, [r0, #0]
  ADC_InjectedInitStruct->ADC_ExternalTrigInjecEventEdge = ADC_ExternalTrigInjecEventEdge_None;     
 8002df0:	6043      	str	r3, [r0, #4]
  ADC_InjectedInitStruct->ADC_NbrOfInjecChannel = 1;                                                             
 8002df2:	2301      	movs	r3, #1
 8002df4:	7203      	strb	r3, [r0, #8]
  ADC_InjectedInitStruct->ADC_InjecSequence1 = ADC_InjectedChannel_1; 
 8002df6:	60c3      	str	r3, [r0, #12]
  ADC_InjectedInitStruct->ADC_InjecSequence2 = ADC_InjectedChannel_1;
 8002df8:	6103      	str	r3, [r0, #16]
  ADC_InjectedInitStruct->ADC_InjecSequence3 = ADC_InjectedChannel_1;
 8002dfa:	6143      	str	r3, [r0, #20]
  ADC_InjectedInitStruct->ADC_InjecSequence4 = ADC_InjectedChannel_1; 
 8002dfc:	6183      	str	r3, [r0, #24]
 8002dfe:	4770      	bx	lr

08002e00 <ADC_CommonInit>:
  assert_param(IS_ADC_CLOCKMODE(ADC_CommonInitStruct->ADC_Clock));
  assert_param(IS_ADC_DMA_MODE(ADC_CommonInitStruct->ADC_DMAMode));
  assert_param(IS_ADC_DMA_ACCESS_MODE(ADC_CommonInitStruct->ADC_DMAAccessMode));
  assert_param(IS_ADC_TWOSAMPLING_DELAY(ADC_CommonInitStruct->ADC_TwoSamplingDelay));

  if((ADCx == ADC1) || (ADCx == ADC2))
 8002e00:	f1b0 4fa0 	cmp.w	r0, #1342177280	; 0x50000000
  * @param  ADC_CommonInitStruct: pointer to an ADC_CommonInitTypeDef structure 
  *         that contains the configuration information for  All ADCs peripherals.
  * @retval None
  */
void ADC_CommonInit(ADC_TypeDef* ADCx, ADC_CommonInitTypeDef* ADC_CommonInitStruct)
{
 8002e04:	b510      	push	{r4, lr}
  assert_param(IS_ADC_CLOCKMODE(ADC_CommonInitStruct->ADC_Clock));
  assert_param(IS_ADC_DMA_MODE(ADC_CommonInitStruct->ADC_DMAMode));
  assert_param(IS_ADC_DMA_ACCESS_MODE(ADC_CommonInitStruct->ADC_DMAAccessMode));
  assert_param(IS_ADC_TWOSAMPLING_DELAY(ADC_CommonInitStruct->ADC_TwoSamplingDelay));

  if((ADCx == ADC1) || (ADCx == ADC2))
 8002e06:	d002      	beq.n	8002e0e <ADC_CommonInit+0xe>
 8002e08:	4b11      	ldr	r3, [pc, #68]	; (8002e50 <ADC_CommonInit+0x50>)
 8002e0a:	4298      	cmp	r0, r3
 8002e0c:	d101      	bne.n	8002e12 <ADC_CommonInit+0x12>
  {
    /* Get the ADC CCR value */
    tmpreg1 = ADC1_2->CCR;
 8002e0e:	4b11      	ldr	r3, [pc, #68]	; (8002e54 <ADC_CommonInit+0x54>)
 8002e10:	e000      	b.n	8002e14 <ADC_CommonInit+0x14>
    tmpreg1 &= CCR_CLEAR_MASK;
  }
  else
  {
    /* Get the ADC CCR value */
    tmpreg1 = ADC3_4->CCR;
 8002e12:	4b11      	ldr	r3, [pc, #68]	; (8002e58 <ADC_CommonInit+0x58>)
 8002e14:	689a      	ldr	r2, [r3, #8]
  
    /* Clear MULTI, DELAY, DMA and ADCPRE bits */
    tmpreg1 &= CCR_CLEAR_MASK;
 8002e16:	4b11      	ldr	r3, [pc, #68]	; (8002e5c <ADC_CommonInit+0x5c>)
                        ADC_CommonInitStruct->ADC_Clock | 
                        ADC_CommonInitStruct->ADC_DMAAccessMode | 
                        (uint32_t)(ADC_CommonInitStruct->ADC_DMAMode << 12) |
                        (uint32_t)((uint32_t)ADC_CommonInitStruct->ADC_TwoSamplingDelay << 8));

  if((ADCx == ADC1) || (ADCx == ADC2))
 8002e18:	f1b0 4fa0 	cmp.w	r0, #1342177280	; 0x50000000
  {
    /* Get the ADC CCR value */
    tmpreg1 = ADC3_4->CCR;
  
    /* Clear MULTI, DELAY, DMA and ADCPRE bits */
    tmpreg1 &= CCR_CLEAR_MASK;
 8002e1c:	ea02 0303 	and.w	r3, r2, r3
  /* Set MULTI bits according to ADC_Mode value */
  /* Set CKMODE bits according to ADC_Clock value */
  /* Set MDMA bits according to ADC_DMAAccessMode value */
  /* Set DMACFG bits according to ADC_DMAMode value */
  /* Set DELAY bits according to ADC_TwoSamplingDelay value */    
  tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
 8002e20:	e891 0014 	ldmia.w	r1, {r2, r4}
 8002e24:	ea44 0402 	orr.w	r4, r4, r2
                        ADC_CommonInitStruct->ADC_Clock | 
 8002e28:	688a      	ldr	r2, [r1, #8]
 8002e2a:	ea44 0402 	orr.w	r4, r4, r2
                        ADC_CommonInitStruct->ADC_DMAAccessMode | 
                        (uint32_t)(ADC_CommonInitStruct->ADC_DMAMode << 12) |
 8002e2e:	68ca      	ldr	r2, [r1, #12]
                        (uint32_t)((uint32_t)ADC_CommonInitStruct->ADC_TwoSamplingDelay << 8));
 8002e30:	7c09      	ldrb	r1, [r1, #16]
  /* Set MDMA bits according to ADC_DMAAccessMode value */
  /* Set DMACFG bits according to ADC_DMAMode value */
  /* Set DELAY bits according to ADC_TwoSamplingDelay value */    
  tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
                        ADC_CommonInitStruct->ADC_Clock | 
                        ADC_CommonInitStruct->ADC_DMAAccessMode | 
 8002e32:	ea44 3202 	orr.w	r2, r4, r2, lsl #12
  /* Set MULTI bits according to ADC_Mode value */
  /* Set CKMODE bits according to ADC_Clock value */
  /* Set MDMA bits according to ADC_DMAAccessMode value */
  /* Set DMACFG bits according to ADC_DMAMode value */
  /* Set DELAY bits according to ADC_TwoSamplingDelay value */    
  tmpreg1 |= (uint32_t)(ADC_CommonInitStruct->ADC_Mode | 
 8002e36:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8002e3a:	ea42 0303 	orr.w	r3, r2, r3
                        ADC_CommonInitStruct->ADC_Clock | 
                        ADC_CommonInitStruct->ADC_DMAAccessMode | 
                        (uint32_t)(ADC_CommonInitStruct->ADC_DMAMode << 12) |
                        (uint32_t)((uint32_t)ADC_CommonInitStruct->ADC_TwoSamplingDelay << 8));

  if((ADCx == ADC1) || (ADCx == ADC2))
 8002e3e:	d002      	beq.n	8002e46 <ADC_CommonInit+0x46>
 8002e40:	4a03      	ldr	r2, [pc, #12]	; (8002e50 <ADC_CommonInit+0x50>)
 8002e42:	4290      	cmp	r0, r2
 8002e44:	d101      	bne.n	8002e4a <ADC_CommonInit+0x4a>
  {                        
    /* Write to ADC CCR */
    ADC1_2->CCR = tmpreg1;
 8002e46:	4a03      	ldr	r2, [pc, #12]	; (8002e54 <ADC_CommonInit+0x54>)
 8002e48:	e000      	b.n	8002e4c <ADC_CommonInit+0x4c>
  }
  else
  {
    /* Write to ADC CCR */
    ADC3_4->CCR = tmpreg1;
 8002e4a:	4a03      	ldr	r2, [pc, #12]	; (8002e58 <ADC_CommonInit+0x58>)
 8002e4c:	6093      	str	r3, [r2, #8]
 8002e4e:	bd10      	pop	{r4, pc}
 8002e50:	50000100 	.word	0x50000100
 8002e54:	50000300 	.word	0x50000300
 8002e58:	50000700 	.word	0x50000700
 8002e5c:	fffc10e0 	.word	0xfffc10e0

08002e60 <ADC_CommonStructInit>:
  * @retval None
  */
void ADC_CommonStructInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct)
{
  /* Initialize the ADC_Mode member */
  ADC_CommonInitStruct->ADC_Mode = ADC_Mode_Independent;
 8002e60:	2300      	movs	r3, #0
 8002e62:	6003      	str	r3, [r0, #0]

  /* initialize the ADC_Clock member */
  ADC_CommonInitStruct->ADC_Clock = ADC_Clock_AsynClkMode;
 8002e64:	6043      	str	r3, [r0, #4]

  /* Initialize the ADC_DMAAccessMode member */
  ADC_CommonInitStruct->ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;
 8002e66:	6083      	str	r3, [r0, #8]

  /* Initialize the ADC_DMAMode member */
  ADC_CommonInitStruct->ADC_DMAMode = ADC_DMAMode_OneShot;
 8002e68:	60c3      	str	r3, [r0, #12]

  /* Initialize the ADC_TwoSamplingDelay member */
  ADC_CommonInitStruct->ADC_TwoSamplingDelay = 0;
 8002e6a:	7403      	strb	r3, [r0, #16]
 8002e6c:	4770      	bx	lr

08002e6e <ADC_Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Set the ADEN bit */
    ADCx->CR |= ADC_CR_ADEN;
 8002e6e:	6883      	ldr	r3, [r0, #8]
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8002e70:	b111      	cbz	r1, 8002e78 <ADC_Cmd+0xa>
  {
    /* Set the ADEN bit */
    ADCx->CR |= ADC_CR_ADEN;
 8002e72:	f043 0301 	orr.w	r3, r3, #1
 8002e76:	e001      	b.n	8002e7c <ADC_Cmd+0xe>
  }
  else
  {
    /* Disable the selected ADC peripheral: Set the ADDIS bit */
    ADCx->CR |= ADC_CR_ADDIS;
 8002e78:	f043 0302 	orr.w	r3, r3, #2
 8002e7c:	6083      	str	r3, [r0, #8]
 8002e7e:	4770      	bx	lr

08002e80 <ADC_StartCalibration>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  /* Set the ADCAL bit */
  ADCx->CR |= ADC_CR_ADCAL;
 8002e80:	6883      	ldr	r3, [r0, #8]
 8002e82:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8002e86:	6083      	str	r3, [r0, #8]
 8002e88:	4770      	bx	lr

08002e8a <ADC_GetCalibrationValue>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  /* Return the selected ADC calibration value */
  return (uint32_t)ADCx->CALFACT;
 8002e8a:	f8d0 00b4 	ldr.w	r0, [r0, #180]	; 0xb4
}
 8002e8e:	4770      	bx	lr

08002e90 <ADC_SetCalibrationValue>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  /* Set the ADC calibration register value */
  ADCx->CALFACT = ADC_Calibration;
 8002e90:	f8c0 10b4 	str.w	r1, [r0, #180]	; 0xb4
 8002e94:	4770      	bx	lr

08002e96 <ADC_SelectCalibrationMode>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CALIBRATION_MODE(ADC_CalibrationMode));
  /* Set or Reset the ADCALDIF bit */
  ADCx->CR &= (~ADC_CR_ADCALDIF);
 8002e96:	6883      	ldr	r3, [r0, #8]
 8002e98:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 8002e9c:	6083      	str	r3, [r0, #8]
  ADCx->CR |= ADC_CalibrationMode;
 8002e9e:	6883      	ldr	r3, [r0, #8]
 8002ea0:	4319      	orrs	r1, r3
 8002ea2:	6081      	str	r1, [r0, #8]
 8002ea4:	4770      	bx	lr

08002ea6 <ADC_GetCalibrationStatus>:
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  /* Check the status of CAL bit */
  if ((ADCx->CR & ADC_CR_ADCAL) != (uint32_t)RESET)
 8002ea6:	6880      	ldr	r0, [r0, #8]
    /* CAL bit is reset: end of calibration */
    bitstatus = RESET;
  }
  /* Return the CAL bit status */
  return  bitstatus;
}
 8002ea8:	0fc0      	lsrs	r0, r0, #31
 8002eaa:	4770      	bx	lr

08002eac <ADC_DisableCmd>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  /* Set the ADDIS bit */
  ADCx->CR |= ADC_CR_ADDIS;
 8002eac:	6883      	ldr	r3, [r0, #8]
 8002eae:	f043 0302 	orr.w	r3, r3, #2
 8002eb2:	6083      	str	r3, [r0, #8]
 8002eb4:	4770      	bx	lr

08002eb6 <ADC_GetDisableCmdStatus>:
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  /* Check the status of ADDIS bit */
  if ((ADCx->CR & ADC_CR_ADDIS) != (uint32_t)RESET)
 8002eb6:	6880      	ldr	r0, [r0, #8]
    /* ADDIS bit is reset */
    bitstatus = RESET;
  }
  /* Return the ADDIS bit status */
  return  bitstatus;
}
 8002eb8:	f3c0 0040 	ubfx	r0, r0, #1, #1
 8002ebc:	4770      	bx	lr

08002ebe <ADC_VoltageRegulatorCmd>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  /* set the intermediate state before moving the ADC voltage regulator 
  from enable state to disable state or from disable state to enable state */
  ADCx->CR &= ~(ADC_CR_ADVREGEN);
 8002ebe:	6883      	ldr	r3, [r0, #8]
 8002ec0:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
 8002ec4:	6083      	str	r3, [r0, #8]
  
  if (NewState != DISABLE)
  {
    /* Set the ADVREGEN bit 0 */
    ADCx->CR |= ADC_CR_ADVREGEN_0;
 8002ec6:	6883      	ldr	r3, [r0, #8]

  /* set the intermediate state before moving the ADC voltage regulator 
  from enable state to disable state or from disable state to enable state */
  ADCx->CR &= ~(ADC_CR_ADVREGEN);
  
  if (NewState != DISABLE)
 8002ec8:	b111      	cbz	r1, 8002ed0 <ADC_VoltageRegulatorCmd+0x12>
  {
    /* Set the ADVREGEN bit 0 */
    ADCx->CR |= ADC_CR_ADVREGEN_0;
 8002eca:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8002ece:	e001      	b.n	8002ed4 <ADC_VoltageRegulatorCmd+0x16>
  }
  else
  {
    /* Set the ADVREGEN bit 1 */
    ADCx->CR |=ADC_CR_ADVREGEN_1;
 8002ed0:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8002ed4:	6083      	str	r3, [r0, #8]
 8002ed6:	4770      	bx	lr

08002ed8 <ADC_SelectDifferentialMode>:
  *     @arg ADC_Channel_14: ADC Channel14 selected
  * @note : Channel 15, 16 and 17 are fixed to single-ended inputs mode.
  * @retval None
  */
void ADC_SelectDifferentialMode(ADC_TypeDef* ADCx, uint8_t ADC_Channel, FunctionalState NewState)
{
 8002ed8:	2301      	movs	r3, #1
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx)); 
  assert_param(IS_ADC_DIFFCHANNEL(ADC_Channel)); 
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8002eda:	b12a      	cbz	r2, 8002ee8 <ADC_SelectDifferentialMode+0x10>
  {
    /* Set the DIFSEL bit */
   ADCx->DIFSEL |= (uint32_t)(1 << ADC_Channel );
 8002edc:	fa03 f301 	lsl.w	r3, r3, r1
 8002ee0:	f8d0 20b0 	ldr.w	r2, [r0, #176]	; 0xb0
 8002ee4:	4313      	orrs	r3, r2
 8002ee6:	e005      	b.n	8002ef4 <ADC_SelectDifferentialMode+0x1c>
  }
  else
  {
    /* Reset the DIFSEL bit */
   ADCx->DIFSEL &= ~(uint32_t)(1 << ADC_Channel);
 8002ee8:	fa03 f301 	lsl.w	r3, r3, r1
 8002eec:	f8d0 20b0 	ldr.w	r2, [r0, #176]	; 0xb0
 8002ef0:	ea22 0303 	bic.w	r3, r2, r3
 8002ef4:	f8c0 30b0 	str.w	r3, [r0, #176]	; 0xb0
 8002ef8:	4770      	bx	lr

08002efa <ADC_SelectQueueOfContextMode>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Set the JQM bit */
    ADCx->CFGR |= (uint32_t)(ADC_CFGR_JQM );
 8002efa:	68c3      	ldr	r3, [r0, #12]
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx)); 
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8002efc:	b111      	cbz	r1, 8002f04 <ADC_SelectQueueOfContextMode+0xa>
  {
    /* Set the JQM bit */
    ADCx->CFGR |= (uint32_t)(ADC_CFGR_JQM );
 8002efe:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8002f02:	e001      	b.n	8002f08 <ADC_SelectQueueOfContextMode+0xe>
  }
  else
  {
    /* Reset the JQM bit */
    ADCx->CFGR &= ~(uint32_t)(ADC_CFGR_JQM);
 8002f04:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 8002f08:	60c3      	str	r3, [r0, #12]
 8002f0a:	4770      	bx	lr

08002f0c <ADC_AutoDelayCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Set the AUTDLY bit */
    ADCx->CFGR |= (uint32_t)(ADC_CFGR_AUTDLY );
 8002f0c:	68c3      	ldr	r3, [r0, #12]
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx)); 
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8002f0e:	b111      	cbz	r1, 8002f16 <ADC_AutoDelayCmd+0xa>
  {
    /* Set the AUTDLY bit */
    ADCx->CFGR |= (uint32_t)(ADC_CFGR_AUTDLY );
 8002f10:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8002f14:	e001      	b.n	8002f1a <ADC_AutoDelayCmd+0xe>
  }
  else
  {
    /* Reset the AUTDLY bit */
    ADCx->CFGR &= ~(uint32_t)(ADC_CFGR_AUTDLY);
 8002f16:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8002f1a:	60c3      	str	r3, [r0, #12]
 8002f1c:	4770      	bx	lr

08002f1e <ADC_AnalogWatchdogCmd>:
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_ANALOG_WATCHDOG(ADC_AnalogWatchdog));
  /* Get the old register value */
  tmpreg = ADCx->CFGR;
 8002f1e:	68c3      	ldr	r3, [r0, #12]
  /* Clear AWDEN, AWDENJ and AWDSGL bits */
  tmpreg &= ~(uint32_t)(ADC_CFGR_AWD1SGL|ADC_CFGR_AWD1EN|ADC_CFGR_JAWD1EN);
 8002f20:	f023 73e0 	bic.w	r3, r3, #29360128	; 0x1c00000
  /* Set the analog watchdog enable mode */
  tmpreg |= ADC_AnalogWatchdog;
 8002f24:	4319      	orrs	r1, r3
  /* Store the new register value */
  ADCx->CFGR = tmpreg;
 8002f26:	60c1      	str	r1, [r0, #12]
 8002f28:	4770      	bx	lr

08002f2a <ADC_AnalogWatchdog1ThresholdsConfig>:
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_THRESHOLD(HighThreshold));
  assert_param(IS_ADC_THRESHOLD(LowThreshold));
  /* Set the ADCx high threshold */
  ADCx->TR1 &= ~(uint32_t)ADC_TR1_HT1;
 8002f2a:	6a03      	ldr	r3, [r0, #32]
 8002f2c:	f023 637f 	bic.w	r3, r3, #267386880	; 0xff00000
 8002f30:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
 8002f34:	6203      	str	r3, [r0, #32]
  ADCx->TR1 |= (uint32_t)((uint32_t)HighThreshold << 16);
 8002f36:	6a03      	ldr	r3, [r0, #32]
 8002f38:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 8002f3c:	6201      	str	r1, [r0, #32]

  /* Set the ADCx low threshold */
  ADCx->TR1 &= ~(uint32_t)ADC_TR1_LT1;
 8002f3e:	6a03      	ldr	r3, [r0, #32]
 8002f40:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 8002f44:	f023 030f 	bic.w	r3, r3, #15
 8002f48:	6203      	str	r3, [r0, #32]
  ADCx->TR1 |= LowThreshold;
 8002f4a:	6a03      	ldr	r3, [r0, #32]
 8002f4c:	431a      	orrs	r2, r3
 8002f4e:	6202      	str	r2, [r0, #32]
 8002f50:	4770      	bx	lr

08002f52 <ADC_AnalogWatchdog2ThresholdsConfig>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  
  /* Set the ADCx high threshold */
  ADCx->TR2 &= ~(uint32_t)ADC_TR2_HT2;
 8002f52:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8002f54:	f423 037f 	bic.w	r3, r3, #16711680	; 0xff0000
 8002f58:	6243      	str	r3, [r0, #36]	; 0x24
  ADCx->TR2 |= (uint32_t)((uint32_t)HighThreshold << 16);
 8002f5a:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8002f5c:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 8002f60:	6241      	str	r1, [r0, #36]	; 0x24

  /* Set the ADCx low threshold */
  ADCx->TR2 &= ~(uint32_t)ADC_TR2_LT2;
 8002f62:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8002f64:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 8002f68:	6243      	str	r3, [r0, #36]	; 0x24
  ADCx->TR2 |= LowThreshold;
 8002f6a:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8002f6c:	431a      	orrs	r2, r3
 8002f6e:	6242      	str	r2, [r0, #36]	; 0x24
 8002f70:	4770      	bx	lr

08002f72 <ADC_AnalogWatchdog3ThresholdsConfig>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  /* Set the ADCx high threshold */
  ADCx->TR3 &= ~(uint32_t)ADC_TR3_HT3;
 8002f72:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8002f74:	f423 037f 	bic.w	r3, r3, #16711680	; 0xff0000
 8002f78:	6283      	str	r3, [r0, #40]	; 0x28
  ADCx->TR3 |= (uint32_t)((uint32_t)HighThreshold << 16);
 8002f7a:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8002f7c:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 8002f80:	6281      	str	r1, [r0, #40]	; 0x28

  /* Set the ADCx low threshold */
  ADCx->TR3 &= ~(uint32_t)ADC_TR3_LT3;
 8002f82:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8002f84:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 8002f88:	6283      	str	r3, [r0, #40]	; 0x28
  ADCx->TR3 |= LowThreshold;
 8002f8a:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8002f8c:	431a      	orrs	r2, r3
 8002f8e:	6282      	str	r2, [r0, #40]	; 0x28
 8002f90:	4770      	bx	lr

08002f92 <ADC_AnalogWatchdog1SingleChannelConfig>:
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  /* Get the old register value */
  tmpreg = ADCx->CFGR;
 8002f92:	68c3      	ldr	r3, [r0, #12]
  /* Clear the Analog watchdog channel select bits */
  tmpreg &= ~(uint32_t)ADC_CFGR_AWD1CH;
 8002f94:	f023 43f8 	bic.w	r3, r3, #2080374784	; 0x7c000000
  /* Set the Analog watchdog channel */
  tmpreg |= (uint32_t)((uint32_t)ADC_Channel << 26);
 8002f98:	ea43 6181 	orr.w	r1, r3, r1, lsl #26
  /* Store the new register value */
  ADCx->CFGR = tmpreg;
 8002f9c:	60c1      	str	r1, [r0, #12]
 8002f9e:	4770      	bx	lr

08002fa0 <ADC_AnalogWatchdog2SingleChannelConfig>:
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  /* Get the old register value */
  tmpreg = ADCx->AWD2CR;
 8002fa0:	f8d0 20a0 	ldr.w	r2, [r0, #160]	; 0xa0
  /* Clear the Analog watchdog channel select bits */
  tmpreg &= ~(uint32_t)ADC_AWD2CR_AWD2CH;
 8002fa4:	4b05      	ldr	r3, [pc, #20]	; (8002fbc <ADC_AnalogWatchdog2SingleChannelConfig+0x1c>)
 8002fa6:	4013      	ands	r3, r2
  /* Set the Analog watchdog channel */
  tmpreg |= (uint32_t)1 << (ADC_Channel);
  /* Store the new register value */
  ADCx->AWD2CR |= tmpreg;
 8002fa8:	f8d0 20a0 	ldr.w	r2, [r0, #160]	; 0xa0
  /* Get the old register value */
  tmpreg = ADCx->AWD2CR;
  /* Clear the Analog watchdog channel select bits */
  tmpreg &= ~(uint32_t)ADC_AWD2CR_AWD2CH;
  /* Set the Analog watchdog channel */
  tmpreg |= (uint32_t)1 << (ADC_Channel);
 8002fac:	4313      	orrs	r3, r2
 8002fae:	2201      	movs	r2, #1
 8002fb0:	fa02 f101 	lsl.w	r1, r2, r1
  /* Store the new register value */
  ADCx->AWD2CR |= tmpreg;
 8002fb4:	430b      	orrs	r3, r1
 8002fb6:	f8c0 30a0 	str.w	r3, [r0, #160]	; 0xa0
 8002fba:	4770      	bx	lr
 8002fbc:	fff80001 	.word	0xfff80001

08002fc0 <ADC_AnalogWatchdog3SingleChannelConfig>:
  uint32_t tmpreg = 0;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  /* Get the old register value */
  tmpreg = ADCx->AWD3CR;
 8002fc0:	f8d0 20a4 	ldr.w	r2, [r0, #164]	; 0xa4
  /* Clear the Analog watchdog channel select bits */
  tmpreg &= ~(uint32_t)ADC_AWD3CR_AWD3CH;
 8002fc4:	4b05      	ldr	r3, [pc, #20]	; (8002fdc <ADC_AnalogWatchdog3SingleChannelConfig+0x1c>)
 8002fc6:	4013      	ands	r3, r2
  /* Set the Analog watchdog channel */
  tmpreg |= (uint32_t)1 << (ADC_Channel);
  /* Store the new register value */
  ADCx->AWD3CR |= tmpreg;
 8002fc8:	f8d0 20a4 	ldr.w	r2, [r0, #164]	; 0xa4
  /* Get the old register value */
  tmpreg = ADCx->AWD3CR;
  /* Clear the Analog watchdog channel select bits */
  tmpreg &= ~(uint32_t)ADC_AWD3CR_AWD3CH;
  /* Set the Analog watchdog channel */
  tmpreg |= (uint32_t)1 << (ADC_Channel);
 8002fcc:	4313      	orrs	r3, r2
 8002fce:	2201      	movs	r2, #1
 8002fd0:	fa02 f101 	lsl.w	r1, r2, r1
  /* Store the new register value */
  ADCx->AWD3CR |= tmpreg;
 8002fd4:	430b      	orrs	r3, r1
 8002fd6:	f8c0 30a4 	str.w	r3, [r0, #164]	; 0xa4
 8002fda:	4770      	bx	lr
 8002fdc:	fff80001 	.word	0xfff80001

08002fe0 <ADC_TempSensorCmd>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if((ADCx == ADC1) || (ADCx == ADC2))
 8002fe0:	f1b0 4fa0 	cmp.w	r0, #1342177280	; 0x50000000
 8002fe4:	d002      	beq.n	8002fec <ADC_TempSensorCmd+0xc>
 8002fe6:	4b07      	ldr	r3, [pc, #28]	; (8003004 <ADC_TempSensorCmd+0x24>)
 8002fe8:	4298      	cmp	r0, r3
 8002fea:	d101      	bne.n	8002ff0 <ADC_TempSensorCmd+0x10>
 8002fec:	4b06      	ldr	r3, [pc, #24]	; (8003008 <ADC_TempSensorCmd+0x28>)
 8002fee:	e000      	b.n	8002ff2 <ADC_TempSensorCmd+0x12>
 8002ff0:	4b06      	ldr	r3, [pc, #24]	; (800300c <ADC_TempSensorCmd+0x2c>)
  else
  {
    if (NewState != DISABLE)
    {
      /* Enable the temperature sensor channel*/
      ADC3_4->CCR |= ADC34_CCR_TSEN;
 8002ff2:	689a      	ldr	r2, [r3, #8]
      ADC1_2->CCR &= ~(uint32_t)ADC12_CCR_TSEN;
    }
  }
  else
  {
    if (NewState != DISABLE)
 8002ff4:	b111      	cbz	r1, 8002ffc <ADC_TempSensorCmd+0x1c>
    {
      /* Enable the temperature sensor channel*/
      ADC3_4->CCR |= ADC34_CCR_TSEN;
 8002ff6:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
 8002ffa:	e001      	b.n	8003000 <ADC_TempSensorCmd+0x20>
    }
    else
    {
      /* Disable the temperature sensor channel*/
      ADC3_4->CCR &= ~(uint32_t)ADC34_CCR_TSEN;
 8002ffc:	f422 0200 	bic.w	r2, r2, #8388608	; 0x800000
 8003000:	609a      	str	r2, [r3, #8]
 8003002:	4770      	bx	lr
 8003004:	50000100 	.word	0x50000100
 8003008:	50000300 	.word	0x50000300
 800300c:	50000700 	.word	0x50000700

08003010 <ADC_VrefintCmd>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if((ADCx == ADC1) || (ADCx == ADC2))
 8003010:	f1b0 4fa0 	cmp.w	r0, #1342177280	; 0x50000000
 8003014:	d002      	beq.n	800301c <ADC_VrefintCmd+0xc>
 8003016:	4b07      	ldr	r3, [pc, #28]	; (8003034 <ADC_VrefintCmd+0x24>)
 8003018:	4298      	cmp	r0, r3
 800301a:	d101      	bne.n	8003020 <ADC_VrefintCmd+0x10>
 800301c:	4b06      	ldr	r3, [pc, #24]	; (8003038 <ADC_VrefintCmd+0x28>)
 800301e:	e000      	b.n	8003022 <ADC_VrefintCmd+0x12>
 8003020:	4b06      	ldr	r3, [pc, #24]	; (800303c <ADC_VrefintCmd+0x2c>)
  else
  {
    if (NewState != DISABLE)
    {
      /* Enable the Vrefint channel*/
      ADC3_4->CCR |= ADC34_CCR_VREFEN;
 8003022:	689a      	ldr	r2, [r3, #8]
      ADC1_2->CCR &= ~(uint32_t)ADC12_CCR_VREFEN;
    }
  }
  else
  {
    if (NewState != DISABLE)
 8003024:	b111      	cbz	r1, 800302c <ADC_VrefintCmd+0x1c>
    {
      /* Enable the Vrefint channel*/
      ADC3_4->CCR |= ADC34_CCR_VREFEN;
 8003026:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 800302a:	e001      	b.n	8003030 <ADC_VrefintCmd+0x20>
    }
    else
    {
      /* Disable the Vrefint channel*/
      ADC3_4->CCR &= ~(uint32_t)ADC34_CCR_VREFEN;
 800302c:	f422 0280 	bic.w	r2, r2, #4194304	; 0x400000
 8003030:	609a      	str	r2, [r3, #8]
 8003032:	4770      	bx	lr
 8003034:	50000100 	.word	0x50000100
 8003038:	50000300 	.word	0x50000300
 800303c:	50000700 	.word	0x50000700

08003040 <ADC_VbatCmd>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if((ADCx == ADC1) || (ADCx == ADC2))
 8003040:	f1b0 4fa0 	cmp.w	r0, #1342177280	; 0x50000000
 8003044:	d002      	beq.n	800304c <ADC_VbatCmd+0xc>
 8003046:	4b07      	ldr	r3, [pc, #28]	; (8003064 <ADC_VbatCmd+0x24>)
 8003048:	4298      	cmp	r0, r3
 800304a:	d101      	bne.n	8003050 <ADC_VbatCmd+0x10>
 800304c:	4b06      	ldr	r3, [pc, #24]	; (8003068 <ADC_VbatCmd+0x28>)
 800304e:	e000      	b.n	8003052 <ADC_VbatCmd+0x12>
 8003050:	4b06      	ldr	r3, [pc, #24]	; (800306c <ADC_VbatCmd+0x2c>)
  else
  {
    if (NewState != DISABLE)
    {
      /* Enable the Vbat channel*/
      ADC3_4->CCR |= ADC34_CCR_VBATEN;
 8003052:	689a      	ldr	r2, [r3, #8]
      ADC1_2->CCR &= ~(uint32_t)ADC12_CCR_VBATEN;
    }
  }
  else
  {
    if (NewState != DISABLE)
 8003054:	b111      	cbz	r1, 800305c <ADC_VbatCmd+0x1c>
    {
      /* Enable the Vbat channel*/
      ADC3_4->CCR |= ADC34_CCR_VBATEN;
 8003056:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 800305a:	e001      	b.n	8003060 <ADC_VbatCmd+0x20>
    }
    else
    {
      /* Disable the Vbat channel*/
      ADC3_4->CCR &= ~(uint32_t)ADC34_CCR_VBATEN;
 800305c:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 8003060:	609a      	str	r2, [r3, #8]
 8003062:	4770      	bx	lr
 8003064:	50000100 	.word	0x50000100
 8003068:	50000300 	.word	0x50000300
 800306c:	50000700 	.word	0x50000700

08003070 <ADC_RegularChannelConfig>:
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));

  /* Regular sequence configuration */
  /* For Rank 1 to 4 */
  if (Rank < 5)
 8003070:	2a04      	cmp	r2, #4
  *     @arg ADC_SampleTime_181Cycles5: Sample time equal to 181.5 cycles	
  *     @arg ADC_SampleTime_601Cycles5: Sample time equal to 601.5 cycles	
  * @retval None
  */
void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
{
 8003072:	b570      	push	{r4, r5, r6, lr}
 8003074:	f04f 0406 	mov.w	r4, #6
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));

  /* Regular sequence configuration */
  /* For Rank 1 to 4 */
  if (Rank < 5)
 8003078:	d80b      	bhi.n	8003092 <ADC_RegularChannelConfig+0x22>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR1;
    /* Calculate the mask to clear */
    tmpreg2 = 0x1F << (6 * (Rank ));
 800307a:	4362      	muls	r2, r4
 800307c:	241f      	movs	r4, #31
 800307e:	fa04 f402 	lsl.w	r4, r4, r2
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)(ADC_Channel) << (6 * (Rank));
 8003082:	fa01 f202 	lsl.w	r2, r1, r2
  /* Regular sequence configuration */
  /* For Rank 1 to 4 */
  if (Rank < 5)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR1;
 8003086:	6b05      	ldr	r5, [r0, #48]	; 0x30
    /* Calculate the mask to clear */
    tmpreg2 = 0x1F << (6 * (Rank ));
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 8003088:	ea25 0404 	bic.w	r4, r5, r4
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)(ADC_Channel) << (6 * (Rank));
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 800308c:	4322      	orrs	r2, r4
    /* Store the new register value */
    ADCx->SQR1 = tmpreg1;
 800308e:	6302      	str	r2, [r0, #48]	; 0x30
 8003090:	e029      	b.n	80030e6 <ADC_RegularChannelConfig+0x76>
  }
  /* For Rank 5 to 9 */
  else if (Rank < 10)
 8003092:	2a09      	cmp	r2, #9
 8003094:	d80c      	bhi.n	80030b0 <ADC_RegularChannelConfig+0x40>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR2;
    /* Calculate the mask to clear */
    tmpreg2 = ADC_SQR2_SQ5 << (6 * (Rank - 5));
 8003096:	4362      	muls	r2, r4
 8003098:	241f      	movs	r4, #31
 800309a:	3a1e      	subs	r2, #30
 800309c:	fa04 f402 	lsl.w	r4, r4, r2
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)(ADC_Channel) << (6 * (Rank - 5));
 80030a0:	fa01 f202 	lsl.w	r2, r1, r2
  }
  /* For Rank 5 to 9 */
  else if (Rank < 10)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR2;
 80030a4:	6b45      	ldr	r5, [r0, #52]	; 0x34
    /* Calculate the mask to clear */
    tmpreg2 = ADC_SQR2_SQ5 << (6 * (Rank - 5));
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 80030a6:	ea25 0404 	bic.w	r4, r5, r4
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)(ADC_Channel) << (6 * (Rank - 5));
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 80030aa:	4322      	orrs	r2, r4
    /* Store the new register value */
    ADCx->SQR2 = tmpreg1;
 80030ac:	6342      	str	r2, [r0, #52]	; 0x34
 80030ae:	e01a      	b.n	80030e6 <ADC_RegularChannelConfig+0x76>
  }
  /* For Rank 10 to 14 */
  else if (Rank < 15)
 80030b0:	2a0e      	cmp	r2, #14
 80030b2:	d80c      	bhi.n	80030ce <ADC_RegularChannelConfig+0x5e>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR3;
    /* Calculate the mask to clear */
    tmpreg2 = ADC_SQR3_SQ10 << (6 * (Rank - 10));
 80030b4:	4362      	muls	r2, r4
 80030b6:	241f      	movs	r4, #31
 80030b8:	3a3c      	subs	r2, #60	; 0x3c
 80030ba:	fa04 f402 	lsl.w	r4, r4, r2
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)(ADC_Channel) << (6 * (Rank - 10));
 80030be:	fa01 f202 	lsl.w	r2, r1, r2
  }
  /* For Rank 10 to 14 */
  else if (Rank < 15)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR3;
 80030c2:	6b85      	ldr	r5, [r0, #56]	; 0x38
    /* Calculate the mask to clear */
    tmpreg2 = ADC_SQR3_SQ10 << (6 * (Rank - 10));
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 80030c4:	ea25 0404 	bic.w	r4, r5, r4
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)(ADC_Channel) << (6 * (Rank - 10));
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 80030c8:	4322      	orrs	r2, r4
    /* Store the new register value */
    ADCx->SQR3 = tmpreg1;
 80030ca:	6382      	str	r2, [r0, #56]	; 0x38
 80030cc:	e00b      	b.n	80030e6 <ADC_RegularChannelConfig+0x76>
  else 
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR4;
    /* Calculate the mask to clear */
    tmpreg2 = ADC_SQR3_SQ15 << (6 * (Rank - 15));
 80030ce:	4362      	muls	r2, r4
 80030d0:	241f      	movs	r4, #31
 80030d2:	3a5a      	subs	r2, #90	; 0x5a
 80030d4:	fa04 f402 	lsl.w	r4, r4, r2
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)(ADC_Channel) << (6 * (Rank - 15));
 80030d8:	fa01 f202 	lsl.w	r2, r1, r2
    ADCx->SQR3 = tmpreg1;
  }
  else 
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SQR4;
 80030dc:	6bc5      	ldr	r5, [r0, #60]	; 0x3c
    /* Calculate the mask to clear */
    tmpreg2 = ADC_SQR3_SQ15 << (6 * (Rank - 15));
    /* Clear the old SQx bits for the selected rank */
    tmpreg1 &= ~tmpreg2;
 80030de:	ea25 0404 	bic.w	r4, r5, r4
    /* Calculate the mask to set */
    tmpreg2 = (uint32_t)(ADC_Channel) << (6 * (Rank - 15));
    /* Set the SQx bits for the selected rank */
    tmpreg1 |= tmpreg2;
 80030e2:	4322      	orrs	r2, r4
    /* Store the new register value */
    ADCx->SQR4 = tmpreg1;
 80030e4:	63c2      	str	r2, [r0, #60]	; 0x3c
  }

  /* Channel sampling configuration */
  /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
  if (ADC_Channel > ADC_Channel_9)
 80030e6:	2909      	cmp	r1, #9
 80030e8:	f04f 0203 	mov.w	r2, #3
 80030ec:	d90f      	bls.n	800310e <ADC_RegularChannelConfig+0x9e>
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR2;
    /* Calculate the mask to clear */
    tmpreg2 = ADC_SMPR2_SMP10 << (3 * (ADC_Channel - 10));
 80030ee:	434a      	muls	r2, r1
 80030f0:	2107      	movs	r1, #7
 80030f2:	3a1e      	subs	r2, #30
 80030f4:	fa01 f102 	lsl.w	r1, r1, r2
    /* Clear the old channel sample time */
	ADCx->SMPR2 &= ~tmpreg2;
    /* Calculate the mask to set */
	ADCx->SMPR2 |= (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
 80030f8:	fa03 f202 	lsl.w	r2, r3, r2
  /* Channel sampling configuration */
  /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
  if (ADC_Channel > ADC_Channel_9)
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR2;
 80030fc:	6984      	ldr	r4, [r0, #24]
    /* Calculate the mask to clear */
    tmpreg2 = ADC_SMPR2_SMP10 << (3 * (ADC_Channel - 10));
    /* Clear the old channel sample time */
	ADCx->SMPR2 &= ~tmpreg2;
 80030fe:	6984      	ldr	r4, [r0, #24]
 8003100:	ea24 0101 	bic.w	r1, r4, r1
 8003104:	6181      	str	r1, [r0, #24]
    /* Calculate the mask to set */
	ADCx->SMPR2 |= (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
 8003106:	6984      	ldr	r4, [r0, #24]
 8003108:	4322      	orrs	r2, r4
 800310a:	6182      	str	r2, [r0, #24]
 800310c:	bd70      	pop	{r4, r5, r6, pc}

  }
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR1;
 800310e:	6944      	ldr	r4, [r0, #20]
    /* Calculate the mask to clear */
    tmpreg2 = ADC_SMPR1_SMP1 << (3 * (ADC_Channel - 1));
 8003110:	1e4c      	subs	r4, r1, #1
 8003112:	4354      	muls	r4, r2
 8003114:	2638      	movs	r6, #56	; 0x38
 8003116:	fa06 f404 	lsl.w	r4, r6, r4
    /* Clear the old channel sample time */
	ADCx->SMPR1 &= ~tmpreg2;
    /* Calculate the mask to set */
	ADCx->SMPR1 |= (uint32_t)ADC_SampleTime << (3 * (ADC_Channel));
 800311a:	4351      	muls	r1, r2
 800311c:	fa03 f301 	lsl.w	r3, r3, r1
    /* Get the old register value */
    tmpreg1 = ADCx->SMPR1;
    /* Calculate the mask to clear */
    tmpreg2 = ADC_SMPR1_SMP1 << (3 * (ADC_Channel - 1));
    /* Clear the old channel sample time */
	ADCx->SMPR1 &= ~tmpreg2;
 8003120:	6945      	ldr	r5, [r0, #20]
 8003122:	ea25 0404 	bic.w	r4, r5, r4
 8003126:	6144      	str	r4, [r0, #20]
    /* Calculate the mask to set */
	ADCx->SMPR1 |= (uint32_t)ADC_SampleTime << (3 * (ADC_Channel));
 8003128:	6944      	ldr	r4, [r0, #20]
 800312a:	4323      	orrs	r3, r4
 800312c:	6143      	str	r3, [r0, #20]
 800312e:	bd70      	pop	{r4, r5, r6, pc}

08003130 <ADC_RegularChannelSequencerLengthConfig>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  /* Configure the ADC sequence lenght */  
  ADCx->SQR1 &= ~(uint32_t)ADC_SQR1_L;
 8003130:	6b03      	ldr	r3, [r0, #48]	; 0x30
  ADCx->SQR1 |= (uint32_t)(SequencerLength - 1);   
 8003132:	3901      	subs	r1, #1
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  /* Configure the ADC sequence lenght */  
  ADCx->SQR1 &= ~(uint32_t)ADC_SQR1_L;
 8003134:	f023 030f 	bic.w	r3, r3, #15
 8003138:	6303      	str	r3, [r0, #48]	; 0x30
  ADCx->SQR1 |= (uint32_t)(SequencerLength - 1);   
 800313a:	6b03      	ldr	r3, [r0, #48]	; 0x30
 800313c:	430b      	orrs	r3, r1
 800313e:	6303      	str	r3, [r0, #48]	; 0x30
 8003140:	4770      	bx	lr

08003142 <ADC_ExternalTriggerConfig>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_EXT_TRIG(ADC_ExternalTrigConvEvent));
  assert_param(IS_EXTERNALTRIG_EDGE(ADC_ExternalTrigEventEdge));

  /* Disable the selected ADC conversion on external event */
  ADCx->CFGR &= ~(ADC_CFGR_EXTEN | ADC_CFGR_EXTSEL);
 8003142:	68c3      	ldr	r3, [r0, #12]
  ADCx->CFGR |= (uint32_t)(ADC_ExternalTrigEventEdge | ADC_ExternalTrigConvEvent);
 8003144:	430a      	orrs	r2, r1
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_EXT_TRIG(ADC_ExternalTrigConvEvent));
  assert_param(IS_EXTERNALTRIG_EDGE(ADC_ExternalTrigEventEdge));

  /* Disable the selected ADC conversion on external event */
  ADCx->CFGR &= ~(ADC_CFGR_EXTEN | ADC_CFGR_EXTSEL);
 8003146:	f423 637c 	bic.w	r3, r3, #4032	; 0xfc0
 800314a:	60c3      	str	r3, [r0, #12]
  ADCx->CFGR |= (uint32_t)(ADC_ExternalTrigEventEdge | ADC_ExternalTrigConvEvent);
 800314c:	68c3      	ldr	r3, [r0, #12]
 800314e:	4313      	orrs	r3, r2
 8003150:	60c3      	str	r3, [r0, #12]
 8003152:	4770      	bx	lr

08003154 <ADC_StartConversion>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  /* Set the ADSTART bit */
  ADCx->CR |= ADC_CR_ADSTART;
 8003154:	6883      	ldr	r3, [r0, #8]
 8003156:	f043 0304 	orr.w	r3, r3, #4
 800315a:	6083      	str	r3, [r0, #8]
 800315c:	4770      	bx	lr

0800315e <ADC_GetStartConversionStatus>:
{
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  /* Check the status of ADSTART bit */
  if ((ADCx->CR & ADC_CR_ADSTART) != (uint32_t)RESET)
 800315e:	6880      	ldr	r0, [r0, #8]
    /* ADSTART bit is reset */
    bitstatus = RESET;
  }
  /* Return the ADSTART bit status */
  return  bitstatus;
}
 8003160:	f3c0 0080 	ubfx	r0, r0, #2, #1
 8003164:	4770      	bx	lr

08003166 <ADC_StopConversion>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  /* Set the ADSTP bit */
   ADCx->CR |= ADC_CR_ADSTP;
 8003166:	6883      	ldr	r3, [r0, #8]
 8003168:	f043 0310 	orr.w	r3, r3, #16
 800316c:	6083      	str	r3, [r0, #8]
 800316e:	4770      	bx	lr

08003170 <ADC_DiscModeChannelCountConfig>:
  uint32_t tmpreg2 = 0;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));
  /* Get the old register value */
  tmpreg1 = ADCx->CFGR;
 8003170:	68c3      	ldr	r3, [r0, #12]
  /* Clear the old discontinuous mode channel count */
  tmpreg1 &= ~(uint32_t)(ADC_CFGR_DISCNUM);
  /* Set the discontinuous mode channel count */
  tmpreg2 = Number - 1;
 8003172:	3901      	subs	r1, #1
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));
  /* Get the old register value */
  tmpreg1 = ADCx->CFGR;
  /* Clear the old discontinuous mode channel count */
  tmpreg1 &= ~(uint32_t)(ADC_CFGR_DISCNUM);
 8003174:	f423 2360 	bic.w	r3, r3, #917504	; 0xe0000
  /* Set the discontinuous mode channel count */
  tmpreg2 = Number - 1;
  tmpreg1 |= tmpreg2 << 17;
 8003178:	ea43 4341 	orr.w	r3, r3, r1, lsl #17
  /* Store the new register value */
  ADCx->CFGR = tmpreg1;
 800317c:	60c3      	str	r3, [r0, #12]
 800317e:	4770      	bx	lr

08003180 <ADC_DiscModeCmd>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected ADC regular discontinuous mode */
    ADCx->CFGR |= ADC_CFGR_DISCEN;
 8003180:	68c3      	ldr	r3, [r0, #12]
void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8003182:	b111      	cbz	r1, 800318a <ADC_DiscModeCmd+0xa>
  {
    /* Enable the selected ADC regular discontinuous mode */
    ADCx->CFGR |= ADC_CFGR_DISCEN;
 8003184:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8003188:	e001      	b.n	800318e <ADC_DiscModeCmd+0xe>
  }
  else
  {
    /* Disable the selected ADC regular discontinuous mode */
    ADCx->CFGR &= ~(uint32_t)(ADC_CFGR_DISCEN);
 800318a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800318e:	60c3      	str	r3, [r0, #12]
 8003190:	4770      	bx	lr

08003192 <ADC_GetConversionValue>:
uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  /* Return the selected ADC conversion value */
  return (uint16_t) ADCx->DR;
 8003192:	6c00      	ldr	r0, [r0, #64]	; 0x40
}
 8003194:	b280      	uxth	r0, r0
 8003196:	4770      	bx	lr

08003198 <ADC_GetDualModeConversionValue>:
  uint32_t tmpreg1 = 0;

  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  if((ADCx == ADC1) || (ADCx== ADC2))
 8003198:	f1b0 4fa0 	cmp.w	r0, #1342177280	; 0x50000000
 800319c:	d002      	beq.n	80031a4 <ADC_GetDualModeConversionValue+0xc>
 800319e:	4b04      	ldr	r3, [pc, #16]	; (80031b0 <ADC_GetDualModeConversionValue+0x18>)
 80031a0:	4298      	cmp	r0, r3
 80031a2:	d101      	bne.n	80031a8 <ADC_GetDualModeConversionValue+0x10>
  {
    /* Get the dual mode conversion value */
    tmpreg1 = ADC1_2->CDR;
 80031a4:	4b03      	ldr	r3, [pc, #12]	; (80031b4 <ADC_GetDualModeConversionValue+0x1c>)
 80031a6:	e000      	b.n	80031aa <ADC_GetDualModeConversionValue+0x12>
  }
  else
  {	
    /* Get the dual mode conversion value */
    tmpreg1 = ADC3_4->CDR;
 80031a8:	4b03      	ldr	r3, [pc, #12]	; (80031b8 <ADC_GetDualModeConversionValue+0x20>)
 80031aa:	68d8      	ldr	r0, [r3, #12]
  }
  /* Return the dual mode conversion value */
  return (uint32_t) tmpreg1;
}
 80031ac:	4770      	bx	lr
 80031ae:	bf00      	nop
 80031b0:	50000100 	.word	0x50000100
 80031b4:	50000300 	.word	0x50000300
 80031b8:	50000700 	.word	0x50000700

080031bc <ADC_SetChannelOffset1>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_OFFSET(Offset));
    
  /* Select the Channel */
  ADCx->OFR1 &= ~ (uint32_t) ADC_OFR1_OFFSET1_CH;
 80031bc:	6e03      	ldr	r3, [r0, #96]	; 0x60
 80031be:	f023 43f8 	bic.w	r3, r3, #2080374784	; 0x7c000000
 80031c2:	6603      	str	r3, [r0, #96]	; 0x60
  ADCx->OFR1 |=	(uint32_t)((uint32_t)ADC_Channel << 26);
 80031c4:	6e03      	ldr	r3, [r0, #96]	; 0x60
 80031c6:	ea43 6181 	orr.w	r1, r3, r1, lsl #26
 80031ca:	6601      	str	r1, [r0, #96]	; 0x60

  /* Set the data offset */
  ADCx->OFR1 &= ~ (uint32_t) ADC_OFR1_OFFSET1;
 80031cc:	6e03      	ldr	r3, [r0, #96]	; 0x60
 80031ce:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 80031d2:	f023 030f 	bic.w	r3, r3, #15
 80031d6:	6603      	str	r3, [r0, #96]	; 0x60
  ADCx->OFR1 |= (uint32_t)Offset;
 80031d8:	6e03      	ldr	r3, [r0, #96]	; 0x60
 80031da:	431a      	orrs	r2, r3
 80031dc:	6602      	str	r2, [r0, #96]	; 0x60
 80031de:	4770      	bx	lr

080031e0 <ADC_SetChannelOffset2>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_OFFSET(Offset));
    
  /* Select the Channel */
  ADCx->OFR2 &= ~ (uint32_t) ADC_OFR2_OFFSET2_CH;
 80031e0:	6e43      	ldr	r3, [r0, #100]	; 0x64
 80031e2:	f023 43f8 	bic.w	r3, r3, #2080374784	; 0x7c000000
 80031e6:	6643      	str	r3, [r0, #100]	; 0x64
  ADCx->OFR2 |=	(uint32_t)((uint32_t)ADC_Channel << 26);
 80031e8:	6e43      	ldr	r3, [r0, #100]	; 0x64
 80031ea:	ea43 6181 	orr.w	r1, r3, r1, lsl #26
 80031ee:	6641      	str	r1, [r0, #100]	; 0x64

  /* Set the data offset */
  ADCx->OFR2 &= ~ (uint32_t) ADC_OFR2_OFFSET2;
 80031f0:	6e43      	ldr	r3, [r0, #100]	; 0x64
 80031f2:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 80031f6:	f023 030f 	bic.w	r3, r3, #15
 80031fa:	6643      	str	r3, [r0, #100]	; 0x64
  ADCx->OFR2 |= (uint32_t)Offset;
 80031fc:	6e43      	ldr	r3, [r0, #100]	; 0x64
 80031fe:	431a      	orrs	r2, r3
 8003200:	6642      	str	r2, [r0, #100]	; 0x64
 8003202:	4770      	bx	lr

08003204 <ADC_SetChannelOffset3>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_OFFSET(Offset));
    
  /* Select the Channel */
  ADCx->OFR3 &= ~ (uint32_t) ADC_OFR3_OFFSET3_CH;
 8003204:	6e83      	ldr	r3, [r0, #104]	; 0x68
 8003206:	f023 43f8 	bic.w	r3, r3, #2080374784	; 0x7c000000
 800320a:	6683      	str	r3, [r0, #104]	; 0x68
  ADCx->OFR3 |=	(uint32_t)((uint32_t)ADC_Channel << 26);
 800320c:	6e83      	ldr	r3, [r0, #104]	; 0x68
 800320e:	ea43 6181 	orr.w	r1, r3, r1, lsl #26
 8003212:	6681      	str	r1, [r0, #104]	; 0x68

  /* Set the data offset */
  ADCx->OFR3 &= ~ (uint32_t) ADC_OFR3_OFFSET3;
 8003214:	6e83      	ldr	r3, [r0, #104]	; 0x68
 8003216:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 800321a:	f023 030f 	bic.w	r3, r3, #15
 800321e:	6683      	str	r3, [r0, #104]	; 0x68
  ADCx->OFR3 |= (uint32_t)Offset;
 8003220:	6e83      	ldr	r3, [r0, #104]	; 0x68
 8003222:	431a      	orrs	r2, r3
 8003224:	6682      	str	r2, [r0, #104]	; 0x68
 8003226:	4770      	bx	lr

08003228 <ADC_SetChannelOffset4>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CHANNEL(ADC_Channel));
  assert_param(IS_ADC_OFFSET(Offset));
    
  /* Select the Channel */
  ADCx->OFR4 &= ~ (uint32_t) ADC_OFR4_OFFSET4_CH;
 8003228:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 800322a:	f023 43f8 	bic.w	r3, r3, #2080374784	; 0x7c000000
 800322e:	66c3      	str	r3, [r0, #108]	; 0x6c
  ADCx->OFR4 |=	(uint32_t)((uint32_t)ADC_Channel << 26);
 8003230:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 8003232:	ea43 6181 	orr.w	r1, r3, r1, lsl #26
 8003236:	66c1      	str	r1, [r0, #108]	; 0x6c

  /* Set the data offset */
  ADCx->OFR4 &= ~ (uint32_t) ADC_OFR4_OFFSET4;
 8003238:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 800323a:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 800323e:	f023 030f 	bic.w	r3, r3, #15
 8003242:	66c3      	str	r3, [r0, #108]	; 0x6c
  ADCx->OFR4 |= (uint32_t)Offset;
 8003244:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 8003246:	431a      	orrs	r2, r3
 8003248:	66c2      	str	r2, [r0, #108]	; 0x6c
 800324a:	4770      	bx	lr

0800324c <ADC_ChannelOffset1Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Set the OFFSET1_EN bit */
    ADCx->OFR1 |= ADC_OFR1_OFFSET1_EN;
 800324c:	6e03      	ldr	r3, [r0, #96]	; 0x60
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800324e:	b111      	cbz	r1, 8003256 <ADC_ChannelOffset1Cmd+0xa>
  {
    /* Set the OFFSET1_EN bit */
    ADCx->OFR1 |= ADC_OFR1_OFFSET1_EN;
 8003250:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8003254:	e001      	b.n	800325a <ADC_ChannelOffset1Cmd+0xe>
  }
  else
  {
    /* Reset the OFFSET1_EN bit */
    ADCx->OFR1 &= ~(ADC_OFR1_OFFSET1_EN);
 8003256:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 800325a:	6603      	str	r3, [r0, #96]	; 0x60
 800325c:	4770      	bx	lr

0800325e <ADC_ChannelOffset2Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Set the OFFSET1_EN bit */
    ADCx->OFR2 |= ADC_OFR2_OFFSET2_EN;
 800325e:	6e43      	ldr	r3, [r0, #100]	; 0x64
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8003260:	b111      	cbz	r1, 8003268 <ADC_ChannelOffset2Cmd+0xa>
  {
    /* Set the OFFSET1_EN bit */
    ADCx->OFR2 |= ADC_OFR2_OFFSET2_EN;
 8003262:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8003266:	e001      	b.n	800326c <ADC_ChannelOffset2Cmd+0xe>
  }
  else
  {
    /* Reset the OFFSET1_EN bit */
    ADCx->OFR2 &= ~(ADC_OFR2_OFFSET2_EN);
 8003268:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 800326c:	6643      	str	r3, [r0, #100]	; 0x64
 800326e:	4770      	bx	lr

08003270 <ADC_ChannelOffset3Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Set the OFFSET1_EN bit */
    ADCx->OFR3 |= ADC_OFR3_OFFSET3_EN;
 8003270:	6e83      	ldr	r3, [r0, #104]	; 0x68
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8003272:	b111      	cbz	r1, 800327a <ADC_ChannelOffset3Cmd+0xa>
  {
    /* Set the OFFSET1_EN bit */
    ADCx->OFR3 |= ADC_OFR3_OFFSET3_EN;
 8003274:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8003278:	e001      	b.n	800327e <ADC_ChannelOffset3Cmd+0xe>
  }
  else
  {
    /* Reset the OFFSET1_EN bit */
    ADCx->OFR3 &= ~(ADC_OFR3_OFFSET3_EN);
 800327a:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 800327e:	6683      	str	r3, [r0, #104]	; 0x68
 8003280:	4770      	bx	lr

08003282 <ADC_ChannelOffset4Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Set the OFFSET1_EN bit */
    ADCx->OFR4 |= ADC_OFR4_OFFSET4_EN;
 8003282:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8003284:	b111      	cbz	r1, 800328c <ADC_ChannelOffset4Cmd+0xa>
  {
    /* Set the OFFSET1_EN bit */
    ADCx->OFR4 |= ADC_OFR4_OFFSET4_EN;
 8003286:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800328a:	e001      	b.n	8003290 <ADC_ChannelOffset4Cmd+0xe>
  }
  else
  {
    /* Reset the OFFSET1_EN bit */
    ADCx->OFR4 &= ~(ADC_OFR4_OFFSET4_EN);
 800328c:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8003290:	66c3      	str	r3, [r0, #108]	; 0x6c
 8003292:	4770      	bx	lr

08003294 <ADC_DMACmd>:
  assert_param(IS_ADC_DMA_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected ADC DMA request */
    ADCx->CFGR |= ADC_CFGR_DMAEN;
 8003294:	68c3      	ldr	r3, [r0, #12]
void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_DMA_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8003296:	b111      	cbz	r1, 800329e <ADC_DMACmd+0xa>
  {
    /* Enable the selected ADC DMA request */
    ADCx->CFGR |= ADC_CFGR_DMAEN;
 8003298:	f043 0301 	orr.w	r3, r3, #1
 800329c:	e001      	b.n	80032a2 <ADC_DMACmd+0xe>
  }
  else
  {
    /* Disable the selected ADC DMA request */
    ADCx->CFGR &= ~(uint32_t)ADC_CFGR_DMAEN;
 800329e:	f023 0301 	bic.w	r3, r3, #1
 80032a2:	60c3      	str	r3, [r0, #12]
 80032a4:	4770      	bx	lr

080032a6 <ADC_DMAConfig>:
  /* Check the parameters */
  assert_param(IS_ADC_DMA_PERIPH(ADCx));
  assert_param(IS_ADC_DMA_MODE(ADC_DMAMode));

  /* Set or reset the DMACFG bit */
   ADCx->CFGR &= ~(uint32_t)ADC_CFGR_DMACFG;
 80032a6:	68c3      	ldr	r3, [r0, #12]
 80032a8:	f023 0302 	bic.w	r3, r3, #2
 80032ac:	60c3      	str	r3, [r0, #12]
   ADCx->CFGR |= ADC_DMAMode;
 80032ae:	68c3      	ldr	r3, [r0, #12]
 80032b0:	4319      	orrs	r1, r3
 80032b2:	60c1      	str	r1, [r0, #12]
 80032b4:	4770      	bx	lr

080032b6 <ADC_InjectedChannelSampleTimeConfig>:
  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));

  /* Channel sampling configuration */
  /* if ADC_InjectedChannel_10 ... ADC_InjectedChannel_18 is selected */
  if (ADC_InjectedChannel > ADC_InjectedChannel_9)
 80032b6:	2909      	cmp	r1, #9
  *     @arg ADC_SampleTime_181Cycles5: Sample time equal to 181.5 cycles	
  *     @arg ADC_SampleTime_601Cycles5: Sample time equal to 601.5 cycles	
  * @retval None
  */
void ADC_InjectedChannelSampleTimeConfig(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel, uint8_t ADC_SampleTime)
{
 80032b8:	b570      	push	{r4, r5, r6, lr}
 80032ba:	f04f 0303 	mov.w	r3, #3
  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));

  /* Channel sampling configuration */
  /* if ADC_InjectedChannel_10 ... ADC_InjectedChannel_18 is selected */
  if (ADC_InjectedChannel > ADC_InjectedChannel_9)
 80032be:	d90e      	bls.n	80032de <ADC_InjectedChannelSampleTimeConfig+0x28>
  {
    /* Calculate the mask to clear */
    tmpreg1 = ADC_SMPR2_SMP10 << (3 * (ADC_InjectedChannel - 10));
 80032c0:	434b      	muls	r3, r1
 80032c2:	2107      	movs	r1, #7
 80032c4:	3b1e      	subs	r3, #30
 80032c6:	fa01 f103 	lsl.w	r1, r1, r3
    /* Clear the old channel sample time */
	ADCx->SMPR2 &= ~tmpreg1;
    /* Calculate the mask to set */
	ADCx->SMPR2 |= (uint32_t)ADC_SampleTime << (3 * (ADC_InjectedChannel - 10));
 80032ca:	fa02 f303 	lsl.w	r3, r2, r3
  if (ADC_InjectedChannel > ADC_InjectedChannel_9)
  {
    /* Calculate the mask to clear */
    tmpreg1 = ADC_SMPR2_SMP10 << (3 * (ADC_InjectedChannel - 10));
    /* Clear the old channel sample time */
	ADCx->SMPR2 &= ~tmpreg1;
 80032ce:	6984      	ldr	r4, [r0, #24]
 80032d0:	ea24 0101 	bic.w	r1, r4, r1
 80032d4:	6181      	str	r1, [r0, #24]
    /* Calculate the mask to set */
	ADCx->SMPR2 |= (uint32_t)ADC_SampleTime << (3 * (ADC_InjectedChannel - 10));
 80032d6:	6984      	ldr	r4, [r0, #24]
 80032d8:	4323      	orrs	r3, r4
 80032da:	6183      	str	r3, [r0, #24]
 80032dc:	bd70      	pop	{r4, r5, r6, pc}

  }
  else /* ADC_InjectedChannel include in ADC_InjectedChannel_[0..9] */
  {
    /* Calculate the mask to clear */
    tmpreg1 = ADC_SMPR1_SMP1 << (3 * (ADC_InjectedChannel - 1));
 80032de:	1e4c      	subs	r4, r1, #1
 80032e0:	435c      	muls	r4, r3
 80032e2:	2638      	movs	r6, #56	; 0x38
 80032e4:	fa06 f404 	lsl.w	r4, r6, r4
    /* Clear the old channel sample time */
	ADCx->SMPR1 &= ~tmpreg1;
    /* Calculate the mask to set */
	ADCx->SMPR1 |= (uint32_t)ADC_SampleTime << (3 * (ADC_InjectedChannel));
 80032e8:	4359      	muls	r1, r3
 80032ea:	fa02 f201 	lsl.w	r2, r2, r1
  else /* ADC_InjectedChannel include in ADC_InjectedChannel_[0..9] */
  {
    /* Calculate the mask to clear */
    tmpreg1 = ADC_SMPR1_SMP1 << (3 * (ADC_InjectedChannel - 1));
    /* Clear the old channel sample time */
	ADCx->SMPR1 &= ~tmpreg1;
 80032ee:	6945      	ldr	r5, [r0, #20]
 80032f0:	ea25 0404 	bic.w	r4, r5, r4
 80032f4:	6144      	str	r4, [r0, #20]
    /* Calculate the mask to set */
	ADCx->SMPR1 |= (uint32_t)ADC_SampleTime << (3 * (ADC_InjectedChannel));
 80032f6:	6944      	ldr	r4, [r0, #20]
 80032f8:	4322      	orrs	r2, r4
 80032fa:	6142      	str	r2, [r0, #20]
 80032fc:	bd70      	pop	{r4, r5, r6, pc}

080032fe <ADC_StartInjectedConversion>:
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  /* Enable the selected ADC conversion for injected group on external event and start the selected
     ADC injected conversion */
  ADCx->CR |= ADC_CR_JADSTART;
 80032fe:	6883      	ldr	r3, [r0, #8]
 8003300:	f043 0308 	orr.w	r3, r3, #8
 8003304:	6083      	str	r3, [r0, #8]
 8003306:	4770      	bx	lr

08003308 <ADC_StopInjectedConversion>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  /* Set the JADSTP bit */
   ADCx->CR |= ADC_CR_JADSTP;
 8003308:	6883      	ldr	r3, [r0, #8]
 800330a:	f043 0320 	orr.w	r3, r3, #32
 800330e:	6083      	str	r3, [r0, #8]
 8003310:	4770      	bx	lr

08003312 <ADC_GetStartInjectedConversionStatus>:
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));

  /* Check the status of JADSTART bit */
  if ((ADCx->CR & ADC_CR_JADSTART) != (uint32_t)RESET)
 8003312:	6880      	ldr	r0, [r0, #8]
    /* JADSTART bit is reset */
    bitstatus = RESET;
  }
  /* Return the JADSTART bit status */
  return  bitstatus;
}
 8003314:	f3c0 00c0 	ubfx	r0, r0, #3, #1
 8003318:	4770      	bx	lr

0800331a <ADC_AutoInjectedConvCmd>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected ADC automatic injected group conversion */
    ADCx->CFGR |= ADC_CFGR_JAUTO;
 800331a:	68c3      	ldr	r3, [r0, #12]
void ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800331c:	b111      	cbz	r1, 8003324 <ADC_AutoInjectedConvCmd+0xa>
  {
    /* Enable the selected ADC automatic injected group conversion */
    ADCx->CFGR |= ADC_CFGR_JAUTO;
 800331e:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 8003322:	e001      	b.n	8003328 <ADC_AutoInjectedConvCmd+0xe>
  }
  else
  {
    /* Disable the selected ADC automatic injected group conversion */
    ADCx->CFGR &= ~ADC_CFGR_JAUTO;
 8003324:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
 8003328:	60c3      	str	r3, [r0, #12]
 800332a:	4770      	bx	lr

0800332c <ADC_InjectedDiscModeCmd>:
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected ADC injected discontinuous mode */
    ADCx->CFGR |= ADC_CFGR_JDISCEN;
 800332c:	68c3      	ldr	r3, [r0, #12]
void ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800332e:	b111      	cbz	r1, 8003336 <ADC_InjectedDiscModeCmd+0xa>
  {
    /* Enable the selected ADC injected discontinuous mode */
    ADCx->CFGR |= ADC_CFGR_JDISCEN;
 8003330:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8003334:	e001      	b.n	800333a <ADC_InjectedDiscModeCmd+0xe>
  }
  else
  {
    /* Disable the selected ADC injected discontinuous mode */
    ADCx->CFGR &= ~ADC_CFGR_JDISCEN;
 8003336:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
 800333a:	60c3      	str	r3, [r0, #12]
 800333c:	4770      	bx	lr

0800333e <ADC_GetInjectedConversionValue>:
  *     @arg ADC_InjectedSequence_3: Injected Sequence3 selected
  *     @arg ADC_InjectedSequence_4: Injected Sequence4 selected
  * @retval The Data conversion value.
  */
uint16_t ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, uint8_t ADC_InjectedSequence)
{
 800333e:	b082      	sub	sp, #8
  __IO uint32_t tmp = 0;
 8003340:	2300      	movs	r3, #0
 8003342:	9301      	str	r3, [sp, #4]
  
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_INJECTED_SEQUENCE(ADC_InjectedSequence));

  tmp = (uint32_t)ADCx;
 8003344:	9001      	str	r0, [sp, #4]
  tmp += ((ADC_InjectedSequence - 1 )<< 2) + JDR_Offset;
 8003346:	9b01      	ldr	r3, [sp, #4]
 8003348:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 800334c:	f101 037c 	add.w	r3, r1, #124	; 0x7c
 8003350:	9301      	str	r3, [sp, #4]
  
  /* Returns the selected injected channel conversion data value */
  return (uint16_t) (*(__IO uint32_t*)  tmp);   
 8003352:	9b01      	ldr	r3, [sp, #4]
 8003354:	6818      	ldr	r0, [r3, #0]
}
 8003356:	b280      	uxth	r0, r0
 8003358:	b002      	add	sp, #8
 800335a:	4770      	bx	lr

0800335c <ADC_ITConfig>:
  assert_param(IS_ADC_IT(ADC_IT));

  if (NewState != DISABLE)
  {
    /* Enable the selected ADC interrupts */
    ADCx->IER |= ADC_IT;
 800335c:	6843      	ldr	r3, [r0, #4]
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_ADC_IT(ADC_IT));

  if (NewState != DISABLE)
 800335e:	b10a      	cbz	r2, 8003364 <ADC_ITConfig+0x8>
  {
    /* Enable the selected ADC interrupts */
    ADCx->IER |= ADC_IT;
 8003360:	4319      	orrs	r1, r3
 8003362:	e001      	b.n	8003368 <ADC_ITConfig+0xc>
  }
  else
  {
    /* Disable the selected ADC interrupts */
    ADCx->IER &= (~(uint32_t)ADC_IT);
 8003364:	ea23 0101 	bic.w	r1, r3, r1
 8003368:	6041      	str	r1, [r0, #4]
 800336a:	4770      	bx	lr

0800336c <ADC_GetFlagStatus>:
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_GET_FLAG(ADC_FLAG));

  /* Check the status of the specified ADC flag */
  if ((ADCx->ISR & ADC_FLAG) != (uint32_t)RESET)
 800336c:	6803      	ldr	r3, [r0, #0]
 800336e:	4219      	tst	r1, r3
    /* ADC_FLAG is reset */
    bitstatus = RESET;
  }
  /* Return the ADC_FLAG status */
  return  bitstatus;
}
 8003370:	bf0c      	ite	eq
 8003372:	2000      	moveq	r0, #0
 8003374:	2001      	movne	r0, #1
 8003376:	4770      	bx	lr

08003378 <ADC_ClearFlag>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));
  /* Clear the selected ADC flags */
  ADCx->ISR = (uint32_t)ADC_FLAG;
 8003378:	6001      	str	r1, [r0, #0]
 800337a:	4770      	bx	lr

0800337c <ADC_GetCommonFlagStatus>:

  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_GET_COMMONFLAG(ADC_FLAG));

  if((ADCx == ADC1) || (ADCx == ADC2))
 800337c:	f1b0 4fa0 	cmp.w	r0, #1342177280	; 0x50000000
 8003380:	d002      	beq.n	8003388 <ADC_GetCommonFlagStatus+0xc>
 8003382:	4b06      	ldr	r3, [pc, #24]	; (800339c <ADC_GetCommonFlagStatus+0x20>)
 8003384:	4298      	cmp	r0, r3
 8003386:	d101      	bne.n	800338c <ADC_GetCommonFlagStatus+0x10>
  {
    tmpreg1 = ADC1_2->CSR;
 8003388:	4b05      	ldr	r3, [pc, #20]	; (80033a0 <ADC_GetCommonFlagStatus+0x24>)
 800338a:	e000      	b.n	800338e <ADC_GetCommonFlagStatus+0x12>
  }
  else
  {
    tmpreg1 = ADC3_4->CSR;
 800338c:	4b05      	ldr	r3, [pc, #20]	; (80033a4 <ADC_GetCommonFlagStatus+0x28>)
 800338e:	681b      	ldr	r3, [r3, #0]
  }  
  /* Check the status of the specified ADC flag */
  if ((tmpreg1 & ADC_FLAG) != (uint32_t)RESET)
 8003390:	420b      	tst	r3, r1
    /* ADC_FLAG is reset */
    bitstatus = RESET;
  }
  /* Return the ADC_FLAG status */
  return  bitstatus;
}
 8003392:	bf0c      	ite	eq
 8003394:	2000      	moveq	r0, #0
 8003396:	2001      	movne	r0, #1
 8003398:	4770      	bx	lr
 800339a:	bf00      	nop
 800339c:	50000100 	.word	0x50000100
 80033a0:	50000300 	.word	0x50000300
 80033a4:	50000700 	.word	0x50000700

080033a8 <ADC_ClearCommonFlag>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_CLEAR_COMMONFLAG(ADC_FLAG));

  if((ADCx == ADC1) || (ADCx == ADC2))
 80033a8:	f1b0 4fa0 	cmp.w	r0, #1342177280	; 0x50000000
 80033ac:	d002      	beq.n	80033b4 <ADC_ClearCommonFlag+0xc>
 80033ae:	4b05      	ldr	r3, [pc, #20]	; (80033c4 <ADC_ClearCommonFlag+0x1c>)
 80033b0:	4298      	cmp	r0, r3
 80033b2:	d101      	bne.n	80033b8 <ADC_ClearCommonFlag+0x10>
  {
    /* Clear the selected ADC flags */
    ADC1_2->CSR |= (uint32_t)ADC_FLAG;
 80033b4:	4b04      	ldr	r3, [pc, #16]	; (80033c8 <ADC_ClearCommonFlag+0x20>)
 80033b6:	e000      	b.n	80033ba <ADC_ClearCommonFlag+0x12>
  }
  else
  {
    /* Clear the selected ADC flags */
    ADC3_4->CSR |= (uint32_t)ADC_FLAG;
 80033b8:	4b04      	ldr	r3, [pc, #16]	; (80033cc <ADC_ClearCommonFlag+0x24>)
 80033ba:	681a      	ldr	r2, [r3, #0]
 80033bc:	4311      	orrs	r1, r2
 80033be:	6019      	str	r1, [r3, #0]
 80033c0:	4770      	bx	lr
 80033c2:	bf00      	nop
 80033c4:	50000100 	.word	0x50000100
 80033c8:	50000300 	.word	0x50000300
 80033cc:	50000700 	.word	0x50000700

080033d0 <ADC_GetITStatus>:
  uint16_t itstatus = 0x0, itenable = 0x0;
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_GET_IT(ADC_IT));
   
  itstatus = ADCx->ISR & ADC_IT;
 80033d0:	6803      	ldr	r3, [r0, #0]
 80033d2:	b289      	uxth	r1, r1
  
  itenable = ADCx->IER & ADC_IT;
 80033d4:	6842      	ldr	r2, [r0, #4]
  if ((itstatus != (uint32_t)RESET) && (itenable != (uint32_t)RESET))
 80033d6:	ea11 0003 	ands.w	r0, r1, r3
 80033da:	d003      	beq.n	80033e4 <ADC_GetITStatus+0x14>
 80033dc:	4211      	tst	r1, r2
  {
    bitstatus = SET;
 80033de:	bf0c      	ite	eq
 80033e0:	2000      	moveq	r0, #0
 80033e2:	2001      	movne	r0, #1
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 80033e4:	4770      	bx	lr

080033e6 <ADC_ClearITPendingBit>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_PERIPH(ADCx));
  assert_param(IS_ADC_IT(ADC_IT));
  /* Clear the selected ADC interrupt pending bit */
  ADCx->ISR |= (uint32_t)ADC_IT;
 80033e6:	6803      	ldr	r3, [r0, #0]
 80033e8:	4319      	orrs	r1, r3
 80033ea:	6001      	str	r1, [r0, #0]
 80033ec:	4770      	bx	lr
 80033ee:	bf00      	nop

080033f0 <DMA_DeInit>:
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));

  /* Disable the selected DMAy Channelx */
  DMAy_Channelx->CCR &= (uint16_t)(~DMA_CCR_EN);
 80033f0:	6802      	ldr	r2, [r0, #0]
 80033f2:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 80033f6:	4013      	ands	r3, r2
 80033f8:	6003      	str	r3, [r0, #0]

  /* Reset DMAy Channelx control register */
  DMAy_Channelx->CCR  = 0;
 80033fa:	2300      	movs	r3, #0
 80033fc:	6003      	str	r3, [r0, #0]

  /* Reset DMAy Channelx remaining bytes register */
  DMAy_Channelx->CNDTR = 0;
 80033fe:	6043      	str	r3, [r0, #4]

  /* Reset DMAy Channelx peripheral address register */
  DMAy_Channelx->CPAR  = 0;
 8003400:	6083      	str	r3, [r0, #8]

  /* Reset DMAy Channelx memory address register */
  DMAy_Channelx->CMAR = 0;
 8003402:	60c3      	str	r3, [r0, #12]

  if (DMAy_Channelx == DMA1_Channel1)
 8003404:	4b2c      	ldr	r3, [pc, #176]	; (80034b8 <DMA_DeInit+0xc8>)
 8003406:	4298      	cmp	r0, r3
 8003408:	d100      	bne.n	800340c <DMA_DeInit+0x1c>
 800340a:	e026      	b.n	800345a <DMA_DeInit+0x6a>
  {
    /* Reset interrupt pending bits for DMA1 Channel1 */
    DMA1->IFCR |= DMA1_CHANNEL1_IT_MASK;
  }
  else if (DMAy_Channelx == DMA1_Channel2)
 800340c:	4b2b      	ldr	r3, [pc, #172]	; (80034bc <DMA_DeInit+0xcc>)
 800340e:	4298      	cmp	r0, r3
 8003410:	d100      	bne.n	8003414 <DMA_DeInit+0x24>
 8003412:	e02c      	b.n	800346e <DMA_DeInit+0x7e>
  {
    /* Reset interrupt pending bits for DMA1 Channel2 */
    DMA1->IFCR |= DMA1_CHANNEL2_IT_MASK;
  }
  else if (DMAy_Channelx == DMA1_Channel3)
 8003414:	4b2a      	ldr	r3, [pc, #168]	; (80034c0 <DMA_DeInit+0xd0>)
 8003416:	4298      	cmp	r0, r3
 8003418:	d100      	bne.n	800341c <DMA_DeInit+0x2c>
 800341a:	e032      	b.n	8003482 <DMA_DeInit+0x92>
  {
    /* Reset interrupt pending bits for DMA1 Channel3 */
    DMA1->IFCR |= DMA1_CHANNEL3_IT_MASK;
  }
  else if (DMAy_Channelx == DMA1_Channel4)
 800341c:	4b29      	ldr	r3, [pc, #164]	; (80034c4 <DMA_DeInit+0xd4>)
 800341e:	4298      	cmp	r0, r3
 8003420:	d100      	bne.n	8003424 <DMA_DeInit+0x34>
 8003422:	e038      	b.n	8003496 <DMA_DeInit+0xa6>
  {
    /* Reset interrupt pending bits for DMA1 Channel4 */
    DMA1->IFCR |= DMA1_CHANNEL4_IT_MASK;
  }
  else if (DMAy_Channelx == DMA1_Channel5)
 8003424:	4b28      	ldr	r3, [pc, #160]	; (80034c8 <DMA_DeInit+0xd8>)
 8003426:	4298      	cmp	r0, r3
 8003428:	d100      	bne.n	800342c <DMA_DeInit+0x3c>
 800342a:	e03e      	b.n	80034aa <DMA_DeInit+0xba>
  {
    /* Reset interrupt pending bits for DMA1 Channel5 */
    DMA1->IFCR |= DMA1_CHANNEL5_IT_MASK;
  }
  else if (DMAy_Channelx == DMA1_Channel6)
 800342c:	4b27      	ldr	r3, [pc, #156]	; (80034cc <DMA_DeInit+0xdc>)
 800342e:	4298      	cmp	r0, r3
 8003430:	d106      	bne.n	8003440 <DMA_DeInit+0x50>
  {
    /* Reset interrupt pending bits for DMA1 Channel6 */
    DMA1->IFCR |= DMA1_CHANNEL6_IT_MASK;
 8003432:	f853 2c68 	ldr.w	r2, [r3, #-104]
 8003436:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 800343a:	f843 2c68 	str.w	r2, [r3, #-104]
 800343e:	4770      	bx	lr
  }
  else if (DMAy_Channelx == DMA1_Channel7)
 8003440:	4b23      	ldr	r3, [pc, #140]	; (80034d0 <DMA_DeInit+0xe0>)
 8003442:	4298      	cmp	r0, r3
 8003444:	d106      	bne.n	8003454 <DMA_DeInit+0x64>
  {
    /* Reset interrupt pending bits for DMA1 Channel7 */
    DMA1->IFCR |= DMA1_CHANNEL7_IT_MASK;
 8003446:	f853 2c7c 	ldr.w	r2, [r3, #-124]
 800344a:	f042 6270 	orr.w	r2, r2, #251658240	; 0xf000000
 800344e:	f843 2c7c 	str.w	r2, [r3, #-124]
 8003452:	4770      	bx	lr
  }
  else if (DMAy_Channelx == DMA2_Channel1)
 8003454:	4b1f      	ldr	r3, [pc, #124]	; (80034d4 <DMA_DeInit+0xe4>)
 8003456:	4298      	cmp	r0, r3
 8003458:	d106      	bne.n	8003468 <DMA_DeInit+0x78>
  {
    /* Reset interrupt pending bits for DMA2 Channel1 */
    DMA2->IFCR |= DMA2_CHANNEL1_IT_MASK;
 800345a:	f853 2c04 	ldr.w	r2, [r3, #-4]
 800345e:	f042 020f 	orr.w	r2, r2, #15
 8003462:	f843 2c04 	str.w	r2, [r3, #-4]
 8003466:	4770      	bx	lr
  }
  else if (DMAy_Channelx == DMA2_Channel2)
 8003468:	4b1b      	ldr	r3, [pc, #108]	; (80034d8 <DMA_DeInit+0xe8>)
 800346a:	4298      	cmp	r0, r3
 800346c:	d106      	bne.n	800347c <DMA_DeInit+0x8c>
  {
    /* Reset interrupt pending bits for DMA2 Channel2 */
    DMA2->IFCR |= DMA2_CHANNEL2_IT_MASK;
 800346e:	f853 2c18 	ldr.w	r2, [r3, #-24]
 8003472:	f042 02f0 	orr.w	r2, r2, #240	; 0xf0
 8003476:	f843 2c18 	str.w	r2, [r3, #-24]
 800347a:	4770      	bx	lr
  }
  else if (DMAy_Channelx == DMA2_Channel3)
 800347c:	4b17      	ldr	r3, [pc, #92]	; (80034dc <DMA_DeInit+0xec>)
 800347e:	4298      	cmp	r0, r3
 8003480:	d106      	bne.n	8003490 <DMA_DeInit+0xa0>
  {
    /* Reset interrupt pending bits for DMA2 Channel3 */
    DMA2->IFCR |= DMA2_CHANNEL3_IT_MASK;
 8003482:	f853 2c2c 	ldr.w	r2, [r3, #-44]
 8003486:	f442 6270 	orr.w	r2, r2, #3840	; 0xf00
 800348a:	f843 2c2c 	str.w	r2, [r3, #-44]
 800348e:	4770      	bx	lr
  }
  else if (DMAy_Channelx == DMA2_Channel4)
 8003490:	4b13      	ldr	r3, [pc, #76]	; (80034e0 <DMA_DeInit+0xf0>)
 8003492:	4298      	cmp	r0, r3
 8003494:	d106      	bne.n	80034a4 <DMA_DeInit+0xb4>
  {
    /* Reset interrupt pending bits for DMA2 Channel4 */
    DMA2->IFCR |= DMA2_CHANNEL4_IT_MASK;
 8003496:	f853 2c40 	ldr.w	r2, [r3, #-64]
 800349a:	f442 4270 	orr.w	r2, r2, #61440	; 0xf000
 800349e:	f843 2c40 	str.w	r2, [r3, #-64]
 80034a2:	4770      	bx	lr
  }
  else
  { 
    if (DMAy_Channelx == DMA2_Channel5)
 80034a4:	4b0f      	ldr	r3, [pc, #60]	; (80034e4 <DMA_DeInit+0xf4>)
 80034a6:	4298      	cmp	r0, r3
 80034a8:	d105      	bne.n	80034b6 <DMA_DeInit+0xc6>
    {
      /* Reset interrupt pending bits for DMA2 Channel5 */
      DMA2->IFCR |= DMA2_CHANNEL5_IT_MASK;
 80034aa:	f853 2c54 	ldr.w	r2, [r3, #-84]
 80034ae:	f442 2270 	orr.w	r2, r2, #983040	; 0xf0000
 80034b2:	f843 2c54 	str.w	r2, [r3, #-84]
 80034b6:	4770      	bx	lr
 80034b8:	40020008 	.word	0x40020008
 80034bc:	4002001c 	.word	0x4002001c
 80034c0:	40020030 	.word	0x40020030
 80034c4:	40020044 	.word	0x40020044
 80034c8:	40020058 	.word	0x40020058
 80034cc:	4002006c 	.word	0x4002006c
 80034d0:	40020080 	.word	0x40020080
 80034d4:	40020408 	.word	0x40020408
 80034d8:	4002041c 	.word	0x4002041c
 80034dc:	40020430 	.word	0x40020430
 80034e0:	40020444 	.word	0x40020444
 80034e4:	40020458 	.word	0x40020458

080034e8 <DMA_Init>:
  * @param  DMA_InitStruct: pointer to a DMA_InitTypeDef structure that contains
  *         the configuration information for the specified DMA Channel.
  * @retval None
  */
void DMA_Init(DMA_Channel_TypeDef* DMAy_Channelx, DMA_InitTypeDef* DMA_InitStruct)
{
 80034e8:	b570      	push	{r4, r5, r6, lr}
  /* Set MINC bit according to DMA_MemoryInc value */
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
 80034ea:	688c      	ldr	r4, [r1, #8]
 80034ec:	6a0d      	ldr	r5, [r1, #32]
  assert_param(IS_DMA_PRIORITY(DMA_InitStruct->DMA_Priority));
  assert_param(IS_DMA_M2M_STATE(DMA_InitStruct->DMA_M2M));

/*--------------------------- DMAy Channelx CCR Configuration ----------------*/
  /* Get the DMAy_Channelx CCR value */
  tmpreg = DMAy_Channelx->CCR;
 80034ee:	6806      	ldr	r6, [r0, #0]
  /* Set MINC bit according to DMA_MemoryInc value */
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
 80034f0:	ea45 0204 	orr.w	r2, r5, r4
 80034f4:	690c      	ldr	r4, [r1, #16]
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
            DMA_InitStruct->DMA_Priority | DMA_InitStruct->DMA_M2M;
 80034f6:	6a8b      	ldr	r3, [r1, #40]	; 0x28
  /* Set MINC bit according to DMA_MemoryInc value */
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
 80034f8:	4322      	orrs	r2, r4
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 80034fa:	694c      	ldr	r4, [r1, #20]
/*--------------------------- DMAy Channelx CCR Configuration ----------------*/
  /* Get the DMAy_Channelx CCR value */
  tmpreg = DMAy_Channelx->CCR;

  /* Clear MEM2MEM, PL, MSIZE, PSIZE, MINC, PINC, CIRC and DIR bits */
  tmpreg &= CCR_CLEAR_MASK;
 80034fc:	f426 46ff 	bic.w	r6, r6, #32640	; 0x7f80
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 8003500:	4322      	orrs	r2, r4
 8003502:	698c      	ldr	r4, [r1, #24]
/*--------------------------- DMAy Channelx CCR Configuration ----------------*/
  /* Get the DMAy_Channelx CCR value */
  tmpreg = DMAy_Channelx->CCR;

  /* Clear MEM2MEM, PL, MSIZE, PSIZE, MINC, PINC, CIRC and DIR bits */
  tmpreg &= CCR_CLEAR_MASK;
 8003504:	f026 0670 	bic.w	r6, r6, #112	; 0x70
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 8003508:	4322      	orrs	r2, r4
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
 800350a:	69cc      	ldr	r4, [r1, #28]
 800350c:	4314      	orrs	r4, r2
 800350e:	6a4a      	ldr	r2, [r1, #36]	; 0x24
 8003510:	4322      	orrs	r2, r4
            DMA_InitStruct->DMA_Priority | DMA_InitStruct->DMA_M2M;
 8003512:	4313      	orrs	r3, r2
  /* Set MINC bit according to DMA_MemoryInc value */
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
 8003514:	4333      	orrs	r3, r6
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
            DMA_InitStruct->DMA_Priority | DMA_InitStruct->DMA_M2M;

  /* Write to DMAy Channelx CCR */
  DMAy_Channelx->CCR = tmpreg;
 8003516:	6003      	str	r3, [r0, #0]

/*--------------------------- DMAy Channelx CNDTR Configuration --------------*/
  /* Write to DMAy Channelx CNDTR */
  DMAy_Channelx->CNDTR = DMA_InitStruct->DMA_BufferSize;
 8003518:	898b      	ldrh	r3, [r1, #12]
 800351a:	6043      	str	r3, [r0, #4]

/*--------------------------- DMAy Channelx CPAR Configuration ---------------*/
  /* Write to DMAy Channelx CPAR */
  DMAy_Channelx->CPAR = DMA_InitStruct->DMA_PeripheralBaseAddr;
 800351c:	680b      	ldr	r3, [r1, #0]
 800351e:	6083      	str	r3, [r0, #8]

/*--------------------------- DMAy Channelx CMAR Configuration ---------------*/
  /* Write to DMAy Channelx CMAR */
  DMAy_Channelx->CMAR = DMA_InitStruct->DMA_MemoryBaseAddr;
 8003520:	684b      	ldr	r3, [r1, #4]
 8003522:	60c3      	str	r3, [r0, #12]
 8003524:	bd70      	pop	{r4, r5, r6, pc}

08003526 <DMA_StructInit>:
  */
void DMA_StructInit(DMA_InitTypeDef* DMA_InitStruct)
{
/*-------------- Reset DMA init structure parameters values ------------------*/
  /* Initialize the DMA_PeripheralBaseAddr member */
  DMA_InitStruct->DMA_PeripheralBaseAddr = 0;
 8003526:	2300      	movs	r3, #0
 8003528:	6003      	str	r3, [r0, #0]
  /* Initialize the DMA_MemoryBaseAddr member */
  DMA_InitStruct->DMA_MemoryBaseAddr = 0;
 800352a:	6043      	str	r3, [r0, #4]
  /* Initialize the DMA_DIR member */
  DMA_InitStruct->DMA_DIR = DMA_DIR_PeripheralSRC;
 800352c:	6083      	str	r3, [r0, #8]
  /* Initialize the DMA_BufferSize member */
  DMA_InitStruct->DMA_BufferSize = 0;
 800352e:	8183      	strh	r3, [r0, #12]
  /* Initialize the DMA_PeripheralInc member */
  DMA_InitStruct->DMA_PeripheralInc = DMA_PeripheralInc_Disable;
 8003530:	6103      	str	r3, [r0, #16]
  /* Initialize the DMA_MemoryInc member */
  DMA_InitStruct->DMA_MemoryInc = DMA_MemoryInc_Disable;
 8003532:	6143      	str	r3, [r0, #20]
  /* Initialize the DMA_PeripheralDataSize member */
  DMA_InitStruct->DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
 8003534:	6183      	str	r3, [r0, #24]
  /* Initialize the DMA_MemoryDataSize member */
  DMA_InitStruct->DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
 8003536:	61c3      	str	r3, [r0, #28]
  /* Initialize the DMA_Mode member */
  DMA_InitStruct->DMA_Mode = DMA_Mode_Normal;
 8003538:	6203      	str	r3, [r0, #32]
  /* Initialize the DMA_Priority member */
  DMA_InitStruct->DMA_Priority = DMA_Priority_Low;
 800353a:	6243      	str	r3, [r0, #36]	; 0x24
  /* Initialize the DMA_M2M member */
  DMA_InitStruct->DMA_M2M = DMA_M2M_Disable;
 800353c:	6283      	str	r3, [r0, #40]	; 0x28
 800353e:	4770      	bx	lr

08003540 <DMA_Cmd>:
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8003540:	b119      	cbz	r1, 800354a <DMA_Cmd+0xa>
  {
    /* Enable the selected DMAy Channelx */
    DMAy_Channelx->CCR |= DMA_CCR_EN;
 8003542:	6803      	ldr	r3, [r0, #0]
 8003544:	f043 0301 	orr.w	r3, r3, #1
 8003548:	e003      	b.n	8003552 <DMA_Cmd+0x12>
  }
  else
  {
    /* Disable the selected DMAy Channelx */
    DMAy_Channelx->CCR &= (uint16_t)(~DMA_CCR_EN);
 800354a:	6802      	ldr	r2, [r0, #0]
 800354c:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 8003550:	4013      	ands	r3, r2
 8003552:	6003      	str	r3, [r0, #0]
 8003554:	4770      	bx	lr

08003556 <DMA_SetCurrDataCounter>:
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));

/*--------------------------- DMAy Channelx CNDTR Configuration --------------*/
  /* Write to DMAy Channelx CNDTR */
  DMAy_Channelx->CNDTR = DataNumber;
 8003556:	6041      	str	r1, [r0, #4]
 8003558:	4770      	bx	lr

0800355a <DMA_GetCurrDataCounter>:
uint16_t DMA_GetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx)
{
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
  /* Return the number of remaining data units for DMAy Channelx */
  return ((uint16_t)(DMAy_Channelx->CNDTR));
 800355a:	6840      	ldr	r0, [r0, #4]
}
 800355c:	b280      	uxth	r0, r0
 800355e:	4770      	bx	lr

08003560 <DMA_ITConfig>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the selected DMA interrupts */
    DMAy_Channelx->CCR |= DMA_IT;
 8003560:	6803      	ldr	r3, [r0, #0]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
  assert_param(IS_DMA_CONFIG_IT(DMA_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003562:	b10a      	cbz	r2, 8003568 <DMA_ITConfig+0x8>
  {
    /* Enable the selected DMA interrupts */
    DMAy_Channelx->CCR |= DMA_IT;
 8003564:	4319      	orrs	r1, r3
 8003566:	e001      	b.n	800356c <DMA_ITConfig+0xc>
  }
  else
  {
    /* Disable the selected DMA interrupts */
    DMAy_Channelx->CCR &= ~DMA_IT;
 8003568:	ea23 0101 	bic.w	r1, r3, r1
 800356c:	6001      	str	r1, [r0, #0]
 800356e:	4770      	bx	lr

08003570 <DMA_GetFlagStatus>:
  
  /* Check the parameters */
  assert_param(IS_DMA_GET_FLAG(DMAy_FLAG));

  /* Calculate the used DMAy */
  if ((DMAy_FLAG & FLAG_Mask) != (uint32_t)RESET)
 8003570:	00c3      	lsls	r3, r0, #3
  {
    /* Get DMA2 ISR register value */
    tmpreg = DMA2->ISR ;
 8003572:	bf4c      	ite	mi
 8003574:	4b03      	ldrmi	r3, [pc, #12]	; (8003584 <DMA_GetFlagStatus+0x14>)
  }
  else
  {
    /* Get DMA1 ISR register value */
    tmpreg = DMA1->ISR ;
 8003576:	4b04      	ldrpl	r3, [pc, #16]	; (8003588 <DMA_GetFlagStatus+0x18>)
 8003578:	681b      	ldr	r3, [r3, #0]
  }

  /* Check the status of the specified DMAy flag */
  if ((tmpreg & DMAy_FLAG) != (uint32_t)RESET)
 800357a:	4203      	tst	r3, r0
    bitstatus = RESET;
  }
  
  /* Return the DMAy_FLAG status */
  return  bitstatus;
}
 800357c:	bf0c      	ite	eq
 800357e:	2000      	moveq	r0, #0
 8003580:	2001      	movne	r0, #1
 8003582:	4770      	bx	lr
 8003584:	40020400 	.word	0x40020400
 8003588:	40020000 	.word	0x40020000

0800358c <DMA_ClearFlag>:
{
  /* Check the parameters */
  assert_param(IS_DMA_CLEAR_FLAG(DMAy_FLAG));

/* Calculate the used DMAy */
  if ((DMAy_FLAG & FLAG_Mask) != (uint32_t)RESET)
 800358c:	00c2      	lsls	r2, r0, #3
  {
    /* Clear the selected DMAy flags */
    DMA2->IFCR = DMAy_FLAG;
 800358e:	bf4c      	ite	mi
 8003590:	4b01      	ldrmi	r3, [pc, #4]	; (8003598 <DMA_ClearFlag+0xc>)
  }
  else
  {
    /* Clear the selected DMAy flags */
    DMA1->IFCR = DMAy_FLAG;
 8003592:	4b02      	ldrpl	r3, [pc, #8]	; (800359c <DMA_ClearFlag+0x10>)
 8003594:	6058      	str	r0, [r3, #4]
 8003596:	4770      	bx	lr
 8003598:	40020400 	.word	0x40020400
 800359c:	40020000 	.word	0x40020000

080035a0 <DMA_GetITStatus>:

  /* Check the parameters */
  assert_param(IS_DMA_GET_IT(DMAy_IT));

  /* Calculate the used DMA */
  if ((DMAy_IT & FLAG_Mask) != (uint32_t)RESET)
 80035a0:	00c1      	lsls	r1, r0, #3
  {
    /* Get DMA2 ISR register value */
    tmpreg = DMA2->ISR;
 80035a2:	bf4c      	ite	mi
 80035a4:	4b03      	ldrmi	r3, [pc, #12]	; (80035b4 <DMA_GetITStatus+0x14>)
  }
  else
  {
    /* Get DMA1 ISR register value */
    tmpreg = DMA1->ISR;
 80035a6:	4b04      	ldrpl	r3, [pc, #16]	; (80035b8 <DMA_GetITStatus+0x18>)
 80035a8:	681b      	ldr	r3, [r3, #0]
  }

  /* Check the status of the specified DMAy interrupt */
  if ((tmpreg & DMAy_IT) != (uint32_t)RESET)
 80035aa:	4203      	tst	r3, r0
    /* DMAy_IT is reset */
    bitstatus = RESET;
  }
  /* Return the DMAy_IT status */
  return  bitstatus;
}
 80035ac:	bf0c      	ite	eq
 80035ae:	2000      	moveq	r0, #0
 80035b0:	2001      	movne	r0, #1
 80035b2:	4770      	bx	lr
 80035b4:	40020400 	.word	0x40020400
 80035b8:	40020000 	.word	0x40020000

080035bc <DMA_ClearITPendingBit>:
{
  /* Check the parameters */
  assert_param(IS_DMA_CLEAR_IT(DMAy_IT));
  
  /* Calculate the used DMAy */
  if ((DMAy_IT & FLAG_Mask) != (uint32_t)RESET)
 80035bc:	00c3      	lsls	r3, r0, #3
  {
    /* Clear the selected DMAy interrupt pending bits */
    DMA2->IFCR = DMAy_IT;
 80035be:	bf4c      	ite	mi
 80035c0:	4b01      	ldrmi	r3, [pc, #4]	; (80035c8 <DMA_ClearITPendingBit+0xc>)
  }
  else
  {
    /* Clear the selected DMAy interrupt pending bits */
    DMA1->IFCR = DMAy_IT;
 80035c2:	4b02      	ldrpl	r3, [pc, #8]	; (80035cc <DMA_ClearITPendingBit+0x10>)
 80035c4:	6058      	str	r0, [r3, #4]
 80035c6:	4770      	bx	lr
 80035c8:	40020400 	.word	0x40020400
 80035cc:	40020000 	.word	0x40020000

080035d0 <EXTI_DeInit>:
  * @param  None
  * @retval None
  */
void EXTI_DeInit(void)
{
  EXTI->IMR    = 0x1F800000;
 80035d0:	4b0a      	ldr	r3, [pc, #40]	; (80035fc <EXTI_DeInit+0x2c>)
 80035d2:	f04f 52fc 	mov.w	r2, #528482304	; 0x1f800000
 80035d6:	601a      	str	r2, [r3, #0]
  EXTI->EMR    = 0x00000000;
  EXTI->RTSR   = 0x00000000;
  EXTI->FTSR   = 0x00000000;
  EXTI->SWIER  = 0x00000000;
  EXTI->PR     = 0xE07FFFFF;
 80035d8:	f06f 51fc 	mvn.w	r1, #528482304	; 0x1f800000
  * @retval None
  */
void EXTI_DeInit(void)
{
  EXTI->IMR    = 0x1F800000;
  EXTI->EMR    = 0x00000000;
 80035dc:	2200      	movs	r2, #0
 80035de:	605a      	str	r2, [r3, #4]
  EXTI->RTSR   = 0x00000000;
 80035e0:	609a      	str	r2, [r3, #8]
  EXTI->FTSR   = 0x00000000;
 80035e2:	60da      	str	r2, [r3, #12]
  EXTI->SWIER  = 0x00000000;
 80035e4:	611a      	str	r2, [r3, #16]
  EXTI->PR     = 0xE07FFFFF;
 80035e6:	6159      	str	r1, [r3, #20]
  EXTI->IMR2   = 0x0000000C;
 80035e8:	210c      	movs	r1, #12
 80035ea:	6219      	str	r1, [r3, #32]
  EXTI->EMR2   = 0x00000000;
 80035ec:	625a      	str	r2, [r3, #36]	; 0x24
  EXTI->RTSR2  = 0x00000000;
 80035ee:	629a      	str	r2, [r3, #40]	; 0x28
  EXTI->FTSR2  = 0x00000000;
 80035f0:	62da      	str	r2, [r3, #44]	; 0x2c
  EXTI->SWIER2 = 0x00000000;
 80035f2:	631a      	str	r2, [r3, #48]	; 0x30
  EXTI->PR2    = 0x00000003;
 80035f4:	2203      	movs	r2, #3
 80035f6:	635a      	str	r2, [r3, #52]	; 0x34
 80035f8:	4770      	bx	lr
 80035fa:	bf00      	nop
 80035fc:	40010400 	.word	0x40010400

08003600 <EXTI_Init>:
  assert_param(IS_EXTI_LINE_ALL(EXTI_InitStruct->EXTI_Line));
  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct->EXTI_LineCmd));

  tmp = (uint32_t)EXTI_BASE;
      
  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
 8003600:	7982      	ldrb	r2, [r0, #6]
  * @retval None
  */
  

void EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct)
{
 8003602:	b570      	push	{r4, r5, r6, lr}
 8003604:	6803      	ldr	r3, [r0, #0]
  assert_param(IS_EXTI_LINE_ALL(EXTI_InitStruct->EXTI_Line));
  assert_param(IS_FUNCTIONAL_STATE(EXTI_InitStruct->EXTI_LineCmd));

  tmp = (uint32_t)EXTI_BASE;
      
  if (EXTI_InitStruct->EXTI_LineCmd != DISABLE)
 8003606:	2a00      	cmp	r2, #0
 8003608:	d066      	beq.n	80036d8 <EXTI_Init+0xd8>
  {
    /* Clear EXTI line configuration */   
    *(__IO uint32_t *) (((uint32_t) &(EXTI->IMR)) + ((EXTI_InitStruct->EXTI_Line) >> 5 ) * 0x20) &= ~(uint32_t)(1 << (EXTI_InitStruct->EXTI_Line & 0x1F));   
 800360a:	f023 021f 	bic.w	r2, r3, #31
 800360e:	f003 011f 	and.w	r1, r3, #31
 8003612:	2301      	movs	r3, #1
 8003614:	fa03 f101 	lsl.w	r1, r3, r1
 8003618:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
 800361c:	f502 3282 	add.w	r2, r2, #66560	; 0x10400
 8003620:	6814      	ldr	r4, [r2, #0]
 8003622:	ea24 0101 	bic.w	r1, r4, r1
 8003626:	6011      	str	r1, [r2, #0]
    *(__IO uint32_t *) (((uint32_t) &(EXTI->EMR)) + ((EXTI_InitStruct->EXTI_Line) >> 5 ) * 0x20) &= ~(uint32_t)(1 << (EXTI_InitStruct->EXTI_Line & 0x1F));
 8003628:	6804      	ldr	r4, [r0, #0]
 800362a:	4a34      	ldr	r2, [pc, #208]	; (80036fc <EXTI_Init+0xfc>)
 800362c:	f024 011f 	bic.w	r1, r4, #31
 8003630:	f004 041f 	and.w	r4, r4, #31
 8003634:	fa03 f404 	lsl.w	r4, r3, r4
 8003638:	588d      	ldr	r5, [r1, r2]
 800363a:	ea25 0404 	bic.w	r4, r5, r4
 800363e:	508c      	str	r4, [r1, r2]
     
    tmp += EXTI_InitStruct->EXTI_Mode + (((EXTI_InitStruct->EXTI_Line) >> 5 ) * 0x20);
 8003640:	6804      	ldr	r4, [r0, #0]
 8003642:	7901      	ldrb	r1, [r0, #4]
 8003644:	f024 021f 	bic.w	r2, r4, #31

    *(__IO uint32_t *) tmp |= (uint32_t)(1 << (EXTI_InitStruct->EXTI_Line & 0x1F));
 8003648:	f004 041f 	and.w	r4, r4, #31
 800364c:	fa03 f404 	lsl.w	r4, r3, r4
  {
    /* Clear EXTI line configuration */   
    *(__IO uint32_t *) (((uint32_t) &(EXTI->IMR)) + ((EXTI_InitStruct->EXTI_Line) >> 5 ) * 0x20) &= ~(uint32_t)(1 << (EXTI_InitStruct->EXTI_Line & 0x1F));   
    *(__IO uint32_t *) (((uint32_t) &(EXTI->EMR)) + ((EXTI_InitStruct->EXTI_Line) >> 5 ) * 0x20) &= ~(uint32_t)(1 << (EXTI_InitStruct->EXTI_Line & 0x1F));
     
    tmp += EXTI_InitStruct->EXTI_Mode + (((EXTI_InitStruct->EXTI_Line) >> 5 ) * 0x20);
 8003650:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 8003654:	f501 3182 	add.w	r1, r1, #66560	; 0x10400

    *(__IO uint32_t *) tmp |= (uint32_t)(1 << (EXTI_InitStruct->EXTI_Line & 0x1F));
 8003658:	588d      	ldr	r5, [r1, r2]
 800365a:	432c      	orrs	r4, r5
 800365c:	508c      	str	r4, [r1, r2]
    
    tmp = (uint32_t)EXTI_BASE;

    /* Clear Rising Falling edge configuration */
    *(__IO uint32_t *) (((uint32_t) &(EXTI->RTSR)) + ((EXTI_InitStruct->EXTI_Line) >> 5 ) * 0x20) &= ~(uint32_t)(1 << (EXTI_InitStruct->EXTI_Line & 0x1F));
 800365e:	6801      	ldr	r1, [r0, #0]
 8003660:	4c27      	ldr	r4, [pc, #156]	; (8003700 <EXTI_Init+0x100>)
 8003662:	f021 021f 	bic.w	r2, r1, #31
 8003666:	f001 011f 	and.w	r1, r1, #31
 800366a:	fa03 f101 	lsl.w	r1, r3, r1
 800366e:	5915      	ldr	r5, [r2, r4]
 8003670:	ea25 0101 	bic.w	r1, r5, r1
 8003674:	5111      	str	r1, [r2, r4]
    *(__IO uint32_t *) (((uint32_t) &(EXTI->FTSR)) + ((EXTI_InitStruct->EXTI_Line) >> 5 ) * 0x20) &= ~(uint32_t)(1 << (EXTI_InitStruct->EXTI_Line & 0x1F));
 8003676:	6805      	ldr	r5, [r0, #0]
 8003678:	4922      	ldr	r1, [pc, #136]	; (8003704 <EXTI_Init+0x104>)
 800367a:	f025 021f 	bic.w	r2, r5, #31
 800367e:	f005 051f 	and.w	r5, r5, #31
 8003682:	fa03 f505 	lsl.w	r5, r3, r5
 8003686:	5856      	ldr	r6, [r2, r1]
 8003688:	ea26 0505 	bic.w	r5, r6, r5
 800368c:	5055      	str	r5, [r2, r1]
    
      /* Select the trigger for the selected interrupts */
    if (EXTI_InitStruct->EXTI_Trigger == EXTI_Trigger_Rising_Falling)
 800368e:	7945      	ldrb	r5, [r0, #5]
 8003690:	6802      	ldr	r2, [r0, #0]
 8003692:	2d10      	cmp	r5, #16
 8003694:	d112      	bne.n	80036bc <EXTI_Init+0xbc>
    {
      /* Rising Falling edge */
    *(__IO uint32_t *) (((uint32_t) &(EXTI->RTSR)) + ((EXTI_InitStruct->EXTI_Line) >> 5 ) * 0x20) |= (uint32_t)(1 << (EXTI_InitStruct->EXTI_Line & 0x1F));
 8003696:	f022 051f 	bic.w	r5, r2, #31
 800369a:	f002 021f 	and.w	r2, r2, #31
 800369e:	fa03 f202 	lsl.w	r2, r3, r2
 80036a2:	592e      	ldr	r6, [r5, r4]
 80036a4:	4332      	orrs	r2, r6
 80036a6:	512a      	str	r2, [r5, r4]
    *(__IO uint32_t *) (((uint32_t) &(EXTI->FTSR)) + ((EXTI_InitStruct->EXTI_Line) >> 5 ) * 0x20) |= (uint32_t)(1 << (EXTI_InitStruct->EXTI_Line & 0x1F));      
 80036a8:	6800      	ldr	r0, [r0, #0]
 80036aa:	f020 021f 	bic.w	r2, r0, #31
 80036ae:	f000 001f 	and.w	r0, r0, #31
 80036b2:	fa03 f300 	lsl.w	r3, r3, r0
 80036b6:	5854      	ldr	r4, [r2, r1]
 80036b8:	4323      	orrs	r3, r4
 80036ba:	e01c      	b.n	80036f6 <EXTI_Init+0xf6>
    }
    else
    {
      tmp += EXTI_InitStruct->EXTI_Trigger + (((EXTI_InitStruct->EXTI_Line) >> 5 ) * 0x20);
 80036bc:	f022 011f 	bic.w	r1, r2, #31

      *(__IO uint32_t *) tmp |= (uint32_t)(1 << (EXTI_InitStruct->EXTI_Line & 0x1F));
 80036c0:	f002 021f 	and.w	r2, r2, #31
 80036c4:	fa03 f302 	lsl.w	r3, r3, r2
    *(__IO uint32_t *) (((uint32_t) &(EXTI->RTSR)) + ((EXTI_InitStruct->EXTI_Line) >> 5 ) * 0x20) |= (uint32_t)(1 << (EXTI_InitStruct->EXTI_Line & 0x1F));
    *(__IO uint32_t *) (((uint32_t) &(EXTI->FTSR)) + ((EXTI_InitStruct->EXTI_Line) >> 5 ) * 0x20) |= (uint32_t)(1 << (EXTI_InitStruct->EXTI_Line & 0x1F));      
    }
    else
    {
      tmp += EXTI_InitStruct->EXTI_Trigger + (((EXTI_InitStruct->EXTI_Line) >> 5 ) * 0x20);
 80036c8:	f105 4080 	add.w	r0, r5, #1073741824	; 0x40000000
 80036cc:	f500 3082 	add.w	r0, r0, #66560	; 0x10400

      *(__IO uint32_t *) tmp |= (uint32_t)(1 << (EXTI_InitStruct->EXTI_Line & 0x1F));
 80036d0:	5844      	ldr	r4, [r0, r1]
 80036d2:	4323      	orrs	r3, r4
 80036d4:	5043      	str	r3, [r0, r1]
 80036d6:	bd70      	pop	{r4, r5, r6, pc}
    }
  }
      
  else
  {
    tmp += EXTI_InitStruct->EXTI_Mode + (((EXTI_InitStruct->EXTI_Line) >> 5 ) * 0x20);
 80036d8:	f023 021f 	bic.w	r2, r3, #31

    /* Disable the selected external lines */
    *(__IO uint32_t *) tmp &= ~(uint32_t)(1 << (EXTI_InitStruct->EXTI_Line & 0x1F));
 80036dc:	2401      	movs	r4, #1
 80036de:	f003 031f 	and.w	r3, r3, #31
 80036e2:	fa04 f303 	lsl.w	r3, r4, r3
    }
  }
      
  else
  {
    tmp += EXTI_InitStruct->EXTI_Mode + (((EXTI_InitStruct->EXTI_Line) >> 5 ) * 0x20);
 80036e6:	7901      	ldrb	r1, [r0, #4]
 80036e8:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
 80036ec:	f501 3182 	add.w	r1, r1, #66560	; 0x10400

    /* Disable the selected external lines */
    *(__IO uint32_t *) tmp &= ~(uint32_t)(1 << (EXTI_InitStruct->EXTI_Line & 0x1F));
 80036f0:	5888      	ldr	r0, [r1, r2]
 80036f2:	ea20 0303 	bic.w	r3, r0, r3
 80036f6:	508b      	str	r3, [r1, r2]
 80036f8:	bd70      	pop	{r4, r5, r6, pc}
 80036fa:	bf00      	nop
 80036fc:	40010404 	.word	0x40010404
 8003700:	40010408 	.word	0x40010408
 8003704:	4001040c 	.word	0x4001040c

08003708 <EXTI_StructInit>:
  *         be initialized.
  * @retval None
  */
void EXTI_StructInit(EXTI_InitTypeDef* EXTI_InitStruct)
{
  EXTI_InitStruct->EXTI_Line = EXTI_LINENONE;
 8003708:	2300      	movs	r3, #0
  EXTI_InitStruct->EXTI_Mode = EXTI_Mode_Interrupt;
  EXTI_InitStruct->EXTI_Trigger = EXTI_Trigger_Rising_Falling;
 800370a:	2210      	movs	r2, #16
  *         be initialized.
  * @retval None
  */
void EXTI_StructInit(EXTI_InitTypeDef* EXTI_InitStruct)
{
  EXTI_InitStruct->EXTI_Line = EXTI_LINENONE;
 800370c:	6003      	str	r3, [r0, #0]
  EXTI_InitStruct->EXTI_Mode = EXTI_Mode_Interrupt;
 800370e:	7103      	strb	r3, [r0, #4]
  EXTI_InitStruct->EXTI_Trigger = EXTI_Trigger_Rising_Falling;
 8003710:	7142      	strb	r2, [r0, #5]
  EXTI_InitStruct->EXTI_LineCmd = DISABLE;
 8003712:	7183      	strb	r3, [r0, #6]
 8003714:	4770      	bx	lr

08003716 <EXTI_GenerateSWInterrupt>:
void EXTI_GenerateSWInterrupt(uint32_t EXTI_Line)
{
  /* Check the parameters */
  assert_param(IS_EXTI_LINE_EXT(EXTI_Line));

  *(__IO uint32_t *) (((uint32_t) &(EXTI->SWIER)) + ((EXTI_Line) >> 5 ) * 0x20) |= (uint32_t)(1 << (EXTI_Line & 0x1F));
 8003716:	f020 021f 	bic.w	r2, r0, #31
  *         will be generated.
  *   This parameter can be any combination of EXTI_Linex where x can be (0..20).
  * @retval None
  */
void EXTI_GenerateSWInterrupt(uint32_t EXTI_Line)
{
 800371a:	b510      	push	{r4, lr}
  /* Check the parameters */
  assert_param(IS_EXTI_LINE_EXT(EXTI_Line));

  *(__IO uint32_t *) (((uint32_t) &(EXTI->SWIER)) + ((EXTI_Line) >> 5 ) * 0x20) |= (uint32_t)(1 << (EXTI_Line & 0x1F));
 800371c:	f000 001f 	and.w	r0, r0, #31
 8003720:	2401      	movs	r4, #1
 8003722:	fa04 f000 	lsl.w	r0, r4, r0
 8003726:	4b02      	ldr	r3, [pc, #8]	; (8003730 <EXTI_GenerateSWInterrupt+0x1a>)
 8003728:	58d1      	ldr	r1, [r2, r3]
 800372a:	4308      	orrs	r0, r1
 800372c:	50d0      	str	r0, [r2, r3]
 800372e:	bd10      	pop	{r4, pc}
 8003730:	40010410 	.word	0x40010410

08003734 <EXTI_GetFlagStatus>:
  FlagStatus bitstatus = RESET;
  
  /* Check the parameters */
  assert_param(IS_GET_EXTI_LINE(EXTI_Line));
   
  if ((*(__IO uint32_t *) (((uint32_t) &(EXTI->PR)) + ((EXTI_Line) >> 5 ) * 0x20)& (uint32_t)(1 << (EXTI_Line & 0x1F))) != (uint32_t)RESET)
 8003734:	4b06      	ldr	r3, [pc, #24]	; (8003750 <EXTI_GetFlagStatus+0x1c>)
 8003736:	f020 021f 	bic.w	r2, r0, #31
 800373a:	58d3      	ldr	r3, [r2, r3]
 800373c:	f000 001f 	and.w	r0, r0, #31
 8003740:	2201      	movs	r2, #1
 8003742:	fa02 f000 	lsl.w	r0, r2, r0
 8003746:	4203      	tst	r3, r0
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 8003748:	bf0c      	ite	eq
 800374a:	2000      	moveq	r0, #0
 800374c:	2001      	movne	r0, #1
 800374e:	4770      	bx	lr
 8003750:	40010414 	.word	0x40010414

08003754 <EXTI_ClearFlag>:
void EXTI_ClearFlag(uint32_t EXTI_Line)
{
  /* Check the parameters */
  assert_param(IS_EXTI_LINE_EXT(EXTI_Line));

  *(__IO uint32_t *) (((uint32_t) &(EXTI->PR)) + ((EXTI_Line) >> 5 ) * 0x20) = (1 << (EXTI_Line & 0x1F));  
 8003754:	f020 021f 	bic.w	r2, r0, #31
 8003758:	2301      	movs	r3, #1
 800375a:	f000 001f 	and.w	r0, r0, #31
 800375e:	fa03 f000 	lsl.w	r0, r3, r0
 8003762:	4b01      	ldr	r3, [pc, #4]	; (8003768 <EXTI_ClearFlag+0x14>)
 8003764:	50d0      	str	r0, [r2, r3]
 8003766:	4770      	bx	lr
 8003768:	40010414 	.word	0x40010414

0800376c <EXTI_GetITStatus>:
  uint32_t enablestatus = 0;
  
  /* Check the parameters */
  assert_param(IS_GET_EXTI_LINE(EXTI_Line));
  
  enablestatus =  *(__IO uint32_t *) (((uint32_t) &(EXTI->IMR)) + ((EXTI_Line) >> 5 ) * 0x20) & (uint32_t)(1 << (EXTI_Line & 0x1F));
 800376c:	0942      	lsrs	r2, r0, #5
 800376e:	f102 7300 	add.w	r3, r2, #33554432	; 0x2000000
 8003772:	f503 6302 	add.w	r3, r3, #2080	; 0x820
 8003776:	015b      	lsls	r3, r3, #5
 8003778:	6819      	ldr	r1, [r3, #0]
 800377a:	f000 001f 	and.w	r0, r0, #31
 800377e:	2301      	movs	r3, #1
 8003780:	fa03 f300 	lsl.w	r3, r3, r0
 
  if ( (((*(__IO uint32_t *) (((uint32_t) &(EXTI->PR)) + (((EXTI_Line) >> 5 ) * 0x20) )) & (uint32_t)(1 << (EXTI_Line & 0x1F))) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))
 8003784:	4804      	ldr	r0, [pc, #16]	; (8003798 <EXTI_GetITStatus+0x2c>)
 8003786:	0152      	lsls	r2, r2, #5
 8003788:	5810      	ldr	r0, [r2, r0]
 800378a:	4018      	ands	r0, r3
 800378c:	d003      	beq.n	8003796 <EXTI_GetITStatus+0x2a>
 800378e:	4219      	tst	r1, r3
  {
    bitstatus = SET;
 8003790:	bf0c      	ite	eq
 8003792:	2000      	moveq	r0, #0
 8003794:	2001      	movne	r0, #1
  {
    bitstatus = RESET;
  }
  return bitstatus;
  
}
 8003796:	4770      	bx	lr
 8003798:	40010414 	.word	0x40010414

0800379c <EXTI_ClearITPendingBit>:
void EXTI_ClearITPendingBit(uint32_t EXTI_Line)
{
  /* Check the parameters */
  assert_param(IS_EXTI_LINE_EXT(EXTI_Line));
  
  *(__IO uint32_t *) (((uint32_t) &(EXTI->PR)) + ((EXTI_Line) >> 5 ) * 0x20) = (1 << (EXTI_Line & 0x1F));
 800379c:	f020 021f 	bic.w	r2, r0, #31
 80037a0:	2301      	movs	r3, #1
 80037a2:	f000 001f 	and.w	r0, r0, #31
 80037a6:	fa03 f000 	lsl.w	r0, r3, r0
 80037aa:	4b01      	ldr	r3, [pc, #4]	; (80037b0 <EXTI_ClearITPendingBit+0x14>)
 80037ac:	50d0      	str	r0, [r2, r3]
 80037ae:	4770      	bx	lr
 80037b0:	40010414 	.word	0x40010414

080037b4 <GPIO_DeInit>:
void GPIO_DeInit(GPIO_TypeDef* GPIOx)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  if(GPIOx == GPIOA)
 80037b4:	f1b0 4f90 	cmp.w	r0, #1207959552	; 0x48000000
  *         values.
  * @param  GPIOx: where x can be (A, B, C, D, E or F) to select the GPIO peripheral.
  * @retval None
  */
void GPIO_DeInit(GPIO_TypeDef* GPIOx)
{
 80037b8:	b508      	push	{r3, lr}
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  if(GPIOx == GPIOA)
 80037ba:	d107      	bne.n	80037cc <GPIO_DeInit+0x18>
  {
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOA, ENABLE);
 80037bc:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 80037c0:	2101      	movs	r1, #1
 80037c2:	f000 fd73 	bl	80042ac <RCC_AHBPeriphResetCmd>
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOA, DISABLE);
 80037c6:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 80037ca:	e035      	b.n	8003838 <GPIO_DeInit+0x84>
  }
  else if(GPIOx == GPIOB)
 80037cc:	4b1d      	ldr	r3, [pc, #116]	; (8003844 <GPIO_DeInit+0x90>)
 80037ce:	4298      	cmp	r0, r3
 80037d0:	d107      	bne.n	80037e2 <GPIO_DeInit+0x2e>
  {
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOB, ENABLE);
 80037d2:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 80037d6:	2101      	movs	r1, #1
 80037d8:	f000 fd68 	bl	80042ac <RCC_AHBPeriphResetCmd>
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOB, DISABLE);
 80037dc:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 80037e0:	e02a      	b.n	8003838 <GPIO_DeInit+0x84>
  }
  else if(GPIOx == GPIOC)
 80037e2:	4b19      	ldr	r3, [pc, #100]	; (8003848 <GPIO_DeInit+0x94>)
 80037e4:	4298      	cmp	r0, r3
 80037e6:	d107      	bne.n	80037f8 <GPIO_DeInit+0x44>
  {
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOC, ENABLE);
 80037e8:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 80037ec:	2101      	movs	r1, #1
 80037ee:	f000 fd5d 	bl	80042ac <RCC_AHBPeriphResetCmd>
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOC, DISABLE);
 80037f2:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 80037f6:	e01f      	b.n	8003838 <GPIO_DeInit+0x84>
  }
  else if(GPIOx == GPIOD)
 80037f8:	4b14      	ldr	r3, [pc, #80]	; (800384c <GPIO_DeInit+0x98>)
 80037fa:	4298      	cmp	r0, r3
 80037fc:	d107      	bne.n	800380e <GPIO_DeInit+0x5a>
  {
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOD, ENABLE);
 80037fe:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 8003802:	2101      	movs	r1, #1
 8003804:	f000 fd52 	bl	80042ac <RCC_AHBPeriphResetCmd>
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOD, DISABLE);
 8003808:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 800380c:	e014      	b.n	8003838 <GPIO_DeInit+0x84>
  }
  else if(GPIOx == GPIOE)
 800380e:	4b10      	ldr	r3, [pc, #64]	; (8003850 <GPIO_DeInit+0x9c>)
 8003810:	4298      	cmp	r0, r3
 8003812:	d107      	bne.n	8003824 <GPIO_DeInit+0x70>
  {
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOE, ENABLE);
 8003814:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 8003818:	2101      	movs	r1, #1
 800381a:	f000 fd47 	bl	80042ac <RCC_AHBPeriphResetCmd>
    RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOE, DISABLE);
 800381e:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 8003822:	e009      	b.n	8003838 <GPIO_DeInit+0x84>
  }
  else
  {
    if(GPIOx == GPIOF)
 8003824:	4b0b      	ldr	r3, [pc, #44]	; (8003854 <GPIO_DeInit+0xa0>)
 8003826:	4298      	cmp	r0, r3
 8003828:	d10b      	bne.n	8003842 <GPIO_DeInit+0x8e>
    {
      RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOF, ENABLE);
 800382a:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
 800382e:	2101      	movs	r1, #1
 8003830:	f000 fd3c 	bl	80042ac <RCC_AHBPeriphResetCmd>
      RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOF, DISABLE);
 8003834:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
 8003838:	2100      	movs	r1, #0
    }
  }
}
 800383a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  else
  {
    if(GPIOx == GPIOF)
    {
      RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOF, ENABLE);
      RCC_AHBPeriphResetCmd(RCC_AHBPeriph_GPIOF, DISABLE);
 800383e:	f000 bd35 	b.w	80042ac <RCC_AHBPeriphResetCmd>
 8003842:	bd08      	pop	{r3, pc}
 8003844:	48000400 	.word	0x48000400
 8003848:	48000800 	.word	0x48000800
 800384c:	48000c00 	.word	0x48000c00
 8003850:	48001000 	.word	0x48001000
 8003854:	48001400 	.word	0x48001400

08003858 <GPIO_Init>:
  *         GPIO_Pin_0->GPIO_Pin_2, GPIO_Pin_4, GPIO_Pin_6, GPIO_Pin_9 
  *                       and GPIO_Pin_10 for GPIOF.
  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
{ 
 8003858:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
  {
    pos = ((uint32_t)0x01) << pinpos;

    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 800385c:	2300      	movs	r3, #0
 800385e:	680f      	ldr	r7, [r1, #0]
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /*-------------------------- Configure the port pins -----------------------*/
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 8003860:	461a      	mov	r2, r3
  {
    pos = ((uint32_t)0x01) << pinpos;
 8003862:	f04f 0c01 	mov.w	ip, #1
        /* Output mode configuration */
        GPIOx->OTYPER &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos));
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
      }
      
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 8003866:	2403      	movs	r4, #3

  /*-------------------------- Configure the port pins -----------------------*/
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
  {
    pos = ((uint32_t)0x01) << pinpos;
 8003868:	fa0c f602 	lsl.w	r6, ip, r2

    /* Get the port pins position */
    currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 800386c:	ea06 0507 	and.w	r5, r6, r7

    if (currentpin == pos)
 8003870:	42b5      	cmp	r5, r6
 8003872:	d13f      	bne.n	80038f4 <GPIO_Init+0x9c>
    {
      if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
 8003874:	790e      	ldrb	r6, [r1, #4]
 8003876:	f106 38ff 	add.w	r8, r6, #4294967295
 800387a:	f1b8 0f01 	cmp.w	r8, #1
 800387e:	d820      	bhi.n	80038c2 <GPIO_Init+0x6a>
      {
        /* Check Speed mode parameters */
        assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));

        /* Speed mode configuration */
        GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
 8003880:	fa04 f903 	lsl.w	r9, r4, r3
 8003884:	f8d0 8008 	ldr.w	r8, [r0, #8]
 8003888:	ea28 0809 	bic.w	r8, r8, r9
 800388c:	f8c0 8008 	str.w	r8, [r0, #8]
        GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
 8003890:	f891 8005 	ldrb.w	r8, [r1, #5]
 8003894:	f8d0 9008 	ldr.w	r9, [r0, #8]
 8003898:	fa08 f803 	lsl.w	r8, r8, r3
 800389c:	ea48 0809 	orr.w	r8, r8, r9
 80038a0:	f8c0 8008 	str.w	r8, [r0, #8]

        /* Check Output mode parameters */
        assert_param(IS_GPIO_OTYPE(GPIO_InitStruct->GPIO_OType));

        /* Output mode configuration */
        GPIOx->OTYPER &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos));
 80038a4:	f8b0 8004 	ldrh.w	r8, [r0, #4]
 80038a8:	fa1f f888 	uxth.w	r8, r8
 80038ac:	ea28 0505 	bic.w	r5, r8, r5
 80038b0:	8085      	strh	r5, [r0, #4]
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
 80038b2:	798d      	ldrb	r5, [r1, #6]
 80038b4:	f8b0 8004 	ldrh.w	r8, [r0, #4]
 80038b8:	fa05 f502 	lsl.w	r5, r5, r2
 80038bc:	ea45 0508 	orr.w	r5, r5, r8
 80038c0:	8085      	strh	r5, [r0, #4]
      }
      
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 80038c2:	fa04 f503 	lsl.w	r5, r4, r3

      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 80038c6:	fa06 f603 	lsl.w	r6, r6, r3
        /* Output mode configuration */
        GPIOx->OTYPER &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos));
        GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
      }
      
      GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
 80038ca:	f8d0 8000 	ldr.w	r8, [r0]
 80038ce:	43ed      	mvns	r5, r5
 80038d0:	ea05 0808 	and.w	r8, r5, r8
 80038d4:	f8c0 8000 	str.w	r8, [r0]

      GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
 80038d8:	f8d0 8000 	ldr.w	r8, [r0]
 80038dc:	ea46 0608 	orr.w	r6, r6, r8
 80038e0:	6006      	str	r6, [r0, #0]

      /* Pull-up Pull down resistor configuration */
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
 80038e2:	68c6      	ldr	r6, [r0, #12]
 80038e4:	4035      	ands	r5, r6
 80038e6:	60c5      	str	r5, [r0, #12]
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
 80038e8:	79cd      	ldrb	r5, [r1, #7]
 80038ea:	68c6      	ldr	r6, [r0, #12]
 80038ec:	fa05 f503 	lsl.w	r5, r5, r3
 80038f0:	4335      	orrs	r5, r6
 80038f2:	60c5      	str	r5, [r0, #12]
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));

  /*-------------------------- Configure the port pins -----------------------*/
  /*-- GPIO Mode Configuration --*/
  for (pinpos = 0x00; pinpos < 0x10; pinpos++)
 80038f4:	3201      	adds	r2, #1
 80038f6:	3302      	adds	r3, #2
 80038f8:	2a10      	cmp	r2, #16
 80038fa:	d1b5      	bne.n	8003868 <GPIO_Init+0x10>
      /* Pull-up Pull down resistor configuration */
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
      GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
    }
  }
}
 80038fc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

08003900 <GPIO_StructInit>:
  * @retval None
  */
void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
{
  /* Reset GPIO init structure parameters values */
  GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
 8003900:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8003904:	6003      	str	r3, [r0, #0]
  GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN;
  GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
 8003906:	2202      	movs	r2, #2
  */
void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
{
  /* Reset GPIO init structure parameters values */
  GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
  GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN;
 8003908:	2300      	movs	r3, #0
 800390a:	7103      	strb	r3, [r0, #4]
  GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
 800390c:	7142      	strb	r2, [r0, #5]
  GPIO_InitStruct->GPIO_OType = GPIO_OType_PP;
 800390e:	7183      	strb	r3, [r0, #6]
  GPIO_InitStruct->GPIO_PuPd = GPIO_PuPd_NOPULL;
 8003910:	71c3      	strb	r3, [r0, #7]
 8003912:	4770      	bx	lr

08003914 <GPIO_PinLockConfig>:
  
  /* Check the parameters */
  assert_param(IS_GPIO_LIST_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  
  tmp |= GPIO_Pin;
 8003914:	f441 3380 	orr.w	r3, r1, #65536	; 0x10000
  /* Set LCKK bit */
  GPIOx->LCKR = tmp;
 8003918:	61c3      	str	r3, [r0, #28]
  /* Reset LCKK bit */
  GPIOx->LCKR =  GPIO_Pin;
 800391a:	61c1      	str	r1, [r0, #28]
  /* Set LCKK bit */
  GPIOx->LCKR = tmp;
 800391c:	61c3      	str	r3, [r0, #28]
  /* Read LCKK bit */
  tmp = GPIOx->LCKR;
 800391e:	69c3      	ldr	r3, [r0, #28]
  /* Read LCKK bit */
  tmp = GPIOx->LCKR;
 8003920:	69c3      	ldr	r3, [r0, #28]
 8003922:	4770      	bx	lr

08003924 <GPIO_ReadInputDataBit>:
  
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)Bit_RESET)
 8003924:	8a03      	ldrh	r3, [r0, #16]
 8003926:	4219      	tst	r1, r3
  else
  {
    bitstatus = (uint8_t)Bit_RESET;
  }
  return bitstatus;
}
 8003928:	bf0c      	ite	eq
 800392a:	2000      	moveq	r0, #0
 800392c:	2001      	movne	r0, #1
 800392e:	4770      	bx	lr

08003930 <GPIO_ReadInputData>:
uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));

  return ((uint16_t)GPIOx->IDR);
 8003930:	8a00      	ldrh	r0, [r0, #16]
}
 8003932:	b280      	uxth	r0, r0
 8003934:	4770      	bx	lr

08003936 <GPIO_ReadOutputDataBit>:

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
  
  if ((GPIOx->ODR & GPIO_Pin) != (uint32_t)Bit_RESET)
 8003936:	8a83      	ldrh	r3, [r0, #20]
 8003938:	4219      	tst	r1, r3
  else
  {
    bitstatus = (uint8_t)Bit_RESET;
  }
  return bitstatus;
}
 800393a:	bf0c      	ite	eq
 800393c:	2000      	moveq	r0, #0
 800393e:	2001      	movne	r0, #1
 8003940:	4770      	bx	lr

08003942 <GPIO_ReadOutputData>:
uint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  
  return ((uint16_t)GPIOx->ODR);
 8003942:	8a80      	ldrh	r0, [r0, #20]
}
 8003944:	b280      	uxth	r0, r0
 8003946:	4770      	bx	lr

08003948 <GPIO_SetBits>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  
  GPIOx->BSRR = GPIO_Pin;
 8003948:	6181      	str	r1, [r0, #24]
 800394a:	4770      	bx	lr

0800394c <GPIO_ResetBits>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  
  GPIOx->BRR = GPIO_Pin;
 800394c:	8501      	strh	r1, [r0, #40]	; 0x28
 800394e:	4770      	bx	lr

08003950 <GPIO_WriteBit>:
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_BIT_ACTION(BitVal));
  
  if (BitVal != Bit_RESET)
 8003950:	b10a      	cbz	r2, 8003956 <GPIO_WriteBit+0x6>
  {
    GPIOx->BSRR = GPIO_Pin;
 8003952:	6181      	str	r1, [r0, #24]
 8003954:	4770      	bx	lr
  }
  else
  {
    GPIOx->BRR = GPIO_Pin ;
 8003956:	8501      	strh	r1, [r0, #40]	; 0x28
 8003958:	4770      	bx	lr

0800395a <GPIO_Write>:
void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal)
{
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  
  GPIOx->ODR = PortVal;
 800395a:	8281      	strh	r1, [r0, #20]
 800395c:	4770      	bx	lr

0800395e <GPIO_PinAFConfig>:
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  assert_param(IS_GPIO_AF(GPIO_AF));
  
  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4));
 800395e:	f001 0307 	and.w	r3, r1, #7
  *        for the detailed mapping of the system and peripherals alternate 
  *        function I/O pins.
  * @retval None
  */
void GPIO_PinAFConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_PinSource, uint8_t GPIO_AF)
{
 8003962:	b530      	push	{r4, r5, lr}
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  assert_param(IS_GPIO_AF(GPIO_AF));
  
  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4));
 8003964:	009b      	lsls	r3, r3, #2
  GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4));
 8003966:	240f      	movs	r4, #15
 8003968:	fa04 f403 	lsl.w	r4, r4, r3
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
  assert_param(IS_GPIO_AF(GPIO_AF));
  
  temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4));
 800396c:	fa02 f203 	lsl.w	r2, r2, r3
  GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4));
 8003970:	08c9      	lsrs	r1, r1, #3
 8003972:	3108      	adds	r1, #8
 8003974:	f850 5021 	ldr.w	r5, [r0, r1, lsl #2]
 8003978:	ea25 0404 	bic.w	r4, r5, r4
 800397c:	f840 4021 	str.w	r4, [r0, r1, lsl #2]
  temp_2 = GPIOx->AFR[GPIO_PinSource >> 0x03] | temp;
 8003980:	f850 4021 	ldr.w	r4, [r0, r1, lsl #2]
 8003984:	4314      	orrs	r4, r2
  GPIOx->AFR[GPIO_PinSource >> 0x03] = temp_2;
 8003986:	f840 4021 	str.w	r4, [r0, r1, lsl #2]
 800398a:	bd30      	pop	{r4, r5, pc}

0800398c <I2C_DeInit>:
  * @brief  Deinitializes the I2Cx peripheral registers to their default reset values.
  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
  * @retval None
  */
void I2C_DeInit(I2C_TypeDef* I2Cx)
{
 800398c:	b508      	push	{r3, lr}
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));

  if (I2Cx == I2C1)
 800398e:	4b0b      	ldr	r3, [pc, #44]	; (80039bc <I2C_DeInit+0x30>)
 8003990:	4298      	cmp	r0, r3
 8003992:	d107      	bne.n	80039a4 <I2C_DeInit+0x18>
  {
    /* Enable I2C1 reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
 8003994:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 8003998:	2101      	movs	r1, #1
 800399a:	f000 fc9f 	bl	80042dc <RCC_APB1PeriphResetCmd>
    /* Release I2C1 from reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, DISABLE);
 800399e:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 80039a2:	e006      	b.n	80039b2 <I2C_DeInit+0x26>
  }
  else
  {
    /* Enable I2C2 reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
 80039a4:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
 80039a8:	2101      	movs	r1, #1
 80039aa:	f000 fc97 	bl	80042dc <RCC_APB1PeriphResetCmd>
    /* Release I2C2 from reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);
 80039ae:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
 80039b2:	2100      	movs	r1, #0
  }
}
 80039b4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  else
  {
    /* Enable I2C2 reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
    /* Release I2C2 from reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, DISABLE);
 80039b8:	f000 bc90 	b.w	80042dc <RCC_APB1PeriphResetCmd>
 80039bc:	40005400 	.word	0x40005400

080039c0 <I2C_Init>:
  assert_param(IS_I2C_OWN_ADDRESS1(I2C_InitStruct->I2C_OwnAddress1));
  assert_param(IS_I2C_ACK(I2C_InitStruct->I2C_Ack));
  assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct->I2C_AcknowledgedAddress));

  /* Disable I2Cx Peripheral */
  I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_PE);
 80039c0:	6803      	ldr	r3, [r0, #0]
 80039c2:	f023 0301 	bic.w	r3, r3, #1
 80039c6:	6003      	str	r3, [r0, #0]

  /*---------------------------- I2Cx FILTERS Configuration ------------------*/
  /* Get the I2Cx CR1 value */
  tmpreg = I2Cx->CR1;
 80039c8:	6802      	ldr	r2, [r0, #0]
  /* Clear I2Cx CR1 register */
  tmpreg &= CR1_CLEAR_MASK;
 80039ca:	4b14      	ldr	r3, [pc, #80]	; (8003a1c <I2C_Init+0x5c>)
 80039cc:	4013      	ands	r3, r2
  /* Configure I2Cx: analog and digital filter */
  /* Set ANFOFF bit according to I2C_AnalogFilter value */
  /* Set DFN bits according to I2C_DigitalFilter value */
  tmpreg |= (uint32_t)I2C_InitStruct->I2C_AnalogFilter |(I2C_InitStruct->I2C_DigitalFilter << 8);
 80039ce:	688a      	ldr	r2, [r1, #8]
 80039d0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80039d4:	684a      	ldr	r2, [r1, #4]
 80039d6:	431a      	orrs	r2, r3

  /*---------------------------- I2Cx TIMING Configuration -------------------*/
  /* Configure I2Cx: Timing */
  /* Set TIMINGR bits according to I2C_Timing */
  /* Write to I2Cx TIMING */
  I2Cx->TIMINGR = I2C_InitStruct->I2C_Timing & TIMING_CLEAR_MASK;
 80039d8:	680b      	ldr	r3, [r1, #0]
  /* Set ANFOFF bit according to I2C_AnalogFilter value */
  /* Set DFN bits according to I2C_DigitalFilter value */
  tmpreg |= (uint32_t)I2C_InitStruct->I2C_AnalogFilter |(I2C_InitStruct->I2C_DigitalFilter << 8);
  
  /* Write to I2Cx CR1 */
  I2Cx->CR1 = tmpreg;
 80039da:	6002      	str	r2, [r0, #0]

  /*---------------------------- I2Cx TIMING Configuration -------------------*/
  /* Configure I2Cx: Timing */
  /* Set TIMINGR bits according to I2C_Timing */
  /* Write to I2Cx TIMING */
  I2Cx->TIMINGR = I2C_InitStruct->I2C_Timing & TIMING_CLEAR_MASK;
 80039dc:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
 80039e0:	6103      	str	r3, [r0, #16]

  /* Enable I2Cx Peripheral */
  I2Cx->CR1 |= I2C_CR1_PE;
 80039e2:	6803      	ldr	r3, [r0, #0]
  /* Clear OAR2 register */
  I2Cx->OAR2 = (uint32_t)tmpreg;
  /* Configure I2Cx: Own Address1 and acknowledged address */
  /* Set OA1MODE bit according to I2C_AcknowledgedAddress value */
  /* Set OA1 bits according to I2C_OwnAddress1 value */
  tmpreg = (uint32_t)((uint32_t)I2C_InitStruct->I2C_AcknowledgedAddress | \
 80039e4:	690a      	ldr	r2, [r1, #16]
  /* Set TIMINGR bits according to I2C_Timing */
  /* Write to I2Cx TIMING */
  I2Cx->TIMINGR = I2C_InitStruct->I2C_Timing & TIMING_CLEAR_MASK;

  /* Enable I2Cx Peripheral */
  I2Cx->CR1 |= I2C_CR1_PE;
 80039e6:	f043 0301 	orr.w	r3, r3, #1
 80039ea:	6003      	str	r3, [r0, #0]

  /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
  /* Clear tmpreg local variable */
  tmpreg = 0;
  /* Clear OAR1 register */
  I2Cx->OAR1 = (uint32_t)tmpreg;
 80039ec:	2300      	movs	r3, #0
 80039ee:	6083      	str	r3, [r0, #8]
  /* Clear OAR2 register */
  I2Cx->OAR2 = (uint32_t)tmpreg;
 80039f0:	60c3      	str	r3, [r0, #12]
  /* Configure I2Cx: Own Address1 and acknowledged address */
  /* Set OA1MODE bit according to I2C_AcknowledgedAddress value */
  /* Set OA1 bits according to I2C_OwnAddress1 value */
  tmpreg = (uint32_t)((uint32_t)I2C_InitStruct->I2C_AcknowledgedAddress | \
 80039f2:	698b      	ldr	r3, [r1, #24]
 80039f4:	4313      	orrs	r3, r2
                      (uint32_t)I2C_InitStruct->I2C_OwnAddress1);
  /* Write to I2Cx OAR1 */
  I2Cx->OAR1 = tmpreg;
 80039f6:	6083      	str	r3, [r0, #8]
  /* Enable Own Address1 acknowledgement */
  I2Cx->OAR1 |= I2C_OAR1_OA1EN;
 80039f8:	6883      	ldr	r3, [r0, #8]
 80039fa:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80039fe:	6083      	str	r3, [r0, #8]
  /*---------------------------- I2Cx MODE Configuration ---------------------*/
  /* Configure I2Cx: mode */
  /* Set SMBDEN and SMBHEN bits according to I2C_Mode value */
  tmpreg = I2C_InitStruct->I2C_Mode;
  /* Write to I2Cx CR1 */
  I2Cx->CR1 |= tmpreg;
 8003a00:	6802      	ldr	r2, [r0, #0]
 8003a02:	68cb      	ldr	r3, [r1, #12]
 8003a04:	4313      	orrs	r3, r2
 8003a06:	6003      	str	r3, [r0, #0]

  /*---------------------------- I2Cx ACK Configuration ----------------------*/
  /* Get the I2Cx CR2 value */
  tmpreg = I2Cx->CR2;
 8003a08:	6843      	ldr	r3, [r0, #4]
  /* Clear I2Cx CR2 register */
  tmpreg &= CR2_CLEAR_MASK;
  /* Configure I2Cx: acknowledgement */
  /* Set NACK bit according to I2C_Ack value */
  tmpreg |= I2C_InitStruct->I2C_Ack;
 8003a0a:	694a      	ldr	r2, [r1, #20]

  /*---------------------------- I2Cx ACK Configuration ----------------------*/
  /* Get the I2Cx CR2 value */
  tmpreg = I2Cx->CR2;
  /* Clear I2Cx CR2 register */
  tmpreg &= CR2_CLEAR_MASK;
 8003a0c:	f023 4378 	bic.w	r3, r3, #4160749568	; 0xf8000000
 8003a10:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
  /* Configure I2Cx: acknowledgement */
  /* Set NACK bit according to I2C_Ack value */
  tmpreg |= I2C_InitStruct->I2C_Ack;
 8003a14:	4313      	orrs	r3, r2
  /* Write to I2Cx CR2 */
  I2Cx->CR2 = tmpreg;
 8003a16:	6043      	str	r3, [r0, #4]
 8003a18:	4770      	bx	lr
 8003a1a:	bf00      	nop
 8003a1c:	00cfe0ff 	.word	0x00cfe0ff

08003a20 <I2C_StructInit>:
  */
void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
{
  /*---------------- Reset I2C init structure parameters values --------------*/
  /* Initialize the I2C_Timing member */
  I2C_InitStruct->I2C_Timing = 0;
 8003a20:	2300      	movs	r3, #0
  /* Initialize the I2C_Mode member */
  I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
  /* Initialize the I2C_OwnAddress1 member */
  I2C_InitStruct->I2C_OwnAddress1 = 0;
  /* Initialize the I2C_Ack member */
  I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
 8003a22:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  */
void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
{
  /*---------------- Reset I2C init structure parameters values --------------*/
  /* Initialize the I2C_Timing member */
  I2C_InitStruct->I2C_Timing = 0;
 8003a26:	6003      	str	r3, [r0, #0]
  /* Initialize the I2C_AnalogFilter member */
  I2C_InitStruct->I2C_AnalogFilter = I2C_AnalogFilter_Enable;
 8003a28:	6043      	str	r3, [r0, #4]
  /* Initialize the I2C_DigitalFilter member */
  I2C_InitStruct->I2C_DigitalFilter = 0;
 8003a2a:	6083      	str	r3, [r0, #8]
  /* Initialize the I2C_Mode member */
  I2C_InitStruct->I2C_Mode = I2C_Mode_I2C;
 8003a2c:	60c3      	str	r3, [r0, #12]
  /* Initialize the I2C_OwnAddress1 member */
  I2C_InitStruct->I2C_OwnAddress1 = 0;
 8003a2e:	6103      	str	r3, [r0, #16]
  /* Initialize the I2C_Ack member */
  I2C_InitStruct->I2C_Ack = I2C_Ack_Disable;
 8003a30:	6142      	str	r2, [r0, #20]
  /* Initialize the I2C_AcknowledgedAddress member */
  I2C_InitStruct->I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 8003a32:	6183      	str	r3, [r0, #24]
 8003a34:	4770      	bx	lr

08003a36 <I2C_Cmd>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected I2C peripheral */
    I2Cx->CR1 |= I2C_CR1_PE;
 8003a36:	6803      	ldr	r3, [r0, #0]
void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8003a38:	b111      	cbz	r1, 8003a40 <I2C_Cmd+0xa>
  {
    /* Enable the selected I2C peripheral */
    I2Cx->CR1 |= I2C_CR1_PE;
 8003a3a:	f043 0301 	orr.w	r3, r3, #1
 8003a3e:	e001      	b.n	8003a44 <I2C_Cmd+0xe>
  }
  else
  {
    /* Disable the selected I2C peripheral */
    I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_PE);
 8003a40:	f023 0301 	bic.w	r3, r3, #1
 8003a44:	6003      	str	r3, [r0, #0]
 8003a46:	4770      	bx	lr

08003a48 <I2C_SoftwareResetCmd>:
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));

  /* Disable peripheral */
  I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_PE);
 8003a48:	6803      	ldr	r3, [r0, #0]
 8003a4a:	f023 0301 	bic.w	r3, r3, #1
 8003a4e:	6003      	str	r3, [r0, #0]

  /* Perform a dummy read to delay the disable of peripheral for minimum
     3 APB clock cycles to perform the software reset functionality */
  *(__IO uint32_t *)(uint32_t)I2Cx; 
 8003a50:	6803      	ldr	r3, [r0, #0]

  /* Enable peripheral */
  I2Cx->CR1 |= I2C_CR1_PE;
 8003a52:	6803      	ldr	r3, [r0, #0]
 8003a54:	f043 0301 	orr.w	r3, r3, #1
 8003a58:	6003      	str	r3, [r0, #0]
 8003a5a:	4770      	bx	lr

08003a5c <I2C_ITConfig>:
  assert_param(IS_I2C_CONFIG_IT(I2C_IT));
  
  if (NewState != DISABLE)
  {
    /* Enable the selected I2C interrupts */
    I2Cx->CR1 |= I2C_IT;
 8003a5c:	6803      	ldr	r3, [r0, #0]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_I2C_CONFIG_IT(I2C_IT));
  
  if (NewState != DISABLE)
 8003a5e:	b10a      	cbz	r2, 8003a64 <I2C_ITConfig+0x8>
  {
    /* Enable the selected I2C interrupts */
    I2Cx->CR1 |= I2C_IT;
 8003a60:	4319      	orrs	r1, r3
 8003a62:	e001      	b.n	8003a68 <I2C_ITConfig+0xc>
  }
  else
  {
    /* Disable the selected I2C interrupts */
    I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_IT);
 8003a64:	ea23 0101 	bic.w	r1, r3, r1
 8003a68:	6001      	str	r1, [r0, #0]
 8003a6a:	4770      	bx	lr

08003a6c <I2C_StretchClockCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable clock stretching */
    I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_NOSTRETCH);    
 8003a6c:	6803      	ldr	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003a6e:	b111      	cbz	r1, 8003a76 <I2C_StretchClockCmd+0xa>
  {
    /* Enable clock stretching */
    I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_NOSTRETCH);    
 8003a70:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 8003a74:	e001      	b.n	8003a7a <I2C_StretchClockCmd+0xe>
  }
  else
  {
    /* Disable clock stretching  */
    I2Cx->CR1 |= I2C_CR1_NOSTRETCH;
 8003a76:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8003a7a:	6003      	str	r3, [r0, #0]
 8003a7c:	4770      	bx	lr

08003a7e <I2C_StopModeCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable wakeup from stop mode */
    I2Cx->CR1 |= I2C_CR1_WUPEN;   
 8003a7e:	6803      	ldr	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003a80:	b111      	cbz	r1, 8003a88 <I2C_StopModeCmd+0xa>
  {
    /* Enable wakeup from stop mode */
    I2Cx->CR1 |= I2C_CR1_WUPEN;   
 8003a82:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8003a86:	e001      	b.n	8003a8c <I2C_StopModeCmd+0xe>
  }
  else
  {
    /* Disable wakeup from stop mode */    
    I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_WUPEN); 
 8003a88:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8003a8c:	6003      	str	r3, [r0, #0]
 8003a8e:	4770      	bx	lr

08003a90 <I2C_DualAddressCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable own address 2 */
    I2Cx->OAR2 |= I2C_OAR2_OA2EN;
 8003a90:	68c3      	ldr	r3, [r0, #12]
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003a92:	b111      	cbz	r1, 8003a9a <I2C_DualAddressCmd+0xa>
  {
    /* Enable own address 2 */
    I2Cx->OAR2 |= I2C_OAR2_OA2EN;
 8003a94:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8003a98:	e001      	b.n	8003a9e <I2C_DualAddressCmd+0xe>
  }
  else
  {
    /* Disable own address 2 */
    I2Cx->OAR2 &= (uint32_t)~((uint32_t)I2C_OAR2_OA2EN);
 8003a9a:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8003a9e:	60c3      	str	r3, [r0, #12]
 8003aa0:	4770      	bx	lr

08003aa2 <I2C_OwnAddress2Config>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_OWN_ADDRESS2(Address));
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(Mask));
  
  /* Get the old register value */
  tmpreg = I2Cx->OAR2;
 8003aa2:	68c3      	ldr	r3, [r0, #12]

  /* Reset I2Cx OA2 bit [7:1] and OA2MSK bit [1:0]  */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_OAR2_OA2 | I2C_OAR2_OA2MSK));

  /* Set I2Cx SADD */
  tmpreg |= (uint32_t)(((uint32_t)Address & I2C_OAR2_OA2) | \
 8003aa4:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
  
  /* Get the old register value */
  tmpreg = I2Cx->OAR2;

  /* Reset I2Cx OA2 bit [7:1] and OA2MSK bit [1:0]  */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_OAR2_OA2 | I2C_OAR2_OA2MSK));
 8003aa8:	f423 63ff 	bic.w	r3, r3, #2040	; 0x7f8
 8003aac:	f023 0306 	bic.w	r3, r3, #6

  /* Set I2Cx SADD */
  tmpreg |= (uint32_t)(((uint32_t)Address & I2C_OAR2_OA2) | \
            (((uint32_t)Mask << 8) & I2C_OAR2_OA2MSK)) ;
 8003ab0:	0212      	lsls	r2, r2, #8

  /* Reset I2Cx OA2 bit [7:1] and OA2MSK bit [1:0]  */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_OAR2_OA2 | I2C_OAR2_OA2MSK));

  /* Set I2Cx SADD */
  tmpreg |= (uint32_t)(((uint32_t)Address & I2C_OAR2_OA2) | \
 8003ab2:	430b      	orrs	r3, r1
            (((uint32_t)Mask << 8) & I2C_OAR2_OA2MSK)) ;
 8003ab4:	f402 62e0 	and.w	r2, r2, #1792	; 0x700

  /* Reset I2Cx OA2 bit [7:1] and OA2MSK bit [1:0]  */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_OAR2_OA2 | I2C_OAR2_OA2MSK));

  /* Set I2Cx SADD */
  tmpreg |= (uint32_t)(((uint32_t)Address & I2C_OAR2_OA2) | \
 8003ab8:	4313      	orrs	r3, r2
            (((uint32_t)Mask << 8) & I2C_OAR2_OA2MSK)) ;

  /* Store the new register value */
  I2Cx->OAR2 = tmpreg;
 8003aba:	60c3      	str	r3, [r0, #12]
 8003abc:	4770      	bx	lr

08003abe <I2C_GeneralCallCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable general call mode */
    I2Cx->CR1 |= I2C_CR1_GCEN;
 8003abe:	6803      	ldr	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003ac0:	b111      	cbz	r1, 8003ac8 <I2C_GeneralCallCmd+0xa>
  {
    /* Enable general call mode */
    I2Cx->CR1 |= I2C_CR1_GCEN;
 8003ac2:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8003ac6:	e001      	b.n	8003acc <I2C_GeneralCallCmd+0xe>
  }
  else
  {
    /* Disable general call mode */
    I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_GCEN);
 8003ac8:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 8003acc:	6003      	str	r3, [r0, #0]
 8003ace:	4770      	bx	lr

08003ad0 <I2C_SlaveByteControlCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable slave byte control */
    I2Cx->CR1 |= I2C_CR1_SBC;
 8003ad0:	6803      	ldr	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003ad2:	b111      	cbz	r1, 8003ada <I2C_SlaveByteControlCmd+0xa>
  {
    /* Enable slave byte control */
    I2Cx->CR1 |= I2C_CR1_SBC;
 8003ad4:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8003ad8:	e001      	b.n	8003ade <I2C_SlaveByteControlCmd+0xe>
  }
  else
  {
    /* Disable slave byte control */
    I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_SBC);
 8003ada:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8003ade:	6003      	str	r3, [r0, #0]
 8003ae0:	4770      	bx	lr

08003ae2 <I2C_SlaveAddressConfig>:
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_SLAVE_ADDRESS(Address));
               
  /* Get the old register value */
  tmpreg = I2Cx->CR2;
 8003ae2:	6843      	ldr	r3, [r0, #4]

  /* Reset I2Cx SADD bit [9:0] */
  tmpreg &= (uint32_t)~((uint32_t)I2C_CR2_SADD);

  /* Set I2Cx SADD */
  tmpreg |= (uint32_t)((uint32_t)Address & I2C_CR2_SADD);
 8003ae4:	0589      	lsls	r1, r1, #22
               
  /* Get the old register value */
  tmpreg = I2Cx->CR2;

  /* Reset I2Cx SADD bit [9:0] */
  tmpreg &= (uint32_t)~((uint32_t)I2C_CR2_SADD);
 8003ae6:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
 8003aea:	f023 0303 	bic.w	r3, r3, #3

  /* Set I2Cx SADD */
  tmpreg |= (uint32_t)((uint32_t)Address & I2C_CR2_SADD);
 8003aee:	ea43 5391 	orr.w	r3, r3, r1, lsr #22

  /* Store the new register value */
  I2Cx->CR2 = tmpreg;
 8003af2:	6043      	str	r3, [r0, #4]
 8003af4:	4770      	bx	lr

08003af6 <I2C_10BitAddressingModeCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable 10-bit addressing mode */
    I2Cx->CR2 |= I2C_CR2_ADD10;
 8003af6:	6843      	ldr	r3, [r0, #4]
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003af8:	b111      	cbz	r1, 8003b00 <I2C_10BitAddressingModeCmd+0xa>
  {
    /* Enable 10-bit addressing mode */
    I2Cx->CR2 |= I2C_CR2_ADD10;
 8003afa:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8003afe:	e001      	b.n	8003b04 <I2C_10BitAddressingModeCmd+0xe>
  }
  else
  {
    /* Disable 10-bit addressing mode */
    I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_ADD10);
 8003b00:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8003b04:	6043      	str	r3, [r0, #4]
 8003b06:	4770      	bx	lr

08003b08 <I2C_AutoEndCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable Auto end mode */
    I2Cx->CR2 |= I2C_CR2_AUTOEND;
 8003b08:	6843      	ldr	r3, [r0, #4]
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003b0a:	b111      	cbz	r1, 8003b12 <I2C_AutoEndCmd+0xa>
  {
    /* Enable Auto end mode */
    I2Cx->CR2 |= I2C_CR2_AUTOEND;
 8003b0c:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 8003b10:	e001      	b.n	8003b16 <I2C_AutoEndCmd+0xe>
  }
  else
  {
    /* Disable Auto end mode */
    I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_AUTOEND);
 8003b12:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
 8003b16:	6043      	str	r3, [r0, #4]
 8003b18:	4770      	bx	lr

08003b1a <I2C_ReloadCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable Auto Reload mode */
    I2Cx->CR2 |= I2C_CR2_RELOAD;
 8003b1a:	6843      	ldr	r3, [r0, #4]
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003b1c:	b111      	cbz	r1, 8003b24 <I2C_ReloadCmd+0xa>
  {
    /* Enable Auto Reload mode */
    I2Cx->CR2 |= I2C_CR2_RELOAD;
 8003b1e:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8003b22:	e001      	b.n	8003b28 <I2C_ReloadCmd+0xe>
  }
  else
  {
    /* Disable Auto Reload mode */
    I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_RELOAD);
 8003b24:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8003b28:	6043      	str	r3, [r0, #4]
 8003b2a:	4770      	bx	lr

08003b2c <I2C_NumberOfBytesConfig>:

  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));

  /* Get the old register value */
  tmpreg = I2Cx->CR2;
 8003b2c:	6843      	ldr	r3, [r0, #4]

  /* Reset I2Cx Nbytes bit [7:0] */
  tmpreg &= (uint32_t)~((uint32_t)I2C_CR2_NBYTES);
 8003b2e:	f423 037f 	bic.w	r3, r3, #16711680	; 0xff0000

  /* Set I2Cx Nbytes */
  tmpreg |= (uint32_t)(((uint32_t)Number_Bytes << 16 ) & I2C_CR2_NBYTES);
 8003b32:	ea43 4101 	orr.w	r1, r3, r1, lsl #16

  /* Store the new register value */
  I2Cx->CR2 = tmpreg;
 8003b36:	6041      	str	r1, [r0, #4]
 8003b38:	4770      	bx	lr

08003b3a <I2C_MasterRequestConfig>:
  
  /* Test on the direction to set/reset the read/write bit */
  if (I2C_Direction == I2C_Direction_Transmitter)
  {
    /* Request a write Transfer */
    I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_RD_WRN);
 8003b3a:	6843      	ldr	r3, [r0, #4]
/* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_DIRECTION(I2C_Direction));
  
  /* Test on the direction to set/reset the read/write bit */
  if (I2C_Direction == I2C_Direction_Transmitter)
 8003b3c:	b911      	cbnz	r1, 8003b44 <I2C_MasterRequestConfig+0xa>
  {
    /* Request a write Transfer */
    I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_RD_WRN);
 8003b3e:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8003b42:	e001      	b.n	8003b48 <I2C_MasterRequestConfig+0xe>
  }
  else
  {
    /* Request a read Transfer */
    I2Cx->CR2 |= I2C_CR2_RD_WRN;
 8003b44:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8003b48:	6043      	str	r3, [r0, #4]
 8003b4a:	4770      	bx	lr

08003b4c <I2C_GenerateSTART>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Generate a START condition */
    I2Cx->CR2 |= I2C_CR2_START;
 8003b4c:	6843      	ldr	r3, [r0, #4]
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003b4e:	b111      	cbz	r1, 8003b56 <I2C_GenerateSTART+0xa>
  {
    /* Generate a START condition */
    I2Cx->CR2 |= I2C_CR2_START;
 8003b50:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8003b54:	e001      	b.n	8003b5a <I2C_GenerateSTART+0xe>
  }
  else
  {
    /* Disable the START condition generation */
    I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_START);
 8003b56:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8003b5a:	6043      	str	r3, [r0, #4]
 8003b5c:	4770      	bx	lr

08003b5e <I2C_GenerateSTOP>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Generate a STOP condition */
    I2Cx->CR2 |= I2C_CR2_STOP;
 8003b5e:	6843      	ldr	r3, [r0, #4]
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003b60:	b111      	cbz	r1, 8003b68 <I2C_GenerateSTOP+0xa>
  {
    /* Generate a STOP condition */
    I2Cx->CR2 |= I2C_CR2_STOP;
 8003b62:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8003b66:	e001      	b.n	8003b6c <I2C_GenerateSTOP+0xe>
  }
  else
  {
    /* Disable the STOP condition generation */
    I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_STOP);
 8003b68:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8003b6c:	6043      	str	r3, [r0, #4]
 8003b6e:	4770      	bx	lr

08003b70 <I2C_10BitAddressHeaderCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable 10-bit header only mode */
    I2Cx->CR2 |= I2C_CR2_HEAD10R;
 8003b70:	6843      	ldr	r3, [r0, #4]
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003b72:	b111      	cbz	r1, 8003b7a <I2C_10BitAddressHeaderCmd+0xa>
  {
    /* Enable 10-bit header only mode */
    I2Cx->CR2 |= I2C_CR2_HEAD10R;
 8003b74:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8003b78:	e001      	b.n	8003b7e <I2C_10BitAddressHeaderCmd+0xe>
  }
  else
  {
    /* Disable 10-bit header only mode */
    I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_HEAD10R);
 8003b7a:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8003b7e:	6043      	str	r3, [r0, #4]
 8003b80:	4770      	bx	lr

08003b82 <I2C_AcknowledgeConfig>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable ACK generation */
    I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_NACK);    
 8003b82:	6843      	ldr	r3, [r0, #4]
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003b84:	b111      	cbz	r1, 8003b8c <I2C_AcknowledgeConfig+0xa>
  {
    /* Enable ACK generation */
    I2Cx->CR2 &= (uint32_t)~((uint32_t)I2C_CR2_NACK);    
 8003b86:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8003b8a:	e001      	b.n	8003b90 <I2C_AcknowledgeConfig+0xe>
  }
  else
  {
    /* Enable NACK generation */
    I2Cx->CR2 |= I2C_CR2_NACK;
 8003b8c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8003b90:	6043      	str	r3, [r0, #4]
 8003b92:	4770      	bx	lr

08003b94 <I2C_GetAddressMatched>:
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  
  /* Return the slave matched address in the SR1 register */
  return (uint8_t)(((uint32_t)I2Cx->ISR & I2C_ISR_ADDCODE) >> 16) ;
 8003b94:	6980      	ldr	r0, [r0, #24]
 8003b96:	f400 007e 	and.w	r0, r0, #16646144	; 0xfe0000
}
 8003b9a:	0c00      	lsrs	r0, r0, #16
 8003b9c:	4770      	bx	lr

08003b9e <I2C_GetTransferDirection>:
  
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  
  /* Return the slave matched address in the SR1 register */
  tmpreg = (uint32_t)(I2Cx->ISR & I2C_ISR_DIR);
 8003b9e:	6983      	ldr	r3, [r0, #24]
  
  /* If write transfer is requested */
  if (tmpreg == 0)
 8003ba0:	f413 3f80 	tst.w	r3, #65536	; 0x10000
  {
    /* Read transfer is requested */
    direction = I2C_Direction_Receiver;
  }  
  return direction;
}
 8003ba4:	bf14      	ite	ne
 8003ba6:	f44f 6080 	movne.w	r0, #1024	; 0x400
 8003baa:	2000      	moveq	r0, #0
 8003bac:	4770      	bx	lr

08003bae <I2C_TransferHandling>:
  *     @arg I2C_Generate_Start_Read: Generate Restart for read request.
  *     @arg I2C_Generate_Start_Write: Generate Restart for write request.
  * @retval None
  */
void I2C_TransferHandling(I2C_TypeDef* I2Cx, uint16_t Address, uint8_t Number_Bytes, uint32_t ReloadEndMode, uint32_t StartStopMode)
{
 8003bae:	b530      	push	{r4, r5, lr}
  assert_param(IS_I2C_SLAVE_ADDRESS(Address));  
  assert_param(IS_RELOAD_END_MODE(ReloadEndMode));
  assert_param(IS_START_STOP_MODE(StartStopMode));
    
  /* Get the CR2 register value */
  tmpreg = I2Cx->CR2;
 8003bb0:	6845      	ldr	r5, [r0, #4]
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 8003bb2:	4c06      	ldr	r4, [pc, #24]	; (8003bcc <I2C_TransferHandling+0x1e>)
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)Address & I2C_CR2_SADD) | (((uint32_t)Number_Bytes << 16 ) & I2C_CR2_NBYTES) | \
 8003bb4:	0589      	lsls	r1, r1, #22
 8003bb6:	ea43 5391 	orr.w	r3, r3, r1, lsr #22
    
  /* Get the CR2 register value */
  tmpreg = I2Cx->CR2;
  
  /* clear tmpreg specific bits */
  tmpreg &= (uint32_t)~((uint32_t)(I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP));
 8003bba:	402c      	ands	r4, r5
  
  /* update tmpreg */
  tmpreg |= (uint32_t)(((uint32_t)Address & I2C_CR2_SADD) | (((uint32_t)Number_Bytes << 16 ) & I2C_CR2_NBYTES) | \
 8003bbc:	9903      	ldr	r1, [sp, #12]
 8003bbe:	431c      	orrs	r4, r3
 8003bc0:	4321      	orrs	r1, r4
 8003bc2:	ea41 4202 	orr.w	r2, r1, r2, lsl #16
            (uint32_t)ReloadEndMode | (uint32_t)StartStopMode);
  
  /* update CR2 register */
  I2Cx->CR2 = tmpreg;  
 8003bc6:	6042      	str	r2, [r0, #4]
 8003bc8:	bd30      	pop	{r4, r5, pc}
 8003bca:	bf00      	nop
 8003bcc:	fc009800 	.word	0xfc009800

08003bd0 <I2C_SMBusAlertCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable SMBus alert */
    I2Cx->CR1 |= I2C_CR1_ALERTEN;   
 8003bd0:	6803      	ldr	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003bd2:	b111      	cbz	r1, 8003bda <I2C_SMBusAlertCmd+0xa>
  {
    /* Enable SMBus alert */
    I2Cx->CR1 |= I2C_CR1_ALERTEN;   
 8003bd4:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8003bd8:	e001      	b.n	8003bde <I2C_SMBusAlertCmd+0xe>
  }
  else
  {
    /* Disable SMBus alert */    
    I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_ALERTEN); 
 8003bda:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
 8003bde:	6003      	str	r3, [r0, #0]
 8003be0:	4770      	bx	lr

08003be2 <I2C_ClockTimeoutCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable Clock Timeout */
    I2Cx->TIMEOUTR |= I2C_TIMEOUTR_TIMOUTEN;   
 8003be2:	6943      	ldr	r3, [r0, #20]
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003be4:	b111      	cbz	r1, 8003bec <I2C_ClockTimeoutCmd+0xa>
  {
    /* Enable Clock Timeout */
    I2Cx->TIMEOUTR |= I2C_TIMEOUTR_TIMOUTEN;   
 8003be6:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8003bea:	e001      	b.n	8003bf0 <I2C_ClockTimeoutCmd+0xe>
  }
  else
  {
    /* Disable Clock Timeout */    
    I2Cx->TIMEOUTR &= (uint32_t)~((uint32_t)I2C_TIMEOUTR_TIMOUTEN); 
 8003bec:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8003bf0:	6143      	str	r3, [r0, #20]
 8003bf2:	4770      	bx	lr

08003bf4 <I2C_ExtendedClockTimeoutCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable Clock Timeout */
    I2Cx->TIMEOUTR |= I2C_TIMEOUTR_TEXTEN;   
 8003bf4:	6943      	ldr	r3, [r0, #20]
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003bf6:	b111      	cbz	r1, 8003bfe <I2C_ExtendedClockTimeoutCmd+0xa>
  {
    /* Enable Clock Timeout */
    I2Cx->TIMEOUTR |= I2C_TIMEOUTR_TEXTEN;   
 8003bf8:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8003bfc:	e001      	b.n	8003c02 <I2C_ExtendedClockTimeoutCmd+0xe>
  }
  else
  {
    /* Disable Clock Timeout */    
    I2Cx->TIMEOUTR &= (uint32_t)~((uint32_t)I2C_TIMEOUTR_TEXTEN); 
 8003bfe:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8003c02:	6143      	str	r3, [r0, #20]
 8003c04:	4770      	bx	lr

08003c06 <I2C_IdleClockTimeoutCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable Clock Timeout */
    I2Cx->TIMEOUTR |= I2C_TIMEOUTR_TIDLE;   
 8003c06:	6943      	ldr	r3, [r0, #20]
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003c08:	b111      	cbz	r1, 8003c10 <I2C_IdleClockTimeoutCmd+0xa>
  {
    /* Enable Clock Timeout */
    I2Cx->TIMEOUTR |= I2C_TIMEOUTR_TIDLE;   
 8003c0a:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8003c0e:	e001      	b.n	8003c14 <I2C_IdleClockTimeoutCmd+0xe>
  }
  else
  {
    /* Disable Clock Timeout */    
    I2Cx->TIMEOUTR &= (uint32_t)~((uint32_t)I2C_TIMEOUTR_TIDLE); 
 8003c10:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8003c14:	6143      	str	r3, [r0, #20]
 8003c16:	4770      	bx	lr

08003c18 <I2C_TimeoutAConfig>:
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_TIMEOUT(Timeout));
    
  /* Get the old register value */
  tmpreg = I2Cx->TIMEOUTR;
 8003c18:	6943      	ldr	r3, [r0, #20]

  /* Reset I2Cx TIMEOUTA bit [11:0] */
  tmpreg &= (uint32_t)~((uint32_t)I2C_TIMEOUTR_TIMEOUTA);

  /* Set I2Cx TIMEOUTA */
  tmpreg |= (uint32_t)((uint32_t)Timeout & I2C_TIMEOUTR_TIMEOUTA) ;
 8003c1a:	0509      	lsls	r1, r1, #20
    
  /* Get the old register value */
  tmpreg = I2Cx->TIMEOUTR;

  /* Reset I2Cx TIMEOUTA bit [11:0] */
  tmpreg &= (uint32_t)~((uint32_t)I2C_TIMEOUTR_TIMEOUTA);
 8003c1c:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 8003c20:	f023 030f 	bic.w	r3, r3, #15

  /* Set I2Cx TIMEOUTA */
  tmpreg |= (uint32_t)((uint32_t)Timeout & I2C_TIMEOUTR_TIMEOUTA) ;
 8003c24:	ea43 5311 	orr.w	r3, r3, r1, lsr #20

  /* Store the new register value */
  I2Cx->TIMEOUTR = tmpreg;
 8003c28:	6143      	str	r3, [r0, #20]
 8003c2a:	4770      	bx	lr

08003c2c <I2C_TimeoutBConfig>:
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_TIMEOUT(Timeout));

  /* Get the old register value */
  tmpreg = I2Cx->TIMEOUTR;
 8003c2c:	6943      	ldr	r3, [r0, #20]

  /* Reset I2Cx TIMEOUTB bit [11:0] */
  tmpreg &= (uint32_t)~((uint32_t)I2C_TIMEOUTR_TIMEOUTB);

  /* Set I2Cx TIMEOUTB */
  tmpreg |= (uint32_t)(((uint32_t)Timeout << 16) & I2C_TIMEOUTR_TIMEOUTB) ;
 8003c2e:	4a05      	ldr	r2, [pc, #20]	; (8003c44 <I2C_TimeoutBConfig+0x18>)

  /* Get the old register value */
  tmpreg = I2Cx->TIMEOUTR;

  /* Reset I2Cx TIMEOUTB bit [11:0] */
  tmpreg &= (uint32_t)~((uint32_t)I2C_TIMEOUTR_TIMEOUTB);
 8003c30:	f023 637f 	bic.w	r3, r3, #267386880	; 0xff00000
 8003c34:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000

  /* Set I2Cx TIMEOUTB */
  tmpreg |= (uint32_t)(((uint32_t)Timeout << 16) & I2C_TIMEOUTR_TIMEOUTB) ;
 8003c38:	ea02 4101 	and.w	r1, r2, r1, lsl #16
 8003c3c:	430b      	orrs	r3, r1

  /* Store the new register value */
  I2Cx->TIMEOUTR = tmpreg;
 8003c3e:	6143      	str	r3, [r0, #20]
 8003c40:	4770      	bx	lr
 8003c42:	bf00      	nop
 8003c44:	0fff0000 	.word	0x0fff0000

08003c48 <I2C_CalculatePEC>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable PEC calculation */
    I2Cx->CR1 |= I2C_CR1_PECEN;   
 8003c48:	6803      	ldr	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003c4a:	b111      	cbz	r1, 8003c52 <I2C_CalculatePEC+0xa>
  {
    /* Enable PEC calculation */
    I2Cx->CR1 |= I2C_CR1_PECEN;   
 8003c4c:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8003c50:	e001      	b.n	8003c56 <I2C_CalculatePEC+0xe>
  }
  else
  {
    /* Disable PEC calculation */    
    I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR1_PECEN); 
 8003c52:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
 8003c56:	6003      	str	r3, [r0, #0]
 8003c58:	4770      	bx	lr

08003c5a <I2C_PECRequestCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable PEC transmission/reception request */
    I2Cx->CR1 |= I2C_CR2_PECBYTE;   
 8003c5a:	6803      	ldr	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003c5c:	b111      	cbz	r1, 8003c64 <I2C_PECRequestCmd+0xa>
  {
    /* Enable PEC transmission/reception request */
    I2Cx->CR1 |= I2C_CR2_PECBYTE;   
 8003c5e:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 8003c62:	e001      	b.n	8003c68 <I2C_PECRequestCmd+0xe>
  }
  else
  {
    /* Disable PEC transmission/reception request */    
    I2Cx->CR1 &= (uint32_t)~((uint32_t)I2C_CR2_PECBYTE); 
 8003c64:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 8003c68:	6003      	str	r3, [r0, #0]
 8003c6a:	4770      	bx	lr

08003c6c <I2C_GetPEC>:
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  
  /* Return the slave matched address in the SR1 register */
  return (uint8_t)((uint32_t)I2Cx->PECR & I2C_PECR_PEC);
 8003c6c:	6a00      	ldr	r0, [r0, #32]
}
 8003c6e:	b2c0      	uxtb	r0, r0
 8003c70:	4770      	bx	lr

08003c72 <I2C_ReadRegister>:
  *     @arg I2C_Register_RXDR: RXDR register.
  *     @arg I2C_Register_TXDR: TXDR register.
  * @retval The value of the read register.
  */
uint32_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register)
{
 8003c72:	b082      	sub	sp, #8
  __IO uint32_t tmp = 0;
 8003c74:	2300      	movs	r3, #0
 8003c76:	9301      	str	r3, [sp, #4]

  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_REGISTER(I2C_Register));

  tmp = (uint32_t)I2Cx;
 8003c78:	9001      	str	r0, [sp, #4]
  tmp += I2C_Register;
 8003c7a:	9b01      	ldr	r3, [sp, #4]
 8003c7c:	18c9      	adds	r1, r1, r3
 8003c7e:	9101      	str	r1, [sp, #4]

  /* Return the selected register value */
  return (*(__IO uint32_t *) tmp);
 8003c80:	9b01      	ldr	r3, [sp, #4]
 8003c82:	6818      	ldr	r0, [r3, #0]
}
 8003c84:	b002      	add	sp, #8
 8003c86:	4770      	bx	lr

08003c88 <I2C_SendData>:
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  
  /* Write in the DR register the data to be sent */
  I2Cx->TXDR = (uint8_t)Data;
 8003c88:	6281      	str	r1, [r0, #40]	; 0x28
 8003c8a:	4770      	bx	lr

08003c8c <I2C_ReceiveData>:
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  
  /* Return the data in the DR register */
  return (uint8_t)I2Cx->RXDR;
 8003c8c:	6a40      	ldr	r0, [r0, #36]	; 0x24
}  
 8003c8e:	b2c0      	uxtb	r0, r0
 8003c90:	4770      	bx	lr

08003c92 <I2C_DMACmd>:
  assert_param(IS_I2C_DMA_REQ(I2C_DMAReq));

  if (NewState != DISABLE)
  {
    /* Enable the selected I2C DMA requests */
    I2Cx->CR1 |= I2C_DMAReq;
 8003c92:	6803      	ldr	r3, [r0, #0]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_I2C_DMA_REQ(I2C_DMAReq));

  if (NewState != DISABLE)
 8003c94:	b10a      	cbz	r2, 8003c9a <I2C_DMACmd+0x8>
  {
    /* Enable the selected I2C DMA requests */
    I2Cx->CR1 |= I2C_DMAReq;
 8003c96:	4319      	orrs	r1, r3
 8003c98:	e001      	b.n	8003c9e <I2C_DMACmd+0xc>
  }
  else
  {
    /* Disable the selected I2C DMA requests */
    I2Cx->CR1 &= (uint32_t)~I2C_DMAReq;
 8003c9a:	ea23 0101 	bic.w	r1, r3, r1
 8003c9e:	6001      	str	r1, [r0, #0]
 8003ca0:	4770      	bx	lr

08003ca2 <I2C_GetFlagStatus>:
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_GET_FLAG(I2C_FLAG));
  
  /* Get the ISR register value */
  tmpreg = I2Cx->ISR;
 8003ca2:	6983      	ldr	r3, [r0, #24]
  
  /* Get flag status */
  tmpreg &= I2C_FLAG;
  
  if(tmpreg != 0)
 8003ca4:	4219      	tst	r1, r3
  {
    /* I2C_FLAG is reset */
    bitstatus = RESET;
  }
  return bitstatus;
}  
 8003ca6:	bf0c      	ite	eq
 8003ca8:	2000      	moveq	r0, #0
 8003caa:	2001      	movne	r0, #1
 8003cac:	4770      	bx	lr

08003cae <I2C_ClearFlag>:
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));

  /* Clear the selected flag */
  I2Cx->ICR = I2C_FLAG;
 8003cae:	61c1      	str	r1, [r0, #28]
 8003cb0:	4770      	bx	lr

08003cb2 <I2C_GetITStatus>:
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_GET_IT(I2C_IT));

  /* Check if the interrupt source is enabled or not */
  /* If Error interrupt */
  if((uint32_t)(I2C_IT & ERROR_IT_MASK))
 8003cb2:	f411 5f7c 	tst.w	r1, #16128	; 0x3f00
  {
    enablestatus = (uint32_t)((I2C_CR1_ERRIE) & (I2Cx->CR1));
 8003cb6:	6803      	ldr	r3, [r0, #0]
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_GET_IT(I2C_IT));

  /* Check if the interrupt source is enabled or not */
  /* If Error interrupt */
  if((uint32_t)(I2C_IT & ERROR_IT_MASK))
 8003cb8:	d002      	beq.n	8003cc0 <I2C_GetITStatus+0xe>
  {
    enablestatus = (uint32_t)((I2C_CR1_ERRIE) & (I2Cx->CR1));
 8003cba:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8003cbe:	e005      	b.n	8003ccc <I2C_GetITStatus+0x1a>
  }
  /* If TC interrupt */
  else if((uint32_t)(I2C_IT & TC_IT_MASK))
 8003cc0:	f011 0fc0 	tst.w	r1, #192	; 0xc0
  {
    enablestatus = (uint32_t)((I2C_CR1_TCIE) & (I2Cx->CR1));
 8003cc4:	bf14      	ite	ne
 8003cc6:	f003 0340 	andne.w	r3, r3, #64	; 0x40
  }
  else
  {
    enablestatus = (uint32_t)((I2C_IT) & (I2Cx->CR1));
 8003cca:	400b      	andeq	r3, r1
  }
  
  /* Get the ISR register value */
  tmpreg = I2Cx->ISR;
 8003ccc:	6980      	ldr	r0, [r0, #24]

  /* Get flag status */
  tmpreg &= I2C_IT;

  /* Check the status of the specified I2C flag */
  if((tmpreg != RESET) && enablestatus)
 8003cce:	4008      	ands	r0, r1
 8003cd0:	d002      	beq.n	8003cd8 <I2C_GetITStatus+0x26>
  {
    /* I2C_IT is set */
    bitstatus = SET;
 8003cd2:	1c18      	adds	r0, r3, #0
 8003cd4:	bf18      	it	ne
 8003cd6:	2001      	movne	r0, #1
    bitstatus = RESET;
  }

  /* Return the I2C_IT status */
  return bitstatus;
}
 8003cd8:	4770      	bx	lr

08003cda <I2C_ClearITPendingBit>:
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_CLEAR_IT(I2C_IT));

  /* Clear the selected flag */
  I2Cx->ICR = I2C_IT;
 8003cda:	61c1      	str	r1, [r0, #28]
 8003cdc:	4770      	bx	lr
 8003cde:	bf00      	nop

08003ce0 <NVIC_PriorityGroupConfig>:
{
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */
  SCB->AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;
 8003ce0:	f040 60bf 	orr.w	r0, r0, #100139008	; 0x5f80000
 8003ce4:	4b02      	ldr	r3, [pc, #8]	; (8003cf0 <NVIC_PriorityGroupConfig+0x10>)
 8003ce6:	f440 3000 	orr.w	r0, r0, #131072	; 0x20000
 8003cea:	60d8      	str	r0, [r3, #12]
 8003cec:	4770      	bx	lr
 8003cee:	bf00      	nop
 8003cf0:	e000ed00 	.word	0xe000ed00

08003cf4 <NVIC_Init>:
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority));  
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
 8003cf4:	78c3      	ldrb	r3, [r0, #3]
  * @param  NVIC_InitStruct: pointer to a NVIC_InitTypeDef structure that contains
  *         the configuration information for the specified NVIC peripheral.
  * @retval None
  */
void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct)
{
 8003cf6:	b510      	push	{r4, lr}
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority));  
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
 8003cf8:	b1fb      	cbz	r3, 8003d3a <NVIC_Init+0x46>
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
 8003cfa:	4b16      	ldr	r3, [pc, #88]	; (8003d54 <NVIC_Init+0x60>)
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (uint32_t)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 8003cfc:	7841      	ldrb	r1, [r0, #1]
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
 8003cfe:	68db      	ldr	r3, [r3, #12]
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (uint32_t)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
 8003d00:	7884      	ldrb	r4, [r0, #2]
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
 8003d02:	43db      	mvns	r3, r3
 8003d04:	f3c3 2302 	ubfx	r3, r3, #8, #3
    tmppre = (0x4 - tmppriority);
 8003d08:	f1c3 0204 	rsb	r2, r3, #4
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (uint32_t)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 8003d0c:	fa01 f102 	lsl.w	r1, r1, r2
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;
 8003d10:	220f      	movs	r2, #15
 8003d12:	fa22 f203 	lsr.w	r2, r2, r3

    tmppriority = (uint32_t)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 8003d16:	7803      	ldrb	r3, [r0, #0]
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (uint32_t)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
 8003d18:	4022      	ands	r2, r4
 8003d1a:	430a      	orrs	r2, r1
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 8003d1c:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (uint32_t)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
    tmppriority = tmppriority << 0x04;
 8003d20:	0112      	lsls	r2, r2, #4
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 8003d22:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
 8003d26:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8003d2a:	7803      	ldrb	r3, [r0, #0]
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8003d2c:	2201      	movs	r2, #1
    tmppriority = tmppriority << 0x04;
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8003d2e:	0959      	lsrs	r1, r3, #5
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8003d30:	f003 031f 	and.w	r3, r3, #31
 8003d34:	fa02 f303 	lsl.w	r3, r2, r3
 8003d38:	e007      	b.n	8003d4a <NVIC_Init+0x56>
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8003d3a:	7803      	ldrb	r3, [r0, #0]
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8003d3c:	2201      	movs	r2, #1
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8003d3e:	0959      	lsrs	r1, r3, #5
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8003d40:	f003 031f 	and.w	r3, r3, #31
 8003d44:	fa02 f303 	lsl.w	r3, r2, r3
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
  else
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8003d48:	3120      	adds	r1, #32
 8003d4a:	4a03      	ldr	r2, [pc, #12]	; (8003d58 <NVIC_Init+0x64>)
 8003d4c:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
 8003d50:	bd10      	pop	{r4, pc}
 8003d52:	bf00      	nop
 8003d54:	e000ed00 	.word	0xe000ed00
 8003d58:	e000e100 	.word	0xe000e100

08003d5c <NVIC_SetVectorTable>:
{ 
  /* Check the parameters */
  assert_param(IS_NVIC_VECTTAB(NVIC_VectTab));
  assert_param(IS_NVIC_OFFSET(Offset));  
   
  SCB->VTOR = NVIC_VectTab | (Offset & (uint32_t)0x1FFFFF80);
 8003d5c:	f021 4160 	bic.w	r1, r1, #3758096384	; 0xe0000000
 8003d60:	f021 017f 	bic.w	r1, r1, #127	; 0x7f
 8003d64:	4b01      	ldr	r3, [pc, #4]	; (8003d6c <NVIC_SetVectorTable+0x10>)
 8003d66:	4308      	orrs	r0, r1
 8003d68:	6098      	str	r0, [r3, #8]
 8003d6a:	4770      	bx	lr
 8003d6c:	e000ed00 	.word	0xe000ed00

08003d70 <NVIC_SystemLPConfig>:
  *     @arg NVIC_LP_SLEEPONEXIT
  * @param  NewState: new state of LP condition. This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void NVIC_SystemLPConfig(uint8_t LowPowerMode, FunctionalState NewState)
{
 8003d70:	4b04      	ldr	r3, [pc, #16]	; (8003d84 <NVIC_SystemLPConfig+0x14>)
  assert_param(IS_NVIC_LP(LowPowerMode));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if (NewState != DISABLE)
  {
    SCB->SCR |= LowPowerMode;
 8003d72:	691a      	ldr	r2, [r3, #16]
{
  /* Check the parameters */
  assert_param(IS_NVIC_LP(LowPowerMode));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  if (NewState != DISABLE)
 8003d74:	b109      	cbz	r1, 8003d7a <NVIC_SystemLPConfig+0xa>
  {
    SCB->SCR |= LowPowerMode;
 8003d76:	4310      	orrs	r0, r2
 8003d78:	e001      	b.n	8003d7e <NVIC_SystemLPConfig+0xe>
  }
  else
  {
    SCB->SCR &= (uint32_t)(~(uint32_t)LowPowerMode);
 8003d7a:	ea22 0000 	bic.w	r0, r2, r0
 8003d7e:	6118      	str	r0, [r3, #16]
 8003d80:	4770      	bx	lr
 8003d82:	bf00      	nop
 8003d84:	e000ed00 	.word	0xe000ed00

08003d88 <SysTick_CLKSourceConfig>:
  *     @arg SysTick_CLKSource_HCLK_Div8: AHB clock divided by 8 selected as SysTick clock source.
  *     @arg SysTick_CLKSource_HCLK: AHB clock selected as SysTick clock source.
  * @retval None
  */
void SysTick_CLKSourceConfig(uint32_t SysTick_CLKSource)
{
 8003d88:	4b04      	ldr	r3, [pc, #16]	; (8003d9c <SysTick_CLKSourceConfig+0x14>)
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(SysTick_CLKSource));
  if (SysTick_CLKSource == SysTick_CLKSource_HCLK)
 8003d8a:	2804      	cmp	r0, #4
  {
    SysTick->CTRL |= SysTick_CLKSource_HCLK;
 8003d8c:	681a      	ldr	r2, [r3, #0]
 8003d8e:	bf0c      	ite	eq
 8003d90:	f042 0204 	orreq.w	r2, r2, #4
  }
  else
  {
    SysTick->CTRL &= SysTick_CLKSource_HCLK_Div8;
 8003d94:	f022 0204 	bicne.w	r2, r2, #4
 8003d98:	601a      	str	r2, [r3, #0]
 8003d9a:	4770      	bx	lr
 8003d9c:	e000e010 	.word	0xe000e010

08003da0 <RCC_DeInit>:
  * @retval None
  */
void RCC_DeInit(void)
{
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8003da0:	4b11      	ldr	r3, [pc, #68]	; (8003de8 <RCC_DeInit+0x48>)
 8003da2:	681a      	ldr	r2, [r3, #0]
 8003da4:	f042 0201 	orr.w	r2, r2, #1
 8003da8:	601a      	str	r2, [r3, #0]

  /* Reset SW[1:0], HPRE[3:0], PPRE[2:0] and MCOSEL[2:0] bits */
  RCC->CFGR &= (uint32_t)0xF8FFC000;
 8003daa:	6859      	ldr	r1, [r3, #4]
 8003dac:	4a0f      	ldr	r2, [pc, #60]	; (8003dec <RCC_DeInit+0x4c>)
 8003dae:	400a      	ands	r2, r1
 8003db0:	605a      	str	r2, [r3, #4]
  
  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8003db2:	681a      	ldr	r2, [r3, #0]
 8003db4:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 8003db8:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8003dbc:	601a      	str	r2, [r3, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8003dbe:	681a      	ldr	r2, [r3, #0]
 8003dc0:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8003dc4:	601a      	str	r2, [r3, #0]

  /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE bits */
  RCC->CFGR &= (uint32_t)0xFF80FFFF;
 8003dc6:	685a      	ldr	r2, [r3, #4]
 8003dc8:	f422 02fe 	bic.w	r2, r2, #8323072	; 0x7f0000
 8003dcc:	605a      	str	r2, [r3, #4]

  /* Reset PREDIV1[3:0] and ADCPRE[13:4] bits */
  RCC->CFGR2 &= (uint32_t)0xFFFFC000;
 8003dce:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8003dd0:	f422 527f 	bic.w	r2, r2, #16320	; 0x3fc0
 8003dd4:	f022 023f 	bic.w	r2, r2, #63	; 0x3f
 8003dd8:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Reset USARTSW[1:0], I2CSW and TIMSW bits */
  RCC->CFGR3 &= (uint32_t)0xF00FCCC;
 8003dda:	6b19      	ldr	r1, [r3, #48]	; 0x30
 8003ddc:	4a04      	ldr	r2, [pc, #16]	; (8003df0 <RCC_DeInit+0x50>)
 8003dde:	400a      	ands	r2, r1
 8003de0:	631a      	str	r2, [r3, #48]	; 0x30
  
  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 8003de2:	2200      	movs	r2, #0
 8003de4:	609a      	str	r2, [r3, #8]
 8003de6:	4770      	bx	lr
 8003de8:	40021000 	.word	0x40021000
 8003dec:	f8ffc000 	.word	0xf8ffc000
 8003df0:	0f00fccc 	.word	0x0f00fccc

08003df4 <RCC_HSEConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_HSE(RCC_HSE));

  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
  *(__IO uint8_t *) CR_BYTE2_ADDRESS = RCC_HSE_OFF;
 8003df4:	4b02      	ldr	r3, [pc, #8]	; (8003e00 <RCC_HSEConfig+0xc>)
 8003df6:	2200      	movs	r2, #0
 8003df8:	701a      	strb	r2, [r3, #0]

  /* Set the new HSE configuration -------------------------------------------*/
  *(__IO uint8_t *) CR_BYTE2_ADDRESS = RCC_HSE;
 8003dfa:	7018      	strb	r0, [r3, #0]
 8003dfc:	4770      	bx	lr
 8003dfe:	bf00      	nop
 8003e00:	40021002 	.word	0x40021002

08003e04 <RCC_AdjustHSICalibrationValue>:
  uint32_t tmpreg = 0;
  
  /* Check the parameters */
  assert_param(IS_RCC_HSI_CALIBRATION_VALUE(HSICalibrationValue));
  
  tmpreg = RCC->CR;
 8003e04:	4b03      	ldr	r3, [pc, #12]	; (8003e14 <RCC_AdjustHSICalibrationValue+0x10>)
 8003e06:	681a      	ldr	r2, [r3, #0]
  
  /* Clear HSITRIM[4:0] bits */
  tmpreg &= ~RCC_CR_HSITRIM;
 8003e08:	f022 02f8 	bic.w	r2, r2, #248	; 0xf8
  
  /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
  tmpreg |= (uint32_t)HSICalibrationValue << 3;
 8003e0c:	ea42 00c0 	orr.w	r0, r2, r0, lsl #3
  
  /* Store the new value */
  RCC->CR = tmpreg;
 8003e10:	6018      	str	r0, [r3, #0]
 8003e12:	4770      	bx	lr
 8003e14:	40021000 	.word	0x40021000

08003e18 <RCC_HSICmd>:
void RCC_HSICmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
 8003e18:	4b01      	ldr	r3, [pc, #4]	; (8003e20 <RCC_HSICmd+0x8>)
 8003e1a:	6018      	str	r0, [r3, #0]
 8003e1c:	4770      	bx	lr
 8003e1e:	bf00      	nop
 8003e20:	42420000 	.word	0x42420000

08003e24 <RCC_LSEConfig>:
  /* Check the parameters */
  assert_param(IS_RCC_LSE(RCC_LSE));

  /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
  /* Reset LSEON bit */
  RCC->BDCR &= ~(RCC_BDCR_LSEON);
 8003e24:	4b06      	ldr	r3, [pc, #24]	; (8003e40 <RCC_LSEConfig+0x1c>)
 8003e26:	6a1a      	ldr	r2, [r3, #32]
 8003e28:	f022 0201 	bic.w	r2, r2, #1
 8003e2c:	621a      	str	r2, [r3, #32]

  /* Reset LSEBYP bit */
  RCC->BDCR &= ~(RCC_BDCR_LSEBYP);
 8003e2e:	6a1a      	ldr	r2, [r3, #32]
 8003e30:	f022 0204 	bic.w	r2, r2, #4
 8003e34:	621a      	str	r2, [r3, #32]

  /* Configure LSE */
  RCC->BDCR |= RCC_LSE;
 8003e36:	6a1a      	ldr	r2, [r3, #32]
 8003e38:	4310      	orrs	r0, r2
 8003e3a:	6218      	str	r0, [r3, #32]
 8003e3c:	4770      	bx	lr
 8003e3e:	bf00      	nop
 8003e40:	40021000 	.word	0x40021000

08003e44 <RCC_LSEDriveConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_LSE_DRIVE(RCC_LSEDrive));
  
  /* Clear LSEDRV[1:0] bits */
  RCC->BDCR &= ~(RCC_BDCR_LSEDRV);
 8003e44:	4b04      	ldr	r3, [pc, #16]	; (8003e58 <RCC_LSEDriveConfig+0x14>)
 8003e46:	6a1a      	ldr	r2, [r3, #32]
 8003e48:	f022 0218 	bic.w	r2, r2, #24
 8003e4c:	621a      	str	r2, [r3, #32]

  /* Set the LSE Drive */
  RCC->BDCR |= RCC_LSEDrive;
 8003e4e:	6a1a      	ldr	r2, [r3, #32]
 8003e50:	4310      	orrs	r0, r2
 8003e52:	6218      	str	r0, [r3, #32]
 8003e54:	4770      	bx	lr
 8003e56:	bf00      	nop
 8003e58:	40021000 	.word	0x40021000

08003e5c <RCC_LSICmd>:
void RCC_LSICmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
 8003e5c:	4b01      	ldr	r3, [pc, #4]	; (8003e64 <RCC_LSICmd+0x8>)
 8003e5e:	6018      	str	r0, [r3, #0]
 8003e60:	4770      	bx	lr
 8003e62:	bf00      	nop
 8003e64:	42420480 	.word	0x42420480

08003e68 <RCC_PLLConfig>:
  /* Check the parameters */
  assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
  assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));
  
  /* Clear PLL Source [16] and Multiplier [21:18] bits */
  RCC->CFGR &= ~(RCC_CFGR_PLLMULL | RCC_CFGR_PLLSRC);
 8003e68:	4b04      	ldr	r3, [pc, #16]	; (8003e7c <RCC_PLLConfig+0x14>)
 8003e6a:	685a      	ldr	r2, [r3, #4]
 8003e6c:	f422 1274 	bic.w	r2, r2, #3997696	; 0x3d0000
 8003e70:	605a      	str	r2, [r3, #4]

  /* Set the PLL Source and Multiplier */
  RCC->CFGR |= (uint32_t)(RCC_PLLSource | RCC_PLLMul);
 8003e72:	685a      	ldr	r2, [r3, #4]
 8003e74:	4310      	orrs	r0, r2
 8003e76:	4301      	orrs	r1, r0
 8003e78:	6059      	str	r1, [r3, #4]
 8003e7a:	4770      	bx	lr
 8003e7c:	40021000 	.word	0x40021000

08003e80 <RCC_PLLCmd>:
void RCC_PLLCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
 8003e80:	4b01      	ldr	r3, [pc, #4]	; (8003e88 <RCC_PLLCmd+0x8>)
 8003e82:	6018      	str	r0, [r3, #0]
 8003e84:	4770      	bx	lr
 8003e86:	bf00      	nop
 8003e88:	42420060 	.word	0x42420060

08003e8c <RCC_PREDIV1Config>:
  uint32_t tmpreg = 0;
  
  /* Check the parameters */
  assert_param(IS_RCC_PREDIV1(RCC_PREDIV1_Div));

  tmpreg = RCC->CFGR2;
 8003e8c:	4b03      	ldr	r3, [pc, #12]	; (8003e9c <RCC_PREDIV1Config+0x10>)
 8003e8e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  /* Clear PREDIV1[3:0] bits */
  tmpreg &= ~(RCC_CFGR2_PREDIV1);
 8003e90:	f022 020f 	bic.w	r2, r2, #15

  /* Set the PREDIV1 division factor */
  tmpreg |= RCC_PREDIV1_Div;
 8003e94:	4310      	orrs	r0, r2

  /* Store the new value */
  RCC->CFGR2 = tmpreg;
 8003e96:	62d8      	str	r0, [r3, #44]	; 0x2c
 8003e98:	4770      	bx	lr
 8003e9a:	bf00      	nop
 8003e9c:	40021000 	.word	0x40021000

08003ea0 <RCC_ClockSecuritySystemCmd>:
void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
 8003ea0:	4b01      	ldr	r3, [pc, #4]	; (8003ea8 <RCC_ClockSecuritySystemCmd+0x8>)
 8003ea2:	6018      	str	r0, [r3, #0]
 8003ea4:	4770      	bx	lr
 8003ea6:	bf00      	nop
 8003ea8:	4242004c 	.word	0x4242004c

08003eac <RCC_MCOConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_MCO_SOURCE(RCC_MCOSource));
    
  /* Select MCO clock source and prescaler */
  *(__IO uint8_t *) CFGR_BYTE3_ADDRESS =  RCC_MCOSource; 
 8003eac:	4b01      	ldr	r3, [pc, #4]	; (8003eb4 <RCC_MCOConfig+0x8>)
 8003eae:	7018      	strb	r0, [r3, #0]
 8003eb0:	4770      	bx	lr
 8003eb2:	bf00      	nop
 8003eb4:	40021007 	.word	0x40021007

08003eb8 <RCC_SYSCLKConfig>:
  uint32_t tmpreg = 0;
  
  /* Check the parameters */
  assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
  
  tmpreg = RCC->CFGR;
 8003eb8:	4b03      	ldr	r3, [pc, #12]	; (8003ec8 <RCC_SYSCLKConfig+0x10>)
 8003eba:	685a      	ldr	r2, [r3, #4]
  
  /* Clear SW[1:0] bits */
  tmpreg &= ~RCC_CFGR_SW;
 8003ebc:	f022 0203 	bic.w	r2, r2, #3
  
  /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
  tmpreg |= RCC_SYSCLKSource;
 8003ec0:	4310      	orrs	r0, r2
  
  /* Store the new value */
  RCC->CFGR = tmpreg;
 8003ec2:	6058      	str	r0, [r3, #4]
 8003ec4:	4770      	bx	lr
 8003ec6:	bf00      	nop
 8003ec8:	40021000 	.word	0x40021000

08003ecc <RCC_GetSYSCLKSource>:
  *              - 0x04: HSE used as system clock  
  *              - 0x08: PLL used as system clock
  */
uint8_t RCC_GetSYSCLKSource(void)
{
  return ((uint8_t)(RCC->CFGR & RCC_CFGR_SWS));
 8003ecc:	4b02      	ldr	r3, [pc, #8]	; (8003ed8 <RCC_GetSYSCLKSource+0xc>)
 8003ece:	6858      	ldr	r0, [r3, #4]
}
 8003ed0:	f000 000c 	and.w	r0, r0, #12
 8003ed4:	4770      	bx	lr
 8003ed6:	bf00      	nop
 8003ed8:	40021000 	.word	0x40021000

08003edc <RCC_HCLKConfig>:
  uint32_t tmpreg = 0;
  
  /* Check the parameters */
  assert_param(IS_RCC_HCLK(RCC_SYSCLK));
  
  tmpreg = RCC->CFGR;
 8003edc:	4b03      	ldr	r3, [pc, #12]	; (8003eec <RCC_HCLKConfig+0x10>)
 8003ede:	685a      	ldr	r2, [r3, #4]
  
  /* Clear HPRE[3:0] bits */
  tmpreg &= ~RCC_CFGR_HPRE;
 8003ee0:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
  
  /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
  tmpreg |= RCC_SYSCLK;
 8003ee4:	4310      	orrs	r0, r2
  
  /* Store the new value */
  RCC->CFGR = tmpreg;
 8003ee6:	6058      	str	r0, [r3, #4]
 8003ee8:	4770      	bx	lr
 8003eea:	bf00      	nop
 8003eec:	40021000 	.word	0x40021000

08003ef0 <RCC_PCLK1Config>:
  uint32_t tmpreg = 0;
  
  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));
  
  tmpreg = RCC->CFGR;
 8003ef0:	4b03      	ldr	r3, [pc, #12]	; (8003f00 <RCC_PCLK1Config+0x10>)
 8003ef2:	685a      	ldr	r2, [r3, #4]
  /* Clear PPRE1[2:0] bits */
  tmpreg &= ~RCC_CFGR_PPRE1;
 8003ef4:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
  
  /* Set PPRE1[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK;
 8003ef8:	4310      	orrs	r0, r2
  
  /* Store the new value */
  RCC->CFGR = tmpreg;
 8003efa:	6058      	str	r0, [r3, #4]
 8003efc:	4770      	bx	lr
 8003efe:	bf00      	nop
 8003f00:	40021000 	.word	0x40021000

08003f04 <RCC_PCLK2Config>:
  uint32_t tmpreg = 0;
  
  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));
  
  tmpreg = RCC->CFGR;
 8003f04:	4b03      	ldr	r3, [pc, #12]	; (8003f14 <RCC_PCLK2Config+0x10>)
 8003f06:	685a      	ldr	r2, [r3, #4]
  /* Clear PPRE2[2:0] bits */
  tmpreg &= ~RCC_CFGR_PPRE2;
 8003f08:	f422 5260 	bic.w	r2, r2, #14336	; 0x3800
  /* Set PPRE2[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK << 3;
 8003f0c:	ea42 00c0 	orr.w	r0, r2, r0, lsl #3
  /* Store the new value */
  RCC->CFGR = tmpreg;
 8003f10:	6058      	str	r0, [r3, #4]
 8003f12:	4770      	bx	lr
 8003f14:	40021000 	.word	0x40021000

08003f18 <RCC_GetClocksFreq>:
{
  uint32_t tmp = 0, pllmull = 0, pllsource = 0, prediv1factor = 0, presc = 0, pllclk = 0;
  uint32_t apb2presc = 0, ahbpresc = 0;
  
  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 8003f18:	4b94      	ldr	r3, [pc, #592]	; (800416c <RCC_GetClocksFreq+0x254>)
  *           configuration based on this function will be incorrect.
  *    
  * @retval None
  */
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
 8003f1a:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  uint32_t tmp = 0, pllmull = 0, pllsource = 0, prediv1factor = 0, presc = 0, pllclk = 0;
  uint32_t apb2presc = 0, ahbpresc = 0;
  
  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 8003f1e:	685a      	ldr	r2, [r3, #4]
 8003f20:	f002 020c 	and.w	r2, r2, #12
  
  switch (tmp)
 8003f24:	2a04      	cmp	r2, #4
 8003f26:	d005      	beq.n	8003f34 <RCC_GetClocksFreq+0x1c>
 8003f28:	2a08      	cmp	r2, #8
 8003f2a:	d006      	beq.n	8003f3a <RCC_GetClocksFreq+0x22>
 8003f2c:	4b90      	ldr	r3, [pc, #576]	; (8004170 <RCC_GetClocksFreq+0x258>)
  {
    case 0x00:  /* HSI used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
 8003f2e:	6003      	str	r3, [r0, #0]
  uint32_t apb2presc = 0, ahbpresc = 0;
  
  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
  
  switch (tmp)
 8003f30:	b9b2      	cbnz	r2, 8003f60 <RCC_GetClocksFreq+0x48>
  {
    case 0x00:  /* HSI used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
      break;
 8003f32:	e016      	b.n	8003f62 <RCC_GetClocksFreq+0x4a>
    case 0x04:  /* HSE used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
 8003f34:	4b8e      	ldr	r3, [pc, #568]	; (8004170 <RCC_GetClocksFreq+0x258>)
 8003f36:	6003      	str	r3, [r0, #0]
 8003f38:	e012      	b.n	8003f60 <RCC_GetClocksFreq+0x48>
      break;
    case 0x08:  /* PLL used as system clock */
      /* Get PLL clock source and multiplication factor ----------------------*/
      pllmull = RCC->CFGR & RCC_CFGR_PLLMULL;
 8003f3a:	6859      	ldr	r1, [r3, #4]
      pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
 8003f3c:	685c      	ldr	r4, [r3, #4]
      pllmull = ( pllmull >> 18) + 2;
 8003f3e:	f3c1 4183 	ubfx	r1, r1, #18, #4
 8003f42:	3102      	adds	r1, #2
      
      if (pllsource == 0x00)
 8003f44:	03e6      	lsls	r6, r4, #15
 8003f46:	d401      	bmi.n	8003f4c <RCC_GetClocksFreq+0x34>
      {
        /* HSI oscillator clock divided by 2 selected as PLL clock entry */
        pllclk = (HSI_VALUE >> 1) * pllmull;
 8003f48:	4a8a      	ldr	r2, [pc, #552]	; (8004174 <RCC_GetClocksFreq+0x25c>)
 8003f4a:	e006      	b.n	8003f5a <RCC_GetClocksFreq+0x42>
      }
      else
      {
        prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
 8003f4c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
        /* HSE oscillator clock selected as PREDIV1 clock entry */
        pllclk = (HSE_VALUE / prediv1factor) * pllmull; 
 8003f4e:	4b88      	ldr	r3, [pc, #544]	; (8004170 <RCC_GetClocksFreq+0x258>)
        /* HSI oscillator clock divided by 2 selected as PLL clock entry */
        pllclk = (HSI_VALUE >> 1) * pllmull;
      }
      else
      {
        prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
 8003f50:	f002 020f 	and.w	r2, r2, #15
 8003f54:	3201      	adds	r2, #1
        /* HSE oscillator clock selected as PREDIV1 clock entry */
        pllclk = (HSE_VALUE / prediv1factor) * pllmull; 
 8003f56:	fbb3 f2f2 	udiv	r2, r3, r2
 8003f5a:	434a      	muls	r2, r1
      }
      RCC_Clocks->SYSCLK_Frequency = pllclk;      
 8003f5c:	6002      	str	r2, [r0, #0]
      break;
 8003f5e:	e000      	b.n	8003f62 <RCC_GetClocksFreq+0x4a>
  *    
  * @retval None
  */
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
  uint32_t tmp = 0, pllmull = 0, pllsource = 0, prediv1factor = 0, presc = 0, pllclk = 0;
 8003f60:	2200      	movs	r2, #0
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
      break;
  }
    /* Compute HCLK, PCLK clocks frequencies -----------------------------------*/
  /* Get HCLK prescaler */
  tmp = RCC->CFGR & RCC_CFGR_HPRE;
 8003f62:	4d82      	ldr	r5, [pc, #520]	; (800416c <RCC_GetClocksFreq+0x254>)
  tmp = tmp >> 4;
  ahbpresc = APBAHBPrescTable[tmp]; 
 8003f64:	4c84      	ldr	r4, [pc, #528]	; (8004178 <RCC_GetClocksFreq+0x260>)
      RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
      break;
  }
    /* Compute HCLK, PCLK clocks frequencies -----------------------------------*/
  /* Get HCLK prescaler */
  tmp = RCC->CFGR & RCC_CFGR_HPRE;
 8003f66:	686b      	ldr	r3, [r5, #4]
  tmp = tmp >> 4;
 8003f68:	f3c3 1303 	ubfx	r3, r3, #4, #4
  ahbpresc = APBAHBPrescTable[tmp]; 
 8003f6c:	5ce7      	ldrb	r7, [r4, r3]
  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> ahbpresc;
 8003f6e:	6803      	ldr	r3, [r0, #0]
 8003f70:	fa23 f607 	lsr.w	r6, r3, r7
 8003f74:	6046      	str	r6, [r0, #4]

  /* Get PCLK1 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE1;
 8003f76:	6869      	ldr	r1, [r5, #4]
  tmp = tmp >> 8;
 8003f78:	f3c1 2102 	ubfx	r1, r1, #8, #3
  presc = APBAHBPrescTable[tmp];
 8003f7c:	5c61      	ldrb	r1, [r4, r1]
  /* PCLK1 clock frequency */
  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 8003f7e:	fa26 f101 	lsr.w	r1, r6, r1
 8003f82:	6081      	str	r1, [r0, #8]
  
  /* Get PCLK2 prescaler */
  tmp = RCC->CFGR & RCC_CFGR_PPRE2;
 8003f84:	f8d5 c004 	ldr.w	ip, [r5, #4]
  tmp = tmp >> 11;
 8003f88:	f3cc 2cc2 	ubfx	ip, ip, #11, #3
  apb2presc = APBAHBPrescTable[tmp];
 8003f8c:	f814 c00c 	ldrb.w	ip, [r4, ip]
  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> apb2presc;
 8003f90:	fa26 f60c 	lsr.w	r6, r6, ip
 8003f94:	60c6      	str	r6, [r0, #12]
  
  /* Get ADC12CLK prescaler */
  tmp = RCC->CFGR2 & RCC_CFGR2_ADCPRE12;
 8003f96:	f8d5 802c 	ldr.w	r8, [r5, #44]	; 0x2c
  tmp = tmp >> 4;
 8003f9a:	f3c8 1804 	ubfx	r8, r8, #4, #5
  presc = ADCPrescTable[tmp];
 8003f9e:	eb04 0848 	add.w	r8, r4, r8, lsl #1
 8003fa2:	f8b8 8010 	ldrh.w	r8, [r8, #16]
 8003fa6:	fa1f f888 	uxth.w	r8, r8
  if ((presc & 0x10) != 0)
 8003faa:	f008 0910 	and.w	r9, r8, #16
 8003fae:	fa1f f989 	uxth.w	r9, r9
 8003fb2:	f1b9 0f00 	cmp.w	r9, #0
 8003fb6:	d004      	beq.n	8003fc2 <RCC_GetClocksFreq+0xaa>
  {
     /* ADC12CLK clock frequency is derived from PLL clock */
     RCC_Clocks->ADC12CLK_Frequency = pllclk / presc;
 8003fb8:	fbb2 f8f8 	udiv	r8, r2, r8
 8003fbc:	f8c0 8010 	str.w	r8, [r0, #16]
 8003fc0:	e000      	b.n	8003fc4 <RCC_GetClocksFreq+0xac>
  }
  else
  {
   /* ADC12CLK clock frequency is AHB clock */
     RCC_Clocks->ADC12CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 8003fc2:	6103      	str	r3, [r0, #16]
  }
  
  /* Get ADC34CLK prescaler */
  tmp = RCC->CFGR2 & RCC_CFGR2_ADCPRE34;
 8003fc4:	6aed      	ldr	r5, [r5, #44]	; 0x2c
  tmp = tmp >> 9;
 8003fc6:	f3c5 2544 	ubfx	r5, r5, #9, #5
  presc = ADCPrescTable[tmp];
 8003fca:	eb04 0445 	add.w	r4, r4, r5, lsl #1
 8003fce:	8a24      	ldrh	r4, [r4, #16]
 8003fd0:	b2a4      	uxth	r4, r4
  if ((presc & 0x10) != 0)
 8003fd2:	f004 0510 	and.w	r5, r4, #16
 8003fd6:	b2ad      	uxth	r5, r5
 8003fd8:	b11d      	cbz	r5, 8003fe2 <RCC_GetClocksFreq+0xca>
  {
     /* ADC34CLK clock frequency is derived from PLL clock */
     RCC_Clocks->ADC34CLK_Frequency = pllclk / presc;
 8003fda:	fbb2 f4f4 	udiv	r4, r2, r4
 8003fde:	6144      	str	r4, [r0, #20]
 8003fe0:	e000      	b.n	8003fe4 <RCC_GetClocksFreq+0xcc>
  }
  else
  {
   /* ADC34CLK clock frequency is AHB clock */
     RCC_Clocks->ADC34CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 8003fe2:	6143      	str	r3, [r0, #20]
  }

  /* I2C1CLK clock frequency */
  if((RCC->CFGR3 & RCC_CFGR3_I2C1SW) != RCC_CFGR3_I2C1SW)
 8003fe4:	4c61      	ldr	r4, [pc, #388]	; (800416c <RCC_GetClocksFreq+0x254>)
 8003fe6:	6b25      	ldr	r5, [r4, #48]	; 0x30
 8003fe8:	06ed      	lsls	r5, r5, #27
  {
    /* I2C1 Clock is HSI Osc. */
    RCC_Clocks->I2C1CLK_Frequency = HSI_VALUE;
 8003fea:	bf56      	itet	pl
 8003fec:	4d60      	ldrpl	r5, [pc, #384]	; (8004170 <RCC_GetClocksFreq+0x258>)
  }
  else
  {
    /* I2C1 Clock is System Clock */
    RCC_Clocks->I2C1CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 8003fee:	6183      	strmi	r3, [r0, #24]

  /* I2C1CLK clock frequency */
  if((RCC->CFGR3 & RCC_CFGR3_I2C1SW) != RCC_CFGR3_I2C1SW)
  {
    /* I2C1 Clock is HSI Osc. */
    RCC_Clocks->I2C1CLK_Frequency = HSI_VALUE;
 8003ff0:	6185      	strpl	r5, [r0, #24]
    /* I2C1 Clock is System Clock */
    RCC_Clocks->I2C1CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
  }

  /* I2C2CLK clock frequency */
  if((RCC->CFGR3 & RCC_CFGR3_I2C2SW) != RCC_CFGR3_I2C2SW)
 8003ff2:	6b24      	ldr	r4, [r4, #48]	; 0x30
 8003ff4:	06a4      	lsls	r4, r4, #26
  {
    /* I2C2 Clock is HSI Osc. */
    RCC_Clocks->I2C2CLK_Frequency = HSI_VALUE;
 8003ff6:	bf56      	itet	pl
 8003ff8:	4c5d      	ldrpl	r4, [pc, #372]	; (8004170 <RCC_GetClocksFreq+0x258>)
  }
  else
  {
    /* I2C2 Clock is System Clock */
    RCC_Clocks->I2C2CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 8003ffa:	61c3      	strmi	r3, [r0, #28]

  /* I2C2CLK clock frequency */
  if((RCC->CFGR3 & RCC_CFGR3_I2C2SW) != RCC_CFGR3_I2C2SW)
  {
    /* I2C2 Clock is HSI Osc. */
    RCC_Clocks->I2C2CLK_Frequency = HSI_VALUE;
 8003ffc:	61c4      	strpl	r4, [r0, #28]
    /* I2C2 Clock is System Clock */
    RCC_Clocks->I2C2CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
  }
  
    /* TIM1CLK clock frequency */
  if(((RCC->CFGR3 & RCC_CFGR3_TIM1SW) == RCC_CFGR3_TIM1SW)&& (RCC_Clocks->SYSCLK_Frequency == pllclk) \
 8003ffe:	4c5b      	ldr	r4, [pc, #364]	; (800416c <RCC_GetClocksFreq+0x254>)
 8004000:	6b25      	ldr	r5, [r4, #48]	; 0x30
 8004002:	f415 7f80 	tst.w	r5, #256	; 0x100
 8004006:	d006      	beq.n	8004016 <RCC_GetClocksFreq+0xfe>
 8004008:	4293      	cmp	r3, r2
 800400a:	d104      	bne.n	8004016 <RCC_GetClocksFreq+0xfe>
  && (apb2presc == ahbpresc)) 
 800400c:	45bc      	cmp	ip, r7
 800400e:	d102      	bne.n	8004016 <RCC_GetClocksFreq+0xfe>
  {
    /* TIM1 Clock is 2 * pllclk */
    RCC_Clocks->TIM1CLK_Frequency = pllclk * 2;
 8004010:	005d      	lsls	r5, r3, #1
 8004012:	6205      	str	r5, [r0, #32]
 8004014:	e000      	b.n	8004018 <RCC_GetClocksFreq+0x100>
  }
  else
  {
    /* TIM1 Clock is APB2 clock. */
    RCC_Clocks->TIM1CLK_Frequency = RCC_Clocks->PCLK2_Frequency;
 8004016:	6206      	str	r6, [r0, #32]
  }

    /* TIM8CLK clock frequency */
  if(((RCC->CFGR3 & RCC_CFGR3_TIM8SW) == RCC_CFGR3_TIM8SW)&& (RCC_Clocks->SYSCLK_Frequency == pllclk) \
 8004018:	6b24      	ldr	r4, [r4, #48]	; 0x30
 800401a:	05a4      	lsls	r4, r4, #22
 800401c:	d506      	bpl.n	800402c <RCC_GetClocksFreq+0x114>
 800401e:	4293      	cmp	r3, r2
 8004020:	d104      	bne.n	800402c <RCC_GetClocksFreq+0x114>
  && (apb2presc == ahbpresc))
 8004022:	45bc      	cmp	ip, r7
 8004024:	d102      	bne.n	800402c <RCC_GetClocksFreq+0x114>
  {
    /* TIM8 Clock is 2 * pllclk */
    RCC_Clocks->TIM8CLK_Frequency = pllclk * 2;
 8004026:	005a      	lsls	r2, r3, #1
 8004028:	6242      	str	r2, [r0, #36]	; 0x24
 800402a:	e000      	b.n	800402e <RCC_GetClocksFreq+0x116>
  }
  else
  {
    /* TIM8 Clock is APB2 clock. */
    RCC_Clocks->TIM8CLK_Frequency = RCC_Clocks->PCLK2_Frequency;
 800402c:	6246      	str	r6, [r0, #36]	; 0x24
  }
  
  /* USART1CLK clock frequency */
  if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == 0x0)
 800402e:	4a4f      	ldr	r2, [pc, #316]	; (800416c <RCC_GetClocksFreq+0x254>)
 8004030:	6b14      	ldr	r4, [r2, #48]	; 0x30
 8004032:	07a4      	lsls	r4, r4, #30
 8004034:	d101      	bne.n	800403a <RCC_GetClocksFreq+0x122>
  {
    /* USART Clock is PCLK */
    RCC_Clocks->USART1CLK_Frequency = RCC_Clocks->PCLK2_Frequency;
 8004036:	6286      	str	r6, [r0, #40]	; 0x28
 8004038:	e015      	b.n	8004066 <RCC_GetClocksFreq+0x14e>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == RCC_CFGR3_USART1SW_0)
 800403a:	6b14      	ldr	r4, [r2, #48]	; 0x30
 800403c:	f004 0403 	and.w	r4, r4, #3
 8004040:	2c01      	cmp	r4, #1
 8004042:	d101      	bne.n	8004048 <RCC_GetClocksFreq+0x130>
  {
    /* USART Clock is System Clock */
    RCC_Clocks->USART1CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 8004044:	6283      	str	r3, [r0, #40]	; 0x28
 8004046:	e00e      	b.n	8004066 <RCC_GetClocksFreq+0x14e>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == RCC_CFGR3_USART1SW_1)
 8004048:	6b14      	ldr	r4, [r2, #48]	; 0x30
 800404a:	f004 0403 	and.w	r4, r4, #3
 800404e:	2c02      	cmp	r4, #2
 8004050:	d102      	bne.n	8004058 <RCC_GetClocksFreq+0x140>
  {
    /* USART Clock is LSE Osc. */
    RCC_Clocks->USART1CLK_Frequency = LSE_VALUE;
 8004052:	f44f 4400 	mov.w	r4, #32768	; 0x8000
 8004056:	e005      	b.n	8004064 <RCC_GetClocksFreq+0x14c>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART1SW) == RCC_CFGR3_USART1SW)
 8004058:	6b14      	ldr	r4, [r2, #48]	; 0x30
 800405a:	f004 0403 	and.w	r4, r4, #3
 800405e:	2c03      	cmp	r4, #3
 8004060:	d101      	bne.n	8004066 <RCC_GetClocksFreq+0x14e>
  {
    /* USART Clock is HSI Osc. */
    RCC_Clocks->USART1CLK_Frequency = HSI_VALUE;
 8004062:	4c43      	ldr	r4, [pc, #268]	; (8004170 <RCC_GetClocksFreq+0x258>)
 8004064:	6284      	str	r4, [r0, #40]	; 0x28
  }

  /* USART2CLK clock frequency */
  if((RCC->CFGR3 & RCC_CFGR3_USART2SW) == 0x0)
 8004066:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8004068:	4c40      	ldr	r4, [pc, #256]	; (800416c <RCC_GetClocksFreq+0x254>)
 800406a:	f412 3f40 	tst.w	r2, #196608	; 0x30000
 800406e:	d101      	bne.n	8004074 <RCC_GetClocksFreq+0x15c>
  {
    /* USART Clock is PCLK */
    RCC_Clocks->USART2CLK_Frequency = RCC_Clocks->PCLK1_Frequency;
 8004070:	62c1      	str	r1, [r0, #44]	; 0x2c
 8004072:	e018      	b.n	80040a6 <RCC_GetClocksFreq+0x18e>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART2SW) == RCC_CFGR3_USART2SW_0)
 8004074:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8004076:	f402 3240 	and.w	r2, r2, #196608	; 0x30000
 800407a:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 800407e:	d101      	bne.n	8004084 <RCC_GetClocksFreq+0x16c>
  {
    /* USART Clock is System Clock */
    RCC_Clocks->USART2CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 8004080:	62c3      	str	r3, [r0, #44]	; 0x2c
 8004082:	e010      	b.n	80040a6 <RCC_GetClocksFreq+0x18e>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART2SW) == RCC_CFGR3_USART2SW_1)
 8004084:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8004086:	f402 3240 	and.w	r2, r2, #196608	; 0x30000
 800408a:	f5b2 3f00 	cmp.w	r2, #131072	; 0x20000
 800408e:	d102      	bne.n	8004096 <RCC_GetClocksFreq+0x17e>
  {
    /* USART Clock is LSE Osc. */
    RCC_Clocks->USART2CLK_Frequency = LSE_VALUE;
 8004090:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 8004094:	e006      	b.n	80040a4 <RCC_GetClocksFreq+0x18c>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART2SW) == RCC_CFGR3_USART2SW)
 8004096:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8004098:	f402 3240 	and.w	r2, r2, #196608	; 0x30000
 800409c:	f5b2 3f40 	cmp.w	r2, #196608	; 0x30000
 80040a0:	d101      	bne.n	80040a6 <RCC_GetClocksFreq+0x18e>
  {
    /* USART Clock is HSI Osc. */
    RCC_Clocks->USART2CLK_Frequency = HSI_VALUE;
 80040a2:	4a33      	ldr	r2, [pc, #204]	; (8004170 <RCC_GetClocksFreq+0x258>)
 80040a4:	62c2      	str	r2, [r0, #44]	; 0x2c
  }    

  /* USART3CLK clock frequency */
  if((RCC->CFGR3 & RCC_CFGR3_USART3SW) == 0x0)
 80040a6:	4a31      	ldr	r2, [pc, #196]	; (800416c <RCC_GetClocksFreq+0x254>)
 80040a8:	6b14      	ldr	r4, [r2, #48]	; 0x30
 80040aa:	f414 2f40 	tst.w	r4, #786432	; 0xc0000
 80040ae:	d101      	bne.n	80040b4 <RCC_GetClocksFreq+0x19c>
  {
    /* USART Clock is PCLK */
    RCC_Clocks->USART3CLK_Frequency = RCC_Clocks->PCLK1_Frequency;
 80040b0:	6301      	str	r1, [r0, #48]	; 0x30
 80040b2:	e018      	b.n	80040e6 <RCC_GetClocksFreq+0x1ce>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART3SW) == RCC_CFGR3_USART3SW_0)
 80040b4:	6b14      	ldr	r4, [r2, #48]	; 0x30
 80040b6:	f404 2440 	and.w	r4, r4, #786432	; 0xc0000
 80040ba:	f5b4 2f80 	cmp.w	r4, #262144	; 0x40000
 80040be:	d101      	bne.n	80040c4 <RCC_GetClocksFreq+0x1ac>
  {
    /* USART Clock is System Clock */
    RCC_Clocks->USART3CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 80040c0:	6303      	str	r3, [r0, #48]	; 0x30
 80040c2:	e010      	b.n	80040e6 <RCC_GetClocksFreq+0x1ce>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART3SW) == RCC_CFGR3_USART3SW_1)
 80040c4:	6b14      	ldr	r4, [r2, #48]	; 0x30
 80040c6:	f404 2440 	and.w	r4, r4, #786432	; 0xc0000
 80040ca:	f5b4 2f00 	cmp.w	r4, #524288	; 0x80000
 80040ce:	d102      	bne.n	80040d6 <RCC_GetClocksFreq+0x1be>
  {
    /* USART Clock is LSE Osc. */
    RCC_Clocks->USART3CLK_Frequency = LSE_VALUE;
 80040d0:	f44f 4400 	mov.w	r4, #32768	; 0x8000
 80040d4:	e006      	b.n	80040e4 <RCC_GetClocksFreq+0x1cc>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_USART3SW) == RCC_CFGR3_USART3SW)
 80040d6:	6b14      	ldr	r4, [r2, #48]	; 0x30
 80040d8:	f404 2440 	and.w	r4, r4, #786432	; 0xc0000
 80040dc:	f5b4 2f40 	cmp.w	r4, #786432	; 0xc0000
 80040e0:	d101      	bne.n	80040e6 <RCC_GetClocksFreq+0x1ce>
  {
    /* USART Clock is HSI Osc. */
    RCC_Clocks->USART3CLK_Frequency = HSI_VALUE;
 80040e2:	4c23      	ldr	r4, [pc, #140]	; (8004170 <RCC_GetClocksFreq+0x258>)
 80040e4:	6304      	str	r4, [r0, #48]	; 0x30
  }
  
    /* UART4CLK clock frequency */
  if((RCC->CFGR3 & RCC_CFGR3_UART4SW) == 0x0)
 80040e6:	6b12      	ldr	r2, [r2, #48]	; 0x30
 80040e8:	4c20      	ldr	r4, [pc, #128]	; (800416c <RCC_GetClocksFreq+0x254>)
 80040ea:	f412 1f40 	tst.w	r2, #3145728	; 0x300000
 80040ee:	d101      	bne.n	80040f4 <RCC_GetClocksFreq+0x1dc>
  {
    /* USART Clock is PCLK */
    RCC_Clocks->UART4CLK_Frequency = RCC_Clocks->PCLK1_Frequency;
 80040f0:	6341      	str	r1, [r0, #52]	; 0x34
 80040f2:	e018      	b.n	8004126 <RCC_GetClocksFreq+0x20e>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_UART4SW) == RCC_CFGR3_UART4SW_0)
 80040f4:	6b22      	ldr	r2, [r4, #48]	; 0x30
 80040f6:	f402 1240 	and.w	r2, r2, #3145728	; 0x300000
 80040fa:	f5b2 1f80 	cmp.w	r2, #1048576	; 0x100000
 80040fe:	d101      	bne.n	8004104 <RCC_GetClocksFreq+0x1ec>
  {
    /* USART Clock is System Clock */
    RCC_Clocks->UART4CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
 8004100:	6343      	str	r3, [r0, #52]	; 0x34
 8004102:	e010      	b.n	8004126 <RCC_GetClocksFreq+0x20e>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_UART4SW) == RCC_CFGR3_UART4SW_1)
 8004104:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8004106:	f402 1240 	and.w	r2, r2, #3145728	; 0x300000
 800410a:	f5b2 1f00 	cmp.w	r2, #2097152	; 0x200000
 800410e:	d102      	bne.n	8004116 <RCC_GetClocksFreq+0x1fe>
  {
    /* USART Clock is LSE Osc. */
    RCC_Clocks->UART4CLK_Frequency = LSE_VALUE;
 8004110:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 8004114:	e006      	b.n	8004124 <RCC_GetClocksFreq+0x20c>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_UART4SW) == RCC_CFGR3_UART4SW)
 8004116:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8004118:	f402 1240 	and.w	r2, r2, #3145728	; 0x300000
 800411c:	f5b2 1f40 	cmp.w	r2, #3145728	; 0x300000
 8004120:	d101      	bne.n	8004126 <RCC_GetClocksFreq+0x20e>
  {
    /* USART Clock is HSI Osc. */
    RCC_Clocks->UART4CLK_Frequency = HSI_VALUE;
 8004122:	4a13      	ldr	r2, [pc, #76]	; (8004170 <RCC_GetClocksFreq+0x258>)
 8004124:	6342      	str	r2, [r0, #52]	; 0x34
  }   
  
  /* UART5CLK clock frequency */
  if((RCC->CFGR3 & RCC_CFGR3_UART5SW) == 0x0)
 8004126:	4a11      	ldr	r2, [pc, #68]	; (800416c <RCC_GetClocksFreq+0x254>)
 8004128:	6b14      	ldr	r4, [r2, #48]	; 0x30
 800412a:	f414 0f40 	tst.w	r4, #12582912	; 0xc00000
 800412e:	d102      	bne.n	8004136 <RCC_GetClocksFreq+0x21e>
  {
    /* USART Clock is PCLK */
    RCC_Clocks->UART5CLK_Frequency = RCC_Clocks->PCLK1_Frequency;
 8004130:	6381      	str	r1, [r0, #56]	; 0x38
 8004132:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  }
  else if((RCC->CFGR3 & RCC_CFGR3_UART5SW) == RCC_CFGR3_UART5SW_0)
 8004136:	6b11      	ldr	r1, [r2, #48]	; 0x30
 8004138:	f401 0140 	and.w	r1, r1, #12582912	; 0xc00000
 800413c:	f5b1 0f80 	cmp.w	r1, #4194304	; 0x400000
 8004140:	d100      	bne.n	8004144 <RCC_GetClocksFreq+0x22c>
 8004142:	e00f      	b.n	8004164 <RCC_GetClocksFreq+0x24c>
  {
    /* USART Clock is System Clock */
    RCC_Clocks->UART5CLK_Frequency = RCC_Clocks->SYSCLK_Frequency;
  }
  else if((RCC->CFGR3 & RCC_CFGR3_UART5SW) == RCC_CFGR3_UART5SW_1)
 8004144:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8004146:	f403 0340 	and.w	r3, r3, #12582912	; 0xc00000
 800414a:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 800414e:	d102      	bne.n	8004156 <RCC_GetClocksFreq+0x23e>
  {
    /* USART Clock is LSE Osc. */
    RCC_Clocks->UART5CLK_Frequency = LSE_VALUE;
 8004150:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8004154:	e006      	b.n	8004164 <RCC_GetClocksFreq+0x24c>
  }
  else if((RCC->CFGR3 & RCC_CFGR3_UART5SW) == RCC_CFGR3_UART5SW)
 8004156:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8004158:	f403 0340 	and.w	r3, r3, #12582912	; 0xc00000
 800415c:	f5b3 0f40 	cmp.w	r3, #12582912	; 0xc00000
 8004160:	d101      	bne.n	8004166 <RCC_GetClocksFreq+0x24e>
  {
    /* USART Clock is HSI Osc. */
    RCC_Clocks->UART5CLK_Frequency = HSI_VALUE;
 8004162:	4b03      	ldr	r3, [pc, #12]	; (8004170 <RCC_GetClocksFreq+0x258>)
 8004164:	6383      	str	r3, [r0, #56]	; 0x38
 8004166:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800416a:	bf00      	nop
 800416c:	40021000 	.word	0x40021000
 8004170:	007a1200 	.word	0x007a1200
 8004174:	003d0900 	.word	0x003d0900
 8004178:	20000000 	.word	0x20000000

0800417c <RCC_ADCCLKConfig>:
  assert_param(IS_RCC_ADCCLK(RCC_PLLCLK));

  tmp = (RCC_PLLCLK >> 28);
  
  /* Clears ADCPRE34 bits */
  if (tmp != 0)
 800417c:	0f03      	lsrs	r3, r0, #28
 800417e:	4b06      	ldr	r3, [pc, #24]	; (8004198 <RCC_ADCCLKConfig+0x1c>)
  {
    RCC->CFGR2 &= ~RCC_CFGR2_ADCPRE34;
 8004180:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8004182:	bf14      	ite	ne
 8004184:	f422 5278 	bicne.w	r2, r2, #15872	; 0x3e00
  }
   /* Clears ADCPRE12 bits */
  else
  {
    RCC->CFGR2 &= ~RCC_CFGR2_ADCPRE12;
 8004188:	f422 72f8 	biceq.w	r2, r2, #496	; 0x1f0
 800418c:	62da      	str	r2, [r3, #44]	; 0x2c
  }
  /* Set ADCPRE bits according to RCC_PLLCLK value */
  RCC->CFGR2 |= RCC_PLLCLK;
 800418e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8004190:	4310      	orrs	r0, r2
 8004192:	62d8      	str	r0, [r3, #44]	; 0x2c
 8004194:	4770      	bx	lr
 8004196:	bf00      	nop
 8004198:	40021000 	.word	0x40021000

0800419c <RCC_I2CCLKConfig>:
  assert_param(IS_RCC_I2CCLK(RCC_I2CCLK));

  tmp = (RCC_I2CCLK >> 28);
  
  /* Clear I2CSW bit */
  if (tmp != 0)
 800419c:	0f03      	lsrs	r3, r0, #28
 800419e:	4b06      	ldr	r3, [pc, #24]	; (80041b8 <RCC_I2CCLKConfig+0x1c>)
  {
    RCC->CFGR3 &= ~RCC_CFGR3_I2C2SW;
 80041a0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80041a2:	bf14      	ite	ne
 80041a4:	f022 0220 	bicne.w	r2, r2, #32
  }
  else
  {
    RCC->CFGR3 &= ~RCC_CFGR3_I2C1SW;
 80041a8:	f022 0210 	biceq.w	r2, r2, #16
 80041ac:	631a      	str	r2, [r3, #48]	; 0x30
  }
  /* Set I2CSW bits according to RCC_I2CCLK value */
  RCC->CFGR3 |= RCC_I2CCLK;
 80041ae:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80041b0:	4310      	orrs	r0, r2
 80041b2:	6318      	str	r0, [r3, #48]	; 0x30
 80041b4:	4770      	bx	lr
 80041b6:	bf00      	nop
 80041b8:	40021000 	.word	0x40021000

080041bc <RCC_TIMCLKConfig>:
  assert_param(IS_RCC_TIMCLK(RCC_TIMCLK));

  tmp = (RCC_TIMCLK >> 28);
  
  /* Clear I2CSW bit */
  if (tmp != 0)
 80041bc:	0f03      	lsrs	r3, r0, #28
 80041be:	4b06      	ldr	r3, [pc, #24]	; (80041d8 <RCC_TIMCLKConfig+0x1c>)
  {
    RCC->CFGR3 &= ~RCC_CFGR3_TIM8SW;
 80041c0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80041c2:	bf14      	ite	ne
 80041c4:	f422 7200 	bicne.w	r2, r2, #512	; 0x200
  }
  else
  {
    RCC->CFGR3 &= ~RCC_CFGR3_TIM1SW;
 80041c8:	f422 7280 	biceq.w	r2, r2, #256	; 0x100
 80041cc:	631a      	str	r2, [r3, #48]	; 0x30
  }
  /* Set I2CSW bits according to RCC_TIMCLK value */
  RCC->CFGR3 |= RCC_TIMCLK;
 80041ce:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80041d0:	4310      	orrs	r0, r2
 80041d2:	6318      	str	r0, [r3, #48]	; 0x30
 80041d4:	4770      	bx	lr
 80041d6:	bf00      	nop
 80041d8:	40021000 	.word	0x40021000

080041dc <RCC_USARTCLKConfig>:
  uint32_t tmp = 0;
  
  /* Check the parameters */
  assert_param(IS_RCC_USARTCLK(RCC_USARTCLK));

  tmp = (RCC_USARTCLK >> 28);
 80041dc:	0f02      	lsrs	r2, r0, #28

  /* Clear USARTSW[1:0] bit */
  switch (tmp)
 80041de:	3a01      	subs	r2, #1
 80041e0:	4b0f      	ldr	r3, [pc, #60]	; (8004220 <RCC_USARTCLKConfig+0x44>)
 80041e2:	2a04      	cmp	r2, #4
 80041e4:	d818      	bhi.n	8004218 <RCC_USARTCLKConfig+0x3c>
 80041e6:	e8df f002 	tbb	[pc, r2]
 80041ea:	0703      	.short	0x0703
 80041ec:	0f0b      	.short	0x0f0b
 80041ee:	13          	.byte	0x13
 80041ef:	00          	.byte	0x00
  {
    case 0x01:  /* clear USART1SW */
      RCC->CFGR3 &= ~RCC_CFGR3_USART1SW;
 80041f0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80041f2:	f022 0203 	bic.w	r2, r2, #3
 80041f6:	e00e      	b.n	8004216 <RCC_USARTCLKConfig+0x3a>
      break;
    case 0x02:  /* clear USART2SW */
      RCC->CFGR3 &= ~RCC_CFGR3_USART2SW;
 80041f8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80041fa:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
 80041fe:	e00a      	b.n	8004216 <RCC_USARTCLKConfig+0x3a>
      break;
    case 0x03:  /* clear USART3SW */
      RCC->CFGR3 &= ~RCC_CFGR3_USART3SW;
 8004200:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8004202:	f422 2240 	bic.w	r2, r2, #786432	; 0xc0000
 8004206:	e006      	b.n	8004216 <RCC_USARTCLKConfig+0x3a>
      break;
    case 0x04:  /* clear UART4SW */
      RCC->CFGR3 &= ~RCC_CFGR3_UART4SW;
 8004208:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800420a:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
 800420e:	e002      	b.n	8004216 <RCC_USARTCLKConfig+0x3a>
      break;
    case 0x05:  /* clear UART5SW */
      RCC->CFGR3 &= ~RCC_CFGR3_UART5SW;
 8004210:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8004212:	f422 0240 	bic.w	r2, r2, #12582912	; 0xc00000
 8004216:	631a      	str	r2, [r3, #48]	; 0x30
    default:
      break;
  }

  /* Set USARTSW bits according to RCC_USARTCLK value */
  RCC->CFGR3 |= RCC_USARTCLK;
 8004218:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800421a:	4310      	orrs	r0, r2
 800421c:	6318      	str	r0, [r3, #48]	; 0x30
 800421e:	4770      	bx	lr
 8004220:	40021000 	.word	0x40021000

08004224 <RCC_USBCLKConfig>:
void RCC_USBCLKConfig(uint32_t RCC_USBCLKSource)
{
  /* Check the parameters */
  assert_param(IS_RCC_USBCLK_SOURCE(RCC_USBCLKSource));

  *(__IO uint32_t *) CFGR_USBPRE_BB = RCC_USBCLKSource;
 8004224:	4b01      	ldr	r3, [pc, #4]	; (800422c <RCC_USBCLKConfig+0x8>)
 8004226:	6018      	str	r0, [r3, #0]
 8004228:	4770      	bx	lr
 800422a:	bf00      	nop
 800422c:	424200d8 	.word	0x424200d8

08004230 <RCC_RTCCLKConfig>:
{
  /* Check the parameters */
  assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
  
  /* Select the RTC clock source */
  RCC->BDCR |= RCC_RTCCLKSource;
 8004230:	4b02      	ldr	r3, [pc, #8]	; (800423c <RCC_RTCCLKConfig+0xc>)
 8004232:	6a1a      	ldr	r2, [r3, #32]
 8004234:	4310      	orrs	r0, r2
 8004236:	6218      	str	r0, [r3, #32]
 8004238:	4770      	bx	lr
 800423a:	bf00      	nop
 800423c:	40021000 	.word	0x40021000

08004240 <RCC_I2SCLKConfig>:
void RCC_I2SCLKConfig(uint32_t RCC_I2SCLKSource)
{
  /* Check the parameters */
  assert_param(IS_RCC_I2SCLK_SOURCE(RCC_I2SCLKSource));

  *(__IO uint32_t *) CFGR_I2SSRC_BB = RCC_I2SCLKSource;
 8004240:	4b01      	ldr	r3, [pc, #4]	; (8004248 <RCC_I2SCLKConfig+0x8>)
 8004242:	6018      	str	r0, [r3, #0]
 8004244:	4770      	bx	lr
 8004246:	bf00      	nop
 8004248:	424200dc 	.word	0x424200dc

0800424c <RCC_RTCCLKCmd>:
void RCC_RTCCLKCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
 800424c:	4b01      	ldr	r3, [pc, #4]	; (8004254 <RCC_RTCCLKCmd+0x8>)
 800424e:	6018      	str	r0, [r3, #0]
 8004250:	4770      	bx	lr
 8004252:	bf00      	nop
 8004254:	4242043c 	.word	0x4242043c

08004258 <RCC_BackupResetCmd>:
void RCC_BackupResetCmd(FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
 8004258:	4b01      	ldr	r3, [pc, #4]	; (8004260 <RCC_BackupResetCmd+0x8>)
 800425a:	6018      	str	r0, [r3, #0]
 800425c:	4770      	bx	lr
 800425e:	bf00      	nop
 8004260:	42420440 	.word	0x42420440

08004264 <RCC_AHBPeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
{
 8004264:	4b04      	ldr	r3, [pc, #16]	; (8004278 <RCC_AHBPeriphClockCmd+0x14>)
  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    RCC->AHBENR |= RCC_AHBPeriph;
 8004266:	695a      	ldr	r2, [r3, #20]
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8004268:	b109      	cbz	r1, 800426e <RCC_AHBPeriphClockCmd+0xa>
  {
    RCC->AHBENR |= RCC_AHBPeriph;
 800426a:	4310      	orrs	r0, r2
 800426c:	e001      	b.n	8004272 <RCC_AHBPeriphClockCmd+0xe>
  }
  else
  {
    RCC->AHBENR &= ~RCC_AHBPeriph;
 800426e:	ea22 0000 	bic.w	r0, r2, r0
 8004272:	6158      	str	r0, [r3, #20]
 8004274:	4770      	bx	lr
 8004276:	bf00      	nop
 8004278:	40021000 	.word	0x40021000

0800427c <RCC_APB2PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
 800427c:	4b04      	ldr	r3, [pc, #16]	; (8004290 <RCC_APB2PeriphClockCmd+0x14>)
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->APB2ENR |= RCC_APB2Periph;
 800427e:	699a      	ldr	r2, [r3, #24]
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8004280:	b109      	cbz	r1, 8004286 <RCC_APB2PeriphClockCmd+0xa>
  {
    RCC->APB2ENR |= RCC_APB2Periph;
 8004282:	4310      	orrs	r0, r2
 8004284:	e001      	b.n	800428a <RCC_APB2PeriphClockCmd+0xe>
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
 8004286:	ea22 0000 	bic.w	r0, r2, r0
 800428a:	6198      	str	r0, [r3, #24]
 800428c:	4770      	bx	lr
 800428e:	bf00      	nop
 8004290:	40021000 	.word	0x40021000

08004294 <RCC_APB1PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
 8004294:	4b04      	ldr	r3, [pc, #16]	; (80042a8 <RCC_APB1PeriphClockCmd+0x14>)
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->APB1ENR |= RCC_APB1Periph;
 8004296:	69da      	ldr	r2, [r3, #28]
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8004298:	b109      	cbz	r1, 800429e <RCC_APB1PeriphClockCmd+0xa>
  {
    RCC->APB1ENR |= RCC_APB1Periph;
 800429a:	4310      	orrs	r0, r2
 800429c:	e001      	b.n	80042a2 <RCC_APB1PeriphClockCmd+0xe>
  }
  else
  {
    RCC->APB1ENR &= ~RCC_APB1Periph;
 800429e:	ea22 0000 	bic.w	r0, r2, r0
 80042a2:	61d8      	str	r0, [r3, #28]
 80042a4:	4770      	bx	lr
 80042a6:	bf00      	nop
 80042a8:	40021000 	.word	0x40021000

080042ac <RCC_AHBPeriphResetCmd>:
  * @param  NewState: new state of the specified peripheral reset.
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHBPeriphResetCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
{
 80042ac:	4b04      	ldr	r3, [pc, #16]	; (80042c0 <RCC_AHBPeriphResetCmd+0x14>)
  assert_param(IS_RCC_AHB_RST_PERIPH(RCC_AHBPeriph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->AHBRSTR |= RCC_AHBPeriph;
 80042ae:	6a9a      	ldr	r2, [r3, #40]	; 0x28
{
  /* Check the parameters */
  assert_param(IS_RCC_AHB_RST_PERIPH(RCC_AHBPeriph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80042b0:	b109      	cbz	r1, 80042b6 <RCC_AHBPeriphResetCmd+0xa>
  {
    RCC->AHBRSTR |= RCC_AHBPeriph;
 80042b2:	4310      	orrs	r0, r2
 80042b4:	e001      	b.n	80042ba <RCC_AHBPeriphResetCmd+0xe>
  }
  else
  {
    RCC->AHBRSTR &= ~RCC_AHBPeriph;
 80042b6:	ea22 0000 	bic.w	r0, r2, r0
 80042ba:	6298      	str	r0, [r3, #40]	; 0x28
 80042bc:	4770      	bx	lr
 80042be:	bf00      	nop
 80042c0:	40021000 	.word	0x40021000

080042c4 <RCC_APB2PeriphResetCmd>:
  * @param  NewState: new state of the specified peripheral reset.
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
 80042c4:	4b04      	ldr	r3, [pc, #16]	; (80042d8 <RCC_APB2PeriphResetCmd+0x14>)
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->APB2RSTR |= RCC_APB2Periph;
 80042c6:	68da      	ldr	r2, [r3, #12]
{
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80042c8:	b109      	cbz	r1, 80042ce <RCC_APB2PeriphResetCmd+0xa>
  {
    RCC->APB2RSTR |= RCC_APB2Periph;
 80042ca:	4310      	orrs	r0, r2
 80042cc:	e001      	b.n	80042d2 <RCC_APB2PeriphResetCmd+0xe>
  }
  else
  {
    RCC->APB2RSTR &= ~RCC_APB2Periph;
 80042ce:	ea22 0000 	bic.w	r0, r2, r0
 80042d2:	60d8      	str	r0, [r3, #12]
 80042d4:	4770      	bx	lr
 80042d6:	bf00      	nop
 80042d8:	40021000 	.word	0x40021000

080042dc <RCC_APB1PeriphResetCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
 80042dc:	4b04      	ldr	r3, [pc, #16]	; (80042f0 <RCC_APB1PeriphResetCmd+0x14>)
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
 80042de:	691a      	ldr	r2, [r3, #16]
{
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80042e0:	b109      	cbz	r1, 80042e6 <RCC_APB1PeriphResetCmd+0xa>
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
 80042e2:	4310      	orrs	r0, r2
 80042e4:	e001      	b.n	80042ea <RCC_APB1PeriphResetCmd+0xe>
  }
  else
  {
    RCC->APB1RSTR &= ~RCC_APB1Periph;
 80042e6:	ea22 0000 	bic.w	r0, r2, r0
 80042ea:	6118      	str	r0, [r3, #16]
 80042ec:	4770      	bx	lr
 80042ee:	bf00      	nop
 80042f0:	40021000 	.word	0x40021000

080042f4 <RCC_ITConfig>:
  * @param  NewState: new state of the specified RCC interrupts.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
{
 80042f4:	4b04      	ldr	r3, [pc, #16]	; (8004308 <RCC_ITConfig+0x14>)
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Perform Byte access to RCC_CIR[13:8] bits to enable the selected interrupts */
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
 80042f6:	781a      	ldrb	r2, [r3, #0]
{
  /* Check the parameters */
  assert_param(IS_RCC_IT(RCC_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80042f8:	b109      	cbz	r1, 80042fe <RCC_ITConfig+0xa>
  {
    /* Perform Byte access to RCC_CIR[13:8] bits to enable the selected interrupts */
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
 80042fa:	4310      	orrs	r0, r2
 80042fc:	e001      	b.n	8004302 <RCC_ITConfig+0xe>
  }
  else
  {
    /* Perform Byte access to RCC_CIR[13:8] bits to disable the selected interrupts */
    *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
 80042fe:	ea22 0000 	bic.w	r0, r2, r0
 8004302:	7018      	strb	r0, [r3, #0]
 8004304:	4770      	bx	lr
 8004306:	bf00      	nop
 8004308:	40021009 	.word	0x40021009

0800430c <RCC_GetFlagStatus>:
  assert_param(IS_RCC_FLAG(RCC_FLAG));

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;

   if (tmp == 0)               /* The flag to check is in CR register */
 800430c:	0943      	lsrs	r3, r0, #5
 800430e:	4a09      	ldr	r2, [pc, #36]	; (8004334 <RCC_GetFlagStatus+0x28>)
 8004310:	d101      	bne.n	8004316 <RCC_GetFlagStatus+0xa>
  {
    statusreg = RCC->CR;
 8004312:	6813      	ldr	r3, [r2, #0]
 8004314:	e007      	b.n	8004326 <RCC_GetFlagStatus+0x1a>
  }
  else if (tmp == 1)          /* The flag to check is in BDCR register */
 8004316:	2b01      	cmp	r3, #1
 8004318:	d101      	bne.n	800431e <RCC_GetFlagStatus+0x12>
  {
    statusreg = RCC->BDCR;
 800431a:	6a13      	ldr	r3, [r2, #32]
 800431c:	e003      	b.n	8004326 <RCC_GetFlagStatus+0x1a>
  }
  else if (tmp == 4)          /* The flag to check is in CFGR register */
 800431e:	2b04      	cmp	r3, #4
  {
    statusreg = RCC->CFGR;
 8004320:	bf0c      	ite	eq
 8004322:	6853      	ldreq	r3, [r2, #4]
  }
  else                       /* The flag to check is in CSR register */
  {
    statusreg = RCC->CSR;
 8004324:	6a53      	ldrne	r3, [r2, #36]	; 0x24
  }

  /* Get the flag position */
  tmp = RCC_FLAG & FLAG_MASK;

  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
 8004326:	f000 001f 	and.w	r0, r0, #31
 800432a:	fa23 f000 	lsr.w	r0, r3, r0
  {
    bitstatus = RESET;
  }
  /* Return the flag status */
  return bitstatus;
}
 800432e:	f000 0001 	and.w	r0, r0, #1
 8004332:	4770      	bx	lr
 8004334:	40021000 	.word	0x40021000

08004338 <RCC_WaitForHSEStartUp>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: HSE oscillator is stable and ready to use
  *          - ERROR: HSE oscillator not yet ready
  */
ErrorStatus RCC_WaitForHSEStartUp(void)
{
 8004338:	b507      	push	{r0, r1, r2, lr}
  __IO uint32_t StartUpCounter = 0;
 800433a:	2300      	movs	r3, #0
 800433c:	9301      	str	r3, [sp, #4]
  FlagStatus HSEStatus = RESET;
  
  /* Wait till HSE is ready and if timeout is reached exit */
  do
  {
    HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
 800433e:	2011      	movs	r0, #17
 8004340:	f7ff ffe4 	bl	800430c <RCC_GetFlagStatus>
    StartUpCounter++;  
 8004344:	9b01      	ldr	r3, [sp, #4]
 8004346:	3301      	adds	r3, #1
 8004348:	9301      	str	r3, [sp, #4]
  } while((StartUpCounter != HSE_STARTUP_TIMEOUT) && (HSEStatus == RESET));
 800434a:	9b01      	ldr	r3, [sp, #4]
 800434c:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 8004350:	d001      	beq.n	8004356 <RCC_WaitForHSEStartUp+0x1e>
 8004352:	2800      	cmp	r0, #0
 8004354:	d0f3      	beq.n	800433e <RCC_WaitForHSEStartUp+0x6>
  
  if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
 8004356:	2011      	movs	r0, #17
 8004358:	f7ff ffd8 	bl	800430c <RCC_GetFlagStatus>
  else
  {
    status = ERROR;
  }  
  return (status);
}
 800435c:	3000      	adds	r0, #0
 800435e:	bf18      	it	ne
 8004360:	2001      	movne	r0, #1
 8004362:	bd0e      	pop	{r1, r2, r3, pc}

08004364 <RCC_ClearFlag>:
  * @retval None
  */
void RCC_ClearFlag(void)
{
  /* Set RMVF bit to clear the reset flags */
  RCC->CSR |= RCC_CSR_RMVF;
 8004364:	4b02      	ldr	r3, [pc, #8]	; (8004370 <RCC_ClearFlag+0xc>)
 8004366:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8004368:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 800436c:	625a      	str	r2, [r3, #36]	; 0x24
 800436e:	4770      	bx	lr
 8004370:	40021000 	.word	0x40021000

08004374 <RCC_GetITStatus>:
  
  /* Check the parameters */
  assert_param(IS_RCC_GET_IT(RCC_IT));
  
  /* Check the status of the specified RCC interrupt */
  if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
 8004374:	4b03      	ldr	r3, [pc, #12]	; (8004384 <RCC_GetITStatus+0x10>)
 8004376:	689b      	ldr	r3, [r3, #8]
 8004378:	4218      	tst	r0, r3
  {
    bitstatus = RESET;
  }
  /* Return the RCC_IT status */
  return  bitstatus;
}
 800437a:	bf0c      	ite	eq
 800437c:	2000      	moveq	r0, #0
 800437e:	2001      	movne	r0, #1
 8004380:	4770      	bx	lr
 8004382:	bf00      	nop
 8004384:	40021000 	.word	0x40021000

08004388 <RCC_ClearITPendingBit>:
  /* Check the parameters */
  assert_param(IS_RCC_CLEAR_IT(RCC_IT));
  
  /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
     pending bits */
  *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
 8004388:	4b01      	ldr	r3, [pc, #4]	; (8004390 <RCC_ClearITPendingBit+0x8>)
 800438a:	7018      	strb	r0, [r3, #0]
 800438c:	4770      	bx	lr
 800438e:	bf00      	nop
 8004390:	4002100a 	.word	0x4002100a

08004394 <SPI_I2S_DeInit>:
  * @param  SPIx: To select the SPIx peripheral, where x can be: 1, 2 or 3 
  *         in SPI mode.
  * @retval None
  */
void SPI_I2S_DeInit(SPI_TypeDef* SPIx)
{
 8004394:	b508      	push	{r3, lr}
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));

  if (SPIx == SPI1)
 8004396:	4b15      	ldr	r3, [pc, #84]	; (80043ec <SPI_I2S_DeInit+0x58>)
 8004398:	4298      	cmp	r0, r3
 800439a:	d10b      	bne.n	80043b4 <SPI_I2S_DeInit+0x20>
  {
    /* Enable SPI1 reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
 800439c:	2101      	movs	r1, #1
 800439e:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 80043a2:	f7ff ff8f 	bl	80042c4 <RCC_APB2PeriphResetCmd>
    /* Release SPI1 from reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
 80043a6:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 80043aa:	2100      	movs	r1, #0
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
      /* Release SPI3 from reset state */
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
    }
  }
}
 80043ac:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  if (SPIx == SPI1)
  {
    /* Enable SPI1 reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
    /* Release SPI1 from reset state */
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
 80043b0:	f7ff bf88 	b.w	80042c4 <RCC_APB2PeriphResetCmd>
  }
  else if (SPIx == SPI2)
 80043b4:	4b0e      	ldr	r3, [pc, #56]	; (80043f0 <SPI_I2S_DeInit+0x5c>)
 80043b6:	4298      	cmp	r0, r3
 80043b8:	d107      	bne.n	80043ca <SPI_I2S_DeInit+0x36>
  {
    /* Enable SPI2 reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, ENABLE);
 80043ba:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 80043be:	2101      	movs	r1, #1
 80043c0:	f7ff ff8c 	bl	80042dc <RCC_APB1PeriphResetCmd>
    /* Release SPI2 from reset state */
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, DISABLE);
 80043c4:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 80043c8:	e009      	b.n	80043de <SPI_I2S_DeInit+0x4a>
  }
  else
  {
    if (SPIx == SPI3)
 80043ca:	4b0a      	ldr	r3, [pc, #40]	; (80043f4 <SPI_I2S_DeInit+0x60>)
 80043cc:	4298      	cmp	r0, r3
 80043ce:	d10b      	bne.n	80043e8 <SPI_I2S_DeInit+0x54>
    {
      /* Enable SPI3 reset state */
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
 80043d0:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 80043d4:	2101      	movs	r1, #1
 80043d6:	f7ff ff81 	bl	80042dc <RCC_APB1PeriphResetCmd>
      /* Release SPI3 from reset state */
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
 80043da:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 80043de:	2100      	movs	r1, #0
    }
  }
}
 80043e0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    if (SPIx == SPI3)
    {
      /* Enable SPI3 reset state */
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
      /* Release SPI3 from reset state */
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
 80043e4:	f7ff bf7a 	b.w	80042dc <RCC_APB1PeriphResetCmd>
 80043e8:	bd08      	pop	{r3, pc}
 80043ea:	bf00      	nop
 80043ec:	40013000 	.word	0x40013000
 80043f0:	40003800 	.word	0x40003800
 80043f4:	40003c00 	.word	0x40003c00

080043f8 <SPI_StructInit>:
  */
void SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct)
{
/*--------------- Reset SPI init structure parameters values -----------------*/
  /* Initialize the SPI_Direction member */
  SPI_InitStruct->SPI_Direction = SPI_Direction_2Lines_FullDuplex;
 80043f8:	2300      	movs	r3, #0
 80043fa:	8003      	strh	r3, [r0, #0]
  /* Initialize the SPI_Mode member */
  SPI_InitStruct->SPI_Mode = SPI_Mode_Slave;
 80043fc:	8043      	strh	r3, [r0, #2]
  /* Initialize the SPI_DataSize member */
  SPI_InitStruct->SPI_DataSize = SPI_DataSize_8b;
 80043fe:	f44f 62e0 	mov.w	r2, #1792	; 0x700
  /* Initialize the SPI_CPOL member */
  SPI_InitStruct->SPI_CPOL = SPI_CPOL_Low;
 8004402:	80c3      	strh	r3, [r0, #6]
  /* Initialize the SPI_CPHA member */
  SPI_InitStruct->SPI_CPHA = SPI_CPHA_1Edge;
 8004404:	8103      	strh	r3, [r0, #8]
  /* Initialize the SPI_NSS member */
  SPI_InitStruct->SPI_NSS = SPI_NSS_Hard;
 8004406:	8143      	strh	r3, [r0, #10]
  /* Initialize the SPI_BaudRatePrescaler member */
  SPI_InitStruct->SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
 8004408:	8183      	strh	r3, [r0, #12]
  /* Initialize the SPI_FirstBit member */
  SPI_InitStruct->SPI_FirstBit = SPI_FirstBit_MSB;
 800440a:	81c3      	strh	r3, [r0, #14]
  /* Initialize the SPI_CRCPolynomial member */
  SPI_InitStruct->SPI_CRCPolynomial = 7;
 800440c:	2307      	movs	r3, #7
  /* Initialize the SPI_Direction member */
  SPI_InitStruct->SPI_Direction = SPI_Direction_2Lines_FullDuplex;
  /* Initialize the SPI_Mode member */
  SPI_InitStruct->SPI_Mode = SPI_Mode_Slave;
  /* Initialize the SPI_DataSize member */
  SPI_InitStruct->SPI_DataSize = SPI_DataSize_8b;
 800440e:	8082      	strh	r2, [r0, #4]
  /* Initialize the SPI_BaudRatePrescaler member */
  SPI_InitStruct->SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
  /* Initialize the SPI_FirstBit member */
  SPI_InitStruct->SPI_FirstBit = SPI_FirstBit_MSB;
  /* Initialize the SPI_CRCPolynomial member */
  SPI_InitStruct->SPI_CRCPolynomial = 7;
 8004410:	8203      	strh	r3, [r0, #16]
 8004412:	4770      	bx	lr

08004414 <SPI_Init>:
  assert_param(IS_SPI_BAUDRATE_PRESCALER(SPI_InitStruct->SPI_BaudRatePrescaler));
  assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct->SPI_FirstBit));
  assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct->SPI_CRCPolynomial));

  /* Configuring the SPI in master mode */
  if(SPI_InitStruct->SPI_Mode == SPI_Mode_Master)
 8004414:	884a      	ldrh	r2, [r1, #2]
  * @param  SPI_InitStruct: pointer to a SPI_InitTypeDef structure that
  *         contains the configuration information for the specified SPI peripheral.
  * @retval None
  */
void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)
{
 8004416:	b530      	push	{r4, r5, lr}
  assert_param(IS_SPI_BAUDRATE_PRESCALER(SPI_InitStruct->SPI_BaudRatePrescaler));
  assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct->SPI_FirstBit));
  assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct->SPI_CRCPolynomial));

  /* Configuring the SPI in master mode */
  if(SPI_InitStruct->SPI_Mode == SPI_Mode_Master)
 8004418:	f5b2 7f82 	cmp.w	r2, #260	; 0x104
 800441c:	d11a      	bne.n	8004454 <SPI_Init+0x40>
    /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
    /* Set LSBFirst bit according to SPI_FirstBit value */
    /* Set BR bits according to SPI_BaudRatePrescaler value */
    /* Set CPOL bit according to SPI_CPOL value */
    /* Set CPHA bit according to SPI_CPHA value */
    tmpreg |= (uint16_t)((uint16_t)(SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode) |
 800441e:	880c      	ldrh	r4, [r1, #0]
 8004420:	88cb      	ldrh	r3, [r1, #6]
  /* Configuring the SPI in master mode */
  if(SPI_InitStruct->SPI_Mode == SPI_Mode_Master)
  {
/*---------------------------- SPIx CR1 Configuration ------------------------*/
    /* Get the SPIx CR1 value */
    tmpreg = SPIx->CR1;
 8004422:	8802      	ldrh	r2, [r0, #0]
    /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
    /* Set LSBFirst bit according to SPI_FirstBit value */
    /* Set BR bits according to SPI_BaudRatePrescaler value */
    /* Set CPOL bit according to SPI_CPOL value */
    /* Set CPHA bit according to SPI_CPHA value */
    tmpreg |= (uint16_t)((uint16_t)(SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode) |
 8004424:	4323      	orrs	r3, r4
                         (uint16_t)((uint16_t)(SPI_InitStruct->SPI_CPOL | SPI_InitStruct->SPI_CPHA) |
                         (uint16_t)((uint16_t)(SPI_InitStruct->SPI_NSS | SPI_InitStruct->SPI_BaudRatePrescaler) | 
 8004426:	890c      	ldrh	r4, [r1, #8]
 8004428:	f443 7382 	orr.w	r3, r3, #260	; 0x104
 800442c:	4323      	orrs	r3, r4
    /* Set LSBFirst bit according to SPI_FirstBit value */
    /* Set BR bits according to SPI_BaudRatePrescaler value */
    /* Set CPOL bit according to SPI_CPOL value */
    /* Set CPHA bit according to SPI_CPHA value */
    tmpreg |= (uint16_t)((uint16_t)(SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode) |
                         (uint16_t)((uint16_t)(SPI_InitStruct->SPI_CPOL | SPI_InitStruct->SPI_CPHA) |
 800442e:	894c      	ldrh	r4, [r1, #10]
  {
/*---------------------------- SPIx CR1 Configuration ------------------------*/
    /* Get the SPIx CR1 value */
    tmpreg = SPIx->CR1;
    /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, MSTR, CPOL and CPHA bits */
    tmpreg &= CR1_CLEAR_MASK;
 8004430:	f402 5241 	and.w	r2, r2, #12352	; 0x3040
    /* Set LSBFirst bit according to SPI_FirstBit value */
    /* Set BR bits according to SPI_BaudRatePrescaler value */
    /* Set CPOL bit according to SPI_CPOL value */
    /* Set CPHA bit according to SPI_CPHA value */
    tmpreg |= (uint16_t)((uint16_t)(SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode) |
                         (uint16_t)((uint16_t)(SPI_InitStruct->SPI_CPOL | SPI_InitStruct->SPI_CPHA) |
 8004434:	4323      	orrs	r3, r4
 8004436:	898c      	ldrh	r4, [r1, #12]
 8004438:	4323      	orrs	r3, r4
    /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
    /* Set LSBFirst bit according to SPI_FirstBit value */
    /* Set BR bits according to SPI_BaudRatePrescaler value */
    /* Set CPOL bit according to SPI_CPOL value */
    /* Set CPHA bit according to SPI_CPHA value */
    tmpreg |= (uint16_t)((uint16_t)(SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode) |
 800443a:	89cc      	ldrh	r4, [r1, #14]
 800443c:	4323      	orrs	r3, r4
 800443e:	4313      	orrs	r3, r2
                         (uint16_t)((uint16_t)(SPI_InitStruct->SPI_CPOL | SPI_InitStruct->SPI_CPHA) |
                         (uint16_t)((uint16_t)(SPI_InitStruct->SPI_NSS | SPI_InitStruct->SPI_BaudRatePrescaler) | 
                         SPI_InitStruct->SPI_FirstBit)));
    /* Write to SPIx CR1 */
    SPIx->CR1 = tmpreg;
 8004440:	8003      	strh	r3, [r0, #0]
    /*-------------------------Data Size Configuration -----------------------*/
    /* Get the SPIx CR2 value */
    tmpreg = SPIx->CR2;
 8004442:	8883      	ldrh	r3, [r0, #4]
    /* Clear DS[3:0] bits */
    tmpreg &= (uint16_t)~SPI_CR2_DS;
    /* Configure SPIx: Data Size */
    tmpreg |= (uint16_t)(SPI_InitStruct->SPI_DataSize);
 8004444:	888a      	ldrh	r2, [r1, #4]
    SPIx->CR1 = tmpreg;
    /*-------------------------Data Size Configuration -----------------------*/
    /* Get the SPIx CR2 value */
    tmpreg = SPIx->CR2;
    /* Clear DS[3:0] bits */
    tmpreg &= (uint16_t)~SPI_CR2_DS;
 8004446:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
 800444a:	041b      	lsls	r3, r3, #16
 800444c:	0c1b      	lsrs	r3, r3, #16
    /* Configure SPIx: Data Size */
    tmpreg |= (uint16_t)(SPI_InitStruct->SPI_DataSize);
 800444e:	4313      	orrs	r3, r2
    /* Write to SPIx CR2 */
    SPIx->CR2 = tmpreg;
 8004450:	8083      	strh	r3, [r0, #4]
 8004452:	e018      	b.n	8004486 <SPI_Init+0x72>
  /* Configuring the SPI in slave mode */
  else
  {
/*---------------------------- Data size Configuration -----------------------*/
    /* Get the SPIx CR2 value */
    tmpreg = SPIx->CR2;
 8004454:	8883      	ldrh	r3, [r0, #4]
    /* Clear DS[3:0] bits */
    tmpreg &= (uint16_t)~SPI_CR2_DS;
    /* Configure SPIx: Data Size */
    tmpreg |= (uint16_t)(SPI_InitStruct->SPI_DataSize);
 8004456:	888c      	ldrh	r4, [r1, #4]
  {
/*---------------------------- Data size Configuration -----------------------*/
    /* Get the SPIx CR2 value */
    tmpreg = SPIx->CR2;
    /* Clear DS[3:0] bits */
    tmpreg &= (uint16_t)~SPI_CR2_DS;
 8004458:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
 800445c:	041b      	lsls	r3, r3, #16
 800445e:	0c1b      	lsrs	r3, r3, #16
    /* Configure SPIx: Data Size */
    tmpreg |= (uint16_t)(SPI_InitStruct->SPI_DataSize);
 8004460:	4323      	orrs	r3, r4
    /* Write to SPIx CR2 */
    SPIx->CR2 = tmpreg;
 8004462:	8083      	strh	r3, [r0, #4]
    /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
    /* Set LSBFirst bit according to SPI_FirstBit value */
    /* Set BR bits according to SPI_BaudRatePrescaler value */
    /* Set CPOL bit according to SPI_CPOL value */
    /* Set CPHA bit according to SPI_CPHA value */
    tmpreg |= (uint16_t)((uint16_t)(SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode) | 
 8004464:	880b      	ldrh	r3, [r1, #0]
                         (uint16_t)((uint16_t)(SPI_InitStruct->SPI_CPOL | SPI_InitStruct->SPI_CPHA) | 
                         (uint16_t)((uint16_t)(SPI_InitStruct->SPI_NSS | SPI_InitStruct->SPI_BaudRatePrescaler) | 
 8004466:	88cd      	ldrh	r5, [r1, #6]
    /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
    /* Set LSBFirst bit according to SPI_FirstBit value */
    /* Set BR bits according to SPI_BaudRatePrescaler value */
    /* Set CPOL bit according to SPI_CPOL value */
    /* Set CPHA bit according to SPI_CPHA value */
    tmpreg |= (uint16_t)((uint16_t)(SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode) | 
 8004468:	4313      	orrs	r3, r2
                         (uint16_t)((uint16_t)(SPI_InitStruct->SPI_CPOL | SPI_InitStruct->SPI_CPHA) | 
                         (uint16_t)((uint16_t)(SPI_InitStruct->SPI_NSS | SPI_InitStruct->SPI_BaudRatePrescaler) | 
 800446a:	432b      	orrs	r3, r5
 800446c:	890d      	ldrh	r5, [r1, #8]
    tmpreg |= (uint16_t)(SPI_InitStruct->SPI_DataSize);
    /* Write to SPIx CR2 */
    SPIx->CR2 = tmpreg;
/*---------------------------- SPIx CR1 Configuration ------------------------*/
    /* Get the SPIx CR1 value */
    tmpreg = SPIx->CR1;
 800446e:	8804      	ldrh	r4, [r0, #0]
    /* Set BR bits according to SPI_BaudRatePrescaler value */
    /* Set CPOL bit according to SPI_CPOL value */
    /* Set CPHA bit according to SPI_CPHA value */
    tmpreg |= (uint16_t)((uint16_t)(SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode) | 
                         (uint16_t)((uint16_t)(SPI_InitStruct->SPI_CPOL | SPI_InitStruct->SPI_CPHA) | 
                         (uint16_t)((uint16_t)(SPI_InitStruct->SPI_NSS | SPI_InitStruct->SPI_BaudRatePrescaler) | 
 8004470:	432b      	orrs	r3, r5
    /* Set LSBFirst bit according to SPI_FirstBit value */
    /* Set BR bits according to SPI_BaudRatePrescaler value */
    /* Set CPOL bit according to SPI_CPOL value */
    /* Set CPHA bit according to SPI_CPHA value */
    tmpreg |= (uint16_t)((uint16_t)(SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode) | 
                         (uint16_t)((uint16_t)(SPI_InitStruct->SPI_CPOL | SPI_InitStruct->SPI_CPHA) | 
 8004472:	894d      	ldrh	r5, [r1, #10]
    /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
    /* Set LSBFirst bit according to SPI_FirstBit value */
    /* Set BR bits according to SPI_BaudRatePrescaler value */
    /* Set CPOL bit according to SPI_CPOL value */
    /* Set CPHA bit according to SPI_CPHA value */
    tmpreg |= (uint16_t)((uint16_t)(SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode) | 
 8004474:	89ca      	ldrh	r2, [r1, #14]
                         (uint16_t)((uint16_t)(SPI_InitStruct->SPI_CPOL | SPI_InitStruct->SPI_CPHA) | 
 8004476:	432b      	orrs	r3, r5
 8004478:	898d      	ldrh	r5, [r1, #12]
    SPIx->CR2 = tmpreg;
/*---------------------------- SPIx CR1 Configuration ------------------------*/
    /* Get the SPIx CR1 value */
    tmpreg = SPIx->CR1;
    /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, MSTR, CPOL and CPHA bits */
    tmpreg &= CR1_CLEAR_MASK;
 800447a:	f404 5441 	and.w	r4, r4, #12352	; 0x3040
    /* Set LSBFirst bit according to SPI_FirstBit value */
    /* Set BR bits according to SPI_BaudRatePrescaler value */
    /* Set CPOL bit according to SPI_CPOL value */
    /* Set CPHA bit according to SPI_CPHA value */
    tmpreg |= (uint16_t)((uint16_t)(SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode) | 
                         (uint16_t)((uint16_t)(SPI_InitStruct->SPI_CPOL | SPI_InitStruct->SPI_CPHA) | 
 800447e:	432b      	orrs	r3, r5
    /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
    /* Set LSBFirst bit according to SPI_FirstBit value */
    /* Set BR bits according to SPI_BaudRatePrescaler value */
    /* Set CPOL bit according to SPI_CPOL value */
    /* Set CPHA bit according to SPI_CPHA value */
    tmpreg |= (uint16_t)((uint16_t)(SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode) | 
 8004480:	4313      	orrs	r3, r2
 8004482:	4323      	orrs	r3, r4
                         (uint16_t)((uint16_t)(SPI_InitStruct->SPI_CPOL | SPI_InitStruct->SPI_CPHA) | 
                         (uint16_t)((uint16_t)(SPI_InitStruct->SPI_NSS | SPI_InitStruct->SPI_BaudRatePrescaler) | 
                         SPI_InitStruct->SPI_FirstBit)));

    /* Write to SPIx CR1 */
    SPIx->CR1 = tmpreg;
 8004484:	8003      	strh	r3, [r0, #0]
  }

  /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
  SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SMOD);
 8004486:	8b83      	ldrh	r3, [r0, #28]
 8004488:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 800448c:	041b      	lsls	r3, r3, #16
 800448e:	0c1b      	lsrs	r3, r3, #16
 8004490:	8383      	strh	r3, [r0, #28]

/*---------------------------- SPIx CRCPOLY Configuration --------------------*/
  /* Write to SPIx CRCPOLY */
  SPIx->CRCPR = SPI_InitStruct->SPI_CRCPolynomial;
 8004492:	8a0b      	ldrh	r3, [r1, #16]
 8004494:	8203      	strh	r3, [r0, #16]
 8004496:	bd30      	pop	{r4, r5, pc}

08004498 <I2S_StructInit>:
  */
void I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct)
{
/*--------------- Reset I2S init structure parameters values -----------------*/
  /* Initialize the I2S_Mode member */
  I2S_InitStruct->I2S_Mode = I2S_Mode_SlaveTx;
 8004498:	2300      	movs	r3, #0

  /* Initialize the I2S_MCLKOutput member */
  I2S_InitStruct->I2S_MCLKOutput = I2S_MCLKOutput_Disable;

  /* Initialize the I2S_AudioFreq member */
  I2S_InitStruct->I2S_AudioFreq = I2S_AudioFreq_Default;
 800449a:	2202      	movs	r2, #2
  */
void I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct)
{
/*--------------- Reset I2S init structure parameters values -----------------*/
  /* Initialize the I2S_Mode member */
  I2S_InitStruct->I2S_Mode = I2S_Mode_SlaveTx;
 800449c:	8003      	strh	r3, [r0, #0]

  /* Initialize the I2S_Standard member */
  I2S_InitStruct->I2S_Standard = I2S_Standard_Phillips;
 800449e:	8043      	strh	r3, [r0, #2]

  /* Initialize the I2S_DataFormat member */
  I2S_InitStruct->I2S_DataFormat = I2S_DataFormat_16b;
 80044a0:	8083      	strh	r3, [r0, #4]

  /* Initialize the I2S_MCLKOutput member */
  I2S_InitStruct->I2S_MCLKOutput = I2S_MCLKOutput_Disable;
 80044a2:	80c3      	strh	r3, [r0, #6]

  /* Initialize the I2S_AudioFreq member */
  I2S_InitStruct->I2S_AudioFreq = I2S_AudioFreq_Default;
 80044a4:	6082      	str	r2, [r0, #8]

  /* Initialize the I2S_CPOL member */
  I2S_InitStruct->I2S_CPOL = I2S_CPOL_Low;
 80044a6:	8183      	strh	r3, [r0, #12]
 80044a8:	4770      	bx	lr

080044aa <I2S_Init>:
  assert_param(IS_I2S_AUDIO_FREQ(I2S_InitStruct->I2S_AudioFreq));
  assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  

/*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  SPIx->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
 80044aa:	8b83      	ldrh	r3, [r0, #28]
  *  and the product configuration). But in case the prescaler value is greater 
  *  than 511, the default value (0x02) will be configured instead.     
  * @retval None
  */
void I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct)
{
 80044ac:	b5f0      	push	{r4, r5, r6, r7, lr}
  assert_param(IS_I2S_AUDIO_FREQ(I2S_InitStruct->I2S_AudioFreq));
  assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  

/*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  SPIx->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
 80044ae:	f423 637b 	bic.w	r3, r3, #4016	; 0xfb0
 80044b2:	f023 030f 	bic.w	r3, r3, #15
 80044b6:	041b      	lsls	r3, r3, #16
 80044b8:	0c1b      	lsrs	r3, r3, #16
 80044ba:	8383      	strh	r3, [r0, #28]
  SPIx->I2SPR = 0x0002;
 80044bc:	2302      	movs	r3, #2
 80044be:	8403      	strh	r3, [r0, #32]

  /* Get the I2SCFGR register value */
  tmpreg = SPIx->I2SCFGR;

  /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
  if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
 80044c0:	688b      	ldr	r3, [r1, #8]
  *  and the product configuration). But in case the prescaler value is greater 
  *  than 511, the default value (0x02) will be configured instead.     
  * @retval None
  */
void I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct)
{
 80044c2:	b091      	sub	sp, #68	; 0x44

  /* Get the I2SCFGR register value */
  tmpreg = SPIx->I2SCFGR;

  /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
  if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
 80044c4:	2b02      	cmp	r3, #2
  *  and the product configuration). But in case the prescaler value is greater 
  *  than 511, the default value (0x02) will be configured instead.     
  * @retval None
  */
void I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct)
{
 80044c6:	4605      	mov	r5, r0
 80044c8:	460c      	mov	r4, r1
  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  SPIx->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
  SPIx->I2SPR = 0x0002;

  /* Get the I2SCFGR register value */
  tmpreg = SPIx->I2SCFGR;
 80044ca:	8b86      	ldrh	r6, [r0, #28]

  /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
  if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
 80044cc:	d023      	beq.n	8004516 <I2S_Init+0x6c>
      /* Packet length is 32 bits */
      packetlength = 2;
    }

    /* I2S Clock source is System clock: Get System Clock frequency */
    RCC_GetClocksFreq(&RCC_Clocks);      
 80044ce:	a801      	add	r0, sp, #4
  }
  /* If the requested audio frequency is not the default, compute the prescaler */
  else
  {
    /* Check the frame length (For the Prescaler computing) */
    if(I2S_InitStruct->I2S_DataFormat == I2S_DataFormat_16b)
 80044d0:	888f      	ldrh	r7, [r1, #4]
      /* Packet length is 32 bits */
      packetlength = 2;
    }

    /* I2S Clock source is System clock: Get System Clock frequency */
    RCC_GetClocksFreq(&RCC_Clocks);      
 80044d2:	f7ff fd21 	bl	8003f18 <RCC_GetClocksFreq>

    /* Get the source clock value: based on System Clock value */
    sourceclock = RCC_Clocks.SYSCLK_Frequency;    

    /* Compute the Real divider depending on the MCLK output state with a floating point */
    if(I2S_InitStruct->I2S_MCLKOutput == I2S_MCLKOutput_Enable)
 80044d6:	88e3      	ldrh	r3, [r4, #6]
  {
    /* Check the frame length (For the Prescaler computing) */
    if(I2S_InitStruct->I2S_DataFormat == I2S_DataFormat_16b)
    {
      /* Packet length is 16 bits */
      packetlength = 1;
 80044d8:	2f00      	cmp	r7, #0
 80044da:	bf14      	ite	ne
 80044dc:	2702      	movne	r7, #2
 80044de:	2701      	moveq	r7, #1

    /* Get the source clock value: based on System Clock value */
    sourceclock = RCC_Clocks.SYSCLK_Frequency;    

    /* Compute the Real divider depending on the MCLK output state with a floating point */
    if(I2S_InitStruct->I2S_MCLKOutput == I2S_MCLKOutput_Enable)
 80044e0:	f5b3 7f00 	cmp.w	r3, #512	; 0x200

    /* I2S Clock source is System clock: Get System Clock frequency */
    RCC_GetClocksFreq(&RCC_Clocks);      

    /* Get the source clock value: based on System Clock value */
    sourceclock = RCC_Clocks.SYSCLK_Frequency;    
 80044e4:	9a01      	ldr	r2, [sp, #4]
 80044e6:	f04f 030a 	mov.w	r3, #10

    /* Compute the Real divider depending on the MCLK output state with a floating point */
    if(I2S_InitStruct->I2S_MCLKOutput == I2S_MCLKOutput_Enable)
 80044ea:	d101      	bne.n	80044f0 <I2S_Init+0x46>
    {
      /* MCLK output is enabled */
      tmp = (uint16_t)(((((sourceclock / 256) * 10) / I2S_InitStruct->I2S_AudioFreq)) + 5);
 80044ec:	0a12      	lsrs	r2, r2, #8
 80044ee:	e002      	b.n	80044f6 <I2S_Init+0x4c>
    }
    else
    {
      /* MCLK output is disabled */
      tmp = (uint16_t)(((((sourceclock / (32 * packetlength)) *10 ) / I2S_InitStruct->I2S_AudioFreq)) + 5);
 80044f0:	017f      	lsls	r7, r7, #5
 80044f2:	fbb2 f2f7 	udiv	r2, r2, r7
 80044f6:	4353      	muls	r3, r2
 80044f8:	68a1      	ldr	r1, [r4, #8]
    }
    
    /* Remove the floating point */
    tmp = tmp / 10;
 80044fa:	220a      	movs	r2, #10
      tmp = (uint16_t)(((((sourceclock / 256) * 10) / I2S_InitStruct->I2S_AudioFreq)) + 5);
    }
    else
    {
      /* MCLK output is disabled */
      tmp = (uint16_t)(((((sourceclock / (32 * packetlength)) *10 ) / I2S_InitStruct->I2S_AudioFreq)) + 5);
 80044fc:	fbb3 f3f1 	udiv	r3, r3, r1
 8004500:	3305      	adds	r3, #5
 8004502:	b29b      	uxth	r3, r3
    }
    
    /* Remove the floating point */
    tmp = tmp / 10;
 8004504:	fbb3 f3f2 	udiv	r3, r3, r2

    /* Check the parity of the divider */
    i2sodd = (uint16_t)(tmp & (uint16_t)0x0001);

    /* Compute the i2sdiv prescaler */
    i2sdiv = (uint16_t)((tmp - i2sodd) / 2);
 8004508:	f003 0201 	and.w	r2, r3, #1

    /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
    i2sodd = (uint16_t) (i2sodd << 8);
 800450c:	0212      	lsls	r2, r2, #8

    /* Check the parity of the divider */
    i2sodd = (uint16_t)(tmp & (uint16_t)0x0001);

    /* Compute the i2sdiv prescaler */
    i2sdiv = (uint16_t)((tmp - i2sodd) / 2);
 800450e:	f3c3 034f 	ubfx	r3, r3, #1, #16

    /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
    i2sodd = (uint16_t) (i2sodd << 8);
 8004512:	b292      	uxth	r2, r2
 8004514:	e000      	b.n	8004518 <I2S_Init+0x6e>
  tmpreg = SPIx->I2SCFGR;

  /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
  if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
  {
    i2sodd = (uint16_t)0;
 8004516:	2200      	movs	r2, #0
    /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
    i2sodd = (uint16_t) (i2sodd << 8);
  }

  /* Test if the divider is 1 or 0 or greater than 0xFF */
  if ((i2sdiv < 2) || (i2sdiv > 0xFF))
 8004518:	1e99      	subs	r1, r3, #2
 800451a:	b289      	uxth	r1, r1
  {
    /* Set the default values */
    i2sdiv = 2;
    i2sodd = 0;
 800451c:	29fe      	cmp	r1, #254	; 0xfe
 800451e:	bf28      	it	cs
 8004520:	2200      	movcs	r2, #0
  }

  /* Write to SPIx I2SPR register the computed value */
  SPIx->I2SPR = (uint16_t)(i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct->I2S_MCLKOutput));
 8004522:	88e1      	ldrh	r1, [r4, #6]
  /* Test if the divider is 1 or 0 or greater than 0xFF */
  if ((i2sdiv < 2) || (i2sdiv > 0xFF))
  {
    /* Set the default values */
    i2sdiv = 2;
    i2sodd = 0;
 8004524:	bf28      	it	cs
 8004526:	2302      	movcs	r3, #2
  }

  /* Write to SPIx I2SPR register the computed value */
  SPIx->I2SPR = (uint16_t)(i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct->I2S_MCLKOutput));
 8004528:	4313      	orrs	r3, r2
 800452a:	430b      	orrs	r3, r1
 800452c:	842b      	strh	r3, [r5, #32]

  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)((uint16_t)(SPI_I2SCFGR_I2SMOD | I2S_InitStruct->I2S_Mode) | \
                       (uint16_t)((uint16_t)((uint16_t)(I2S_InitStruct->I2S_Standard |I2S_InitStruct->I2S_DataFormat) |\
 800452e:	8823      	ldrh	r3, [r4, #0]

  /* Write to SPIx I2SPR register the computed value */
  SPIx->I2SPR = (uint16_t)(i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct->I2S_MCLKOutput));

  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)((uint16_t)(SPI_I2SCFGR_I2SMOD | I2S_InitStruct->I2S_Mode) | \
 8004530:	8862      	ldrh	r2, [r4, #2]
                       (uint16_t)((uint16_t)((uint16_t)(I2S_InitStruct->I2S_Standard |I2S_InitStruct->I2S_DataFormat) |\
 8004532:	4333      	orrs	r3, r6
 8004534:	f443 6300 	orr.w	r3, r3, #2048	; 0x800

  /* Write to SPIx I2SPR register the computed value */
  SPIx->I2SPR = (uint16_t)(i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct->I2S_MCLKOutput));

  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)((uint16_t)(SPI_I2SCFGR_I2SMOD | I2S_InitStruct->I2S_Mode) | \
 8004538:	4313      	orrs	r3, r2
 800453a:	88a2      	ldrh	r2, [r4, #4]
 800453c:	4313      	orrs	r3, r2
 800453e:	89a2      	ldrh	r2, [r4, #12]
 8004540:	4313      	orrs	r3, r2
                       (uint16_t)((uint16_t)((uint16_t)(I2S_InitStruct->I2S_Standard |I2S_InitStruct->I2S_DataFormat) |\
                       I2S_InitStruct->I2S_CPOL)));

  /* Write to SPIx I2SCFGR */
  SPIx->I2SCFGR = tmpreg;
 8004542:	83ab      	strh	r3, [r5, #28]
}
 8004544:	b011      	add	sp, #68	; 0x44
 8004546:	bdf0      	pop	{r4, r5, r6, r7, pc}

08004548 <SPI_Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the selected SPI peripheral */
    SPIx->CR1 |= SPI_CR1_SPE;
 8004548:	8803      	ldrh	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800454a:	b119      	cbz	r1, 8004554 <SPI_Cmd+0xc>
  {
    /* Enable the selected SPI peripheral */
    SPIx->CR1 |= SPI_CR1_SPE;
 800454c:	b29b      	uxth	r3, r3
 800454e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8004552:	e003      	b.n	800455c <SPI_Cmd+0x14>
  }
  else
  {
    /* Disable the selected SPI peripheral */
    SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_SPE);
 8004554:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8004558:	041b      	lsls	r3, r3, #16
 800455a:	0c1b      	lsrs	r3, r3, #16
 800455c:	8003      	strh	r3, [r0, #0]
 800455e:	4770      	bx	lr

08004560 <SPI_TIModeCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the TI mode for the selected SPI peripheral */
    SPIx->CR2 |= SPI_CR2_FRF;
 8004560:	8883      	ldrh	r3, [r0, #4]
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8004562:	b119      	cbz	r1, 800456c <SPI_TIModeCmd+0xc>
  {
    /* Enable the TI mode for the selected SPI peripheral */
    SPIx->CR2 |= SPI_CR2_FRF;
 8004564:	b29b      	uxth	r3, r3
 8004566:	f043 0310 	orr.w	r3, r3, #16
 800456a:	e003      	b.n	8004574 <SPI_TIModeCmd+0x14>
  }
  else
  {
    /* Disable the TI mode for the selected SPI peripheral */
    SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_FRF);
 800456c:	f023 0310 	bic.w	r3, r3, #16
 8004570:	041b      	lsls	r3, r3, #16
 8004572:	0c1b      	lsrs	r3, r3, #16
 8004574:	8083      	strh	r3, [r0, #4]
 8004576:	4770      	bx	lr

08004578 <I2S_Cmd>:
  assert_param(IS_SPI_23_PERIPH_EXT(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected SPI peripheral in I2S mode */
    SPIx->I2SCFGR |= SPI_I2SCFGR_I2SE;
 8004578:	8b83      	ldrh	r3, [r0, #28]
void I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_SPI_23_PERIPH_EXT(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800457a:	b119      	cbz	r1, 8004584 <I2S_Cmd+0xc>
  {
    /* Enable the selected SPI peripheral in I2S mode */
    SPIx->I2SCFGR |= SPI_I2SCFGR_I2SE;
 800457c:	b29b      	uxth	r3, r3
 800457e:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8004582:	e003      	b.n	800458c <I2S_Cmd+0x14>
  }
  else
  {
    /* Disable the selected SPI peripheral in I2S mode */
    SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SE);
 8004584:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8004588:	041b      	lsls	r3, r3, #16
 800458a:	0c1b      	lsrs	r3, r3, #16
 800458c:	8383      	strh	r3, [r0, #28]
 800458e:	4770      	bx	lr

08004590 <SPI_DataSizeConfig>:
  
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_DATA_SIZE(SPI_DataSize));
  /* Read the CR2 register */
  tmpreg = SPIx->CR2;
 8004590:	8883      	ldrh	r3, [r0, #4]
  /* Clear DS[3:0] bits */
  tmpreg &= (uint16_t)~SPI_CR2_DS;
 8004592:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
 8004596:	041b      	lsls	r3, r3, #16
 8004598:	0c1b      	lsrs	r3, r3, #16
  /* Set new DS[3:0] bits value */
  tmpreg |= SPI_DataSize;
 800459a:	4319      	orrs	r1, r3
  SPIx->CR2 = tmpreg;
 800459c:	8081      	strh	r1, [r0, #4]
 800459e:	4770      	bx	lr

080045a0 <SPI_RxFIFOThresholdConfig>:
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_RX_FIFO_THRESHOLD(SPI_RxFIFOThreshold));

  /* Clear FRXTH bit */
  SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_FRXTH);
 80045a0:	8883      	ldrh	r3, [r0, #4]
 80045a2:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 80045a6:	041b      	lsls	r3, r3, #16
 80045a8:	0c1b      	lsrs	r3, r3, #16
 80045aa:	8083      	strh	r3, [r0, #4]

  /* Set new FRXTH bit value */
  SPIx->CR2 |= SPI_RxFIFOThreshold;
 80045ac:	8883      	ldrh	r3, [r0, #4]
 80045ae:	b29b      	uxth	r3, r3
 80045b0:	4319      	orrs	r1, r3
 80045b2:	8081      	strh	r1, [r0, #4]
 80045b4:	4770      	bx	lr

080045b6 <SPI_BiDirectionalLineConfig>:
void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, uint16_t SPI_Direction)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_DIRECTION(SPI_Direction));
  if (SPI_Direction == SPI_Direction_Tx)
 80045b6:	f5b1 4f80 	cmp.w	r1, #16384	; 0x4000
  {
    /* Set the Tx only mode */
    SPIx->CR1 |= SPI_Direction_Tx;
 80045ba:	8803      	ldrh	r3, [r0, #0]
void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, uint16_t SPI_Direction)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_DIRECTION(SPI_Direction));
  if (SPI_Direction == SPI_Direction_Tx)
 80045bc:	d103      	bne.n	80045c6 <SPI_BiDirectionalLineConfig+0x10>
  {
    /* Set the Tx only mode */
    SPIx->CR1 |= SPI_Direction_Tx;
 80045be:	b29b      	uxth	r3, r3
 80045c0:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80045c4:	e003      	b.n	80045ce <SPI_BiDirectionalLineConfig+0x18>
  }
  else
  {
    /* Set the Rx only mode */
    SPIx->CR1 &= SPI_Direction_Rx;
 80045c6:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 80045ca:	041b      	lsls	r3, r3, #16
 80045cc:	0c1b      	lsrs	r3, r3, #16
 80045ce:	8003      	strh	r3, [r0, #0]
 80045d0:	4770      	bx	lr

080045d2 <SPI_NSSInternalSoftwareConfig>:
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_NSS_INTERNAL(SPI_NSSInternalSoft));

  if (SPI_NSSInternalSoft != SPI_NSSInternalSoft_Reset)
 80045d2:	f64f 63ff 	movw	r3, #65279	; 0xfeff
 80045d6:	4299      	cmp	r1, r3
  {
    /* Set NSS pin internally by software */
    SPIx->CR1 |= SPI_NSSInternalSoft_Set;
 80045d8:	8803      	ldrh	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_NSS_INTERNAL(SPI_NSSInternalSoft));

  if (SPI_NSSInternalSoft != SPI_NSSInternalSoft_Reset)
 80045da:	d003      	beq.n	80045e4 <SPI_NSSInternalSoftwareConfig+0x12>
  {
    /* Set NSS pin internally by software */
    SPIx->CR1 |= SPI_NSSInternalSoft_Set;
 80045dc:	b29b      	uxth	r3, r3
 80045de:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80045e2:	e003      	b.n	80045ec <SPI_NSSInternalSoftwareConfig+0x1a>
  }
  else
  {
    /* Reset NSS pin internally by software */
    SPIx->CR1 &= SPI_NSSInternalSoft_Reset;
 80045e4:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 80045e8:	041b      	lsls	r3, r3, #16
 80045ea:	0c1b      	lsrs	r3, r3, #16
 80045ec:	8003      	strh	r3, [r0, #0]
 80045ee:	4770      	bx	lr

080045f0 <I2S_FullDuplexConfig>:
  assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct->I2S_DataFormat));
  assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  

/*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  I2Sxext->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
 80045f0:	8b83      	ldrh	r3, [r0, #28]
  * @note   The I2S full duplex extension can be configured in slave mode only.    
  *  
  * @retval None
  */
void I2S_FullDuplexConfig(SPI_TypeDef* I2Sxext, I2S_InitTypeDef* I2S_InitStruct)
{
 80045f2:	b510      	push	{r4, lr}
  assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct->I2S_DataFormat));
  assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  

/*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  I2Sxext->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
 80045f4:	f423 637b 	bic.w	r3, r3, #4016	; 0xfb0
 80045f8:	f023 030f 	bic.w	r3, r3, #15
 80045fc:	041b      	lsls	r3, r3, #16
 80045fe:	0c1b      	lsrs	r3, r3, #16
 8004600:	8383      	strh	r3, [r0, #28]
  I2Sxext->I2SPR = 0x0002;
 8004602:	2302      	movs	r3, #2
 8004604:	8403      	strh	r3, [r0, #32]
  
  /* Get the I2SCFGR register value */
  tmpreg = I2Sxext->I2SCFGR;
  
  /* Get the mode to be configured for the extended I2S */
  if ((I2S_InitStruct->I2S_Mode == I2S_Mode_MasterTx) || (I2S_InitStruct->I2S_Mode == I2S_Mode_SlaveTx))
 8004606:	880b      	ldrh	r3, [r1, #0]
  /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
  I2Sxext->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
  I2Sxext->I2SPR = 0x0002;
  
  /* Get the I2SCFGR register value */
  tmpreg = I2Sxext->I2SCFGR;
 8004608:	8b82      	ldrh	r2, [r0, #28]
  
  /* Get the mode to be configured for the extended I2S */
  if ((I2S_InitStruct->I2S_Mode == I2S_Mode_MasterTx) || (I2S_InitStruct->I2S_Mode == I2S_Mode_SlaveTx))
 800460a:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800460e:	d102      	bne.n	8004616 <I2S_FullDuplexConfig+0x26>
  {
    tmp = I2S_Mode_SlaveRx;
 8004610:	f44f 7380 	mov.w	r3, #256	; 0x100
 8004614:	e002      	b.n	800461c <I2S_FullDuplexConfig+0x2c>
  
  /* Get the I2SCFGR register value */
  tmpreg = I2Sxext->I2SCFGR;
  
  /* Get the mode to be configured for the extended I2S */
  if ((I2S_InitStruct->I2S_Mode == I2S_Mode_MasterTx) || (I2S_InitStruct->I2S_Mode == I2S_Mode_SlaveTx))
 8004616:	2b00      	cmp	r3, #0
 8004618:	d0fa      	beq.n	8004610 <I2S_FullDuplexConfig+0x20>
  }
  else
  {
    if ((I2S_InitStruct->I2S_Mode == I2S_Mode_MasterRx) || (I2S_InitStruct->I2S_Mode == I2S_Mode_SlaveRx))
    {
      tmp = I2S_Mode_SlaveTx;
 800461a:	2300      	movs	r3, #0
  }

 
  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(tmp | \
                  (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
 800461c:	884c      	ldrh	r4, [r1, #2]
 800461e:	4322      	orrs	r2, r4
    }
  }

 
  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(tmp | \
 8004620:	888c      	ldrh	r4, [r1, #4]
                  (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
 8004622:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
    }
  }

 
  /* Configure the I2S with the SPI_InitStruct values */
  tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(tmp | \
 8004626:	8989      	ldrh	r1, [r1, #12]
 8004628:	4322      	orrs	r2, r4
 800462a:	430a      	orrs	r2, r1
 800462c:	b292      	uxth	r2, r2
 800462e:	4313      	orrs	r3, r2
                  (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
                  (uint16_t)I2S_InitStruct->I2S_CPOL))));
 
  /* Write to SPIx I2SCFGR */  
  I2Sxext->I2SCFGR = tmpreg;
 8004630:	8383      	strh	r3, [r0, #28]
 8004632:	bd10      	pop	{r4, pc}

08004634 <SPI_SSOutputCmd>:
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the selected SPI SS output */
    SPIx->CR2 |= (uint16_t)SPI_CR2_SSOE;
 8004634:	8883      	ldrh	r3, [r0, #4]
void SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8004636:	b119      	cbz	r1, 8004640 <SPI_SSOutputCmd+0xc>
  {
    /* Enable the selected SPI SS output */
    SPIx->CR2 |= (uint16_t)SPI_CR2_SSOE;
 8004638:	b29b      	uxth	r3, r3
 800463a:	f043 0304 	orr.w	r3, r3, #4
 800463e:	e003      	b.n	8004648 <SPI_SSOutputCmd+0x14>
  }
  else
  {
    /* Disable the selected SPI SS output */
    SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_SSOE);
 8004640:	f023 0304 	bic.w	r3, r3, #4
 8004644:	041b      	lsls	r3, r3, #16
 8004646:	0c1b      	lsrs	r3, r3, #16
 8004648:	8083      	strh	r3, [r0, #4]
 800464a:	4770      	bx	lr

0800464c <SPI_NSSPulseModeCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the NSS pulse management mode */
    SPIx->CR2 |= SPI_CR2_NSSP;
 800464c:	8883      	ldrh	r3, [r0, #4]
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800464e:	b119      	cbz	r1, 8004658 <SPI_NSSPulseModeCmd+0xc>
  {
    /* Enable the NSS pulse management mode */
    SPIx->CR2 |= SPI_CR2_NSSP;
 8004650:	b29b      	uxth	r3, r3
 8004652:	f043 0308 	orr.w	r3, r3, #8
 8004656:	e003      	b.n	8004660 <SPI_NSSPulseModeCmd+0x14>
  }
  else
  {
    /* Disable the NSS pulse management mode */
    SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_NSSP);    
 8004658:	f023 0308 	bic.w	r3, r3, #8
 800465c:	041b      	lsls	r3, r3, #16
 800465e:	0c1b      	lsrs	r3, r3, #16
 8004660:	8083      	strh	r3, [r0, #4]
 8004662:	4770      	bx	lr

08004664 <SPI_SendData8>:
  assert_param(IS_SPI_ALL_PERIPH(SPIx));

  spixbase = (uint32_t)SPIx; 
  spixbase += 0x0C;
  
  *(__IO uint8_t *) spixbase = Data;
 8004664:	7301      	strb	r1, [r0, #12]
 8004666:	4770      	bx	lr

08004668 <SPI_I2S_SendData16>:
void SPI_I2S_SendData16(SPI_TypeDef* SPIx, uint16_t Data)
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  
  SPIx->DR = (uint16_t)Data;
 8004668:	8181      	strh	r1, [r0, #12]
 800466a:	4770      	bx	lr

0800466c <SPI_ReceiveData8>:
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  
  spixbase = (uint32_t)SPIx; 
  spixbase += 0x0C;
  
  return *(__IO uint8_t *) spixbase;
 800466c:	7b00      	ldrb	r0, [r0, #12]
}
 800466e:	4770      	bx	lr

08004670 <SPI_I2S_ReceiveData16>:
uint16_t SPI_I2S_ReceiveData16(SPI_TypeDef* SPIx)
{  
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  
  return SPIx->DR;
 8004670:	8980      	ldrh	r0, [r0, #12]
}
 8004672:	b280      	uxth	r0, r0
 8004674:	4770      	bx	lr

08004676 <SPI_CRCLengthConfig>:
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_CRC_LENGTH(SPI_CRCLength));

  /* Clear CRCL bit */
  SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_CRCL);
 8004676:	8803      	ldrh	r3, [r0, #0]
 8004678:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 800467c:	041b      	lsls	r3, r3, #16
 800467e:	0c1b      	lsrs	r3, r3, #16
 8004680:	8003      	strh	r3, [r0, #0]

  /* Set new CRCL bit value */
  SPIx->CR1 |= SPI_CRCLength;
 8004682:	8803      	ldrh	r3, [r0, #0]
 8004684:	b29b      	uxth	r3, r3
 8004686:	4319      	orrs	r1, r3
 8004688:	8001      	strh	r1, [r0, #0]
 800468a:	4770      	bx	lr

0800468c <SPI_CalculateCRC>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the selected SPI CRC calculation */
    SPIx->CR1 |= SPI_CR1_CRCEN;
 800468c:	8803      	ldrh	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800468e:	b119      	cbz	r1, 8004698 <SPI_CalculateCRC+0xc>
  {
    /* Enable the selected SPI CRC calculation */
    SPIx->CR1 |= SPI_CR1_CRCEN;
 8004690:	b29b      	uxth	r3, r3
 8004692:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8004696:	e003      	b.n	80046a0 <SPI_CalculateCRC+0x14>
  }
  else
  {
    /* Disable the selected SPI CRC calculation */
    SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_CRCEN);
 8004698:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 800469c:	041b      	lsls	r3, r3, #16
 800469e:	0c1b      	lsrs	r3, r3, #16
 80046a0:	8003      	strh	r3, [r0, #0]
 80046a2:	4770      	bx	lr

080046a4 <SPI_TransmitCRC>:
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));

  /* Enable the selected SPI CRC transmission */
  SPIx->CR1 |= SPI_CR1_CRCNEXT;
 80046a4:	8803      	ldrh	r3, [r0, #0]
 80046a6:	b29b      	uxth	r3, r3
 80046a8:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 80046ac:	8003      	strh	r3, [r0, #0]
 80046ae:	4770      	bx	lr

080046b0 <SPI_GetCRC>:
  uint16_t crcreg = 0;
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_CRC(SPI_CRC));

  if (SPI_CRC != SPI_CRC_Rx)
 80046b0:	2901      	cmp	r1, #1
  {
    /* Get the Tx CRC register */
    crcreg = SPIx->TXCRCR;
 80046b2:	bf14      	ite	ne
 80046b4:	8b00      	ldrhne	r0, [r0, #24]
  }
  else
  {
    /* Get the Rx CRC register */
    crcreg = SPIx->RXCRCR;
 80046b6:	8a80      	ldrheq	r0, [r0, #20]
 80046b8:	b280      	uxth	r0, r0
  }
  /* Return the selected CRC register */
  return crcreg;
}
 80046ba:	4770      	bx	lr

080046bc <SPI_GetCRCPolynomial>:
{
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));

  /* Return the CRC polynomial register */
  return SPIx->CRCPR;
 80046bc:	8a00      	ldrh	r0, [r0, #16]
}
 80046be:	b280      	uxth	r0, r0
 80046c0:	4770      	bx	lr

080046c2 <SPI_I2S_DMACmd>:
  assert_param(IS_SPI_I2S_DMA_REQ(SPI_I2S_DMAReq));

  if (NewState != DISABLE)
  {
    /* Enable the selected SPI DMA requests */
    SPIx->CR2 |= SPI_I2S_DMAReq;
 80046c2:	8883      	ldrh	r3, [r0, #4]
 80046c4:	b29b      	uxth	r3, r3
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_SPI_I2S_DMA_REQ(SPI_I2S_DMAReq));

  if (NewState != DISABLE)
 80046c6:	b10a      	cbz	r2, 80046cc <SPI_I2S_DMACmd+0xa>
  {
    /* Enable the selected SPI DMA requests */
    SPIx->CR2 |= SPI_I2S_DMAReq;
 80046c8:	4319      	orrs	r1, r3
 80046ca:	e001      	b.n	80046d0 <SPI_I2S_DMACmd+0xe>
  }
  else
  {
    /* Disable the selected SPI DMA requests */
    SPIx->CR2 &= (uint16_t)~SPI_I2S_DMAReq;
 80046cc:	ea23 0101 	bic.w	r1, r3, r1
 80046d0:	8081      	strh	r1, [r0, #4]
 80046d2:	4770      	bx	lr

080046d4 <SPI_LastDMATransferCmd>:
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH(SPIx));
  assert_param(IS_SPI_LAST_DMA_TRANSFER(SPI_LastDMATransfer));

  /* Clear LDMA_TX and LDMA_RX bits */
  SPIx->CR2 &= CR2_LDMA_MASK;
 80046d4:	8883      	ldrh	r3, [r0, #4]
 80046d6:	f423 43c0 	bic.w	r3, r3, #24576	; 0x6000
 80046da:	041b      	lsls	r3, r3, #16
 80046dc:	0c1b      	lsrs	r3, r3, #16
 80046de:	8083      	strh	r3, [r0, #4]

  /* Set new LDMA_TX and LDMA_RX bits value */
  SPIx->CR2 |= SPI_LastDMATransfer; 
 80046e0:	8883      	ldrh	r3, [r0, #4]
 80046e2:	b29b      	uxth	r3, r3
 80046e4:	4319      	orrs	r1, r3
 80046e6:	8081      	strh	r1, [r0, #4]
 80046e8:	4770      	bx	lr

080046ea <SPI_I2S_ITConfig>:

  /* Get the SPI IT index */
  itpos = SPI_I2S_IT >> 4;

  /* Set the IT mask */
  itmask = (uint16_t)1 << (uint16_t)itpos;
 80046ea:	0909      	lsrs	r1, r1, #4
 80046ec:	2301      	movs	r3, #1
 80046ee:	fa03 f301 	lsl.w	r3, r3, r1
 80046f2:	b29b      	uxth	r3, r3

  if (NewState != DISABLE)
 80046f4:	b11a      	cbz	r2, 80046fe <SPI_I2S_ITConfig+0x14>
  {
    /* Enable the selected SPI interrupt */
    SPIx->CR2 |= itmask;
 80046f6:	8882      	ldrh	r2, [r0, #4]
 80046f8:	b292      	uxth	r2, r2
 80046fa:	4313      	orrs	r3, r2
 80046fc:	e003      	b.n	8004706 <SPI_I2S_ITConfig+0x1c>
  }
  else
  {
    /* Disable the selected SPI interrupt */
    SPIx->CR2 &= (uint16_t)~itmask;
 80046fe:	8882      	ldrh	r2, [r0, #4]
 8004700:	b292      	uxth	r2, r2
 8004702:	ea22 0303 	bic.w	r3, r2, r3
 8004706:	8083      	strh	r3, [r0, #4]
 8004708:	4770      	bx	lr

0800470a <SPI_GetTransmissionFIFOStatus>:
  *   - SPI_TransmissionFIFOStatus_Full: when FIFO is full.
  */
uint16_t SPI_GetTransmissionFIFOStatus(SPI_TypeDef* SPIx)
{
  /* Get the SPIx Transmission FIFO level bits */
  return (uint16_t)((SPIx->SR & SPI_SR_FTLVL));
 800470a:	8900      	ldrh	r0, [r0, #8]
}
 800470c:	f400 50c0 	and.w	r0, r0, #6144	; 0x1800
 8004710:	4770      	bx	lr

08004712 <SPI_GetReceptionFIFOStatus>:
  *   - SPI_ReceptionFIFOStatus_Full: when FIFO is full.
  */
uint16_t SPI_GetReceptionFIFOStatus(SPI_TypeDef* SPIx)
{
  /* Get the SPIx Reception FIFO level bits */
  return (uint16_t)((SPIx->SR & SPI_SR_FRLVL));
 8004712:	8900      	ldrh	r0, [r0, #8]
}
 8004714:	f400 60c0 	and.w	r0, r0, #1536	; 0x600
 8004718:	4770      	bx	lr

0800471a <SPI_I2S_GetFlagStatus>:
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  assert_param(IS_SPI_I2S_GET_FLAG(SPI_I2S_FLAG));

  /* Check the status of the specified SPI flag */
  if ((SPIx->SR & SPI_I2S_FLAG) != (uint16_t)RESET)
 800471a:	8903      	ldrh	r3, [r0, #8]
 800471c:	4219      	tst	r1, r3
    /* SPI_I2S_FLAG is reset */
    bitstatus = RESET;
  }
  /* Return the SPI_I2S_FLAG status */
  return  bitstatus;
}
 800471e:	bf0c      	ite	eq
 8004720:	2000      	moveq	r0, #0
 8004722:	2001      	movne	r0, #1
 8004724:	4770      	bx	lr

08004726 <SPI_I2S_ClearFlag>:
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  assert_param(IS_SPI_CLEAR_FLAG(SPI_I2S_FLAG));

  /* Clear the selected SPI CRC Error (CRCERR) flag */
  SPIx->SR = (uint16_t)~SPI_I2S_FLAG;
 8004726:	43c9      	mvns	r1, r1
 8004728:	8101      	strh	r1, [r0, #8]
 800472a:	4770      	bx	lr

0800472c <SPI_I2S_GetITStatus>:
  /* Check the parameters */
  assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
  assert_param(IS_SPI_I2S_GET_IT(SPI_I2S_IT));

  /* Get the SPI_I2S_IT index */
  itpos = 0x01 << (SPI_I2S_IT & 0x0F);
 800472c:	2301      	movs	r3, #1
 800472e:	f001 020f 	and.w	r2, r1, #15
 8004732:	fa03 f202 	lsl.w	r2, r3, r2
  *     @arg I2S_IT_UDR: Underrun interrupt.  
  *     @arg SPI_I2S_IT_FRE: Format Error interrupt.  
  * @retval The new state of SPI_I2S_IT (SET or RESET).
  */
ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)
{
 8004736:	b510      	push	{r4, lr}

  /* Set the IT mask */
  itmask = 0x01 << itmask;

  /* Get the SPI_I2S_IT enable bit status */
  enablestatus = (SPIx->CR2 & itmask) ;
 8004738:	8884      	ldrh	r4, [r0, #4]

  /* Check the status of the specified SPI interrupt */
  if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)
 800473a:	8900      	ldrh	r0, [r0, #8]

  /* Set the IT mask */
  itmask = 0x01 << itmask;

  /* Get the SPI_I2S_IT enable bit status */
  enablestatus = (SPIx->CR2 & itmask) ;
 800473c:	b2a4      	uxth	r4, r4

  /* Check the status of the specified SPI interrupt */
  if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)
 800473e:	b280      	uxth	r0, r0
 8004740:	4010      	ands	r0, r2
 8004742:	d006      	beq.n	8004752 <SPI_I2S_GetITStatus+0x26>

  /* Get the SPI_I2S_IT IT mask */
  itmask = SPI_I2S_IT >> 4;

  /* Set the IT mask */
  itmask = 0x01 << itmask;
 8004744:	0909      	lsrs	r1, r1, #4
 8004746:	fa03 f301 	lsl.w	r3, r3, r1

  /* Get the SPI_I2S_IT enable bit status */
  enablestatus = (SPIx->CR2 & itmask) ;

  /* Check the status of the specified SPI interrupt */
  if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)
 800474a:	421c      	tst	r4, r3
  {
    /* SPI_I2S_IT is set */
    bitstatus = SET;
 800474c:	bf0c      	ite	eq
 800474e:	2000      	moveq	r0, #0
 8004750:	2001      	movne	r0, #1
    /* SPI_I2S_IT is reset */
    bitstatus = RESET;
  }
  /* Return the SPI_I2S_IT status */
  return bitstatus;
}
 8004752:	bd10      	pop	{r4, pc}

08004754 <TI1_Config>:
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
 8004754:	b530      	push	{r4, r5, lr}
  uint32_t tmpccmr1 = 0, tmpccer = 0;

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint32_t)~TIM_CCER_CC1E;
 8004756:	6a04      	ldr	r4, [r0, #32]
  tmpccmr1 &= ((uint32_t)~TIM_CCMR1_CC1S) & ((uint32_t)~TIM_CCMR1_IC1F);
  tmpccmr1 |= (uint32_t)(TIM_ICSelection | (uint32_t)((uint32_t)TIM_ICFilter << 4));

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= (uint32_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
  tmpccer |= (uint32_t)(TIM_ICPolarity | (uint32_t)TIM_CCER_CC1E);
 8004758:	f041 0101 	orr.w	r1, r1, #1
                       uint16_t TIM_ICFilter)
{
  uint32_t tmpccmr1 = 0, tmpccer = 0;

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint32_t)~TIM_CCER_CC1E;
 800475c:	f024 0401 	bic.w	r4, r4, #1
 8004760:	6204      	str	r4, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
 8004762:	6985      	ldr	r5, [r0, #24]
  tmpccer = TIMx->CCER;
 8004764:	6a04      	ldr	r4, [r0, #32]

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint32_t)~TIM_CCMR1_CC1S) & ((uint32_t)~TIM_CCMR1_IC1F);
 8004766:	f025 05f3 	bic.w	r5, r5, #243	; 0xf3
  tmpccmr1 |= (uint32_t)(TIM_ICSelection | (uint32_t)((uint32_t)TIM_ICFilter << 4));
 800476a:	432a      	orrs	r2, r5

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= (uint32_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 800476c:	f024 040a 	bic.w	r4, r4, #10
  tmpccmr1 = TIMx->CCMR1;
  tmpccer = TIMx->CCER;

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint32_t)~TIM_CCMR1_CC1S) & ((uint32_t)~TIM_CCMR1_IC1F);
  tmpccmr1 |= (uint32_t)(TIM_ICSelection | (uint32_t)((uint32_t)TIM_ICFilter << 4));
 8004770:	ea42 1303 	orr.w	r3, r2, r3, lsl #4

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= (uint32_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
  tmpccer |= (uint32_t)(TIM_ICPolarity | (uint32_t)TIM_CCER_CC1E);
 8004774:	430c      	orrs	r4, r1

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1;
 8004776:	6183      	str	r3, [r0, #24]
  TIMx->CCER = tmpccer;
 8004778:	6204      	str	r4, [r0, #32]
 800477a:	bd30      	pop	{r4, r5, pc}

0800477c <TI2_Config>:
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
                       uint16_t TIM_ICFilter)
{
 800477c:	b530      	push	{r4, r5, lr}
  uint32_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
 800477e:	6a05      	ldr	r5, [r0, #32]
 8004780:	f64f 74ef 	movw	r4, #65519	; 0xffef
 8004784:	402c      	ands	r4, r5
 8004786:	6204      	str	r4, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
 8004788:	6984      	ldr	r4, [r0, #24]
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 4);
 800478a:	0109      	lsls	r1, r1, #4

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint32_t)~TIM_CCMR1_CC2S) & ((uint32_t)~TIM_CCMR1_IC2F);
 800478c:	f424 4473 	bic.w	r4, r4, #62208	; 0xf300
  uint32_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
  tmpccmr1 = TIMx->CCMR1;
  tmpccer = TIMx->CCER;
 8004790:	6a05      	ldr	r5, [r0, #32]
  tmp = (uint16_t)(TIM_ICPolarity << 4);

  /* Select the Input and set the filter */
  tmpccmr1 &= ((uint32_t)~TIM_CCMR1_CC2S) & ((uint32_t)~TIM_CCMR1_IC2F);
  tmpccmr1 |= (uint32_t)((uint32_t)TIM_ICFilter << 12);
 8004792:	ea44 2202 	orr.w	r2, r4, r2, lsl #8
  tmpccmr1 |= (uint32_t)((uint32_t)TIM_ICSelection << 8);
 8004796:	ea42 3303 	orr.w	r3, r2, r3, lsl #12

  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 800479a:	f64f 745f 	movw	r4, #65375	; 0xff5f
  tmpccer |=  (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);
 800479e:	f041 0210 	orr.w	r2, r1, #16
  tmpccmr1 &= ((uint32_t)~TIM_CCMR1_CC2S) & ((uint32_t)~TIM_CCMR1_IC2F);
  tmpccmr1 |= (uint32_t)((uint32_t)TIM_ICFilter << 12);
  tmpccmr1 |= (uint32_t)((uint32_t)TIM_ICSelection << 8);

  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 80047a2:	402c      	ands	r4, r5
  tmpccer |=  (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);
 80047a4:	b292      	uxth	r2, r2
 80047a6:	4314      	orrs	r4, r2

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1 ;
 80047a8:	6183      	str	r3, [r0, #24]
  TIMx->CCER = tmpccer;
 80047aa:	6204      	str	r4, [r0, #32]
 80047ac:	bd30      	pop	{r4, r5, pc}

080047ae <TIM_DeInit>:
  * @param  TIMx: where x can be 1, 2, 3, 4, 6 ,7 ,8, 15, 16 or 17 to select the TIM peripheral.
  * @retval None

  */
void TIM_DeInit(TIM_TypeDef* TIMx)
{
 80047ae:	b508      	push	{r3, lr}
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
 
  if (TIMx == TIM1)
 80047b0:	4b36      	ldr	r3, [pc, #216]	; (800488c <TIM_DeInit+0xde>)
 80047b2:	4298      	cmp	r0, r3
 80047b4:	d107      	bne.n	80047c6 <TIM_DeInit+0x18>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
 80047b6:	f44f 6000 	mov.w	r0, #2048	; 0x800
 80047ba:	2101      	movs	r1, #1
 80047bc:	f7ff fd82 	bl	80042c4 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
 80047c0:	f44f 6000 	mov.w	r0, #2048	; 0x800
 80047c4:	e05b      	b.n	800487e <TIM_DeInit+0xd0>
  } 
  else if (TIMx == TIM2) 
 80047c6:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 80047ca:	d105      	bne.n	80047d8 <TIM_DeInit+0x2a>
  {     
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
 80047cc:	2001      	movs	r0, #1
 80047ce:	4601      	mov	r1, r0
 80047d0:	f7ff fd84 	bl	80042dc <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
 80047d4:	2001      	movs	r0, #1
 80047d6:	e007      	b.n	80047e8 <TIM_DeInit+0x3a>
  }  
  else if (TIMx == TIM3)
 80047d8:	4b2d      	ldr	r3, [pc, #180]	; (8004890 <TIM_DeInit+0xe2>)
 80047da:	4298      	cmp	r0, r3
 80047dc:	d109      	bne.n	80047f2 <TIM_DeInit+0x44>
  { 
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
 80047de:	2002      	movs	r0, #2
 80047e0:	2101      	movs	r1, #1
 80047e2:	f7ff fd7b 	bl	80042dc <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
 80047e6:	2002      	movs	r0, #2
 80047e8:	2100      	movs	r1, #0
    {     
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, ENABLE);
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, DISABLE); 
    }   
  }
}
 80047ea:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
  }  
  else if (TIMx == TIM3)
  { 
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
 80047ee:	f7ff bd75 	b.w	80042dc <RCC_APB1PeriphResetCmd>
  }  
  else if (TIMx == TIM4)
 80047f2:	4b28      	ldr	r3, [pc, #160]	; (8004894 <TIM_DeInit+0xe6>)
 80047f4:	4298      	cmp	r0, r3
 80047f6:	d105      	bne.n	8004804 <TIM_DeInit+0x56>
  { 
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
 80047f8:	2004      	movs	r0, #4
 80047fa:	2101      	movs	r1, #1
 80047fc:	f7ff fd6e 	bl	80042dc <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
 8004800:	2004      	movs	r0, #4
 8004802:	e7f1      	b.n	80047e8 <TIM_DeInit+0x3a>
  }   
  else if (TIMx == TIM6)  
 8004804:	4b24      	ldr	r3, [pc, #144]	; (8004898 <TIM_DeInit+0xea>)
 8004806:	4298      	cmp	r0, r3
 8004808:	d105      	bne.n	8004816 <TIM_DeInit+0x68>
  {    
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
 800480a:	2010      	movs	r0, #16
 800480c:	2101      	movs	r1, #1
 800480e:	f7ff fd65 	bl	80042dc <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
 8004812:	2010      	movs	r0, #16
 8004814:	e7e8      	b.n	80047e8 <TIM_DeInit+0x3a>
  }  
  else if (TIMx == TIM7)
 8004816:	4b21      	ldr	r3, [pc, #132]	; (800489c <TIM_DeInit+0xee>)
 8004818:	4298      	cmp	r0, r3
 800481a:	d105      	bne.n	8004828 <TIM_DeInit+0x7a>
  {      
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
 800481c:	2020      	movs	r0, #32
 800481e:	2101      	movs	r1, #1
 8004820:	f7ff fd5c 	bl	80042dc <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
 8004824:	2020      	movs	r0, #32
 8004826:	e7df      	b.n	80047e8 <TIM_DeInit+0x3a>
  }  
  else if (TIMx == TIM8)
 8004828:	4b1d      	ldr	r3, [pc, #116]	; (80048a0 <TIM_DeInit+0xf2>)
 800482a:	4298      	cmp	r0, r3
 800482c:	d107      	bne.n	800483e <TIM_DeInit+0x90>
  {      
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
 800482e:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 8004832:	2101      	movs	r1, #1
 8004834:	f7ff fd46 	bl	80042c4 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);  
 8004838:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 800483c:	e01f      	b.n	800487e <TIM_DeInit+0xd0>
  }    
  else if (TIMx == TIM15)
 800483e:	4b19      	ldr	r3, [pc, #100]	; (80048a4 <TIM_DeInit+0xf6>)
 8004840:	4298      	cmp	r0, r3
 8004842:	d107      	bne.n	8004854 <TIM_DeInit+0xa6>
  {      
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM15, ENABLE);
 8004844:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 8004848:	2101      	movs	r1, #1
 800484a:	f7ff fd3b 	bl	80042c4 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM15, DISABLE);  
 800484e:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 8004852:	e014      	b.n	800487e <TIM_DeInit+0xd0>
  }  
  else if (TIMx == TIM16) 
 8004854:	4b14      	ldr	r3, [pc, #80]	; (80048a8 <TIM_DeInit+0xfa>)
 8004856:	4298      	cmp	r0, r3
 8004858:	d107      	bne.n	800486a <TIM_DeInit+0xbc>
  {       
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM16, ENABLE);
 800485a:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 800485e:	2101      	movs	r1, #1
 8004860:	f7ff fd30 	bl	80042c4 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM16, DISABLE);  
 8004864:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 8004868:	e009      	b.n	800487e <TIM_DeInit+0xd0>
  }  
  else
  { 
    if (TIMx == TIM17) 
 800486a:	4b10      	ldr	r3, [pc, #64]	; (80048ac <TIM_DeInit+0xfe>)
 800486c:	4298      	cmp	r0, r3
 800486e:	d10b      	bne.n	8004888 <TIM_DeInit+0xda>
    {     
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, ENABLE);
 8004870:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 8004874:	2101      	movs	r1, #1
 8004876:	f7ff fd25 	bl	80042c4 <RCC_APB2PeriphResetCmd>
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, DISABLE); 
 800487a:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 800487e:	2100      	movs	r1, #0
    }   
  }
}
 8004880:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  else
  { 
    if (TIMx == TIM17) 
    {     
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, ENABLE);
      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, DISABLE); 
 8004884:	f7ff bd1e 	b.w	80042c4 <RCC_APB2PeriphResetCmd>
 8004888:	bd08      	pop	{r3, pc}
 800488a:	bf00      	nop
 800488c:	40012c00 	.word	0x40012c00
 8004890:	40000400 	.word	0x40000400
 8004894:	40000800 	.word	0x40000800
 8004898:	40001000 	.word	0x40001000
 800489c:	40001400 	.word	0x40001400
 80048a0:	40013400 	.word	0x40013400
 80048a4:	40014000 	.word	0x40014000
 80048a8:	40014400 	.word	0x40014400
 80048ac:	40014800 	.word	0x40014800

080048b0 <TIM_TimeBaseInit>:
  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));

  tmpcr1 = TIMx->CR1;  

  if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM2) || 
 80048b0:	4a20      	ldr	r2, [pc, #128]	; (8004934 <TIM_TimeBaseInit+0x84>)
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));

  tmpcr1 = TIMx->CR1;  
 80048b2:	8803      	ldrh	r3, [r0, #0]

  if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM2) || 
 80048b4:	4290      	cmp	r0, r2
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));

  tmpcr1 = TIMx->CR1;  
 80048b6:	b29b      	uxth	r3, r3

  if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM2) || 
 80048b8:	d00e      	beq.n	80048d8 <TIM_TimeBaseInit+0x28>
 80048ba:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 80048be:	4290      	cmp	r0, r2
 80048c0:	d00a      	beq.n	80048d8 <TIM_TimeBaseInit+0x28>
 80048c2:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 80048c6:	d007      	beq.n	80048d8 <TIM_TimeBaseInit+0x28>
 80048c8:	f5a2 3298 	sub.w	r2, r2, #77824	; 0x13000
 80048cc:	4290      	cmp	r0, r2
 80048ce:	d003      	beq.n	80048d8 <TIM_TimeBaseInit+0x28>
     (TIMx == TIM3)|| (TIMx == TIM4)) 
 80048d0:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80048d4:	4290      	cmp	r0, r2
 80048d6:	d103      	bne.n	80048e0 <TIM_TimeBaseInit+0x30>
  {
    /* Select the Counter Mode */
    tmpcr1 &= (uint16_t)(~(TIM_CR1_DIR | TIM_CR1_CMS));
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
 80048d8:	884a      	ldrh	r2, [r1, #2]

  if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM2) || 
     (TIMx == TIM3)|| (TIMx == TIM4)) 
  {
    /* Select the Counter Mode */
    tmpcr1 &= (uint16_t)(~(TIM_CR1_DIR | TIM_CR1_CMS));
 80048da:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
 80048de:	4313      	orrs	r3, r2
  }
 
  if((TIMx != TIM6) && (TIMx != TIM7))
 80048e0:	4a15      	ldr	r2, [pc, #84]	; (8004938 <TIM_TimeBaseInit+0x88>)
 80048e2:	4290      	cmp	r0, r2
 80048e4:	d008      	beq.n	80048f8 <TIM_TimeBaseInit+0x48>
 80048e6:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80048ea:	4290      	cmp	r0, r2
 80048ec:	d004      	beq.n	80048f8 <TIM_TimeBaseInit+0x48>
  {
    /* Set the clock division */
    tmpcr1 &=  (uint16_t)(~TIM_CR1_CKD);
 80048ee:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
 80048f2:	890a      	ldrh	r2, [r1, #8]
  }
 
  if((TIMx != TIM6) && (TIMx != TIM7))
  {
    /* Set the clock division */
    tmpcr1 &=  (uint16_t)(~TIM_CR1_CKD);
 80048f4:	b29b      	uxth	r3, r3
    tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
 80048f6:	4313      	orrs	r3, r2
  }

  TIMx->CR1 = tmpcr1;
 80048f8:	8003      	strh	r3, [r0, #0]

  /* Set the Autoreload value */
  TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
 80048fa:	684b      	ldr	r3, [r1, #4]
 80048fc:	62c3      	str	r3, [r0, #44]	; 0x2c
 
  /* Set the Prescaler value */
  TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
 80048fe:	880b      	ldrh	r3, [r1, #0]
 8004900:	8503      	strh	r3, [r0, #40]	; 0x28
    
  if ((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM15) || 
 8004902:	4b0c      	ldr	r3, [pc, #48]	; (8004934 <TIM_TimeBaseInit+0x84>)
 8004904:	4298      	cmp	r0, r3
 8004906:	d00f      	beq.n	8004928 <TIM_TimeBaseInit+0x78>
 8004908:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 800490c:	4298      	cmp	r0, r3
 800490e:	d00b      	beq.n	8004928 <TIM_TimeBaseInit+0x78>
 8004910:	f503 6340 	add.w	r3, r3, #3072	; 0xc00
 8004914:	4298      	cmp	r0, r3
 8004916:	d007      	beq.n	8004928 <TIM_TimeBaseInit+0x78>
 8004918:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800491c:	4298      	cmp	r0, r3
 800491e:	d003      	beq.n	8004928 <TIM_TimeBaseInit+0x78>
      (TIMx == TIM16) || (TIMx == TIM17))  
 8004920:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8004924:	4298      	cmp	r0, r3
 8004926:	d101      	bne.n	800492c <TIM_TimeBaseInit+0x7c>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
 8004928:	7a8b      	ldrb	r3, [r1, #10]
 800492a:	8603      	strh	r3, [r0, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler 
     and the repetition counter(only for TIM1 and TIM8) value immediatly */
  TIMx->EGR = TIM_PSCReloadMode_Immediate;          
 800492c:	2301      	movs	r3, #1
 800492e:	6143      	str	r3, [r0, #20]
 8004930:	4770      	bx	lr
 8004932:	bf00      	nop
 8004934:	40012c00 	.word	0x40012c00
 8004938:	40001000 	.word	0x40001000

0800493c <TIM_TimeBaseStructInit>:
  * @retval None
  */
void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
{
  /* Set the default configuration */
  TIM_TimeBaseInitStruct->TIM_Period = 0xFFFFFFFF;
 800493c:	f04f 33ff 	mov.w	r3, #4294967295
 8004940:	6043      	str	r3, [r0, #4]
  TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
 8004942:	2300      	movs	r3, #0
 8004944:	8003      	strh	r3, [r0, #0]
  TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
 8004946:	8103      	strh	r3, [r0, #8]
  TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
 8004948:	8043      	strh	r3, [r0, #2]
  TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
 800494a:	7283      	strb	r3, [r0, #10]
 800494c:	4770      	bx	lr

0800494e <TIM_PrescalerConfig>:
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
  /* Set the Prescaler value */
  TIMx->PSC = Prescaler;
 800494e:	8501      	strh	r1, [r0, #40]	; 0x28
  /* Set or reset the UG Bit */
  TIMx->EGR = TIM_PSCReloadMode;
 8004950:	6142      	str	r2, [r0, #20]
 8004952:	4770      	bx	lr

08004954 <TIM_CounterModeConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));

  tmpcr1 = TIMx->CR1;
 8004954:	8803      	ldrh	r3, [r0, #0]

  /* Reset the CMS and DIR Bits */
  tmpcr1 &= (uint16_t)~(TIM_CR1_DIR | TIM_CR1_CMS);
 8004956:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800495a:	041b      	lsls	r3, r3, #16
 800495c:	0c1b      	lsrs	r3, r3, #16

  /* Set the Counter Mode */
  tmpcr1 |= TIM_CounterMode;
 800495e:	4319      	orrs	r1, r3

  /* Write to TIMx CR1 register */
  TIMx->CR1 = tmpcr1;
 8004960:	8001      	strh	r1, [r0, #0]
 8004962:	4770      	bx	lr

08004964 <TIM_SetCounter>:
{
  /* Check the parameters */
   assert_param(IS_TIM_ALL_PERIPH(TIMx));

  /* Set the Counter Register value */
  TIMx->CNT = Counter;
 8004964:	6241      	str	r1, [r0, #36]	; 0x24
 8004966:	4770      	bx	lr

08004968 <TIM_SetAutoreload>:
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  
  /* Set the Autoreload Register value */
  TIMx->ARR = Autoreload;
 8004968:	62c1      	str	r1, [r0, #44]	; 0x2c
 800496a:	4770      	bx	lr

0800496c <TIM_GetCounter>:
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));

  /* Get the Counter Register value */
  return TIMx->CNT;
 800496c:	6a40      	ldr	r0, [r0, #36]	; 0x24
}
 800496e:	4770      	bx	lr

08004970 <TIM_GetPrescaler>:
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));

  /* Get the Prescaler Register value */
  return TIMx->PSC;
 8004970:	8d00      	ldrh	r0, [r0, #40]	; 0x28
}
 8004972:	b280      	uxth	r0, r0
 8004974:	4770      	bx	lr

08004976 <TIM_UpdateDisableConfig>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Set the Update Disable Bit */
    TIMx->CR1 |= TIM_CR1_UDIS;
 8004976:	8803      	ldrh	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8004978:	b119      	cbz	r1, 8004982 <TIM_UpdateDisableConfig+0xc>
  {
    /* Set the Update Disable Bit */
    TIMx->CR1 |= TIM_CR1_UDIS;
 800497a:	b29b      	uxth	r3, r3
 800497c:	f043 0302 	orr.w	r3, r3, #2
 8004980:	e003      	b.n	800498a <TIM_UpdateDisableConfig+0x14>
  }
  else
  {
    /* Reset the Update Disable Bit */
    TIMx->CR1 &= (uint16_t)~TIM_CR1_UDIS;
 8004982:	f023 0302 	bic.w	r3, r3, #2
 8004986:	041b      	lsls	r3, r3, #16
 8004988:	0c1b      	lsrs	r3, r3, #16
 800498a:	8003      	strh	r3, [r0, #0]
 800498c:	4770      	bx	lr

0800498e <TIM_UpdateRequestConfig>:
  assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));

  if (TIM_UpdateSource != TIM_UpdateSource_Global)
  {
    /* Set the URS Bit */
    TIMx->CR1 |= TIM_CR1_URS;
 800498e:	8803      	ldrh	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));

  if (TIM_UpdateSource != TIM_UpdateSource_Global)
 8004990:	b119      	cbz	r1, 800499a <TIM_UpdateRequestConfig+0xc>
  {
    /* Set the URS Bit */
    TIMx->CR1 |= TIM_CR1_URS;
 8004992:	b29b      	uxth	r3, r3
 8004994:	f043 0304 	orr.w	r3, r3, #4
 8004998:	e003      	b.n	80049a2 <TIM_UpdateRequestConfig+0x14>
  }
  else
  {
    /* Reset the URS Bit */
    TIMx->CR1 &= (uint16_t)~TIM_CR1_URS;
 800499a:	f023 0304 	bic.w	r3, r3, #4
 800499e:	041b      	lsls	r3, r3, #16
 80049a0:	0c1b      	lsrs	r3, r3, #16
 80049a2:	8003      	strh	r3, [r0, #0]
 80049a4:	4770      	bx	lr

080049a6 <TIM_UIFRemap>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the TIM Counter */
    TIMx->CR1 |= TIM_CR1_UIFREMAP;
 80049a6:	8803      	ldrh	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80049a8:	b119      	cbz	r1, 80049b2 <TIM_UIFRemap+0xc>
  {
    /* Enable the TIM Counter */
    TIMx->CR1 |= TIM_CR1_UIFREMAP;
 80049aa:	b29b      	uxth	r3, r3
 80049ac:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 80049b0:	e003      	b.n	80049ba <TIM_UIFRemap+0x14>
  }
  else
  {
    /* Disable the TIM Counter */
    TIMx->CR1 &= (uint16_t)~TIM_CR1_UIFREMAP;
 80049b2:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 80049b6:	041b      	lsls	r3, r3, #16
 80049b8:	0c1b      	lsrs	r3, r3, #16
 80049ba:	8003      	strh	r3, [r0, #0]
 80049bc:	4770      	bx	lr

080049be <TIM_ARRPreloadConfig>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Set the ARR Preload Bit */
    TIMx->CR1 |= TIM_CR1_ARPE;
 80049be:	8803      	ldrh	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80049c0:	b119      	cbz	r1, 80049ca <TIM_ARRPreloadConfig+0xc>
  {
    /* Set the ARR Preload Bit */
    TIMx->CR1 |= TIM_CR1_ARPE;
 80049c2:	b29b      	uxth	r3, r3
 80049c4:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80049c8:	e003      	b.n	80049d2 <TIM_ARRPreloadConfig+0x14>
  }
  else
  {
    /* Reset the ARR Preload Bit */
    TIMx->CR1 &= (uint16_t)~TIM_CR1_ARPE;
 80049ca:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 80049ce:	041b      	lsls	r3, r3, #16
 80049d0:	0c1b      	lsrs	r3, r3, #16
 80049d2:	8003      	strh	r3, [r0, #0]
 80049d4:	4770      	bx	lr

080049d6 <TIM_SelectOnePulseMode>:
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_OPM_MODE(TIM_OPMode));

  /* Reset the OPM Bit */
  TIMx->CR1 &= (uint16_t)~TIM_CR1_OPM;
 80049d6:	8803      	ldrh	r3, [r0, #0]
 80049d8:	f023 0308 	bic.w	r3, r3, #8
 80049dc:	041b      	lsls	r3, r3, #16
 80049de:	0c1b      	lsrs	r3, r3, #16
 80049e0:	8003      	strh	r3, [r0, #0]

  /* Configure the OPM Mode */
  TIMx->CR1 |= TIM_OPMode;
 80049e2:	8803      	ldrh	r3, [r0, #0]
 80049e4:	b29b      	uxth	r3, r3
 80049e6:	4319      	orrs	r1, r3
 80049e8:	8001      	strh	r1, [r0, #0]
 80049ea:	4770      	bx	lr

080049ec <TIM_SetClockDivision>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_CKD_DIV(TIM_CKD));

  /* Reset the CKD Bits */
  TIMx->CR1 &= (uint16_t)(~TIM_CR1_CKD);
 80049ec:	8803      	ldrh	r3, [r0, #0]
 80049ee:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 80049f2:	041b      	lsls	r3, r3, #16
 80049f4:	0c1b      	lsrs	r3, r3, #16
 80049f6:	8003      	strh	r3, [r0, #0]

  /* Set the CKD value */
  TIMx->CR1 |= TIM_CKD;
 80049f8:	8803      	ldrh	r3, [r0, #0]
 80049fa:	b29b      	uxth	r3, r3
 80049fc:	4319      	orrs	r1, r3
 80049fe:	8001      	strh	r1, [r0, #0]
 8004a00:	4770      	bx	lr

08004a02 <TIM_Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the TIM Counter */
    TIMx->CR1 |= TIM_CR1_CEN;
 8004a02:	8803      	ldrh	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8004a04:	b119      	cbz	r1, 8004a0e <TIM_Cmd+0xc>
  {
    /* Enable the TIM Counter */
    TIMx->CR1 |= TIM_CR1_CEN;
 8004a06:	b29b      	uxth	r3, r3
 8004a08:	f043 0301 	orr.w	r3, r3, #1
 8004a0c:	e003      	b.n	8004a16 <TIM_Cmd+0x14>
  }
  else
  {
    /* Disable the TIM Counter */
    TIMx->CR1 &= (uint16_t)~TIM_CR1_CEN;
 8004a0e:	f023 0301 	bic.w	r3, r3, #1
 8004a12:	041b      	lsls	r3, r3, #16
 8004a14:	0c1b      	lsrs	r3, r3, #16
 8004a16:	8003      	strh	r3, [r0, #0]
 8004a18:	4770      	bx	lr

08004a1a <TIM_OC1Init>:
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint32_t)~TIM_CCER_CC1E;
 8004a1a:	6a03      	ldr	r3, [r0, #32]
  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 8004a1c:	b530      	push	{r4, r5, lr}
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= (uint32_t)~TIM_CCER_CC1E;
 8004a1e:	f023 0301 	bic.w	r3, r3, #1
 8004a22:	6203      	str	r3, [r0, #32]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8004a24:	6a03      	ldr	r3, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8004a26:	6842      	ldr	r2, [r0, #4]
  
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 8004a28:	6985      	ldr	r5, [r0, #24]
    
  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= (uint32_t)~TIM_CCMR1_OC1M;
  tmpccmrx &= (uint32_t)~TIM_CCMR1_CC1S;
  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
 8004a2a:	680c      	ldr	r4, [r1, #0]
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
    
  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= (uint32_t)~TIM_CCMR1_OC1M;
  tmpccmrx &= (uint32_t)~TIM_CCMR1_CC1S;
 8004a2c:	f425 3580 	bic.w	r5, r5, #65536	; 0x10000
 8004a30:	f025 0573 	bic.w	r5, r5, #115	; 0x73
  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
 8004a34:	432c      	orrs	r4, r5
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC1P;
  /* Set the Output Compare Polarity */
  tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
 8004a36:	898d      	ldrh	r5, [r1, #12]
  tmpccmrx &= (uint32_t)~TIM_CCMR1_CC1S;
  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC1P;
 8004a38:	f023 0302 	bic.w	r3, r3, #2
  /* Set the Output Compare Polarity */
  tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
 8004a3c:	432b      	orrs	r3, r5
  
  /* Set the Output State */
  tmpccer |= TIM_OCInitStruct->TIM_OutputState;
 8004a3e:	888d      	ldrh	r5, [r1, #4]
 8004a40:	432b      	orrs	r3, r5
    
  if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM15) || (TIMx == TIM16) || (TIMx == TIM17))
 8004a42:	4d13      	ldr	r5, [pc, #76]	; (8004a90 <TIM_OC1Init+0x76>)
 8004a44:	42a8      	cmp	r0, r5
 8004a46:	d00f      	beq.n	8004a68 <TIM_OC1Init+0x4e>
 8004a48:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 8004a4c:	42a8      	cmp	r0, r5
 8004a4e:	d00b      	beq.n	8004a68 <TIM_OC1Init+0x4e>
 8004a50:	f505 6540 	add.w	r5, r5, #3072	; 0xc00
 8004a54:	42a8      	cmp	r0, r5
 8004a56:	d007      	beq.n	8004a68 <TIM_OC1Init+0x4e>
 8004a58:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8004a5c:	42a8      	cmp	r0, r5
 8004a5e:	d003      	beq.n	8004a68 <TIM_OC1Init+0x4e>
 8004a60:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8004a64:	42a8      	cmp	r0, r5
 8004a66:	d10d      	bne.n	8004a84 <TIM_OC1Init+0x6a>
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= (uint32_t)~TIM_CCER_CC1NP;
    /* Set the Output N Polarity */
    tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
 8004a68:	89cd      	ldrh	r5, [r1, #14]
    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= (uint32_t)~TIM_CCER_CC1NP;
 8004a6a:	f023 0308 	bic.w	r3, r3, #8
    /* Set the Output N Polarity */
    tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
 8004a6e:	432b      	orrs	r3, r5
    /* Reset the Output N State */
    tmpccer &= (uint32_t)~TIM_CCER_CC1NE;
    
    /* Set the Output N State */
    tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
 8004a70:	88cd      	ldrh	r5, [r1, #6]
    /* Reset the Output N Polarity level */
    tmpccer &= (uint32_t)~TIM_CCER_CC1NP;
    /* Set the Output N Polarity */
    tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
    /* Reset the Output N State */
    tmpccer &= (uint32_t)~TIM_CCER_CC1NE;
 8004a72:	f023 0304 	bic.w	r3, r3, #4
    
    /* Set the Output N State */
    tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
 8004a76:	432b      	orrs	r3, r5
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint32_t)~TIM_CR2_OIS1;
    tmpcr2 &= (uint32_t)~TIM_CR2_OIS1N;
    /* Set the Output Idle state */
    tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
 8004a78:	8a0d      	ldrh	r5, [r1, #16]
    
    /* Set the Output N State */
    tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint32_t)~TIM_CR2_OIS1;
    tmpcr2 &= (uint32_t)~TIM_CR2_OIS1N;
 8004a7a:	f422 7240 	bic.w	r2, r2, #768	; 0x300
    /* Set the Output Idle state */
    tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
 8004a7e:	432a      	orrs	r2, r5
    /* Set the Output N Idle state */
    tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
 8004a80:	8a4d      	ldrh	r5, [r1, #18]
 8004a82:	432a      	orrs	r2, r5
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8004a84:	6042      	str	r2, [r0, #4]
  
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
  
  /* Set the Capture Compare Register value */
  TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse;
 8004a86:	688a      	ldr	r2, [r1, #8]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
  
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 8004a88:	6184      	str	r4, [r0, #24]
  
  /* Set the Capture Compare Register value */
  TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse;
 8004a8a:	6342      	str	r2, [r0, #52]	; 0x34
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8004a8c:	6203      	str	r3, [r0, #32]
 8004a8e:	bd30      	pop	{r4, r5, pc}
 8004a90:	40012c00 	.word	0x40012c00

08004a94 <TIM_OC2Init>:
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint32_t)~TIM_CCER_CC2E;
 8004a94:	6a03      	ldr	r3, [r0, #32]
  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 8004a96:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= (uint32_t)~TIM_CCER_CC2E;
 8004a98:	f023 0310 	bic.w	r3, r3, #16
 8004a9c:	6203      	str	r3, [r0, #32]
  
  /* Get the TIMx CCER register value */  
  tmpccer = TIMx->CCER;
 8004a9e:	6a05      	ldr	r5, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8004aa0:	6842      	ldr	r2, [r0, #4]
  
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 8004aa2:	6983      	ldr	r3, [r0, #24]
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint32_t)~TIM_CCMR1_OC2M;
  tmpccmrx &= (uint32_t)~TIM_CCMR1_CC2S;
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint32_t)(TIM_OCInitStruct->TIM_OCMode << 8);
 8004aa4:	680c      	ldr	r4, [r1, #0]
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint32_t)~TIM_CCMR1_OC2M;
  tmpccmrx &= (uint32_t)~TIM_CCMR1_CC2S;
 8004aa6:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8004aaa:	f423 43e6 	bic.w	r3, r3, #29440	; 0x7300
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint32_t)(TIM_OCInitStruct->TIM_OCMode << 8);
 8004aae:	ea43 2404 	orr.w	r4, r3, r4, lsl #8
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC2P;
  /* Set the Output Compare Polarity */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCPolarity << 4);
 8004ab2:	898e      	ldrh	r6, [r1, #12]
  
  /* Set the Output State */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputState << 4);
 8004ab4:	888b      	ldrh	r3, [r1, #4]
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint32_t)(TIM_OCInitStruct->TIM_OCMode << 8);
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC2P;
 8004ab6:	f025 0520 	bic.w	r5, r5, #32
  /* Set the Output Compare Polarity */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCPolarity << 4);
 8004aba:	4333      	orrs	r3, r6
  
  /* Set the Output State */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputState << 4);
 8004abc:	ea45 1303 	orr.w	r3, r5, r3, lsl #4
    
  if((TIMx == TIM1) || (TIMx == TIM8))
 8004ac0:	4d0e      	ldr	r5, [pc, #56]	; (8004afc <TIM_OC2Init+0x68>)
 8004ac2:	42a8      	cmp	r0, r5
 8004ac4:	d003      	beq.n	8004ace <TIM_OC2Init+0x3a>
 8004ac6:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 8004aca:	42a8      	cmp	r0, r5
 8004acc:	d110      	bne.n	8004af0 <TIM_OC2Init+0x5c>
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= (uint32_t)~TIM_CCER_CC2NP;
    /* Set the Output N Polarity */
    tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCNPolarity << 4);
 8004ace:	89cd      	ldrh	r5, [r1, #14]
    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= (uint32_t)~TIM_CCER_CC2NP;
 8004ad0:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    /* Set the Output N Polarity */
    tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCNPolarity << 4);
 8004ad4:	ea43 1305 	orr.w	r3, r3, r5, lsl #4
    /* Reset the Output N State */
    tmpccer &= (uint32_t)~TIM_CCER_CC2NE;
    
    /* Set the Output N State */
    tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputNState << 4);
 8004ad8:	88cd      	ldrh	r5, [r1, #6]
    /* Reset the Output N Polarity level */
    tmpccer &= (uint32_t)~TIM_CCER_CC2NP;
    /* Set the Output N Polarity */
    tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCNPolarity << 4);
    /* Reset the Output N State */
    tmpccer &= (uint32_t)~TIM_CCER_CC2NE;
 8004ada:	f023 0340 	bic.w	r3, r3, #64	; 0x40
    
    /* Set the Output N State */
    tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputNState << 4);
 8004ade:	ea43 1305 	orr.w	r3, r3, r5, lsl #4
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint32_t)~TIM_CR2_OIS2;
    tmpcr2 &= (uint32_t)~TIM_CR2_OIS2N;
    /* Set the Output Idle state */
    tmpcr2 |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCIdleState << 2);
 8004ae2:	8a0e      	ldrh	r6, [r1, #16]
    /* Set the Output N Idle state */
    tmpcr2 |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCNIdleState << 2);
 8004ae4:	8a4d      	ldrh	r5, [r1, #18]
    
    /* Set the Output N State */
    tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputNState << 4);
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint32_t)~TIM_CR2_OIS2;
    tmpcr2 &= (uint32_t)~TIM_CR2_OIS2N;
 8004ae6:	f422 6240 	bic.w	r2, r2, #3072	; 0xc00
    /* Set the Output Idle state */
    tmpcr2 |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCIdleState << 2);
 8004aea:	4335      	orrs	r5, r6
    /* Set the Output N Idle state */
    tmpcr2 |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCNIdleState << 2);
 8004aec:	ea42 0285 	orr.w	r2, r2, r5, lsl #2
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8004af0:	6042      	str	r2, [r0, #4]
  
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
  
  /* Set the Capture Compare Register value */
  TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
 8004af2:	688a      	ldr	r2, [r1, #8]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
  
  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 8004af4:	6184      	str	r4, [r0, #24]
  
  /* Set the Capture Compare Register value */
  TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
 8004af6:	6382      	str	r2, [r0, #56]	; 0x38
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8004af8:	6203      	str	r3, [r0, #32]
 8004afa:	bd70      	pop	{r4, r5, r6, pc}
 8004afc:	40012c00 	.word	0x40012c00

08004b00 <TIM_OC3Init>:
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= (uint32_t)~TIM_CCER_CC3E;
 8004b00:	6a03      	ldr	r3, [r0, #32]
  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 8004b02:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= (uint32_t)~TIM_CCER_CC3E;
 8004b04:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8004b08:	6203      	str	r3, [r0, #32]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8004b0a:	6a05      	ldr	r5, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8004b0c:	6842      	ldr	r2, [r0, #4]
  
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 8004b0e:	69c3      	ldr	r3, [r0, #28]
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint32_t)~TIM_CCMR2_OC3M;
  tmpccmrx &= (uint32_t)~TIM_CCMR2_CC3S;  
  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
 8004b10:	680c      	ldr	r4, [r1, #0]
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint32_t)~TIM_CCMR2_OC3M;
  tmpccmrx &= (uint32_t)~TIM_CCMR2_CC3S;  
 8004b12:	f023 0373 	bic.w	r3, r3, #115	; 0x73
  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
 8004b16:	431c      	orrs	r4, r3
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC3P;
  /* Set the Output Compare Polarity */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCPolarity << 8);
 8004b18:	898e      	ldrh	r6, [r1, #12]
  
  /* Set the Output State */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputState << 8);
 8004b1a:	888b      	ldrh	r3, [r1, #4]
  tmpccmrx &= (uint32_t)~TIM_CCMR2_CC3S;  
  /* Select the Output Compare Mode */
  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC3P;
 8004b1c:	f425 7500 	bic.w	r5, r5, #512	; 0x200
  /* Set the Output Compare Polarity */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCPolarity << 8);
 8004b20:	4333      	orrs	r3, r6
  
  /* Set the Output State */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputState << 8);
 8004b22:	ea45 2303 	orr.w	r3, r5, r3, lsl #8
    
  if((TIMx == TIM1) || (TIMx == TIM8))
 8004b26:	4d0f      	ldr	r5, [pc, #60]	; (8004b64 <TIM_OC3Init+0x64>)
 8004b28:	42a8      	cmp	r0, r5
 8004b2a:	d003      	beq.n	8004b34 <TIM_OC3Init+0x34>
 8004b2c:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 8004b30:	42a8      	cmp	r0, r5
 8004b32:	d110      	bne.n	8004b56 <TIM_OC3Init+0x56>
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= (uint32_t)~TIM_CCER_CC3NP;
    /* Set the Output N Polarity */
    tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCNPolarity << 8);
 8004b34:	89cd      	ldrh	r5, [r1, #14]
    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    
    /* Reset the Output N Polarity level */
    tmpccer &= (uint32_t)~TIM_CCER_CC3NP;
 8004b36:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
    /* Set the Output N Polarity */
    tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCNPolarity << 8);
 8004b3a:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
    /* Reset the Output N State */
    tmpccer &= (uint32_t)~TIM_CCER_CC3NE;
    
    /* Set the Output N State */
    tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputNState << 8);
 8004b3e:	88cd      	ldrh	r5, [r1, #6]
    /* Reset the Output N Polarity level */
    tmpccer &= (uint32_t)~TIM_CCER_CC3NP;
    /* Set the Output N Polarity */
    tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCNPolarity << 8);
    /* Reset the Output N State */
    tmpccer &= (uint32_t)~TIM_CCER_CC3NE;
 8004b40:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
    
    /* Set the Output N State */
    tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputNState << 8);
 8004b44:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint32_t)~TIM_CR2_OIS3;
    tmpcr2 &= (uint32_t)~TIM_CR2_OIS3N;
    /* Set the Output Idle state */
    tmpcr2 |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCIdleState << 4);
 8004b48:	8a0e      	ldrh	r6, [r1, #16]
    /* Set the Output N Idle state */
    tmpcr2 |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCNIdleState << 4);
 8004b4a:	8a4d      	ldrh	r5, [r1, #18]
    
    /* Set the Output N State */
    tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputNState << 8);
    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= (uint32_t)~TIM_CR2_OIS3;
    tmpcr2 &= (uint32_t)~TIM_CR2_OIS3N;
 8004b4c:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
    /* Set the Output Idle state */
    tmpcr2 |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCIdleState << 4);
 8004b50:	4335      	orrs	r5, r6
    /* Set the Output N Idle state */
    tmpcr2 |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCNIdleState << 4);
 8004b52:	ea42 1205 	orr.w	r2, r2, r5, lsl #4
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8004b56:	6042      	str	r2, [r0, #4]
  
  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
  
  /* Set the Capture Compare Register value */
  TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
 8004b58:	688a      	ldr	r2, [r1, #8]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
  
  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 8004b5a:	61c4      	str	r4, [r0, #28]
  
  /* Set the Capture Compare Register value */
  TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
 8004b5c:	63c2      	str	r2, [r0, #60]	; 0x3c
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8004b5e:	6203      	str	r3, [r0, #32]
 8004b60:	bd70      	pop	{r4, r5, r6, pc}
 8004b62:	bf00      	nop
 8004b64:	40012c00 	.word	0x40012c00

08004b68 <TIM_OC4Init>:
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= (uint32_t)~TIM_CCER_CC4E;
 8004b68:	6a03      	ldr	r3, [r0, #32]
  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 8004b6a:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= (uint32_t)~TIM_CCER_CC4E;
 8004b6c:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8004b70:	6203      	str	r3, [r0, #32]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8004b72:	6a05      	ldr	r5, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8004b74:	6843      	ldr	r3, [r0, #4]
  
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 8004b76:	69c4      	ldr	r4, [r0, #28]
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint32_t)~TIM_CCMR2_OC4M;
  tmpccmrx &= (uint32_t)~TIM_CCMR2_CC4S;
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint32_t)(TIM_OCInitStruct->TIM_OCMode << 8);
 8004b78:	680a      	ldr	r2, [r1, #0]
  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
    
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint32_t)~TIM_CCMR2_OC4M;
  tmpccmrx &= (uint32_t)~TIM_CCMR2_CC4S;
 8004b7a:	f424 44e6 	bic.w	r4, r4, #29440	; 0x7300
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint32_t)(TIM_OCInitStruct->TIM_OCMode << 8);
 8004b7e:	ea44 2202 	orr.w	r2, r4, r2, lsl #8
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC4P;
  /* Set the Output Compare Polarity */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCPolarity << 12);
 8004b82:	898e      	ldrh	r6, [r1, #12]
  
  /* Set the Output State */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputState << 12);
 8004b84:	888c      	ldrh	r4, [r1, #4]
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint32_t)(TIM_OCInitStruct->TIM_OCMode << 8);
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC4P;
 8004b86:	f425 5500 	bic.w	r5, r5, #8192	; 0x2000
  /* Set the Output Compare Polarity */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCPolarity << 12);
 8004b8a:	4334      	orrs	r4, r6
  
  /* Set the Output State */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputState << 12);
 8004b8c:	ea45 3404 	orr.w	r4, r5, r4, lsl #12
  
  if((TIMx == TIM1) || (TIMx == TIM8))
 8004b90:	4d08      	ldr	r5, [pc, #32]	; (8004bb4 <TIM_OC4Init+0x4c>)
 8004b92:	42a8      	cmp	r0, r5
 8004b94:	d003      	beq.n	8004b9e <TIM_OC4Init+0x36>
 8004b96:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 8004b9a:	42a8      	cmp	r0, r5
 8004b9c:	d104      	bne.n	8004ba8 <TIM_OC4Init+0x40>
  {
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    /* Reset the Output Compare IDLE State */
    tmpcr2 &=(uint32_t) ~TIM_CR2_OIS4;
    /* Set the Output Idle state */
    tmpcr2 |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCIdleState << 6);
 8004b9e:	8a0d      	ldrh	r5, [r1, #16]
  
  if((TIMx == TIM1) || (TIMx == TIM8))
  {
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    /* Reset the Output Compare IDLE State */
    tmpcr2 &=(uint32_t) ~TIM_CR2_OIS4;
 8004ba0:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
    /* Set the Output Idle state */
    tmpcr2 |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCIdleState << 6);
 8004ba4:	ea43 1385 	orr.w	r3, r3, r5, lsl #6
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8004ba8:	6043      	str	r3, [r0, #4]
  
  /* Write to TIMx CCMR2 */  
  TIMx->CCMR2 = tmpccmrx;
    
  /* Set the Capture Compare Register value */
  TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
 8004baa:	688b      	ldr	r3, [r1, #8]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
  
  /* Write to TIMx CCMR2 */  
  TIMx->CCMR2 = tmpccmrx;
 8004bac:	61c2      	str	r2, [r0, #28]
    
  /* Set the Capture Compare Register value */
  TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
 8004bae:	6403      	str	r3, [r0, #64]	; 0x40
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8004bb0:	6204      	str	r4, [r0, #32]
 8004bb2:	bd70      	pop	{r4, r5, r6, pc}
 8004bb4:	40012c00 	.word	0x40012c00

08004bb8 <TIM_OC5Init>:
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 5: Reset the CC5E Bit */
  TIMx->CCER &= (uint32_t)~TIM_CCER_CC5E; /* to be verified*/
 8004bb8:	6a03      	ldr	r3, [r0, #32]
  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_OC5Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 8004bba:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 5: Reset the CC5E Bit */
  TIMx->CCER &= (uint32_t)~TIM_CCER_CC5E; /* to be verified*/
 8004bbc:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8004bc0:	6203      	str	r3, [r0, #32]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8004bc2:	6a05      	ldr	r5, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8004bc4:	6843      	ldr	r3, [r0, #4]
  
  /* Get the TIMx CCMR3 register value */
  tmpccmrx = TIMx->CCMR3;
 8004bc6:	6d44      	ldr	r4, [r0, #84]	; 0x54
  
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint32_t)~TIM_CCMR3_OC5M;
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint32_t)(TIM_OCInitStruct->TIM_OCMode);
 8004bc8:	680a      	ldr	r2, [r1, #0]
  
  /* Get the TIMx CCMR3 register value */
  tmpccmrx = TIMx->CCMR3;
  
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint32_t)~TIM_CCMR3_OC5M;
 8004bca:	f024 0470 	bic.w	r4, r4, #112	; 0x70
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint32_t)(TIM_OCInitStruct->TIM_OCMode);
 8004bce:	4322      	orrs	r2, r4
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC5P;
  /* Set the Output Compare Polarity */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCPolarity << 16);
 8004bd0:	898e      	ldrh	r6, [r1, #12]

  /* Set the Output State */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputState << 16);
 8004bd2:	888c      	ldrh	r4, [r1, #4]
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint32_t)(TIM_OCInitStruct->TIM_OCMode);
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC5P;
 8004bd4:	f425 3500 	bic.w	r5, r5, #131072	; 0x20000
  /* Set the Output Compare Polarity */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCPolarity << 16);
 8004bd8:	4334      	orrs	r4, r6

  /* Set the Output State */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputState << 16);
 8004bda:	ea45 4404 	orr.w	r4, r5, r4, lsl #16
  
  if((TIMx == TIM1) || (TIMx == TIM8))
 8004bde:	4d09      	ldr	r5, [pc, #36]	; (8004c04 <TIM_OC5Init+0x4c>)
 8004be0:	42a8      	cmp	r0, r5
 8004be2:	d003      	beq.n	8004bec <TIM_OC5Init+0x34>
 8004be4:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 8004be8:	42a8      	cmp	r0, r5
 8004bea:	d104      	bne.n	8004bf6 <TIM_OC5Init+0x3e>
  {
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    /* Reset the Output Compare IDLE State */
    tmpcr2 &=(uint32_t) ~TIM_CR2_OIS5;
    /* Set the Output Idle state */
    tmpcr2 |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCIdleState << 16);
 8004bec:	8a0d      	ldrh	r5, [r1, #16]
  
  if((TIMx == TIM1) || (TIMx == TIM8))
  {
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    /* Reset the Output Compare IDLE State */
    tmpcr2 &=(uint32_t) ~TIM_CR2_OIS5;
 8004bee:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
    /* Set the Output Idle state */
    tmpcr2 |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCIdleState << 16);
 8004bf2:	ea43 4305 	orr.w	r3, r3, r5, lsl #16
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8004bf6:	6043      	str	r3, [r0, #4]
  
  /* Write to TIMx CCMR2 */  
  TIMx->CCMR3 = tmpccmrx;
    
  /* Set the Capture Compare Register value */
  TIMx->CCR5 = TIM_OCInitStruct->TIM_Pulse;
 8004bf8:	688b      	ldr	r3, [r1, #8]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
  
  /* Write to TIMx CCMR2 */  
  TIMx->CCMR3 = tmpccmrx;
 8004bfa:	6542      	str	r2, [r0, #84]	; 0x54
    
  /* Set the Capture Compare Register value */
  TIMx->CCR5 = TIM_OCInitStruct->TIM_Pulse;
 8004bfc:	6583      	str	r3, [r0, #88]	; 0x58
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8004bfe:	6204      	str	r4, [r0, #32]
 8004c00:	bd70      	pop	{r4, r5, r6, pc}
 8004c02:	bf00      	nop
 8004c04:	40012c00 	.word	0x40012c00

08004c08 <TIM_OC6Init>:
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 5: Reset the CC5E Bit */
  TIMx->CCER &= (uint32_t)~TIM_CCER_CC6E; /* to be verified*/
 8004c08:	6a03      	ldr	r3, [r0, #32]
  * @param  TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_OC6Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
{
 8004c0a:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   

  /* Disable the Channel 5: Reset the CC5E Bit */
  TIMx->CCER &= (uint32_t)~TIM_CCER_CC6E; /* to be verified*/
 8004c0c:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
 8004c10:	6203      	str	r3, [r0, #32]
  
  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8004c12:	6a05      	ldr	r5, [r0, #32]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8004c14:	6843      	ldr	r3, [r0, #4]
  
  /* Get the TIMx CCMR3 register value */
  tmpccmrx = TIMx->CCMR3;
 8004c16:	6d44      	ldr	r4, [r0, #84]	; 0x54
  
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint32_t)~TIM_CCMR3_OC6M;
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint32_t)(TIM_OCInitStruct->TIM_OCMode << 8);
 8004c18:	680a      	ldr	r2, [r1, #0]
  
  /* Get the TIMx CCMR3 register value */
  tmpccmrx = TIMx->CCMR3;
  
  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= (uint32_t)~TIM_CCMR3_OC6M;
 8004c1a:	f424 44e0 	bic.w	r4, r4, #28672	; 0x7000
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint32_t)(TIM_OCInitStruct->TIM_OCMode << 8);
 8004c1e:	ea44 2202 	orr.w	r2, r4, r2, lsl #8
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC6P;
  /* Set the Output Compare Polarity */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCPolarity << 20);
 8004c22:	898e      	ldrh	r6, [r1, #12]

  /* Set the Output State */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputState << 20);
 8004c24:	888c      	ldrh	r4, [r1, #4]
  
  /* Select the Output Compare Mode */
  tmpccmrx |= (uint32_t)(TIM_OCInitStruct->TIM_OCMode << 8);
  
  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC6P;
 8004c26:	f425 1500 	bic.w	r5, r5, #2097152	; 0x200000
  /* Set the Output Compare Polarity */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OCPolarity << 20);
 8004c2a:	4334      	orrs	r4, r6

  /* Set the Output State */
  tmpccer |= (uint32_t)((uint32_t)TIM_OCInitStruct->TIM_OutputState << 20);
 8004c2c:	ea45 5404 	orr.w	r4, r5, r4, lsl #20
  
  if((TIMx == TIM1) || (TIMx == TIM8))
 8004c30:	4d07      	ldr	r5, [pc, #28]	; (8004c50 <TIM_OC6Init+0x48>)
 8004c32:	42a8      	cmp	r0, r5
 8004c34:	d003      	beq.n	8004c3e <TIM_OC6Init+0x36>
 8004c36:	f505 6500 	add.w	r5, r5, #2048	; 0x800
 8004c3a:	42a8      	cmp	r0, r5
 8004c3c:	d101      	bne.n	8004c42 <TIM_OC6Init+0x3a>
  {
    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
    /* Reset the Output Compare IDLE State */
    tmpcr2 &=(uint32_t) ~TIM_CR2_OIS6;
 8004c3e:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
    /* Set the Output Idle state */
    tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 18);
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8004c42:	6043      	str	r3, [r0, #4]
  
  /* Write to TIMx CCMR2 */  
  TIMx->CCMR3 = tmpccmrx;
    
  /* Set the Capture Compare Register value */
  TIMx->CCR6 = TIM_OCInitStruct->TIM_Pulse;
 8004c44:	688b      	ldr	r3, [r1, #8]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
  
  /* Write to TIMx CCMR2 */  
  TIMx->CCMR3 = tmpccmrx;
 8004c46:	6542      	str	r2, [r0, #84]	; 0x54
    
  /* Set the Capture Compare Register value */
  TIMx->CCR6 = TIM_OCInitStruct->TIM_Pulse;
 8004c48:	65c3      	str	r3, [r0, #92]	; 0x5c
  
  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8004c4a:	6204      	str	r4, [r0, #32]
 8004c4c:	bd70      	pop	{r4, r5, r6, pc}
 8004c4e:	bf00      	nop
 8004c50:	40012c00 	.word	0x40012c00

08004c54 <TIM_SelectGC5C1>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Set the GC5C1 Bit */
    TIMx->CCR5 |= TIM_CCR5_GC5C1;
 8004c54:	6d83      	ldr	r3, [r0, #88]	; 0x58
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8004c56:	b111      	cbz	r1, 8004c5e <TIM_SelectGC5C1+0xa>
  {
    /* Set the GC5C1 Bit */
    TIMx->CCR5 |= TIM_CCR5_GC5C1;
 8004c58:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8004c5c:	e001      	b.n	8004c62 <TIM_SelectGC5C1+0xe>
  }
  else
  {
    /* Reset the GC5C1 Bit */
    TIMx->CCR5 &= (uint32_t)~TIM_CCR5_GC5C1;
 8004c5e:	f023 5300 	bic.w	r3, r3, #536870912	; 0x20000000
 8004c62:	6583      	str	r3, [r0, #88]	; 0x58
 8004c64:	4770      	bx	lr

08004c66 <TIM_SelectGC5C2>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Set the GC5C2 Bit */
    TIMx->CCR5 |= TIM_CCR5_GC5C2;
 8004c66:	6d83      	ldr	r3, [r0, #88]	; 0x58
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8004c68:	b111      	cbz	r1, 8004c70 <TIM_SelectGC5C2+0xa>
  {
    /* Set the GC5C2 Bit */
    TIMx->CCR5 |= TIM_CCR5_GC5C2;
 8004c6a:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8004c6e:	e001      	b.n	8004c74 <TIM_SelectGC5C2+0xe>
  }
  else
  {
    /* Reset the GC5C2 Bit */
    TIMx->CCR5 &= (uint32_t)~TIM_CCR5_GC5C2;
 8004c70:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 8004c74:	6583      	str	r3, [r0, #88]	; 0x58
 8004c76:	4770      	bx	lr

08004c78 <TIM_SelectGC5C3>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Set the GC5C3 Bit */
    TIMx->CCR5 |= TIM_CCR5_GC5C3;
 8004c78:	6d83      	ldr	r3, [r0, #88]	; 0x58
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8004c7a:	b111      	cbz	r1, 8004c82 <TIM_SelectGC5C3+0xa>
  {
    /* Set the GC5C3 Bit */
    TIMx->CCR5 |= TIM_CCR5_GC5C3;
 8004c7c:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8004c80:	e001      	b.n	8004c86 <TIM_SelectGC5C3+0xe>
  }
  else
  {
    /* Reset the GC5C3 Bit */
    TIMx->CCR5 &= (uint32_t)~TIM_CCR5_GC5C3;
 8004c82:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8004c86:	6583      	str	r3, [r0, #88]	; 0x58
 8004c88:	4770      	bx	lr

08004c8a <TIM_OCStructInit>:
  * @retval None
  */
void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
{
  /* Set the default configuration */
  TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
 8004c8a:	2300      	movs	r3, #0
 8004c8c:	6003      	str	r3, [r0, #0]
  TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
 8004c8e:	8083      	strh	r3, [r0, #4]
  TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
 8004c90:	80c3      	strh	r3, [r0, #6]
  TIM_OCInitStruct->TIM_Pulse = 0x00000000;
 8004c92:	6083      	str	r3, [r0, #8]
  TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
 8004c94:	8183      	strh	r3, [r0, #12]
  TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
 8004c96:	81c3      	strh	r3, [r0, #14]
  TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
 8004c98:	8203      	strh	r3, [r0, #16]
  TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
 8004c9a:	8243      	strh	r3, [r0, #18]
 8004c9c:	4770      	bx	lr

08004c9e <TIM_SelectOCxM>:
  *            @arg TIM_OCMode_Asymmetric_PWM1
  *            @arg TIM_OCMode_Asymmetric_PWM2            
  * @retval None
  */
void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint32_t TIM_OCMode) /* to be updated*/
{
 8004c9e:	b530      	push	{r4, r5, lr}
  assert_param(IS_TIM_OCM(TIM_OCMode));

  tmp = (uint32_t) TIMx;
  tmp += CCMR_OFFSET;

  tmp1 = CCER_CCE_SET << (uint16_t)TIM_Channel;
 8004ca0:	2401      	movs	r4, #1
 8004ca2:	fa04 f401 	lsl.w	r4, r4, r1

  /* Disable the Channel: Reset the CCxE Bit */
  TIMx->CCER &= (uint16_t) ~tmp1;
 8004ca6:	6a05      	ldr	r5, [r0, #32]
 8004ca8:	43e4      	mvns	r4, r4
 8004caa:	b2a4      	uxth	r4, r4
 8004cac:	402c      	ands	r4, r5
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_CHANNEL(TIM_Channel));
  assert_param(IS_TIM_OCM(TIM_OCMode));

  tmp = (uint32_t) TIMx;
  tmp += CCMR_OFFSET;
 8004cae:	f100 0318 	add.w	r3, r0, #24

  tmp1 = CCER_CCE_SET << (uint16_t)TIM_Channel;

  /* Disable the Channel: Reset the CCxE Bit */
  TIMx->CCER &= (uint16_t) ~tmp1;
 8004cb2:	6204      	str	r4, [r0, #32]

  if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
 8004cb4:	b109      	cbz	r1, 8004cba <TIM_SelectOCxM+0x1c>
 8004cb6:	2908      	cmp	r1, #8
 8004cb8:	d108      	bne.n	8004ccc <TIM_SelectOCxM+0x2e>
  {
    tmp += (TIM_Channel>>1);
 8004cba:	0849      	lsrs	r1, r1, #1

    /* Reset the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp &= CCMR_OC13M_MASK;
 8004cbc:	58c8      	ldr	r0, [r1, r3]
 8004cbe:	f420 3080 	bic.w	r0, r0, #65536	; 0x10000
 8004cc2:	f020 0070 	bic.w	r0, r0, #112	; 0x70
 8004cc6:	50c8      	str	r0, [r1, r3]
   
    /* Configure the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp |= TIM_OCMode;
 8004cc8:	58c8      	ldr	r0, [r1, r3]
 8004cca:	e00a      	b.n	8004ce2 <TIM_SelectOCxM+0x44>
  }
  else
  {
    tmp += (uint32_t)(TIM_Channel - (uint32_t)4)>> (uint32_t)1;
 8004ccc:	3904      	subs	r1, #4
 8004cce:	0849      	lsrs	r1, r1, #1

    /* Reset the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp &= CCMR_OC24M_MASK;
 8004cd0:	58c8      	ldr	r0, [r1, r3]
    
    /* Configure the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);
 8004cd2:	0212      	lsls	r2, r2, #8
  else
  {
    tmp += (uint32_t)(TIM_Channel - (uint32_t)4)>> (uint32_t)1;

    /* Reset the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp &= CCMR_OC24M_MASK;
 8004cd4:	f020 7080 	bic.w	r0, r0, #16777216	; 0x1000000
 8004cd8:	f420 40e0 	bic.w	r0, r0, #28672	; 0x7000
 8004cdc:	50c8      	str	r0, [r1, r3]
    
    /* Configure the OCxM bits in the CCMRx register */
    *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);
 8004cde:	58c8      	ldr	r0, [r1, r3]
 8004ce0:	b292      	uxth	r2, r2
 8004ce2:	4302      	orrs	r2, r0
 8004ce4:	50ca      	str	r2, [r1, r3]
 8004ce6:	bd30      	pop	{r4, r5, pc}

08004ce8 <TIM_SetCompare1>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));

  /* Set the Capture Compare1 Register value */
  TIMx->CCR1 = Compare1;
 8004ce8:	6341      	str	r1, [r0, #52]	; 0x34
 8004cea:	4770      	bx	lr

08004cec <TIM_SetCompare2>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));

  /* Set the Capture Compare2 Register value */
  TIMx->CCR2 = Compare2;
 8004cec:	6381      	str	r1, [r0, #56]	; 0x38
 8004cee:	4770      	bx	lr

08004cf0 <TIM_SetCompare3>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));

  /* Set the Capture Compare3 Register value */
  TIMx->CCR3 = Compare3;
 8004cf0:	63c1      	str	r1, [r0, #60]	; 0x3c
 8004cf2:	4770      	bx	lr

08004cf4 <TIM_SetCompare4>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));

  /* Set the Capture Compare4 Register value */
  TIMx->CCR4 = Compare4;
 8004cf4:	6401      	str	r1, [r0, #64]	; 0x40
 8004cf6:	4770      	bx	lr

08004cf8 <TIM_SetCompare5>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));

  /* Set the Capture Compare5 Register value */
  TIMx->CCR5 = Compare5;
 8004cf8:	6581      	str	r1, [r0, #88]	; 0x58
 8004cfa:	4770      	bx	lr

08004cfc <TIM_SetCompare6>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));

  /* Set the Capture Compare6 Register value */
  TIMx->CCR6 = Compare6;
 8004cfc:	65c1      	str	r1, [r0, #92]	; 0x5c
 8004cfe:	4770      	bx	lr

08004d00 <TIM_ForcedOC1Config>:
  uint32_t tmpccmr1 = 0;

  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
  tmpccmr1 = TIMx->CCMR1;
 8004d00:	6983      	ldr	r3, [r0, #24]

  /* Reset the OC1M Bits */
  tmpccmr1 &= (uint32_t)~TIM_CCMR1_OC1M;
 8004d02:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8004d06:	f023 0370 	bic.w	r3, r3, #112	; 0x70

  /* Configure The Forced output Mode */
  tmpccmr1 |= TIM_ForcedAction;
 8004d0a:	4319      	orrs	r1, r3

  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 8004d0c:	6181      	str	r1, [r0, #24]
 8004d0e:	4770      	bx	lr

08004d10 <TIM_ForcedOC2Config>:
  uint32_t tmpccmr1 = 0;

  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
  tmpccmr1 = TIMx->CCMR1;
 8004d10:	6983      	ldr	r3, [r0, #24]

  /* Reset the OC2M Bits */
  tmpccmr1 &= (uint32_t)~TIM_CCMR1_OC2M;
 8004d12:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8004d16:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000

  /* Configure The Forced output Mode */
  tmpccmr1 |= ((uint32_t)TIM_ForcedAction << 8);
 8004d1a:	ea43 2101 	orr.w	r1, r3, r1, lsl #8

  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 8004d1e:	6181      	str	r1, [r0, #24]
 8004d20:	4770      	bx	lr

08004d22 <TIM_ForcedOC3Config>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));

  tmpccmr2 = TIMx->CCMR2;
 8004d22:	69c3      	ldr	r3, [r0, #28]

  /* Reset the OC1M Bits */
  tmpccmr2 &= (uint32_t)~TIM_CCMR2_OC3M;
 8004d24:	f023 0370 	bic.w	r3, r3, #112	; 0x70

  /* Configure The Forced output Mode */
  tmpccmr2 |= TIM_ForcedAction;
 8004d28:	4319      	orrs	r1, r3

  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 8004d2a:	61c1      	str	r1, [r0, #28]
 8004d2c:	4770      	bx	lr

08004d2e <TIM_ForcedOC4Config>:
  uint32_t tmpccmr2 = 0;

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
  tmpccmr2 = TIMx->CCMR2;
 8004d2e:	69c3      	ldr	r3, [r0, #28]

  /* Reset the OC2M Bits */
  tmpccmr2 &= (uint32_t)~TIM_CCMR2_OC4M;
 8004d30:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000

  /* Configure The Forced output Mode */
  tmpccmr2 |= ((uint32_t)TIM_ForcedAction << 8);
 8004d34:	ea43 2101 	orr.w	r1, r3, r1, lsl #8

  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 8004d38:	61c1      	str	r1, [r0, #28]
 8004d3a:	4770      	bx	lr

08004d3c <TIM_ForcedOC5Config>:
  uint32_t tmpccmr3 = 0;

  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
  tmpccmr3 = TIMx->CCMR3;
 8004d3c:	6d43      	ldr	r3, [r0, #84]	; 0x54

  /* Reset the OC5M Bits */
  tmpccmr3 &= (uint32_t)~TIM_CCMR3_OC5M;
 8004d3e:	f023 0370 	bic.w	r3, r3, #112	; 0x70

  /* Configure The Forced output Mode */
  tmpccmr3 |= (uint32_t)(TIM_ForcedAction);
 8004d42:	4319      	orrs	r1, r3

  /* Write to TIMx CCMR3 register */
  TIMx->CCMR3 = tmpccmr3;
 8004d44:	6541      	str	r1, [r0, #84]	; 0x54
 8004d46:	4770      	bx	lr

08004d48 <TIM_ForcedOC6Config>:
  uint32_t tmpccmr3 = 0;

  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
  tmpccmr3 = TIMx->CCMR3;
 8004d48:	6d43      	ldr	r3, [r0, #84]	; 0x54

  /* Reset the OC6M Bits */
  tmpccmr3 &= (uint32_t)~TIM_CCMR3_OC6M;
 8004d4a:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000

  /* Configure The Forced output Mode */
  tmpccmr3 |= ((uint32_t)TIM_ForcedAction << 8);
 8004d4e:	ea43 2101 	orr.w	r1, r3, r1, lsl #8

  /* Write to TIMx CCMR3 register */
  TIMx->CCMR3 = tmpccmr3;
 8004d52:	6541      	str	r1, [r0, #84]	; 0x54
 8004d54:	4770      	bx	lr

08004d56 <TIM_OC1PreloadConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));

  tmpccmr1 = TIMx->CCMR1;
 8004d56:	6983      	ldr	r3, [r0, #24]

  /* Reset the OC1PE Bit */
  tmpccmr1 &= (uint32_t)(~TIM_CCMR1_OC1PE);
 8004d58:	f023 0308 	bic.w	r3, r3, #8

  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr1 |= TIM_OCPreload;
 8004d5c:	4319      	orrs	r1, r3

  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 8004d5e:	6181      	str	r1, [r0, #24]
 8004d60:	4770      	bx	lr

08004d62 <TIM_OC2PreloadConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));

  tmpccmr1 = TIMx->CCMR1;
 8004d62:	6983      	ldr	r3, [r0, #24]

  /* Reset the OC2PE Bit */
  tmpccmr1 &= (uint32_t)(~TIM_CCMR1_OC2PE);
 8004d64:	f423 6300 	bic.w	r3, r3, #2048	; 0x800

  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr1 |= ((uint32_t)TIM_OCPreload << 8);
 8004d68:	ea43 2101 	orr.w	r1, r3, r1, lsl #8

  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 8004d6c:	6181      	str	r1, [r0, #24]
 8004d6e:	4770      	bx	lr

08004d70 <TIM_OC3PreloadConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));

  tmpccmr2 = TIMx->CCMR2;
 8004d70:	69c3      	ldr	r3, [r0, #28]

  /* Reset the OC3PE Bit */
  tmpccmr2 &= (uint32_t)(~TIM_CCMR2_OC3PE);
 8004d72:	f023 0308 	bic.w	r3, r3, #8

  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr2 |= TIM_OCPreload;
 8004d76:	4319      	orrs	r1, r3

  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 8004d78:	61c1      	str	r1, [r0, #28]
 8004d7a:	4770      	bx	lr

08004d7c <TIM_OC4PreloadConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));

  tmpccmr2 = TIMx->CCMR2;
 8004d7c:	69c3      	ldr	r3, [r0, #28]

  /* Reset the OC4PE Bit */
  tmpccmr2 &= (uint32_t)(~TIM_CCMR2_OC4PE);
 8004d7e:	f423 6300 	bic.w	r3, r3, #2048	; 0x800

  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr2 |= ((uint32_t)TIM_OCPreload << 8);
 8004d82:	ea43 2101 	orr.w	r1, r3, r1, lsl #8

  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 8004d86:	61c1      	str	r1, [r0, #28]
 8004d88:	4770      	bx	lr

08004d8a <TIM_OC5PreloadConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));

  tmpccmr3 = TIMx->CCMR3;
 8004d8a:	6d43      	ldr	r3, [r0, #84]	; 0x54

  /* Reset the OC5PE Bit */
  tmpccmr3 &= (uint32_t)(~TIM_CCMR3_OC5PE);
 8004d8c:	f023 0308 	bic.w	r3, r3, #8

  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr3 |= (uint32_t)(TIM_OCPreload);
 8004d90:	4319      	orrs	r1, r3

  /* Write to TIMx CCMR3 register */
  TIMx->CCMR3 = tmpccmr3;
 8004d92:	6541      	str	r1, [r0, #84]	; 0x54
 8004d94:	4770      	bx	lr

08004d96 <TIM_OC6PreloadConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));

  tmpccmr3 = TIMx->CCMR3;
 8004d96:	6d43      	ldr	r3, [r0, #84]	; 0x54

  /* Reset the OC5PE Bit */
  tmpccmr3 &= (uint32_t)(~TIM_CCMR3_OC6PE);
 8004d98:	f423 6300 	bic.w	r3, r3, #2048	; 0x800

  /* Enable or Disable the Output Compare Preload feature */
  tmpccmr3 |= ((uint32_t)TIM_OCPreload << 8);
 8004d9c:	ea43 2101 	orr.w	r1, r3, r1, lsl #8

  /* Write to TIMx CCMR3 register */
  TIMx->CCMR3 = tmpccmr3;
 8004da0:	6541      	str	r1, [r0, #84]	; 0x54
 8004da2:	4770      	bx	lr

08004da4 <TIM_OC1FastConfig>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));

  /* Get the TIMx CCMR1 register value */
  tmpccmr1 = TIMx->CCMR1;
 8004da4:	6983      	ldr	r3, [r0, #24]

  /* Reset the OC1FE Bit */
  tmpccmr1 &= (uint32_t)~TIM_CCMR1_OC1FE;
 8004da6:	f023 0304 	bic.w	r3, r3, #4

  /* Enable or Disable the Output Compare Fast Bit */
  tmpccmr1 |= TIM_OCFast;
 8004daa:	4319      	orrs	r1, r3

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmr1;
 8004dac:	6181      	str	r1, [r0, #24]
 8004dae:	4770      	bx	lr

08004db0 <TIM_OC2FastConfig>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));

  /* Get the TIMx CCMR1 register value */
  tmpccmr1 = TIMx->CCMR1;
 8004db0:	6983      	ldr	r3, [r0, #24]

  /* Reset the OC2FE Bit */
  tmpccmr1 &= (uint32_t)(~TIM_CCMR1_OC2FE);
 8004db2:	f423 6380 	bic.w	r3, r3, #1024	; 0x400

  /* Enable or Disable the Output Compare Fast Bit */
  tmpccmr1 |= ((uint32_t)TIM_OCFast << 8);
 8004db6:	ea43 2101 	orr.w	r1, r3, r1, lsl #8

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmr1;
 8004dba:	6181      	str	r1, [r0, #24]
 8004dbc:	4770      	bx	lr

08004dbe <TIM_OC3FastConfig>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));

  /* Get the TIMx CCMR2 register value */
  tmpccmr2 = TIMx->CCMR2;
 8004dbe:	69c3      	ldr	r3, [r0, #28]

  /* Reset the OC3FE Bit */
  tmpccmr2 &= (uint32_t)~TIM_CCMR2_OC3FE;
 8004dc0:	f023 0304 	bic.w	r3, r3, #4

  /* Enable or Disable the Output Compare Fast Bit */
  tmpccmr2 |= TIM_OCFast;
 8004dc4:	4319      	orrs	r1, r3

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmr2;
 8004dc6:	61c1      	str	r1, [r0, #28]
 8004dc8:	4770      	bx	lr

08004dca <TIM_OC4FastConfig>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));

  /* Get the TIMx CCMR2 register value */
  tmpccmr2 = TIMx->CCMR2;
 8004dca:	69c3      	ldr	r3, [r0, #28]

  /* Reset the OC4FE Bit */
  tmpccmr2 &= (uint32_t)(~TIM_CCMR2_OC4FE);
 8004dcc:	f423 6380 	bic.w	r3, r3, #1024	; 0x400

  /* Enable or Disable the Output Compare Fast Bit */
  tmpccmr2 |= ((uint32_t)TIM_OCFast << 8);
 8004dd0:	ea43 2101 	orr.w	r1, r3, r1, lsl #8

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmr2;
 8004dd4:	61c1      	str	r1, [r0, #28]
 8004dd6:	4770      	bx	lr

08004dd8 <TIM_ClearOC1Ref>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));

  tmpccmr1 = TIMx->CCMR1;
 8004dd8:	6983      	ldr	r3, [r0, #24]

  /* Reset the OC1CE Bit */
  tmpccmr1 &= (uint32_t)~TIM_CCMR1_OC1CE;
 8004dda:	f023 0380 	bic.w	r3, r3, #128	; 0x80

  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr1 |= TIM_OCClear;
 8004dde:	4319      	orrs	r1, r3

  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 8004de0:	6181      	str	r1, [r0, #24]
 8004de2:	4770      	bx	lr

08004de4 <TIM_ClearOC2Ref>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));

  tmpccmr1 = TIMx->CCMR1;
 8004de4:	6983      	ldr	r3, [r0, #24]

  /* Reset the OC2CE Bit */
  tmpccmr1 &= (uint32_t)~TIM_CCMR1_OC2CE;
 8004de6:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000

  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr1 |= ((uint32_t)TIM_OCClear << 8);
 8004dea:	ea43 2101 	orr.w	r1, r3, r1, lsl #8

  /* Write to TIMx CCMR1 register */
  TIMx->CCMR1 = tmpccmr1;
 8004dee:	6181      	str	r1, [r0, #24]
 8004df0:	4770      	bx	lr

08004df2 <TIM_ClearOC3Ref>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));

  tmpccmr2 = TIMx->CCMR2;
 8004df2:	69c3      	ldr	r3, [r0, #28]

  /* Reset the OC3CE Bit */
  tmpccmr2 &= (uint32_t)~TIM_CCMR2_OC3CE;
 8004df4:	f023 0380 	bic.w	r3, r3, #128	; 0x80

  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr2 |= TIM_OCClear;
 8004df8:	4319      	orrs	r1, r3

  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 8004dfa:	61c1      	str	r1, [r0, #28]
 8004dfc:	4770      	bx	lr

08004dfe <TIM_ClearOC4Ref>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));

  tmpccmr2 = TIMx->CCMR2;
 8004dfe:	69c3      	ldr	r3, [r0, #28]

  /* Reset the OC4CE Bit */
  tmpccmr2 &= (uint32_t)~TIM_CCMR2_OC4CE;
 8004e00:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000

  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr2 |= ((uint32_t)TIM_OCClear << 8);
 8004e04:	ea43 2101 	orr.w	r1, r3, r1, lsl #8

  /* Write to TIMx CCMR2 register */
  TIMx->CCMR2 = tmpccmr2;
 8004e08:	61c1      	str	r1, [r0, #28]
 8004e0a:	4770      	bx	lr

08004e0c <TIM_ClearOC5Ref>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));

  tmpccmr3 = TIMx->CCMR3;
 8004e0c:	6d43      	ldr	r3, [r0, #84]	; 0x54

  /* Reset the OC5CE Bit */
  tmpccmr3 &= (uint32_t)~TIM_CCMR3_OC5CE;
 8004e0e:	f023 0380 	bic.w	r3, r3, #128	; 0x80

  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr3 |= (uint32_t)(TIM_OCClear);
 8004e12:	4319      	orrs	r1, r3

  /* Write to TIMx CCMR3 register */
  TIMx->CCMR3 = tmpccmr3;
 8004e14:	6541      	str	r1, [r0, #84]	; 0x54
 8004e16:	4770      	bx	lr

08004e18 <TIM_ClearOC6Ref>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));

  tmpccmr3 = TIMx->CCMR3;
 8004e18:	6d43      	ldr	r3, [r0, #84]	; 0x54

  /* Reset the OC5CE Bit */
  tmpccmr3 &= (uint32_t)~TIM_CCMR3_OC6CE;
 8004e1a:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000

  /* Enable or Disable the Output Compare Clear Bit */
  tmpccmr3 |= ((uint32_t)TIM_OCClear << 8);
 8004e1e:	ea43 2101 	orr.w	r1, r3, r1, lsl #8

  /* Write to TIMx CCMR3 register */
  TIMx->CCMR3 = tmpccmr3;
 8004e22:	6541      	str	r1, [r0, #84]	; 0x54
 8004e24:	4770      	bx	lr

08004e26 <TIM_SelectOCREFClear>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(TIM_OCREFERENCECECLEAR_SOURCE(TIM_OCReferenceClear));

  /* Set the TIM_OCReferenceClear source */
  TIMx->SMCR &=  (uint16_t)~((uint16_t)TIM_SMCR_OCCS);
 8004e26:	6882      	ldr	r2, [r0, #8]
 8004e28:	f64f 73f7 	movw	r3, #65527	; 0xfff7
 8004e2c:	4013      	ands	r3, r2
 8004e2e:	6083      	str	r3, [r0, #8]
  TIMx->SMCR |=  TIM_OCReferenceClear;
 8004e30:	6883      	ldr	r3, [r0, #8]
 8004e32:	4319      	orrs	r1, r3
 8004e34:	6081      	str	r1, [r0, #8]
 8004e36:	4770      	bx	lr

08004e38 <TIM_OC1PolarityConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));

  tmpccer = TIMx->CCER;
 8004e38:	6a03      	ldr	r3, [r0, #32]

  /* Set or Reset the CC1P Bit */
  tmpccer &= (uint32_t)(~TIM_CCER_CC1P);
 8004e3a:	f023 0302 	bic.w	r3, r3, #2
  tmpccer |= TIM_OCPolarity;
 8004e3e:	4319      	orrs	r1, r3

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 8004e40:	6201      	str	r1, [r0, #32]
 8004e42:	4770      	bx	lr

08004e44 <TIM_OC1NPolarityConfig>:
  uint32_t tmpccer = 0;
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
   
  tmpccer = TIMx->CCER;
 8004e44:	6a03      	ldr	r3, [r0, #32]

  /* Set or Reset the CC1NP Bit */
  tmpccer &= (uint32_t)~TIM_CCER_CC1NP;
 8004e46:	f023 0308 	bic.w	r3, r3, #8
  tmpccer |= TIM_OCNPolarity;
 8004e4a:	4319      	orrs	r1, r3

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 8004e4c:	6201      	str	r1, [r0, #32]
 8004e4e:	4770      	bx	lr

08004e50 <TIM_OC2PolarityConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));

  tmpccer = TIMx->CCER;
 8004e50:	6a03      	ldr	r3, [r0, #32]

  /* Set or Reset the CC2P Bit */
  tmpccer &= (uint32_t)(~TIM_CCER_CC2P);
 8004e52:	f023 0320 	bic.w	r3, r3, #32
  tmpccer |= ((uint32_t)TIM_OCPolarity << 4);
 8004e56:	ea43 1101 	orr.w	r1, r3, r1, lsl #4

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 8004e5a:	6201      	str	r1, [r0, #32]
 8004e5c:	4770      	bx	lr

08004e5e <TIM_OC2NPolarityConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
  
  tmpccer = TIMx->CCER;
 8004e5e:	6a03      	ldr	r3, [r0, #32]

  /* Set or Reset the CC2NP Bit */
  tmpccer &= (uint32_t)~TIM_CCER_CC2NP;
 8004e60:	f023 0380 	bic.w	r3, r3, #128	; 0x80
  tmpccer |= ((uint32_t)TIM_OCNPolarity << 4);
 8004e64:	ea43 1101 	orr.w	r1, r3, r1, lsl #4

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 8004e68:	6201      	str	r1, [r0, #32]
 8004e6a:	4770      	bx	lr

08004e6c <TIM_OC3PolarityConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));

  tmpccer = TIMx->CCER;
 8004e6c:	6a03      	ldr	r3, [r0, #32]

  /* Set or Reset the CC3P Bit */
  tmpccer &= (uint32_t)~TIM_CCER_CC3P;
 8004e6e:	f423 7300 	bic.w	r3, r3, #512	; 0x200
  tmpccer |= ((uint32_t)TIM_OCPolarity << 8);
 8004e72:	ea43 2101 	orr.w	r1, r3, r1, lsl #8

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 8004e76:	6201      	str	r1, [r0, #32]
 8004e78:	4770      	bx	lr

08004e7a <TIM_OC3NPolarityConfig>:
 
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
    
  tmpccer = TIMx->CCER;
 8004e7a:	6a03      	ldr	r3, [r0, #32]

  /* Set or Reset the CC3NP Bit */
  tmpccer &= (uint32_t)~TIM_CCER_CC3NP;
 8004e7c:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
  tmpccer |= ((uint32_t)TIM_OCNPolarity << 8);
 8004e80:	ea43 2101 	orr.w	r1, r3, r1, lsl #8

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 8004e84:	6201      	str	r1, [r0, #32]
 8004e86:	4770      	bx	lr

08004e88 <TIM_OC4PolarityConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));

  tmpccer = TIMx->CCER;
 8004e88:	6a03      	ldr	r3, [r0, #32]

  /* Set or Reset the CC4P Bit */
  tmpccer &= (uint32_t)~TIM_CCER_CC4P;
 8004e8a:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
  tmpccer |= ((uint32_t)TIM_OCPolarity << 12);
 8004e8e:	ea43 3101 	orr.w	r1, r3, r1, lsl #12

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 8004e92:	6201      	str	r1, [r0, #32]
 8004e94:	4770      	bx	lr

08004e96 <TIM_OC5PolarityConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));

  tmpccer = TIMx->CCER;
 8004e96:	6a03      	ldr	r3, [r0, #32]

  /* Set or Reset the CC5P Bit */
  tmpccer &= (uint32_t)~TIM_CCER_CC5P;
 8004e98:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
  tmpccer |= ((uint32_t)TIM_OCPolarity << 16);
 8004e9c:	ea43 4101 	orr.w	r1, r3, r1, lsl #16

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 8004ea0:	6201      	str	r1, [r0, #32]
 8004ea2:	4770      	bx	lr

08004ea4 <TIM_OC6PolarityConfig>:

  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));

  tmpccer = TIMx->CCER;
 8004ea4:	6a03      	ldr	r3, [r0, #32]

  /* Set or Reset the CC6P Bit */
  tmpccer &= (uint32_t)~TIM_CCER_CC6P;
 8004ea6:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
  tmpccer |= ((uint32_t)TIM_OCPolarity << 20);
 8004eaa:	ea43 5101 	orr.w	r1, r3, r1, lsl #20

  /* Write to TIMx CCER register */
  TIMx->CCER = tmpccer;
 8004eae:	6201      	str	r1, [r0, #32]
 8004eb0:	4770      	bx	lr

08004eb2 <TIM_CCxCmd>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
  assert_param(IS_TIM_CHANNEL(TIM_Channel));
  assert_param(IS_TIM_CCX(TIM_CCx));

  tmp = (uint32_t)CCER_CCE_SET << (uint32_t)TIM_Channel;
 8004eb2:	2301      	movs	r3, #1
 8004eb4:	fa03 f301 	lsl.w	r3, r3, r1

  /* Reset the CCxE Bit */
  TIMx->CCER &= (uint32_t)(~tmp);

  /* Set or reset the CCxE Bit */ 
  TIMx->CCER |=  ((uint32_t)TIM_CCx << (uint32_t)TIM_Channel);
 8004eb8:	fa02 f201 	lsl.w	r2, r2, r1
  * @param  TIM_CCx: specifies the TIM Channel CCxE bit new state.
  *          This parameter can be: TIM_CCx_Enable or TIM_CCx_Disable. 
  * @retval None
  */
void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx)
{
 8004ebc:	b510      	push	{r4, lr}
  assert_param(IS_TIM_CCX(TIM_CCx));

  tmp = (uint32_t)CCER_CCE_SET << (uint32_t)TIM_Channel;

  /* Reset the CCxE Bit */
  TIMx->CCER &= (uint32_t)(~tmp);
 8004ebe:	6a04      	ldr	r4, [r0, #32]
 8004ec0:	ea24 0303 	bic.w	r3, r4, r3
 8004ec4:	6203      	str	r3, [r0, #32]

  /* Set or reset the CCxE Bit */ 
  TIMx->CCER |=  ((uint32_t)TIM_CCx << (uint32_t)TIM_Channel);
 8004ec6:	6a03      	ldr	r3, [r0, #32]
 8004ec8:	4313      	orrs	r3, r2
 8004eca:	6203      	str	r3, [r0, #32]
 8004ecc:	bd10      	pop	{r4, pc}

08004ece <TIM_CCxNCmd>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
  assert_param(IS_TIM_CCXN(TIM_CCxN));

  tmp = (uint32_t)CCER_CCNE_SET << (uint32_t)TIM_Channel;
 8004ece:	2304      	movs	r3, #4
 8004ed0:	fa03 f301 	lsl.w	r3, r3, r1

  /* Reset the CCxNE Bit */
  TIMx->CCER &= (uint32_t) ~tmp;

  /* Set or reset the CCxNE Bit */ 
  TIMx->CCER |=  ((uint32_t)TIM_CCxN << (uint32_t)TIM_Channel);
 8004ed4:	fa02 f201 	lsl.w	r2, r2, r1
  * @param  TIM_CCxN: specifies the TIM Channel CCxNE bit new state.
  *          This parameter can be: TIM_CCxN_Enable or TIM_CCxN_Disable. 
  * @retval None
  */
void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN)
{
 8004ed8:	b510      	push	{r4, lr}
  assert_param(IS_TIM_CCXN(TIM_CCxN));

  tmp = (uint32_t)CCER_CCNE_SET << (uint32_t)TIM_Channel;

  /* Reset the CCxNE Bit */
  TIMx->CCER &= (uint32_t) ~tmp;
 8004eda:	6a04      	ldr	r4, [r0, #32]
 8004edc:	ea24 0303 	bic.w	r3, r4, r3
 8004ee0:	6203      	str	r3, [r0, #32]

  /* Set or reset the CCxNE Bit */ 
  TIMx->CCER |=  ((uint32_t)TIM_CCxN << (uint32_t)TIM_Channel);
 8004ee2:	6a03      	ldr	r3, [r0, #32]
 8004ee4:	4313      	orrs	r3, r2
 8004ee6:	6203      	str	r3, [r0, #32]
 8004ee8:	bd10      	pop	{r4, pc}

08004eea <TIM_ICStructInit>:
  * @retval None
  */
void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
{
  /* Set the default configuration */
  TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
 8004eea:	2300      	movs	r3, #0
  TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
  TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
 8004eec:	2201      	movs	r2, #1
  * @retval None
  */
void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
{
  /* Set the default configuration */
  TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
 8004eee:	8003      	strh	r3, [r0, #0]
  TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
 8004ef0:	8043      	strh	r3, [r0, #2]
  TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
 8004ef2:	8082      	strh	r2, [r0, #4]
  TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
 8004ef4:	80c3      	strh	r3, [r0, #6]
  TIM_ICInitStruct->TIM_ICFilter = 0x00;
 8004ef6:	8103      	strh	r3, [r0, #8]
 8004ef8:	4770      	bx	lr

08004efa <TIM_GetCapture1>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));

  /* Get the Capture 1 Register value */
  return TIMx->CCR1;
 8004efa:	6b40      	ldr	r0, [r0, #52]	; 0x34
}
 8004efc:	4770      	bx	lr

08004efe <TIM_GetCapture2>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));

  /* Get the Capture 2 Register value */
  return TIMx->CCR2;
 8004efe:	6b80      	ldr	r0, [r0, #56]	; 0x38
}
 8004f00:	4770      	bx	lr

08004f02 <TIM_GetCapture3>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 

  /* Get the Capture 3 Register value */
  return TIMx->CCR3;
 8004f02:	6bc0      	ldr	r0, [r0, #60]	; 0x3c
}
 8004f04:	4770      	bx	lr

08004f06 <TIM_GetCapture4>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));

  /* Get the Capture 4 Register value */
  return TIMx->CCR4;
 8004f06:	6c00      	ldr	r0, [r0, #64]	; 0x40
}
 8004f08:	4770      	bx	lr

08004f0a <TIM_SetIC1Prescaler>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));

  /* Reset the IC1PSC Bits */
  TIMx->CCMR1 &= (uint32_t)~TIM_CCMR1_IC1PSC;
 8004f0a:	6983      	ldr	r3, [r0, #24]
 8004f0c:	f023 030c 	bic.w	r3, r3, #12
 8004f10:	6183      	str	r3, [r0, #24]

  /* Set the IC1PSC value */
  TIMx->CCMR1 |= TIM_ICPSC;
 8004f12:	6983      	ldr	r3, [r0, #24]
 8004f14:	4319      	orrs	r1, r3
 8004f16:	6181      	str	r1, [r0, #24]
 8004f18:	4770      	bx	lr

08004f1a <TIM_SetIC2Prescaler>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));

  /* Reset the IC2PSC Bits */
  TIMx->CCMR1 &= (uint32_t)~TIM_CCMR1_IC2PSC;
 8004f1a:	6983      	ldr	r3, [r0, #24]
 8004f1c:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
 8004f20:	6183      	str	r3, [r0, #24]

  /* Set the IC2PSC value */
  TIMx->CCMR1 |= (uint32_t)((uint32_t)TIM_ICPSC << 8);
 8004f22:	6983      	ldr	r3, [r0, #24]
 8004f24:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
 8004f28:	6181      	str	r1, [r0, #24]
 8004f2a:	4770      	bx	lr

08004f2c <TIM_PWMIConfig>:
  * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
{
 8004f2c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004f2e:	460c      	mov	r4, r1
  else
  {
    icoppositepolarity = TIM_ICPolarity_Rising;
  }
  /* Select the Opposite Input */
  if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
 8004f30:	88a2      	ldrh	r2, [r4, #4]

  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));

  /* Select the Opposite Input Polarity */
  if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
 8004f32:	8849      	ldrh	r1, [r1, #2]
  }
  else
  {
    icoppositeselection = TIM_ICSelection_DirectTI;
  }
  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
 8004f34:	f8b4 e000 	ldrh.w	lr, [r4]
  * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
{
 8004f38:	4605      	mov	r5, r0
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));

  /* Select the Opposite Input Polarity */
  if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
  {
    icoppositepolarity = TIM_ICPolarity_Falling;
 8004f3a:	2900      	cmp	r1, #0
 8004f3c:	bf0c      	ite	eq
 8004f3e:	2702      	moveq	r7, #2
 8004f40:	2700      	movne	r7, #0
    icoppositepolarity = TIM_ICPolarity_Rising;
  }
  /* Select the Opposite Input */
  if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
  {
    icoppositeselection = TIM_ICSelection_IndirectTI;
 8004f42:	2a01      	cmp	r2, #1
 8004f44:	bf14      	ite	ne
 8004f46:	2601      	movne	r6, #1
 8004f48:	2602      	moveq	r6, #2
 8004f4a:	8923      	ldrh	r3, [r4, #8]
  }
  else
  {
    icoppositeselection = TIM_ICSelection_DirectTI;
  }
  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
 8004f4c:	f1be 0f00 	cmp.w	lr, #0
 8004f50:	d111      	bne.n	8004f76 <TIM_PWMIConfig+0x4a>
  {
    /* TI1 Configuration */
    TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
 8004f52:	f7ff fbff 	bl	8004754 <TI1_Config>
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 8004f56:	4628      	mov	r0, r5
 8004f58:	88e1      	ldrh	r1, [r4, #6]
 8004f5a:	f7ff ffd6 	bl	8004f0a <TIM_SetIC1Prescaler>
    /* TI2 Configuration */
    TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
 8004f5e:	4628      	mov	r0, r5
 8004f60:	4639      	mov	r1, r7
 8004f62:	4632      	mov	r2, r6
 8004f64:	8923      	ldrh	r3, [r4, #8]
 8004f66:	f7ff fc09 	bl	800477c <TI2_Config>
    /* Set the Input Capture Prescaler value */
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 8004f6a:	88e1      	ldrh	r1, [r4, #6]
 8004f6c:	4628      	mov	r0, r5
    /* TI1 Configuration */
    TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
  }
}
 8004f6e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
    /* TI2 Configuration */
    TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 8004f72:	f7ff bfd2 	b.w	8004f1a <TIM_SetIC2Prescaler>
  }
  else
  { 
    /* TI2 Configuration */
    TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
 8004f76:	f7ff fc01 	bl	800477c <TI2_Config>
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 8004f7a:	4628      	mov	r0, r5
 8004f7c:	88e1      	ldrh	r1, [r4, #6]
 8004f7e:	f7ff ffcc 	bl	8004f1a <TIM_SetIC2Prescaler>
    /* TI1 Configuration */
    TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
 8004f82:	4628      	mov	r0, r5
 8004f84:	4639      	mov	r1, r7
 8004f86:	4632      	mov	r2, r6
 8004f88:	8923      	ldrh	r3, [r4, #8]
 8004f8a:	f7ff fbe3 	bl	8004754 <TI1_Config>
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 8004f8e:	88e1      	ldrh	r1, [r4, #6]
 8004f90:	4628      	mov	r0, r5
  }
}
 8004f92:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    /* Set the Input Capture Prescaler value */
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
    /* TI1 Configuration */
    TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 8004f96:	f7ff bfb8 	b.w	8004f0a <TIM_SetIC1Prescaler>

08004f9a <TIM_SetIC3Prescaler>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));

  /* Reset the IC3PSC Bits */
  TIMx->CCMR2 &= (uint16_t)~TIM_CCMR2_IC3PSC;
 8004f9a:	69c2      	ldr	r2, [r0, #28]
 8004f9c:	f64f 73f3 	movw	r3, #65523	; 0xfff3
 8004fa0:	4013      	ands	r3, r2
 8004fa2:	61c3      	str	r3, [r0, #28]

  /* Set the IC3PSC value */
  TIMx->CCMR2 |= TIM_ICPSC;
 8004fa4:	69c3      	ldr	r3, [r0, #28]
 8004fa6:	4319      	orrs	r1, r3
 8004fa8:	61c1      	str	r1, [r0, #28]
 8004faa:	4770      	bx	lr

08004fac <TIM_SetIC4Prescaler>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));

  /* Reset the IC4PSC Bits */
  TIMx->CCMR2 &= (uint16_t)~TIM_CCMR2_IC4PSC;
 8004fac:	69c2      	ldr	r2, [r0, #28]
 8004fae:	f24f 33ff 	movw	r3, #62463	; 0xf3ff
 8004fb2:	4013      	ands	r3, r2
 8004fb4:	61c3      	str	r3, [r0, #28]

  /* Set the IC4PSC value */
  TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
 8004fb6:	69c3      	ldr	r3, [r0, #28]
 8004fb8:	0209      	lsls	r1, r1, #8
 8004fba:	b289      	uxth	r1, r1
 8004fbc:	430b      	orrs	r3, r1
 8004fbe:	61c3      	str	r3, [r0, #28]
 8004fc0:	4770      	bx	lr

08004fc2 <TIM_ICInit>:
  * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
{
 8004fc2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
  assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
  assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
  
  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
 8004fc4:	880b      	ldrh	r3, [r1, #0]
  * @param  TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure that contains
  *         the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
{
 8004fc6:	460d      	mov	r5, r1
 8004fc8:	4604      	mov	r4, r0
 8004fca:	8849      	ldrh	r1, [r1, #2]
 8004fcc:	88aa      	ldrh	r2, [r5, #4]
  assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
  assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
  assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
  assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
  
  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
 8004fce:	b943      	cbnz	r3, 8004fe2 <TIM_ICInit+0x20>
  {
    /* TI1 Configuration */
    TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
 8004fd0:	892b      	ldrh	r3, [r5, #8]
 8004fd2:	f7ff fbbf 	bl	8004754 <TI1_Config>
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 8004fd6:	88e9      	ldrh	r1, [r5, #6]
 8004fd8:	4620      	mov	r0, r4
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
  }
}
 8004fda:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    /* TI1 Configuration */
    TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 8004fde:	f7ff bf94 	b.w	8004f0a <TIM_SetIC1Prescaler>
  }
  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
 8004fe2:	2b04      	cmp	r3, #4
 8004fe4:	d108      	bne.n	8004ff8 <TIM_ICInit+0x36>
  {
    /* TI2 Configuration */
    TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
 8004fe6:	892b      	ldrh	r3, [r5, #8]
 8004fe8:	f7ff fbc8 	bl	800477c <TI2_Config>
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 8004fec:	88e9      	ldrh	r1, [r5, #6]
 8004fee:	4620      	mov	r0, r4
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
  }
}
 8004ff0:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    /* TI2 Configuration */
    TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 8004ff4:	f7ff bf91 	b.w	8004f1a <TIM_SetIC2Prescaler>
  }
  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
 8004ff8:	2b08      	cmp	r3, #8
 8004ffa:	f8b5 c008 	ldrh.w	ip, [r5, #8]
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;

  /* Disable the Channel 3: Reset the CC3E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC3E;
 8004ffe:	6a06      	ldr	r6, [r0, #32]
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
  }
  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
 8005000:	d11b      	bne.n	800503a <TIM_ICInit+0x78>
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;

  /* Disable the Channel 3: Reset the CC3E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC3E;
 8005002:	f64f 63ff 	movw	r3, #65279	; 0xfeff
 8005006:	4033      	ands	r3, r6
 8005008:	6203      	str	r3, [r0, #32]
  tmpccmr2 = TIMx->CCMR2;
 800500a:	69c3      	ldr	r3, [r0, #28]
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 8);

  /* Select the Input and set the filter */
  tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR2_IC3F);
 800500c:	f64f 770c 	movw	r7, #65292	; 0xff0c
  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;

  /* Disable the Channel 3: Reset the CC3E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC3E;
  tmpccmr2 = TIMx->CCMR2;
  tmpccer = TIMx->CCER;
 8005010:	6a06      	ldr	r6, [r0, #32]
  tmp = (uint16_t)(TIM_ICPolarity << 8);

  /* Select the Input and set the filter */
  tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR2_IC3F);
 8005012:	401f      	ands	r7, r3
  tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));

  /* Select the Polarity and set the CC3E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
 8005014:	f24f 53ff 	movw	r3, #62975	; 0xf5ff
 8005018:	4033      	ands	r3, r6
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 8);

  /* Select the Input and set the filter */
  tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR2_IC3F);
  tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
 800501a:	ea42 120c 	orr.w	r2, r2, ip, lsl #4

  /* Select the Polarity and set the CC3E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC3E);
 800501e:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 8);

  /* Select the Input and set the filter */
  tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR2_IC3F);
  tmpccmr2 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
 8005022:	4317      	orrs	r7, r2

  /* Select the Polarity and set the CC3E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC3E);
 8005024:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    /* TI3 Configuration */
    TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 8005028:	88e9      	ldrh	r1, [r5, #6]
  /* Select the Polarity and set the CC3E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC3E);

  /* Write to TIMx CCMR2 and CCER registers */
  TIMx->CCMR2 = tmpccmr2;
 800502a:	b2bf      	uxth	r7, r7
  TIMx->CCER = tmpccer;
 800502c:	b29b      	uxth	r3, r3
  /* Select the Polarity and set the CC3E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC3P | TIM_CCER_CC3NP);
  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC3E);

  /* Write to TIMx CCMR2 and CCER registers */
  TIMx->CCMR2 = tmpccmr2;
 800502e:	61c7      	str	r7, [r0, #28]
  TIMx->CCER = tmpccer;
 8005030:	6203      	str	r3, [r0, #32]
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
  }
}
 8005032:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    /* TI3 Configuration */
    TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 8005036:	f7ff bfb0 	b.w	8004f9a <TIM_SetIC3Prescaler>
                       uint16_t TIM_ICFilter)
{
  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC4E;
 800503a:	f64e 73ff 	movw	r3, #61439	; 0xefff
 800503e:	4033      	ands	r3, r6
 8005040:	6203      	str	r3, [r0, #32]
  tmpccmr2 = TIMx->CCMR2;
 8005042:	69c3      	ldr	r3, [r0, #28]
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 12);

  /* Select the Input and set the filter */
  tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
 8005044:	f640 46ff 	movw	r6, #3327	; 0xcff
  uint16_t tmpccmr2 = 0, tmpccer = 0, tmp = 0;

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= (uint16_t)~TIM_CCER_CC4E;
  tmpccmr2 = TIMx->CCMR2;
  tmpccer = TIMx->CCER;
 8005048:	6a07      	ldr	r7, [r0, #32]
  tmp = (uint16_t)(TIM_ICPolarity << 12);

  /* Select the Input and set the filter */
  tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
 800504a:	401e      	ands	r6, r3
  tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
  tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);

  /* Select the Polarity and set the CC4E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
 800504c:	f645 73ff 	movw	r3, #24575	; 0x5fff
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 12);

  /* Select the Input and set the filter */
  tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
  tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
 8005050:	0212      	lsls	r2, r2, #8
  tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);

  /* Select the Polarity and set the CC4E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
 8005052:	403b      	ands	r3, r7
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 12);

  /* Select the Input and set the filter */
  tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
  tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
 8005054:	ea42 3c0c 	orr.w	ip, r2, ip, lsl #12
  tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);

  /* Select the Polarity and set the CC4E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC4E);
 8005058:	ea43 3301 	orr.w	r3, r3, r1, lsl #12
  tmpccer = TIMx->CCER;
  tmp = (uint16_t)(TIM_ICPolarity << 12);

  /* Select the Input and set the filter */
  tmpccmr2 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
  tmpccmr2 |= (uint16_t)(TIM_ICSelection << 8);
 800505c:	fa1f fc8c 	uxth.w	ip, ip
  tmpccmr2 |= (uint16_t)(TIM_ICFilter << 12);

  /* Select the Polarity and set the CC4E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC4E);
 8005060:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
    /* TI4 Configuration */
    TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 8005064:	88e9      	ldrh	r1, [r5, #6]
  /* Select the Polarity and set the CC4E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC4E);

  /* Write to TIMx CCMR2 and CCER registers */
  TIMx->CCMR2 = tmpccmr2;
 8005066:	ea4c 0606 	orr.w	r6, ip, r6
  TIMx->CCER = tmpccer ;
 800506a:	b29b      	uxth	r3, r3
  /* Select the Polarity and set the CC4E Bit */
  tmpccer &= (uint16_t)~(TIM_CCER_CC4P | TIM_CCER_CC4NP);
  tmpccer |= (uint16_t)(tmp | (uint16_t)TIM_CCER_CC4E);

  /* Write to TIMx CCMR2 and CCER registers */
  TIMx->CCMR2 = tmpccmr2;
 800506c:	61c6      	str	r6, [r0, #28]
  TIMx->CCER = tmpccer ;
 800506e:	6203      	str	r3, [r0, #32]
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
  }
}
 8005070:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    /* TI4 Configuration */
    TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
               TIM_ICInitStruct->TIM_ICSelection,
               TIM_ICInitStruct->TIM_ICFilter);
    /* Set the Input Capture Prescaler value */
    TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
 8005074:	f7ff bf9a 	b.w	8004fac <TIM_SetIC4Prescaler>

08005078 <TIM_BDTRConfig>:

  /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
     the OSSI State, the dead time value and the Automatic Output Enable Bit */
  TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
             TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
             TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
 8005078:	884a      	ldrh	r2, [r1, #2]
 800507a:	880b      	ldrh	r3, [r1, #0]
 800507c:	4313      	orrs	r3, r2
 800507e:	888a      	ldrh	r2, [r1, #4]
 8005080:	4313      	orrs	r3, r2
 8005082:	88ca      	ldrh	r2, [r1, #6]
 8005084:	4313      	orrs	r3, r2
 8005086:	890a      	ldrh	r2, [r1, #8]
 8005088:	4313      	orrs	r3, r2
 800508a:	894a      	ldrh	r2, [r1, #10]
 800508c:	4313      	orrs	r3, r2
 800508e:	898a      	ldrh	r2, [r1, #12]
 8005090:	4313      	orrs	r3, r2
 8005092:	b29b      	uxth	r3, r3
  assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));

  /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
     the OSSI State, the dead time value and the Automatic Output Enable Bit */
  TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
 8005094:	6443      	str	r3, [r0, #68]	; 0x44
 8005096:	4770      	bx	lr

08005098 <TIM_Break1Config>:
{   /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_BREAK1_FILTER(TIM_Break1Filter));

  /* Reset the BKP and BKF Bits */
  TIMx->BDTR &= (uint32_t)~ (TIM_BDTR_BKP | TIM_BDTR_BKF);
 8005098:	6c43      	ldr	r3, [r0, #68]	; 0x44
 800509a:	f423 2372 	bic.w	r3, r3, #991232	; 0xf2000
 800509e:	6443      	str	r3, [r0, #68]	; 0x44
  /* Configure the Break1 polarity and filter */
  TIMx->BDTR |=	TIM_Break1Polarity |((uint32_t)TIM_Break1Filter << 16);
 80050a0:	6c43      	ldr	r3, [r0, #68]	; 0x44
 80050a2:	4319      	orrs	r1, r3
 80050a4:	ea41 4202 	orr.w	r2, r1, r2, lsl #16
 80050a8:	6442      	str	r2, [r0, #68]	; 0x44
 80050aa:	4770      	bx	lr

080050ac <TIM_Break2Config>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_BREAK2_FILTER(TIM_Break2Filter));

  /* Reset the BKP and BKF Bits */
  TIMx->BDTR &= (uint32_t)~ (TIM_BDTR_BK2P | TIM_BDTR_BK2F);
 80050ac:	6c43      	ldr	r3, [r0, #68]	; 0x44
 80050ae:	f023 733c 	bic.w	r3, r3, #49283072	; 0x2f00000
 80050b2:	6443      	str	r3, [r0, #68]	; 0x44

  /* Configure the Break1 polarity and filter */
  TIMx->BDTR |=	TIM_Break2Polarity |((uint32_t)TIM_Break2Filter << 20);
 80050b4:	6c43      	ldr	r3, [r0, #68]	; 0x44
 80050b6:	4319      	orrs	r1, r3
 80050b8:	ea41 5202 	orr.w	r2, r1, r2, lsl #20
 80050bc:	6442      	str	r2, [r0, #68]	; 0x44
 80050be:	4770      	bx	lr

080050c0 <TIM_Break1Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the Break1 */
    TIMx->BDTR |= TIM_BDTR_BKE;
 80050c0:	6c43      	ldr	r3, [r0, #68]	; 0x44
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80050c2:	b111      	cbz	r1, 80050ca <TIM_Break1Cmd+0xa>
  {
    /* Enable the Break1 */
    TIMx->BDTR |= TIM_BDTR_BKE;
 80050c4:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 80050c8:	e001      	b.n	80050ce <TIM_Break1Cmd+0xe>
  }
  else
  {
    /* Disable the Break1 */
    TIMx->BDTR &= (uint32_t)~TIM_BDTR_BKE;
 80050ca:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 80050ce:	6443      	str	r3, [r0, #68]	; 0x44
 80050d0:	4770      	bx	lr

080050d2 <TIM_Break2Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the Break1 */
    TIMx->BDTR |= TIM_BDTR_BK2E;
 80050d2:	6c43      	ldr	r3, [r0, #68]	; 0x44
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80050d4:	b111      	cbz	r1, 80050dc <TIM_Break2Cmd+0xa>
  {
    /* Enable the Break1 */
    TIMx->BDTR |= TIM_BDTR_BK2E;
 80050d6:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80050da:	e001      	b.n	80050e0 <TIM_Break2Cmd+0xe>
  }
  else
  {
    /* Disable the Break1 */
    TIMx->BDTR &= (uint32_t)~TIM_BDTR_BK2E;
 80050dc:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 80050e0:	6443      	str	r3, [r0, #68]	; 0x44
 80050e2:	4770      	bx	lr

080050e4 <TIM_BDTRStructInit>:
  * @retval None
  */
void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
{
  /* Set the default configuration */
  TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
 80050e4:	2300      	movs	r3, #0
 80050e6:	8003      	strh	r3, [r0, #0]
  TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
 80050e8:	8043      	strh	r3, [r0, #2]
  TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
 80050ea:	8083      	strh	r3, [r0, #4]
  TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
 80050ec:	80c3      	strh	r3, [r0, #6]
  TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
 80050ee:	8103      	strh	r3, [r0, #8]
  TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
 80050f0:	8143      	strh	r3, [r0, #10]
  TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
 80050f2:	8183      	strh	r3, [r0, #12]
 80050f4:	4770      	bx	lr

080050f6 <TIM_CtrlPWMOutputs>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the TIM Main Output */
    TIMx->BDTR |= TIM_BDTR_MOE;
 80050f6:	6c43      	ldr	r3, [r0, #68]	; 0x44
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80050f8:	b111      	cbz	r1, 8005100 <TIM_CtrlPWMOutputs+0xa>
  {
    /* Enable the TIM Main Output */
    TIMx->BDTR |= TIM_BDTR_MOE;
 80050fa:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80050fe:	e001      	b.n	8005104 <TIM_CtrlPWMOutputs+0xe>
  }
  else
  {
    /* Disable the TIM Main Output */
    TIMx->BDTR &= (uint16_t)~TIM_BDTR_MOE;
 8005100:	045b      	lsls	r3, r3, #17
 8005102:	0c5b      	lsrs	r3, r3, #17
 8005104:	6443      	str	r3, [r0, #68]	; 0x44
 8005106:	4770      	bx	lr

08005108 <TIM_SelectCOM>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8005108:	b119      	cbz	r1, 8005112 <TIM_SelectCOM+0xa>
  {
    /* Set the COM Bit */
    TIMx->CR2 |= TIM_CR2_CCUS;
 800510a:	6843      	ldr	r3, [r0, #4]
 800510c:	f043 0304 	orr.w	r3, r3, #4
 8005110:	e003      	b.n	800511a <TIM_SelectCOM+0x12>
  }
  else
  {
    /* Reset the COM Bit */
    TIMx->CR2 &= (uint16_t)~TIM_CR2_CCUS;
 8005112:	6842      	ldr	r2, [r0, #4]
 8005114:	f64f 73fb 	movw	r3, #65531	; 0xfffb
 8005118:	4013      	ands	r3, r2
 800511a:	6043      	str	r3, [r0, #4]
 800511c:	4770      	bx	lr

0800511e <TIM_CCPreloadControl>:
void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
{ 
  /* Check the parameters */
  assert_param(IS_TIM_LIST6_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800511e:	b119      	cbz	r1, 8005128 <TIM_CCPreloadControl+0xa>
  {
    /* Set the CCPC Bit */
    TIMx->CR2 |= TIM_CR2_CCPC;
 8005120:	6843      	ldr	r3, [r0, #4]
 8005122:	f043 0301 	orr.w	r3, r3, #1
 8005126:	e003      	b.n	8005130 <TIM_CCPreloadControl+0x12>
  }
  else
  {
    /* Reset the CCPC Bit */
    TIMx->CR2 &= (uint16_t)~TIM_CR2_CCPC;
 8005128:	6842      	ldr	r2, [r0, #4]
 800512a:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 800512e:	4013      	ands	r3, r2
 8005130:	6043      	str	r3, [r0, #4]
 8005132:	4770      	bx	lr

08005134 <TIM_ITConfig>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the Interrupt sources */
    TIMx->DIER |= TIM_IT;
 8005134:	68c3      	ldr	r3, [r0, #12]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_IT(TIM_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8005136:	b10a      	cbz	r2, 800513c <TIM_ITConfig+0x8>
  {
    /* Enable the Interrupt sources */
    TIMx->DIER |= TIM_IT;
 8005138:	4319      	orrs	r1, r3
 800513a:	e002      	b.n	8005142 <TIM_ITConfig+0xe>
  }
  else
  {
    /* Disable the Interrupt sources */
    TIMx->DIER &= (uint16_t)~TIM_IT;
 800513c:	43c9      	mvns	r1, r1
 800513e:	b289      	uxth	r1, r1
 8005140:	4019      	ands	r1, r3
 8005142:	60c1      	str	r1, [r0, #12]
 8005144:	4770      	bx	lr

08005146 <TIM_GenerateEvent>:
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));
 
  /* Set the event sources */
  TIMx->EGR = TIM_EventSource;
 8005146:	6141      	str	r1, [r0, #20]
 8005148:	4770      	bx	lr

0800514a <TIM_GetFlagStatus>:
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_GET_FLAG(TIM_FLAG));

  
  if ((TIMx->SR & TIM_FLAG) != RESET)
 800514a:	6903      	ldr	r3, [r0, #16]
 800514c:	4219      	tst	r1, r3
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 800514e:	bf0c      	ite	eq
 8005150:	2000      	moveq	r0, #0
 8005152:	2001      	movne	r0, #1
 8005154:	4770      	bx	lr

08005156 <TIM_ClearFlag>:
{  
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
   
  /* Clear the flags */
  TIMx->SR = (uint16_t)~TIM_FLAG;
 8005156:	43c9      	mvns	r1, r1
 8005158:	b289      	uxth	r1, r1
 800515a:	6101      	str	r1, [r0, #16]
 800515c:	4770      	bx	lr

0800515e <TIM_GetITStatus>:
  uint16_t itstatus = 0x0, itenable = 0x0;
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_GET_IT(TIM_IT));
   
  itstatus = TIMx->SR & TIM_IT;
 800515e:	6903      	ldr	r3, [r0, #16]
  
  itenable = TIMx->DIER & TIM_IT;
 8005160:	68c2      	ldr	r2, [r0, #12]
  if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
 8005162:	ea11 0003 	ands.w	r0, r1, r3
 8005166:	d003      	beq.n	8005170 <TIM_GetITStatus+0x12>
 8005168:	4211      	tst	r1, r2
  {
    bitstatus = SET;
 800516a:	bf0c      	ite	eq
 800516c:	2000      	moveq	r0, #0
 800516e:	2001      	movne	r0, #1
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 8005170:	4770      	bx	lr

08005172 <TIM_ClearITPendingBit>:
{
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));

  /* Clear the IT pending Bit */
  TIMx->SR = (uint16_t)~TIM_IT;
 8005172:	43c9      	mvns	r1, r1
 8005174:	b289      	uxth	r1, r1
 8005176:	6101      	str	r1, [r0, #16]
 8005178:	4770      	bx	lr

0800517a <TIM_DMAConfig>:
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_TIM_DMA_BASE(TIM_DMABase)); 
  assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));

  /* Set the DMA Base and the DMA Burst Length */
  TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
 800517a:	430a      	orrs	r2, r1
 800517c:	f8a0 2048 	strh.w	r2, [r0, #72]	; 0x48
 8005180:	4770      	bx	lr

08005182 <TIM_DMACmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the DMA sources */
    TIMx->DIER |= TIM_DMASource; 
 8005182:	68c3      	ldr	r3, [r0, #12]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8005184:	b10a      	cbz	r2, 800518a <TIM_DMACmd+0x8>
  {
    /* Enable the DMA sources */
    TIMx->DIER |= TIM_DMASource; 
 8005186:	4319      	orrs	r1, r3
 8005188:	e002      	b.n	8005190 <TIM_DMACmd+0xe>
  }
  else
  {
    /* Disable the DMA sources */
    TIMx->DIER &= (uint16_t)~TIM_DMASource;
 800518a:	43c9      	mvns	r1, r1
 800518c:	b289      	uxth	r1, r1
 800518e:	4019      	ands	r1, r3
 8005190:	60c1      	str	r1, [r0, #12]
 8005192:	4770      	bx	lr

08005194 <TIM_SelectCCDMA>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST1_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8005194:	b119      	cbz	r1, 800519e <TIM_SelectCCDMA+0xa>
  {
    /* Set the CCDS Bit */
    TIMx->CR2 |= TIM_CR2_CCDS;
 8005196:	6843      	ldr	r3, [r0, #4]
 8005198:	f043 0308 	orr.w	r3, r3, #8
 800519c:	e003      	b.n	80051a6 <TIM_SelectCCDMA+0x12>
  }
  else
  {
    /* Reset the CCDS Bit */
    TIMx->CR2 &= (uint16_t)~TIM_CR2_CCDS;
 800519e:	6842      	ldr	r2, [r0, #4]
 80051a0:	f64f 73f7 	movw	r3, #65527	; 0xfff7
 80051a4:	4013      	ands	r3, r2
 80051a6:	6043      	str	r3, [r0, #4]
 80051a8:	4770      	bx	lr

080051aa <TIM_InternalClockConfig>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));

  /* Disable slave mode to clock the prescaler directly with the internal clock */
  TIMx->SMCR &=  (uint16_t)~TIM_SMCR_SMS;
 80051aa:	6882      	ldr	r2, [r0, #8]
 80051ac:	f64f 73f8 	movw	r3, #65528	; 0xfff8
 80051b0:	4013      	ands	r3, r2
 80051b2:	6083      	str	r3, [r0, #8]
 80051b4:	4770      	bx	lr

080051b6 <TIM_ITRxExternalClockConfig>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx)); 
  assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 80051b6:	6882      	ldr	r2, [r0, #8]

  /* Reset the TS Bits */
  tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
 80051b8:	f64f 738f 	movw	r3, #65423	; 0xff8f
 80051bc:	4013      	ands	r3, r2

  /* Set the Input Trigger source */
  tmpsmcr |= TIM_InputTriggerSource;

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 80051be:	4319      	orrs	r1, r3
 80051c0:	6081      	str	r1, [r0, #8]

  /* Select the Internal Trigger */
  TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);

  /* Select the External clock mode1 */
  TIMx->SMCR |= TIM_SlaveMode_External1;
 80051c2:	6883      	ldr	r3, [r0, #8]
 80051c4:	f043 0307 	orr.w	r3, r3, #7
 80051c8:	6083      	str	r3, [r0, #8]
 80051ca:	4770      	bx	lr

080051cc <TIM_TIxExternalClockConfig>:
  *          This parameter must be a value between 0x0 and 0xF.
  * @retval None
  */
void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
                                uint16_t TIM_ICPolarity, uint16_t ICFilter)
{
 80051cc:	b538      	push	{r3, r4, r5, lr}
 80051ce:	460d      	mov	r5, r1
 80051d0:	4611      	mov	r1, r2
  assert_param(IS_TIM_IC_FILTER(ICFilter));

  /* Configure the Timer Input Clock Source */
  if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
  {
    TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
 80051d2:	2201      	movs	r2, #1
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
  assert_param(IS_TIM_IC_FILTER(ICFilter));

  /* Configure the Timer Input Clock Source */
  if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
 80051d4:	2d60      	cmp	r5, #96	; 0x60
  *          This parameter must be a value between 0x0 and 0xF.
  * @retval None
  */
void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
                                uint16_t TIM_ICPolarity, uint16_t ICFilter)
{
 80051d6:	4604      	mov	r4, r0
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
  assert_param(IS_TIM_IC_FILTER(ICFilter));

  /* Configure the Timer Input Clock Source */
  if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
 80051d8:	d102      	bne.n	80051e0 <TIM_TIxExternalClockConfig+0x14>
  {
    TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
 80051da:	f7ff facf 	bl	800477c <TI2_Config>
 80051de:	e001      	b.n	80051e4 <TIM_TIxExternalClockConfig+0x18>
  }
  else
  {
    TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
 80051e0:	f7ff fab8 	bl	8004754 <TI1_Config>
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx)); 
  assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 80051e4:	68a2      	ldr	r2, [r4, #8]

  /* Reset the TS Bits */
  tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
 80051e6:	f64f 738f 	movw	r3, #65423	; 0xff8f
 80051ea:	4013      	ands	r3, r2

  /* Set the Input Trigger source */
  tmpsmcr |= TIM_InputTriggerSource;

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 80051ec:	432b      	orrs	r3, r5
 80051ee:	60a3      	str	r3, [r4, #8]
    TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
  }
  /* Select the Trigger source */
  TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
  /* Select the External clock mode1 */
  TIMx->SMCR |= TIM_SlaveMode_External1;
 80051f0:	68a3      	ldr	r3, [r4, #8]
 80051f2:	f043 0307 	orr.w	r3, r3, #7
 80051f6:	60a3      	str	r3, [r4, #8]
 80051f8:	bd38      	pop	{r3, r4, r5, pc}

080051fa <TIM_SelectInputTrigger>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx)); 
  assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 80051fa:	6882      	ldr	r2, [r0, #8]

  /* Reset the TS Bits */
  tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
 80051fc:	f64f 738f 	movw	r3, #65423	; 0xff8f
 8005200:	4013      	ands	r3, r2

  /* Set the Input Trigger source */
  tmpsmcr |= TIM_InputTriggerSource;

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 8005202:	4319      	orrs	r1, r3
 8005204:	6081      	str	r1, [r0, #8]
 8005206:	4770      	bx	lr

08005208 <TIM_SelectOutputTrigger>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST7_PERIPH(TIMx));
  assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));

  /* Reset the MMS Bits */
  TIMx->CR2 &= (uint16_t)~TIM_CR2_MMS;
 8005208:	6842      	ldr	r2, [r0, #4]
 800520a:	f64f 738f 	movw	r3, #65423	; 0xff8f
 800520e:	4013      	ands	r3, r2
 8005210:	6043      	str	r3, [r0, #4]
  /* Select the TRGO source */
  TIMx->CR2 |=  TIM_TRGOSource;
 8005212:	6843      	ldr	r3, [r0, #4]
 8005214:	4319      	orrs	r1, r3
 8005216:	6041      	str	r1, [r0, #4]
 8005218:	4770      	bx	lr

0800521a <TIM_SelectOutputTrigger2>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST4_PERIPH(TIMx));
  assert_param(IS_TIM_TRGO2_SOURCE(TIM_TRGO2Source));

  /* Reset the MMS Bits */
  TIMx->CR2 &= (uint32_t)~TIM_CR2_MMS2;
 800521a:	6843      	ldr	r3, [r0, #4]
 800521c:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
 8005220:	6043      	str	r3, [r0, #4]
  /* Select the TRGO source */
  TIMx->CR2 |=  TIM_TRGO2Source;
 8005222:	6843      	ldr	r3, [r0, #4]
 8005224:	4319      	orrs	r1, r3
 8005226:	6041      	str	r1, [r0, #4]
 8005228:	4770      	bx	lr

0800522a <TIM_SelectSlaveMode>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));

  /* Reset the SMS Bits */
  TIMx->SMCR &= (uint32_t)~TIM_SMCR_SMS;
 800522a:	6883      	ldr	r3, [r0, #8]
 800522c:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8005230:	f023 0307 	bic.w	r3, r3, #7
 8005234:	6083      	str	r3, [r0, #8]

  /* Select the Slave Mode */
  TIMx->SMCR |= (uint32_t)TIM_SlaveMode;
 8005236:	6883      	ldr	r3, [r0, #8]
 8005238:	4319      	orrs	r1, r3
 800523a:	6081      	str	r1, [r0, #8]
 800523c:	4770      	bx	lr

0800523e <TIM_SelectMasterSlaveMode>:
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));

  /* Reset the MSM Bit */
  TIMx->SMCR &= (uint16_t)~TIM_SMCR_MSM;
 800523e:	6882      	ldr	r2, [r0, #8]
 8005240:	f64f 737f 	movw	r3, #65407	; 0xff7f
 8005244:	4013      	ands	r3, r2
 8005246:	6083      	str	r3, [r0, #8]
  
  /* Set or Reset the MSM Bit */
  TIMx->SMCR |= TIM_MasterSlaveMode;
 8005248:	6883      	ldr	r3, [r0, #8]
 800524a:	4319      	orrs	r1, r3
 800524c:	6081      	str	r1, [r0, #8]
 800524e:	4770      	bx	lr

08005250 <TIM_ETRConfig>:
  *          This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */
void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler,
                   uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
{
 8005250:	b510      	push	{r4, lr}
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));

  tmpsmcr = TIMx->SMCR;
 8005252:	6884      	ldr	r4, [r0, #8]

  /* Reset the ETR Bits */
  tmpsmcr &= SMCR_ETR_MASK;
 8005254:	b2e4      	uxtb	r4, r4

  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
 8005256:	4321      	orrs	r1, r4
 8005258:	430a      	orrs	r2, r1
 800525a:	ea42 2303 	orr.w	r3, r2, r3, lsl #8

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 800525e:	b29c      	uxth	r4, r3
 8005260:	6084      	str	r4, [r0, #8]
 8005262:	bd10      	pop	{r4, pc}

08005264 <TIM_ETRClockMode2Config>:
  *          This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */
void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
                             uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
{
 8005264:	b510      	push	{r4, lr}
 8005266:	4604      	mov	r4, r0
  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));

  /* Configure the ETR Clock source */
  TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
 8005268:	f7ff fff2 	bl	8005250 <TIM_ETRConfig>

  /* Enable the External clock mode2 */
  TIMx->SMCR |= TIM_SMCR_ECE;
 800526c:	68a3      	ldr	r3, [r4, #8]
 800526e:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8005272:	60a3      	str	r3, [r4, #8]
 8005274:	bd10      	pop	{r4, pc}

08005276 <TIM_ETRClockMode1Config>:
  *          This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */
void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler,
                            uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
{
 8005276:	b510      	push	{r4, lr}
 8005278:	4604      	mov	r4, r0
  assert_param(IS_TIM_LIST3_PERIPH(TIMx));
  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
  /* Configure the ETR Clock source */
  TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
 800527a:	f7ff ffe9 	bl	8005250 <TIM_ETRConfig>
  
  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 800527e:	68a2      	ldr	r2, [r4, #8]

  /* Select the External clock mode1 */
  tmpsmcr |= TIM_SlaveMode_External1;

  /* Select the Trigger selection : ETRF */
  tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
 8005280:	f64f 7388 	movw	r3, #65416	; 0xff88
 8005284:	4013      	ands	r3, r2
  tmpsmcr |= TIM_TS_ETRF;
 8005286:	f043 0377 	orr.w	r3, r3, #119	; 0x77

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 800528a:	60a3      	str	r3, [r4, #8]
 800528c:	bd10      	pop	{r4, pc}

0800528e <TIM_EncoderInterfaceConfig>:
  *            @arg TIM_ICPolarity_Rising: IC Rising edge.
  * @retval None
  */
void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
                                uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity)
{
 800528e:	b5f0      	push	{r4, r5, r6, r7, lr}
  assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
  assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
  assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 8005290:	6885      	ldr	r5, [r0, #8]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;

  /* Set the encoder Mode */
  tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
 8005292:	f64f 74f8 	movw	r4, #65528	; 0xfff8

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;

  /* Get the TIMx CCMR1 register value */
  tmpccmr1 = TIMx->CCMR1;
 8005296:	6986      	ldr	r6, [r0, #24]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;

  /* Set the encoder Mode */
  tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
 8005298:	402c      	ands	r4, r5
  tmpsmcr |= TIM_EncoderMode;

  /* Select the Capture Compare 1 and the Capture Compare 2 as input */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_CC2S);
 800529a:	f64f 45fc 	movw	r5, #64764	; 0xfcfc
 800529e:	4035      	ands	r5, r6

  /* Get the TIMx CCMR1 register value */
  tmpccmr1 = TIMx->CCMR1;

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 80052a0:	6a07      	ldr	r7, [r0, #32]
  tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
  tmpsmcr |= TIM_EncoderMode;

  /* Select the Capture Compare 1 and the Capture Compare 2 as input */
  tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_CC2S);
  tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
 80052a2:	f445 7580 	orr.w	r5, r5, #256	; 0x100
 80052a6:	f045 0601 	orr.w	r6, r5, #1

  /* Set the TI1 and the TI2 Polarities */
  tmpccer &= ((uint16_t)~TIM_CCER_CC1P) & ((uint16_t)~TIM_CCER_CC2P);
 80052aa:	f64f 75dd 	movw	r5, #65501	; 0xffdd
 80052ae:	403d      	ands	r5, r7
  tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));
 80052b0:	432a      	orrs	r2, r5
 80052b2:	ea42 1303 	orr.w	r3, r2, r3, lsl #4

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 80052b6:	4321      	orrs	r1, r4

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmr1;

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 80052b8:	b29d      	uxth	r5, r3
  /* Set the TI1 and the TI2 Polarities */
  tmpccer &= ((uint16_t)~TIM_CCER_CC1P) & ((uint16_t)~TIM_CCER_CC2P);
  tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 80052ba:	6081      	str	r1, [r0, #8]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmr1;
 80052bc:	6186      	str	r6, [r0, #24]

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 80052be:	6205      	str	r5, [r0, #32]
 80052c0:	bdf0      	pop	{r4, r5, r6, r7, pc}

080052c2 <TIM_SelectHallSensor>:
{
  /* Check the parameters */
  assert_param(IS_TIM_LIST2_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80052c2:	b119      	cbz	r1, 80052cc <TIM_SelectHallSensor+0xa>
  {
    /* Set the TI1S Bit */
    TIMx->CR2 |= TIM_CR2_TI1S;
 80052c4:	6843      	ldr	r3, [r0, #4]
 80052c6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80052ca:	e003      	b.n	80052d4 <TIM_SelectHallSensor+0x12>
  }
  else
  {
    /* Reset the TI1S Bit */
    TIMx->CR2 &= (uint16_t)~TIM_CR2_TI1S;
 80052cc:	6842      	ldr	r2, [r0, #4]
 80052ce:	f64f 737f 	movw	r3, #65407	; 0xff7f
 80052d2:	4013      	ands	r3, r2
 80052d4:	6043      	str	r3, [r0, #4]
 80052d6:	4770      	bx	lr

080052d8 <TIM_RemapConfig>:
 /* Check the parameters */
  assert_param(IS_TIM_LIST8_PERIPH(TIMx));
  assert_param(IS_TIM_REMAP(TIM_Remap));

  /* Set the Timer remapping configuration */
  TIMx->OR =  TIM_Remap;
 80052d8:	f8a0 1050 	strh.w	r1, [r0, #80]	; 0x50
 80052dc:	4770      	bx	lr
 80052de:	bf00      	nop

080052e0 <USART_DeInit>:
  * @param  USARTx: Select the USART peripheral. This parameter can be one of the 
  *         following values: USART1 or USART2 or USART3 or UART4 or UART5.
  * @retval None
  */
void USART_DeInit(USART_TypeDef* USARTx)
{
 80052e0:	b508      	push	{r3, lr}
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));

  if (USARTx == USART1)
 80052e2:	4b20      	ldr	r3, [pc, #128]	; (8005364 <USART_DeInit+0x84>)
 80052e4:	4298      	cmp	r0, r3
 80052e6:	d10b      	bne.n	8005300 <USART_DeInit+0x20>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
 80052e8:	2101      	movs	r1, #1
 80052ea:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 80052ee:	f7fe ffe9 	bl	80042c4 <RCC_APB2PeriphResetCmd>
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
 80052f2:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 80052f6:	2100      	movs	r1, #0
    {
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
    }
  }
}
 80052f8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  assert_param(IS_USART_ALL_PERIPH(USARTx));

  if (USARTx == USART1)
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
 80052fc:	f7fe bfe2 	b.w	80042c4 <RCC_APB2PeriphResetCmd>
  }
  else if (USARTx == USART2)
 8005300:	4b19      	ldr	r3, [pc, #100]	; (8005368 <USART_DeInit+0x88>)
 8005302:	4298      	cmp	r0, r3
 8005304:	d107      	bne.n	8005316 <USART_DeInit+0x36>
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
 8005306:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 800530a:	2101      	movs	r1, #1
 800530c:	f7fe ffe6 	bl	80042dc <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
 8005310:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 8005314:	e01f      	b.n	8005356 <USART_DeInit+0x76>
  }
  else if (USARTx == USART3)
 8005316:	4b15      	ldr	r3, [pc, #84]	; (800536c <USART_DeInit+0x8c>)
 8005318:	4298      	cmp	r0, r3
 800531a:	d107      	bne.n	800532c <USART_DeInit+0x4c>
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
 800531c:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 8005320:	2101      	movs	r1, #1
 8005322:	f7fe ffdb 	bl	80042dc <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
 8005326:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 800532a:	e014      	b.n	8005356 <USART_DeInit+0x76>
  }
  else if (USARTx == UART4)
 800532c:	4b10      	ldr	r3, [pc, #64]	; (8005370 <USART_DeInit+0x90>)
 800532e:	4298      	cmp	r0, r3
 8005330:	d107      	bne.n	8005342 <USART_DeInit+0x62>
  {
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
 8005332:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 8005336:	2101      	movs	r1, #1
 8005338:	f7fe ffd0 	bl	80042dc <RCC_APB1PeriphResetCmd>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
 800533c:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 8005340:	e009      	b.n	8005356 <USART_DeInit+0x76>
  }
  else
  {
    if  (USARTx == UART5)
 8005342:	4b0c      	ldr	r3, [pc, #48]	; (8005374 <USART_DeInit+0x94>)
 8005344:	4298      	cmp	r0, r3
 8005346:	d10b      	bne.n	8005360 <USART_DeInit+0x80>
    {
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
 8005348:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 800534c:	2101      	movs	r1, #1
 800534e:	f7fe ffc5 	bl	80042dc <RCC_APB1PeriphResetCmd>
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
 8005352:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 8005356:	2100      	movs	r1, #0
    }
  }
}
 8005358:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  else
  {
    if  (USARTx == UART5)
    {
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
 800535c:	f7fe bfbe 	b.w	80042dc <RCC_APB1PeriphResetCmd>
 8005360:	bd08      	pop	{r3, pc}
 8005362:	bf00      	nop
 8005364:	40013800 	.word	0x40013800
 8005368:	40004400 	.word	0x40004400
 800536c:	40004800 	.word	0x40004800
 8005370:	40004c00 	.word	0x40004c00
 8005374:	40005000 	.word	0x40005000

08005378 <USART_Init>:
  assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
  assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
  assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
  
  /* Disable USART */
  USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_UE);
 8005378:	6803      	ldr	r3, [r0, #0]
  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure
  *         that contains the configuration information for the specified USART peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 800537a:	b530      	push	{r4, r5, lr}
  assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
  assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
  assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
  
  /* Disable USART */
  USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_UE);
 800537c:	f023 0301 	bic.w	r3, r3, #1
 8005380:	6003      	str	r3, [r0, #0]
  
  /*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
 8005382:	6842      	ldr	r2, [r0, #4]
  /* Clear STOP[13:12] bits */
  tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
  
  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
  /* Set STOP[13:12] bits according to USART_StopBits value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
 8005384:	688b      	ldr	r3, [r1, #8]
  USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_UE);
  
  /*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
  /* Clear STOP[13:12] bits */
  tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
 8005386:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure
  *         that contains the configuration information for the specified USART peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 800538a:	460d      	mov	r5, r1
  /* Clear STOP[13:12] bits */
  tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
  
  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
  /* Set STOP[13:12] bits according to USART_StopBits value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
 800538c:	4313      	orrs	r3, r2
  
  /* Write to USART CR2 */
  USARTx->CR2 = tmpreg;
 800538e:	6043      	str	r3, [r0, #4]
  
  /* Configure the USART Word Length, Parity and mode ----------------------- */
  /* Set the M bits according to USART_WordLength value */
  /* Set PCE and PS bits according to USART_Parity value */
  /* Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 8005390:	686a      	ldr	r2, [r5, #4]
 8005392:	68eb      	ldr	r3, [r5, #12]
  
  /* Write to USART CR2 */
  USARTx->CR2 = tmpreg;
  
  /*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
 8005394:	6801      	ldr	r1, [r0, #0]
  
  /* Configure the USART Word Length, Parity and mode ----------------------- */
  /* Set the M bits according to USART_WordLength value */
  /* Set PCE and PS bits according to USART_Parity value */
  /* Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 8005396:	431a      	orrs	r2, r3
 8005398:	692b      	ldr	r3, [r5, #16]
  USARTx->CR2 = tmpreg;
  
  /*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= (uint32_t)~((uint32_t)CR1_CLEAR_MASK);
 800539a:	f421 51b0 	bic.w	r1, r1, #5632	; 0x1600
 800539e:	f021 010c 	bic.w	r1, r1, #12
  
  /* Configure the USART Word Length, Parity and mode ----------------------- */
  /* Set the M bits according to USART_WordLength value */
  /* Set PCE and PS bits according to USART_Parity value */
  /* Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 80053a2:	4313      	orrs	r3, r2
 80053a4:	430b      	orrs	r3, r1
    USART_InitStruct->USART_Mode;
  
  /* Write to USART CR1 */
  USARTx->CR1 = tmpreg;
 80053a6:	6003      	str	r3, [r0, #0]
  
  /*---------------------------- USART CR3 Configuration -----------------------*/
  tmpreg = USARTx->CR3;
 80053a8:	6882      	ldr	r2, [r0, #8]
  /* Clear CTSE and RTSE bits */
  tmpreg &= (uint32_t)~((uint32_t)CR3_CLEAR_MASK);
  
  /* Configure the USART HFC -------------------------------------------------*/
  /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
 80053aa:	696b      	ldr	r3, [r5, #20]
  USARTx->CR1 = tmpreg;
  
  /*---------------------------- USART CR3 Configuration -----------------------*/
  tmpreg = USARTx->CR3;
  /* Clear CTSE and RTSE bits */
  tmpreg &= (uint32_t)~((uint32_t)CR3_CLEAR_MASK);
 80053ac:	f422 7240 	bic.w	r2, r2, #768	; 0x300
  
  /* Configure the USART HFC -------------------------------------------------*/
  /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
 80053b0:	4313      	orrs	r3, r2
  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure
  *         that contains the configuration information for the specified USART peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 80053b2:	b091      	sub	sp, #68	; 0x44
  /* Configure the USART HFC -------------------------------------------------*/
  /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
  
  /* Write to USART CR3 */
  USARTx->CR3 = tmpreg;
 80053b4:	6083      	str	r3, [r0, #8]
  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure
  *         that contains the configuration information for the specified USART peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 80053b6:	4604      	mov	r4, r0
  /* Write to USART CR3 */
  USARTx->CR3 = tmpreg;
  
  /*---------------------------- USART BRR Configuration -----------------------*/
  /* Configure the USART Baud Rate -------------------------------------------*/
  RCC_GetClocksFreq(&RCC_ClocksStatus);
 80053b8:	a801      	add	r0, sp, #4
 80053ba:	f7fe fdad 	bl	8003f18 <RCC_GetClocksFreq>
  
  if (USARTx == USART1)
 80053be:	4b18      	ldr	r3, [pc, #96]	; (8005420 <USART_Init+0xa8>)
 80053c0:	429c      	cmp	r4, r3
 80053c2:	d101      	bne.n	80053c8 <USART_Init+0x50>
  {
    apbclock = RCC_ClocksStatus.USART1CLK_Frequency;
 80053c4:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80053c6:	e00e      	b.n	80053e6 <USART_Init+0x6e>
  }
  else if (USARTx == USART2)
 80053c8:	4b16      	ldr	r3, [pc, #88]	; (8005424 <USART_Init+0xac>)
 80053ca:	429c      	cmp	r4, r3
 80053cc:	d101      	bne.n	80053d2 <USART_Init+0x5a>
  {
    apbclock = RCC_ClocksStatus.USART2CLK_Frequency;
 80053ce:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 80053d0:	e009      	b.n	80053e6 <USART_Init+0x6e>
  }
  else if (USARTx == USART3)
 80053d2:	4b15      	ldr	r3, [pc, #84]	; (8005428 <USART_Init+0xb0>)
 80053d4:	429c      	cmp	r4, r3
 80053d6:	d101      	bne.n	80053dc <USART_Init+0x64>
  {
    apbclock = RCC_ClocksStatus.USART3CLK_Frequency;
 80053d8:	9a0d      	ldr	r2, [sp, #52]	; 0x34
 80053da:	e004      	b.n	80053e6 <USART_Init+0x6e>
  }
  else if (USARTx == UART4)
 80053dc:	4b13      	ldr	r3, [pc, #76]	; (800542c <USART_Init+0xb4>)
 80053de:	429c      	cmp	r4, r3
  {
    apbclock = RCC_ClocksStatus.UART4CLK_Frequency;
 80053e0:	bf0c      	ite	eq
 80053e2:	9a0e      	ldreq	r2, [sp, #56]	; 0x38
  }
  else 
  {
    apbclock = RCC_ClocksStatus.UART5CLK_Frequency;
 80053e4:	9a0f      	ldrne	r2, [sp, #60]	; 0x3c
  }  
  
  /* Determine the integer part */
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 80053e6:	6823      	ldr	r3, [r4, #0]
 80053e8:	6829      	ldr	r1, [r5, #0]
 80053ea:	f413 4f00 	tst.w	r3, #32768	; 0x8000
  {
    /* (divider * 10) computing in case Oversampling mode is 8 Samples */
    divider = (uint32_t)((2 * apbclock) / (USART_InitStruct->USART_BaudRate));
 80053ee:	bf18      	it	ne
 80053f0:	0052      	lslne	r2, r2, #1
    tmpreg  = (uint32_t)((2 * apbclock) % (USART_InitStruct->USART_BaudRate));
  }
  else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
  {
    /* (divider * 10) computing in case Oversampling mode is 16 Samples */
    divider = (uint32_t)((apbclock) / (USART_InitStruct->USART_BaudRate));
 80053f2:	fbb2 f3f1 	udiv	r3, r2, r1
    tmpreg  = (uint32_t)((apbclock) % (USART_InitStruct->USART_BaudRate));
 80053f6:	fb01 2113 	mls	r1, r1, r3, r2
  }
  
  /* round the divider : if fractional part i greater than 0.5 increment divider */
  if (tmpreg >=  (USART_InitStruct->USART_BaudRate) / 2)
 80053fa:	682a      	ldr	r2, [r5, #0]
 80053fc:	ebb1 0f52 	cmp.w	r1, r2, lsr #1
  {
    divider++;
  } 
  
  /* Implement the divider in case Oversampling mode is 8 Samples */
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 8005400:	6822      	ldr	r2, [r4, #0]
  }
  
  /* round the divider : if fractional part i greater than 0.5 increment divider */
  if (tmpreg >=  (USART_InitStruct->USART_BaudRate) / 2)
  {
    divider++;
 8005402:	bf28      	it	cs
 8005404:	3301      	addcs	r3, #1
  } 
  
  /* Implement the divider in case Oversampling mode is 8 Samples */
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
 8005406:	0412      	lsls	r2, r2, #16
 8005408:	d506      	bpl.n	8005418 <USART_Init+0xa0>
  {
    /* get the LSB of divider and shift it to the right by 1 bit */
    tmpreg = (divider & (uint16_t)0x000F) >> 1;
    
    /* update the divider value */
    divider = (divider & (uint16_t)0xFFF0) | tmpreg;
 800540a:	f64f 72f0 	movw	r2, #65520	; 0xfff0
  
  /* Implement the divider in case Oversampling mode is 8 Samples */
  if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
  {
    /* get the LSB of divider and shift it to the right by 1 bit */
    tmpreg = (divider & (uint16_t)0x000F) >> 1;
 800540e:	f3c3 0142 	ubfx	r1, r3, #1, #3
    
    /* update the divider value */
    divider = (divider & (uint16_t)0xFFF0) | tmpreg;
 8005412:	401a      	ands	r2, r3
 8005414:	ea41 0302 	orr.w	r3, r1, r2
  }
  
  /* Write to USART BRR */
  USARTx->BRR = (uint16_t)divider;
 8005418:	81a3      	strh	r3, [r4, #12]
}
 800541a:	b011      	add	sp, #68	; 0x44
 800541c:	bd30      	pop	{r4, r5, pc}
 800541e:	bf00      	nop
 8005420:	40013800 	.word	0x40013800
 8005424:	40004400 	.word	0x40004400
 8005428:	40004800 	.word	0x40004800
 800542c:	40004c00 	.word	0x40004c00

08005430 <USART_StructInit>:
  * @retval None
  */
void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
{
  /* USART_InitStruct members default value */
  USART_InitStruct->USART_BaudRate = 9600;
 8005430:	f44f 5316 	mov.w	r3, #9600	; 0x2580
 8005434:	6003      	str	r3, [r0, #0]
  USART_InitStruct->USART_WordLength = USART_WordLength_8b;
  USART_InitStruct->USART_StopBits = USART_StopBits_1;
  USART_InitStruct->USART_Parity = USART_Parity_No ;
  USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 8005436:	220c      	movs	r2, #12
  */
void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
{
  /* USART_InitStruct members default value */
  USART_InitStruct->USART_BaudRate = 9600;
  USART_InitStruct->USART_WordLength = USART_WordLength_8b;
 8005438:	2300      	movs	r3, #0
 800543a:	6043      	str	r3, [r0, #4]
  USART_InitStruct->USART_StopBits = USART_StopBits_1;
 800543c:	6083      	str	r3, [r0, #8]
  USART_InitStruct->USART_Parity = USART_Parity_No ;
 800543e:	60c3      	str	r3, [r0, #12]
  USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 8005440:	6102      	str	r2, [r0, #16]
  USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;
 8005442:	6143      	str	r3, [r0, #20]
 8005444:	4770      	bx	lr

08005446 <USART_ClockInit>:
  /* Configure the USART Clock, CPOL, CPHA, LastBit and SSM ------------*/
  /* Set CLKEN bit according to USART_Clock value */
  /* Set CPOL bit according to USART_CPOL value */
  /* Set CPHA bit according to USART_CPHA value */
  /* Set LBCL bit according to USART_LastBit value */
  tmpreg |= (uint32_t)(USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
 8005446:	e891 000c 	ldmia.w	r1, {r2, r3}
 800544a:	431a      	orrs	r2, r3
 800544c:	688b      	ldr	r3, [r1, #8]
  *         structure that contains the configuration information for the specified
  *         USART peripheral.
  * @retval None
  */
void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
{
 800544e:	b510      	push	{r4, lr}
  /* Configure the USART Clock, CPOL, CPHA, LastBit and SSM ------------*/
  /* Set CLKEN bit according to USART_Clock value */
  /* Set CPOL bit according to USART_CPOL value */
  /* Set CPHA bit according to USART_CPHA value */
  /* Set LBCL bit according to USART_LastBit value */
  tmpreg |= (uint32_t)(USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
 8005450:	68c9      	ldr	r1, [r1, #12]
  assert_param(IS_USART_CLOCK(USART_ClockInitStruct->USART_Clock));
  assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
  assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
  assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
 8005452:	6844      	ldr	r4, [r0, #4]
  /* Configure the USART Clock, CPOL, CPHA, LastBit and SSM ------------*/
  /* Set CLKEN bit according to USART_Clock value */
  /* Set CPOL bit according to USART_CPOL value */
  /* Set CPHA bit according to USART_CPHA value */
  /* Set LBCL bit according to USART_LastBit value */
  tmpreg |= (uint32_t)(USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
 8005454:	4313      	orrs	r3, r2
  assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
  assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
  /* Clear CLKEN, CPOL, CPHA, LBCL and SSM bits */
  tmpreg &= (uint32_t)~((uint32_t)CR2_CLOCK_CLEAR_MASK);
 8005456:	f424 6470 	bic.w	r4, r4, #3840	; 0xf00
  /* Configure the USART Clock, CPOL, CPHA, LastBit and SSM ------------*/
  /* Set CLKEN bit according to USART_Clock value */
  /* Set CPOL bit according to USART_CPOL value */
  /* Set CPHA bit according to USART_CPHA value */
  /* Set LBCL bit according to USART_LastBit value */
  tmpreg |= (uint32_t)(USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
 800545a:	430b      	orrs	r3, r1
 800545c:	4323      	orrs	r3, r4
                       USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit);
  /* Write to USART CR2 */
  USARTx->CR2 = tmpreg;
 800545e:	6043      	str	r3, [r0, #4]
 8005460:	bd10      	pop	{r4, pc}

08005462 <USART_ClockStructInit>:
  * @retval None
  */
void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
{
  /* USART_ClockInitStruct members default value */
  USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
 8005462:	2300      	movs	r3, #0
 8005464:	6003      	str	r3, [r0, #0]
  USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
 8005466:	6043      	str	r3, [r0, #4]
  USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
 8005468:	6083      	str	r3, [r0, #8]
  USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
 800546a:	60c3      	str	r3, [r0, #12]
 800546c:	4770      	bx	lr

0800546e <USART_Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the selected USART by setting the UE bit in the CR1 register */
    USARTx->CR1 |= USART_CR1_UE;
 800546e:	6803      	ldr	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8005470:	b111      	cbz	r1, 8005478 <USART_Cmd+0xa>
  {
    /* Enable the selected USART by setting the UE bit in the CR1 register */
    USARTx->CR1 |= USART_CR1_UE;
 8005472:	f043 0301 	orr.w	r3, r3, #1
 8005476:	e001      	b.n	800547c <USART_Cmd+0xe>
  }
  else
  {
    /* Disable the selected USART by clearing the UE bit in the CR1 register */
    USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_UE);
 8005478:	f023 0301 	bic.w	r3, r3, #1
 800547c:	6003      	str	r3, [r0, #0]
 800547e:	4770      	bx	lr

08005480 <USART_DirectionModeCmd>:

  if (NewState != DISABLE)
  {
    /* Enable the USART's transfer interface by setting the TE and/or RE bits 
       in the USART CR1 register */
    USARTx->CR1 |= USART_DirectionMode;
 8005480:	6803      	ldr	r3, [r0, #0]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_MODE(USART_DirectionMode));
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 

  if (NewState != DISABLE)
 8005482:	b10a      	cbz	r2, 8005488 <USART_DirectionModeCmd+0x8>
  {
    /* Enable the USART's transfer interface by setting the TE and/or RE bits 
       in the USART CR1 register */
    USARTx->CR1 |= USART_DirectionMode;
 8005484:	4319      	orrs	r1, r3
 8005486:	e001      	b.n	800548c <USART_DirectionModeCmd+0xc>
  }
  else
  {
    /* Disable the USART's transfer interface by clearing the TE and/or RE bits
       in the USART CR3 register */
    USARTx->CR1 &= (uint32_t)~USART_DirectionMode;
 8005488:	ea23 0101 	bic.w	r1, r3, r1
 800548c:	6001      	str	r1, [r0, #0]
 800548e:	4770      	bx	lr

08005490 <USART_OverSampling8Cmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */
    USARTx->CR1 |= USART_CR1_OVER8;
 8005490:	6803      	ldr	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8005492:	b111      	cbz	r1, 800549a <USART_OverSampling8Cmd+0xa>
  {
    /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */
    USARTx->CR1 |= USART_CR1_OVER8;
 8005494:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8005498:	e001      	b.n	800549e <USART_OverSampling8Cmd+0xe>
  }
  else
  {
    /* Disable the 8x Oversampling mode by clearing the OVER8 bit in the CR1 register */
    USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_OVER8);
 800549a:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 800549e:	6003      	str	r3, [r0, #0]
 80054a0:	4770      	bx	lr

080054a2 <USART_OneBitMethodCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_ONEBIT;
 80054a2:	6883      	ldr	r3, [r0, #8]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80054a4:	b111      	cbz	r1, 80054ac <USART_OneBitMethodCmd+0xa>
  {
    /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_ONEBIT;
 80054a6:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 80054aa:	e001      	b.n	80054b0 <USART_OneBitMethodCmd+0xe>
  }
  else
  {
    /* Disable the one bit method by clearing the ONEBITE bit in the CR3 register */
    USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_ONEBIT);
 80054ac:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 80054b0:	6083      	str	r3, [r0, #8]
 80054b2:	4770      	bx	lr

080054b4 <USART_MSBFirstCmd>:

  if (NewState != DISABLE)
  {
    /* Enable the most significant bit first transmitted/received following the
       start bit by setting the MSBFIRST bit in the CR2 register */
    USARTx->CR2 |= USART_CR2_MSBFIRST;
 80054b4:	6843      	ldr	r3, [r0, #4]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80054b6:	b111      	cbz	r1, 80054be <USART_MSBFirstCmd+0xa>
  {
    /* Enable the most significant bit first transmitted/received following the
       start bit by setting the MSBFIRST bit in the CR2 register */
    USARTx->CR2 |= USART_CR2_MSBFIRST;
 80054b8:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 80054bc:	e001      	b.n	80054c2 <USART_MSBFirstCmd+0xe>
  }
  else
  {
    /* Disable the most significant bit first transmitted/received following the
       start bit by clearing the MSBFIRST bit in the CR2 register */
    USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_MSBFIRST);
 80054be:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 80054c2:	6043      	str	r3, [r0, #4]
 80054c4:	4770      	bx	lr

080054c6 <USART_DataInvCmd>:

  if (NewState != DISABLE)
  {
    /* Enable the binary data inversion feature by setting the DATAINV bit in
       the CR2 register */
    USARTx->CR2 |= USART_CR2_DATAINV;
 80054c6:	6843      	ldr	r3, [r0, #4]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80054c8:	b111      	cbz	r1, 80054d0 <USART_DataInvCmd+0xa>
  {
    /* Enable the binary data inversion feature by setting the DATAINV bit in
       the CR2 register */
    USARTx->CR2 |= USART_CR2_DATAINV;
 80054ca:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 80054ce:	e001      	b.n	80054d4 <USART_DataInvCmd+0xe>
  }
  else
  {
    /* Disable the binary data inversion feature by clearing the DATAINV bit in
       the CR2 register */
    USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_DATAINV);
 80054d0:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 80054d4:	6043      	str	r3, [r0, #4]
 80054d6:	4770      	bx	lr

080054d8 <USART_InvPinCmd>:

  if (NewState != DISABLE)
  {
    /* Enable the active level inversion for selected pins by setting the TXINV 
       and/or RXINV bits in the USART CR2 register */
    USARTx->CR2 |= USART_InvPin;
 80054d8:	6843      	ldr	r3, [r0, #4]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_INVERSTION_PIN(USART_InvPin));
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 

  if (NewState != DISABLE)
 80054da:	b10a      	cbz	r2, 80054e0 <USART_InvPinCmd+0x8>
  {
    /* Enable the active level inversion for selected pins by setting the TXINV 
       and/or RXINV bits in the USART CR2 register */
    USARTx->CR2 |= USART_InvPin;
 80054dc:	4319      	orrs	r1, r3
 80054de:	e001      	b.n	80054e4 <USART_InvPinCmd+0xc>
  }
  else
  {
    /* Disable the active level inversion for selected requests by clearing the 
       TXINV and/or RXINV bits in the USART CR2 register */
    USARTx->CR2 &= (uint32_t)~USART_InvPin;
 80054e0:	ea23 0101 	bic.w	r1, r3, r1
 80054e4:	6041      	str	r1, [r0, #4]
 80054e6:	4770      	bx	lr

080054e8 <USART_SWAPPinCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the SWAP feature by setting the SWAP bit in the CR2 register */
    USARTx->CR2 |= USART_CR2_SWAP;
 80054e8:	6843      	ldr	r3, [r0, #4]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80054ea:	b111      	cbz	r1, 80054f2 <USART_SWAPPinCmd+0xa>
  {
    /* Enable the SWAP feature by setting the SWAP bit in the CR2 register */
    USARTx->CR2 |= USART_CR2_SWAP;
 80054ec:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80054f0:	e001      	b.n	80054f6 <USART_SWAPPinCmd+0xe>
  }
  else
  {
    /* Disable the SWAP feature by clearing the SWAP bit in the CR2 register */
    USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_SWAP);
 80054f2:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 80054f6:	6043      	str	r3, [r0, #4]
 80054f8:	4770      	bx	lr

080054fa <USART_ReceiverTimeOutCmd>:

  if (NewState != DISABLE)
  {
    /* Enable the receiver time out feature by setting the RTOEN bit in the CR2 
       register */
    USARTx->CR2 |= USART_CR2_RTOEN;
 80054fa:	6843      	ldr	r3, [r0, #4]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80054fc:	b111      	cbz	r1, 8005504 <USART_ReceiverTimeOutCmd+0xa>
  {
    /* Enable the receiver time out feature by setting the RTOEN bit in the CR2 
       register */
    USARTx->CR2 |= USART_CR2_RTOEN;
 80054fe:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8005502:	e001      	b.n	8005508 <USART_ReceiverTimeOutCmd+0xe>
  }
  else
  {
    /* Disable the receiver time out feature by clearing the RTOEN bit in the CR2 
       register */
    USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_RTOEN);
 8005504:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
 8005508:	6043      	str	r3, [r0, #4]
 800550a:	4770      	bx	lr

0800550c <USART_SetReceiverTimeOut>:
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_TIMEOUT(USART_ReceiverTimeOut));

  /* Clear the receiver Time Out value by clearing the RTO[23:0] bits in the RTOR
     register  */
  USARTx->RTOR &= (uint32_t)~((uint32_t)USART_RTOR_RTO);
 800550c:	6943      	ldr	r3, [r0, #20]
 800550e:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
 8005512:	6143      	str	r3, [r0, #20]
  /* Set the receiver Time Out value by setting the RTO[23:0] bits in the RTOR
     register  */
  USARTx->RTOR |= USART_ReceiverTimeOut;
 8005514:	6943      	ldr	r3, [r0, #20]
 8005516:	4319      	orrs	r1, r3
 8005518:	6141      	str	r1, [r0, #20]
 800551a:	4770      	bx	lr

0800551c <USART_SetPrescaler>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));

  /* Clear the USART prescaler */
  USARTx->GTPR &= USART_GTPR_GT;
 800551c:	8a03      	ldrh	r3, [r0, #16]
 800551e:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 8005522:	8203      	strh	r3, [r0, #16]
  /* Set the USART prescaler */
  USARTx->GTPR |= USART_Prescaler;
 8005524:	8a03      	ldrh	r3, [r0, #16]
 8005526:	b29b      	uxth	r3, r3
 8005528:	4319      	orrs	r1, r3
 800552a:	8201      	strh	r1, [r0, #16]
 800552c:	4770      	bx	lr

0800552e <USART_STOPModeCmd>:
  
  if (NewState != DISABLE)
  {
    /* Enable the selected USART in STOP mode by setting the UESM bit in the CR1
       register */
    USARTx->CR1 |= USART_CR1_UESM;
 800552e:	6803      	ldr	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8005530:	b111      	cbz	r1, 8005538 <USART_STOPModeCmd+0xa>
  {
    /* Enable the selected USART in STOP mode by setting the UESM bit in the CR1
       register */
    USARTx->CR1 |= USART_CR1_UESM;
 8005532:	f043 0302 	orr.w	r3, r3, #2
 8005536:	e001      	b.n	800553c <USART_STOPModeCmd+0xe>
  }
  else
  {
    /* Disable the selected USART in STOP mode by clearing the UE bit in the CR1
       register */
    USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_UESM);
 8005538:	f023 0302 	bic.w	r3, r3, #2
 800553c:	6003      	str	r3, [r0, #0]
 800553e:	4770      	bx	lr

08005540 <USART_StopModeWakeUpSourceConfig>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_STOPMODE_WAKEUPSOURCE(USART_WakeUpSource));

  USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_WUS);
 8005540:	6883      	ldr	r3, [r0, #8]
 8005542:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 8005546:	6083      	str	r3, [r0, #8]
  USARTx->CR3 |= USART_WakeUpSource;
 8005548:	6883      	ldr	r3, [r0, #8]
 800554a:	4319      	orrs	r1, r3
 800554c:	6081      	str	r1, [r0, #8]
 800554e:	4770      	bx	lr

08005550 <USART_AutoBaudRateCmd>:

  if (NewState != DISABLE)
  {
    /* Enable the auto baud rate feature by setting the ABREN bit in the CR2 
       register */
    USARTx->CR2 |= USART_CR2_ABREN;
 8005550:	6843      	ldr	r3, [r0, #4]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8005552:	b111      	cbz	r1, 800555a <USART_AutoBaudRateCmd+0xa>
  {
    /* Enable the auto baud rate feature by setting the ABREN bit in the CR2 
       register */
    USARTx->CR2 |= USART_CR2_ABREN;
 8005554:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8005558:	e001      	b.n	800555e <USART_AutoBaudRateCmd+0xe>
  }
  else
  {
    /* Disable the auto baud rate feature by clearing the ABREN bit in the CR2 
       register */
    USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_ABREN);
 800555a:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
 800555e:	6043      	str	r3, [r0, #4]
 8005560:	4770      	bx	lr

08005562 <USART_AutoBaudRateConfig>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_AUTOBAUDRATE_MODE(USART_AutoBaudRate));

  USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_ABRMODE);
 8005562:	6843      	ldr	r3, [r0, #4]
 8005564:	f423 03c0 	bic.w	r3, r3, #6291456	; 0x600000
 8005568:	6043      	str	r3, [r0, #4]
  USARTx->CR2 |= USART_AutoBaudRate;
 800556a:	6843      	ldr	r3, [r0, #4]
 800556c:	4319      	orrs	r1, r3
 800556e:	6041      	str	r1, [r0, #4]
 8005570:	4770      	bx	lr

08005572 <USART_SendData>:
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_DATA(Data)); 

  /* Transmit Data */
  USARTx->TDR = (Data & (uint16_t)0x01FF);
 8005572:	05c9      	lsls	r1, r1, #23
 8005574:	0dc9      	lsrs	r1, r1, #23
 8005576:	8501      	strh	r1, [r0, #40]	; 0x28
 8005578:	4770      	bx	lr

0800557a <USART_ReceiveData>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));

  /* Receive Data */
  return (uint16_t)(USARTx->RDR & (uint16_t)0x01FF);
 800557a:	8c80      	ldrh	r0, [r0, #36]	; 0x24
 800557c:	05c0      	lsls	r0, r0, #23
}
 800557e:	0dc0      	lsrs	r0, r0, #23
 8005580:	4770      	bx	lr

08005582 <USART_SetAddress>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));

  /* Clear the USART address */
  USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_ADD);
 8005582:	6843      	ldr	r3, [r0, #4]
 8005584:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8005588:	6043      	str	r3, [r0, #4]
  /* Set the USART address node */
  USARTx->CR2 |=((uint32_t)USART_Address << (uint32_t)0x18);
 800558a:	6843      	ldr	r3, [r0, #4]
 800558c:	ea43 6101 	orr.w	r1, r3, r1, lsl #24
 8005590:	6041      	str	r1, [r0, #4]
 8005592:	4770      	bx	lr

08005594 <USART_MuteModeCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 

  if (NewState != DISABLE)
  {
    /* Enable the USART mute mode by setting the MME bit in the CR1 register */
    USARTx->CR1 |= USART_CR1_MME;
 8005594:	6803      	ldr	r3, [r0, #0]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 

  if (NewState != DISABLE)
 8005596:	b111      	cbz	r1, 800559e <USART_MuteModeCmd+0xa>
  {
    /* Enable the USART mute mode by setting the MME bit in the CR1 register */
    USARTx->CR1 |= USART_CR1_MME;
 8005598:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 800559c:	e001      	b.n	80055a2 <USART_MuteModeCmd+0xe>
  }
  else
  {
    /* Disable the USART mute mode by clearing the MME bit in the CR1 register */
    USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_MME);
 800559e:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 80055a2:	6003      	str	r3, [r0, #0]
 80055a4:	4770      	bx	lr

080055a6 <USART_MuteModeWakeUpConfig>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_MUTEMODE_WAKEUP(USART_WakeUp));

  USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_WAKE);
 80055a6:	6803      	ldr	r3, [r0, #0]
 80055a8:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 80055ac:	6003      	str	r3, [r0, #0]
  USARTx->CR1 |= USART_WakeUp;
 80055ae:	6803      	ldr	r3, [r0, #0]
 80055b0:	4319      	orrs	r1, r3
 80055b2:	6001      	str	r1, [r0, #0]
 80055b4:	4770      	bx	lr

080055b6 <USART_AddressDetectionConfig>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_ADDRESS_DETECTION(USART_AddressLength));

  USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_ADDM7);
 80055b6:	6843      	ldr	r3, [r0, #4]
 80055b8:	f023 0310 	bic.w	r3, r3, #16
 80055bc:	6043      	str	r3, [r0, #4]
  USARTx->CR2 |= USART_AddressLength;
 80055be:	6843      	ldr	r3, [r0, #4]
 80055c0:	4319      	orrs	r1, r3
 80055c2:	6041      	str	r1, [r0, #4]
 80055c4:	4770      	bx	lr

080055c6 <USART_LINBreakDetectLengthConfig>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));

  USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_LBDL);
 80055c6:	6843      	ldr	r3, [r0, #4]
 80055c8:	f023 0320 	bic.w	r3, r3, #32
 80055cc:	6043      	str	r3, [r0, #4]
  USARTx->CR2 |= USART_LINBreakDetectLength;  
 80055ce:	6843      	ldr	r3, [r0, #4]
 80055d0:	4319      	orrs	r1, r3
 80055d2:	6041      	str	r1, [r0, #4]
 80055d4:	4770      	bx	lr

080055d6 <USART_LINCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
    USARTx->CR2 |= USART_CR2_LINEN;
 80055d6:	6843      	ldr	r3, [r0, #4]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 80055d8:	b111      	cbz	r1, 80055e0 <USART_LINCmd+0xa>
  {
    /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
    USARTx->CR2 |= USART_CR2_LINEN;
 80055da:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80055de:	e001      	b.n	80055e4 <USART_LINCmd+0xe>
  }
  else
  {
    /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
    USARTx->CR2 &= (uint32_t)~((uint32_t)USART_CR2_LINEN);
 80055e0:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 80055e4:	6043      	str	r3, [r0, #4]
 80055e6:	4770      	bx	lr

080055e8 <USART_HalfDuplexCmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
  {
    /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_HDSEL;
 80055e8:	6883      	ldr	r3, [r0, #8]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 80055ea:	b111      	cbz	r1, 80055f2 <USART_HalfDuplexCmd+0xa>
  {
    /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_HDSEL;
 80055ec:	f043 0308 	orr.w	r3, r3, #8
 80055f0:	e001      	b.n	80055f6 <USART_HalfDuplexCmd+0xe>
  }
  else
  {
    /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
    USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_HDSEL);
 80055f2:	f023 0308 	bic.w	r3, r3, #8
 80055f6:	6083      	str	r3, [r0, #8]
 80055f8:	4770      	bx	lr

080055fa <USART_SetGuardTime>:
{    
  /* Check the parameters */
  assert_param(IS_USART_123_PERIPH(USARTx));

  /* Clear the USART Guard time */
  USARTx->GTPR &= USART_GTPR_PSC;
 80055fa:	8a03      	ldrh	r3, [r0, #16]
 80055fc:	b2db      	uxtb	r3, r3
 80055fe:	8203      	strh	r3, [r0, #16]
  /* Set the USART guard time */
  USARTx->GTPR |= (uint16_t)((uint16_t)USART_GuardTime << 0x08);
 8005600:	8a03      	ldrh	r3, [r0, #16]
 8005602:	b29b      	uxth	r3, r3
 8005604:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
 8005608:	8201      	strh	r1, [r0, #16]
 800560a:	4770      	bx	lr

0800560c <USART_SmartCardCmd>:
  assert_param(IS_USART_123_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the SC mode by setting the SCEN bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_SCEN;
 800560c:	6883      	ldr	r3, [r0, #8]
void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_USART_123_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800560e:	b111      	cbz	r1, 8005616 <USART_SmartCardCmd+0xa>
  {
    /* Enable the SC mode by setting the SCEN bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_SCEN;
 8005610:	f043 0320 	orr.w	r3, r3, #32
 8005614:	e001      	b.n	800561a <USART_SmartCardCmd+0xe>
  }
  else
  {
    /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
    USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_SCEN);
 8005616:	f023 0320 	bic.w	r3, r3, #32
 800561a:	6083      	str	r3, [r0, #8]
 800561c:	4770      	bx	lr

0800561e <USART_SmartCardNACKCmd>:
  assert_param(IS_USART_123_PERIPH(USARTx)); 
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_NACK;
 800561e:	6883      	ldr	r3, [r0, #8]
void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_USART_123_PERIPH(USARTx)); 
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8005620:	b111      	cbz	r1, 8005628 <USART_SmartCardNACKCmd+0xa>
  {
    /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_NACK;
 8005622:	f043 0310 	orr.w	r3, r3, #16
 8005626:	e001      	b.n	800562c <USART_SmartCardNACKCmd+0xe>
  }
  else
  {
    /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
    USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_NACK);
 8005628:	f023 0310 	bic.w	r3, r3, #16
 800562c:	6083      	str	r3, [r0, #8]
 800562e:	4770      	bx	lr

08005630 <USART_SetAutoRetryCount>:
{    
  /* Check the parameters */
  assert_param(IS_USART_123_PERIPH(USARTx));
  assert_param(IS_USART_AUTO_RETRY_COUNTER(USART_AutoCount));
  /* Clear the USART auto retry count */
  USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_SCARCNT);
 8005630:	6883      	ldr	r3, [r0, #8]
 8005632:	f423 2360 	bic.w	r3, r3, #917504	; 0xe0000
 8005636:	6083      	str	r3, [r0, #8]
  /* Set the USART auto retry count*/
  USARTx->CR3 |= (uint32_t)((uint32_t)USART_AutoCount << 0x11);
 8005638:	6883      	ldr	r3, [r0, #8]
 800563a:	ea43 4141 	orr.w	r1, r3, r1, lsl #17
 800563e:	6081      	str	r1, [r0, #8]
 8005640:	4770      	bx	lr

08005642 <USART_SetBlockLength>:
{    
  /* Check the parameters */
  assert_param(IS_USART_123_PERIPH(USARTx));

  /* Clear the Smart card block length */
  USARTx->RTOR &= (uint32_t)~((uint32_t)USART_RTOR_BLEN);
 8005642:	6943      	ldr	r3, [r0, #20]
 8005644:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8005648:	6143      	str	r3, [r0, #20]
  /* Set the Smart Card block length */
  USARTx->RTOR |= (uint32_t)((uint32_t)USART_BlockLength << 0x18);
 800564a:	6943      	ldr	r3, [r0, #20]
 800564c:	ea43 6101 	orr.w	r1, r3, r1, lsl #24
 8005650:	6141      	str	r1, [r0, #20]
 8005652:	4770      	bx	lr

08005654 <USART_IrDAConfig>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));

  USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_IRLP);
 8005654:	6883      	ldr	r3, [r0, #8]
 8005656:	f023 0304 	bic.w	r3, r3, #4
 800565a:	6083      	str	r3, [r0, #8]
  USARTx->CR3 |= USART_IrDAMode;
 800565c:	6883      	ldr	r3, [r0, #8]
 800565e:	4319      	orrs	r1, r3
 8005660:	6081      	str	r1, [r0, #8]
 8005662:	4770      	bx	lr

08005664 <USART_IrDACmd>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
  {
    /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_IREN;
 8005664:	6883      	ldr	r3, [r0, #8]
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8005666:	b111      	cbz	r1, 800566e <USART_IrDACmd+0xa>
  {
    /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_IREN;
 8005668:	f043 0302 	orr.w	r3, r3, #2
 800566c:	e001      	b.n	8005672 <USART_IrDACmd+0xe>
  }
  else
  {
    /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
    USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_IREN);
 800566e:	f023 0302 	bic.w	r3, r3, #2
 8005672:	6083      	str	r3, [r0, #8]
 8005674:	4770      	bx	lr

08005676 <USART_DECmd>:
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
  {
    /* Enable the DE functionality by setting the DEM bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_DEM;
 8005676:	6883      	ldr	r3, [r0, #8]
void USART_DECmd(USART_TypeDef* USARTx, FunctionalState NewState)
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8005678:	b111      	cbz	r1, 8005680 <USART_DECmd+0xa>
  {
    /* Enable the DE functionality by setting the DEM bit in the CR3 register */
    USARTx->CR3 |= USART_CR3_DEM;
 800567a:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800567e:	e001      	b.n	8005684 <USART_DECmd+0xe>
  }
  else
  {
    /* Disable the DE functionality by clearing the DEM bit in the CR3 register */
    USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_DEM);
 8005680:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8005684:	6083      	str	r3, [r0, #8]
 8005686:	4770      	bx	lr

08005688 <USART_DEPolarityConfig>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_DE_POLARITY(USART_DEPolarity));

  USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_DEP);
 8005688:	6883      	ldr	r3, [r0, #8]
 800568a:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 800568e:	6083      	str	r3, [r0, #8]
  USARTx->CR3 |= USART_DEPolarity;
 8005690:	6883      	ldr	r3, [r0, #8]
 8005692:	4319      	orrs	r1, r3
 8005694:	6081      	str	r1, [r0, #8]
 8005696:	4770      	bx	lr

08005698 <USART_SetDEAssertionTime>:
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_DE_ASSERTION_DEASSERTION_TIME(USART_DEAssertionTime)); 

  /* Clear the DE assertion time */
  USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_DEAT);
 8005698:	6803      	ldr	r3, [r0, #0]
 800569a:	f023 7378 	bic.w	r3, r3, #65011712	; 0x3e00000
 800569e:	6003      	str	r3, [r0, #0]
  /* Set the new value for the DE assertion time */
  USARTx->CR1 |=((uint32_t)USART_DEAssertionTime << (uint32_t)0x15);
 80056a0:	6803      	ldr	r3, [r0, #0]
 80056a2:	ea43 5141 	orr.w	r1, r3, r1, lsl #21
 80056a6:	6001      	str	r1, [r0, #0]
 80056a8:	4770      	bx	lr

080056aa <USART_SetDEDeassertionTime>:
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_DE_ASSERTION_DEASSERTION_TIME(USART_DEDeassertionTime)); 

  /* Clear the DE deassertion time */
  USARTx->CR1 &= (uint32_t)~((uint32_t)USART_CR1_DEDT);
 80056aa:	6803      	ldr	r3, [r0, #0]
 80056ac:	f423 13f8 	bic.w	r3, r3, #2031616	; 0x1f0000
 80056b0:	6003      	str	r3, [r0, #0]
  /* Set the new value for the DE deassertion time */
  USARTx->CR1 |=((uint32_t)USART_DEDeassertionTime << (uint32_t)0x10);
 80056b2:	6803      	ldr	r3, [r0, #0]
 80056b4:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 80056b8:	6001      	str	r1, [r0, #0]
 80056ba:	4770      	bx	lr

080056bc <USART_DMACmd>:

  if (NewState != DISABLE)
  {
    /* Enable the DMA transfer for selected requests by setting the DMAT and/or
       DMAR bits in the USART CR3 register */
    USARTx->CR3 |= USART_DMAReq;
 80056bc:	6883      	ldr	r3, [r0, #8]
  /* Check the parameters */
  assert_param(IS_USART_1234_PERIPH(USARTx));
  assert_param(IS_USART_DMAREQ(USART_DMAReq));  
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 

  if (NewState != DISABLE)
 80056be:	b10a      	cbz	r2, 80056c4 <USART_DMACmd+0x8>
  {
    /* Enable the DMA transfer for selected requests by setting the DMAT and/or
       DMAR bits in the USART CR3 register */
    USARTx->CR3 |= USART_DMAReq;
 80056c0:	4319      	orrs	r1, r3
 80056c2:	e001      	b.n	80056c8 <USART_DMACmd+0xc>
  }
  else
  {
    /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
       DMAR bits in the USART CR3 register */
    USARTx->CR3 &= (uint32_t)~USART_DMAReq;
 80056c4:	ea23 0101 	bic.w	r1, r3, r1
 80056c8:	6081      	str	r1, [r0, #8]
 80056ca:	4770      	bx	lr

080056cc <USART_DMAReceptionErrorConfig>:
  /* Check the parameters */
  assert_param(IS_USART_1234_PERIPH(USARTx));
  assert_param(IS_USART_DMAONERROR(USART_DMAOnError)); 
  
  /* Clear the DMA Reception error detection bit */
  USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_DDRE);
 80056cc:	6883      	ldr	r3, [r0, #8]
 80056ce:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 80056d2:	6083      	str	r3, [r0, #8]
  /* Set the new value for the DMA Reception error detection bit */
  USARTx->CR3 |= USART_DMAOnError;
 80056d4:	6883      	ldr	r3, [r0, #8]
 80056d6:	4319      	orrs	r1, r3
 80056d8:	6081      	str	r1, [r0, #8]
 80056da:	4770      	bx	lr

080056dc <USART_ITConfig>:
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  usartxbase = (uint32_t)USARTx;

  /* Get the USART register index */
  usartreg = (((uint16_t)USART_IT) >> 0x08);
 80056dc:	f3c1 2307 	ubfx	r3, r1, #8, #8
  * @param  NewState: new state of the specified USARTx interrupts.
  *         This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void USART_ITConfig(USART_TypeDef* USARTx, uint32_t USART_IT, FunctionalState NewState)
{
 80056e0:	b510      	push	{r4, lr}

  /* Get the USART register index */
  usartreg = (((uint16_t)USART_IT) >> 0x08);

  /* Get the interrupt position */
  itpos = USART_IT & IT_MASK;
 80056e2:	b2c9      	uxtb	r1, r1
  itmask = (((uint32_t)0x01) << itpos);
 80056e4:	2401      	movs	r4, #1

  if (usartreg == 0x02) /* The IT is in CR2 register */
 80056e6:	2b02      	cmp	r3, #2
  /* Get the USART register index */
  usartreg = (((uint16_t)USART_IT) >> 0x08);

  /* Get the interrupt position */
  itpos = USART_IT & IT_MASK;
  itmask = (((uint32_t)0x01) << itpos);
 80056e8:	fa04 f101 	lsl.w	r1, r4, r1

  if (usartreg == 0x02) /* The IT is in CR2 register */
 80056ec:	d101      	bne.n	80056f2 <USART_ITConfig+0x16>
  {
    usartxbase += 0x04;
 80056ee:	3004      	adds	r0, #4
 80056f0:	e002      	b.n	80056f8 <USART_ITConfig+0x1c>
  }
  else if (usartreg == 0x03) /* The IT is in CR3 register */
 80056f2:	2b03      	cmp	r3, #3
  {
    usartxbase += 0x08;
 80056f4:	bf08      	it	eq
 80056f6:	3008      	addeq	r0, #8
  else /* The IT is in CR1 register */
  {
  }
  if (NewState != DISABLE)
  {
    *(__IO uint32_t*)usartxbase  |= itmask;
 80056f8:	6803      	ldr	r3, [r0, #0]
    usartxbase += 0x08;
  }
  else /* The IT is in CR1 register */
  {
  }
  if (NewState != DISABLE)
 80056fa:	b10a      	cbz	r2, 8005700 <USART_ITConfig+0x24>
  {
    *(__IO uint32_t*)usartxbase  |= itmask;
 80056fc:	4319      	orrs	r1, r3
 80056fe:	e001      	b.n	8005704 <USART_ITConfig+0x28>
  }
  else
  {
    *(__IO uint32_t*)usartxbase &= ~itmask;
 8005700:	ea23 0101 	bic.w	r1, r3, r1
 8005704:	6001      	str	r1, [r0, #0]
 8005706:	bd10      	pop	{r4, pc}

08005708 <USART_RequestCmd>:

  if (NewState != DISABLE)
  {
    /* Enable the USART ReQuest by setting the dedicated request bit in the RQR
       register.*/
    USARTx->RQR |= USART_Request;
 8005708:	8b03      	ldrh	r3, [r0, #24]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_REQUEST(USART_Request));
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 

  if (NewState != DISABLE)
 800570a:	b10a      	cbz	r2, 8005710 <USART_RequestCmd+0x8>
  {
    /* Enable the USART ReQuest by setting the dedicated request bit in the RQR
       register.*/
    USARTx->RQR |= USART_Request;
 800570c:	4319      	orrs	r1, r3
 800570e:	e002      	b.n	8005716 <USART_RequestCmd+0xe>
  }
  else
  {
    /* Disable the USART ReQuest by clearing the dedicated request bit in the RQR
       register.*/
    USARTx->RQR &= (uint32_t)~USART_Request;
 8005710:	b29b      	uxth	r3, r3
 8005712:	ea23 0101 	bic.w	r1, r3, r1
 8005716:	8301      	strh	r1, [r0, #24]
 8005718:	4770      	bx	lr

0800571a <USART_OverrunDetectionConfig>:
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_OVRDETECTION(USART_OVRDetection));
  
  /* Clear the OVR detection bit */
  USARTx->CR3 &= (uint32_t)~((uint32_t)USART_CR3_OVRDIS);
 800571a:	6883      	ldr	r3, [r0, #8]
 800571c:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8005720:	6083      	str	r3, [r0, #8]
  /* Set the new value for the OVR detection bit */
  USARTx->CR3 |= USART_OVRDetection;
 8005722:	6883      	ldr	r3, [r0, #8]
 8005724:	4319      	orrs	r1, r3
 8005726:	6081      	str	r1, [r0, #8]
 8005728:	4770      	bx	lr

0800572a <USART_GetFlagStatus>:
  FlagStatus bitstatus = RESET;
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_FLAG(USART_FLAG));
  
  if ((USARTx->ISR & USART_FLAG) != (uint16_t)RESET)
 800572a:	69c3      	ldr	r3, [r0, #28]
 800572c:	4219      	tst	r1, r3
  else
  {
    bitstatus = RESET;
  }
  return bitstatus;
}
 800572e:	bf0c      	ite	eq
 8005730:	2000      	moveq	r0, #0
 8005732:	2001      	movne	r0, #1
 8005734:	4770      	bx	lr

08005736 <USART_ClearFlag>:
{
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
     
  USARTx->ICR = USART_FLAG;
 8005736:	6201      	str	r1, [r0, #32]
 8005738:	4770      	bx	lr

0800573a <USART_GetITStatus>:
  *         @arg USART_IT_FE:  Framing Error interrupt.
  *         @arg USART_IT_PE:  Parity Error interrupt.
  * @retval The new state of USART_IT (SET or RESET).
  */
ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint32_t USART_IT)
{
 800573a:	b510      	push	{r4, lr}
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_GET_IT(USART_IT)); 
  
  /* Get the USART register index */
  usartreg = (((uint16_t)USART_IT) >> 0x08);
 800573c:	f3c1 2207 	ubfx	r2, r1, #8, #8
  /* Get the interrupt position */
  itmask = USART_IT & IT_MASK;
  itmask = (uint32_t)0x01 << itmask;
 8005740:	2401      	movs	r4, #1
  assert_param(IS_USART_GET_IT(USART_IT)); 
  
  /* Get the USART register index */
  usartreg = (((uint16_t)USART_IT) >> 0x08);
  /* Get the interrupt position */
  itmask = USART_IT & IT_MASK;
 8005742:	b2cb      	uxtb	r3, r1
  itmask = (uint32_t)0x01 << itmask;
  
  if (usartreg == 0x01) /* The IT  is in CR1 register */
 8005744:	42a2      	cmp	r2, r4
  
  /* Get the USART register index */
  usartreg = (((uint16_t)USART_IT) >> 0x08);
  /* Get the interrupt position */
  itmask = USART_IT & IT_MASK;
  itmask = (uint32_t)0x01 << itmask;
 8005746:	fa04 f303 	lsl.w	r3, r4, r3
  
  if (usartreg == 0x01) /* The IT  is in CR1 register */
 800574a:	d101      	bne.n	8005750 <USART_GetITStatus+0x16>
  {
    itmask &= USARTx->CR1;
 800574c:	6802      	ldr	r2, [r0, #0]
 800574e:	e003      	b.n	8005758 <USART_GetITStatus+0x1e>
  }
  else if (usartreg == 0x02) /* The IT  is in CR2 register */
 8005750:	2a02      	cmp	r2, #2
  {
    itmask &= USARTx->CR2;
 8005752:	bf0c      	ite	eq
 8005754:	6842      	ldreq	r2, [r0, #4]
  }
  else /* The IT  is in CR3 register */
  {
    itmask &= USARTx->CR3;
 8005756:	6882      	ldrne	r2, [r0, #8]
 8005758:	4013      	ands	r3, r2
  }
  
  bitpos = USART_IT >> 0x10;
  bitpos = (uint32_t)0x01 << bitpos;
  bitpos &= USARTx->ISR;
 800575a:	69c2      	ldr	r2, [r0, #28]
  if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
 800575c:	b143      	cbz	r3, 8005770 <USART_GetITStatus+0x36>
  {
    itmask &= USARTx->CR3;
  }
  
  bitpos = USART_IT >> 0x10;
  bitpos = (uint32_t)0x01 << bitpos;
 800575e:	2301      	movs	r3, #1
  else /* The IT  is in CR3 register */
  {
    itmask &= USARTx->CR3;
  }
  
  bitpos = USART_IT >> 0x10;
 8005760:	0c09      	lsrs	r1, r1, #16
  bitpos = (uint32_t)0x01 << bitpos;
 8005762:	fa03 f101 	lsl.w	r1, r3, r1
  bitpos &= USARTx->ISR;
  if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
 8005766:	4211      	tst	r1, r2
  {
    bitstatus = SET;
 8005768:	bf0c      	ite	eq
 800576a:	2000      	moveq	r0, #0
 800576c:	2001      	movne	r0, #1
 800576e:	bd10      	pop	{r4, pc}
  }
  else
  {
    bitstatus = RESET;
 8005770:	4618      	mov	r0, r3
  }
  
  return bitstatus;  
}
 8005772:	bd10      	pop	{r4, pc}

08005774 <USART_ClearITPendingBit>:
  uint32_t bitpos = 0, itmask = 0;
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_USART_CLEAR_IT(USART_IT)); 
  
  bitpos = USART_IT >> 0x10;
 8005774:	0c09      	lsrs	r1, r1, #16
  itmask = ((uint32_t)0x01 << (uint32_t)bitpos);
 8005776:	2301      	movs	r3, #1
 8005778:	fa03 f101 	lsl.w	r1, r3, r1
  USARTx->ICR = (uint32_t)itmask;
 800577c:	6201      	str	r1, [r0, #32]
 800577e:	4770      	bx	lr

08005780 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 8005780:	b538      	push	{r3, r4, r5, lr}
void *pvReturn = NULL;
static unsigned char *pucAlignedHeap = NULL;

	/* Ensure that blocks are always aligned to the required number of bytes. */
	#if portBYTE_ALIGNMENT != 1
		if( xWantedSize & portBYTE_ALIGNMENT_MASK )
 8005782:	0743      	lsls	r3, r0, #29
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 8005784:	4605      	mov	r5, r0
	/* Ensure that blocks are always aligned to the required number of bytes. */
	#if portBYTE_ALIGNMENT != 1
		if( xWantedSize & portBYTE_ALIGNMENT_MASK )
		{
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 8005786:	bf1c      	itt	ne
 8005788:	f020 0507 	bicne.w	r5, r0, #7
 800578c:	3508      	addne	r5, #8
		}
	#endif

	vTaskSuspendAll();
 800578e:	f000 fff9 	bl	8006784 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
 8005792:	4b10      	ldr	r3, [pc, #64]	; (80057d4 <pvPortMalloc+0x54>)
 8005794:	681a      	ldr	r2, [r3, #0]
 8005796:	b922      	cbnz	r2, 80057a2 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( unsigned char * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
 8005798:	f103 020c 	add.w	r2, r3, #12
 800579c:	f022 0207 	bic.w	r2, r2, #7
 80057a0:	601a      	str	r2, [r3, #0]
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
 80057a2:	4a0d      	ldr	r2, [pc, #52]	; (80057d8 <pvPortMalloc+0x58>)
 80057a4:	f242 71f7 	movw	r1, #10231	; 0x27f7
 80057a8:	f8d2 3614 	ldr.w	r3, [r2, #1556]	; 0x614
 80057ac:	18ed      	adds	r5, r5, r3
 80057ae:	428d      	cmp	r5, r1
 80057b0:	d807      	bhi.n	80057c2 <pvPortMalloc+0x42>
 80057b2:	429d      	cmp	r5, r3
 80057b4:	d905      	bls.n	80057c2 <pvPortMalloc+0x42>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
 80057b6:	4907      	ldr	r1, [pc, #28]	; (80057d4 <pvPortMalloc+0x54>)
			xNextFreeByte += xWantedSize;
 80057b8:	f8c2 5614 	str.w	r5, [r2, #1556]	; 0x614
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
 80057bc:	680c      	ldr	r4, [r1, #0]
 80057be:	18e4      	adds	r4, r4, r3
 80057c0:	e000      	b.n	80057c4 <pvPortMalloc+0x44>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
 80057c2:	2400      	movs	r4, #0
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
			xNextFreeByte += xWantedSize;
		}
	}
	xTaskResumeAll();
 80057c4:	f001 f86e 	bl	80068a4 <xTaskResumeAll>

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
 80057c8:	b90c      	cbnz	r4, 80057ce <pvPortMalloc+0x4e>
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
 80057ca:	f7fc fbdf 	bl	8001f8c <vApplicationMallocFailedHook>
		}
	}
	#endif

	return pvReturn;
}
 80057ce:	4620      	mov	r0, r4
 80057d0:	bd38      	pop	{r3, r4, r5, pc}
 80057d2:	bf00      	nop
 80057d4:	200001f0 	.word	0x200001f0
 80057d8:	200023e0 	.word	0x200023e0

080057dc <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 80057dc:	b508      	push	{r3, lr}
	heap_4.c for alternative implementations, and the memory management pages of
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
 80057de:	b110      	cbz	r0, 80057e6 <vPortFree+0xa>
 80057e0:	f000 f844 	bl	800586c <ulPortSetInterruptMask>
 80057e4:	e7fe      	b.n	80057e4 <vPortFree+0x8>
 80057e6:	bd08      	pop	{r3, pc}

080057e8 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
 80057e8:	4b02      	ldr	r3, [pc, #8]	; (80057f4 <vPortInitialiseBlocks+0xc>)
 80057ea:	2200      	movs	r2, #0
 80057ec:	f8c3 2614 	str.w	r2, [r3, #1556]	; 0x614
 80057f0:	4770      	bx	lr
 80057f2:	bf00      	nop
 80057f4:	200023e0 	.word	0x200023e0

080057f8 <xPortGetFreeHeapSize>:
}
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
 80057f8:	4b03      	ldr	r3, [pc, #12]	; (8005808 <xPortGetFreeHeapSize+0x10>)
 80057fa:	f8d3 0614 	ldr.w	r0, [r3, #1556]	; 0x614
 80057fe:	f5c0 501f 	rsb	r0, r0, #10176	; 0x27c0
}
 8005802:	3038      	adds	r0, #56	; 0x38
 8005804:	4770      	bx	lr
 8005806:	bf00      	nop
 8005808:	200023e0 	.word	0x200023e0

0800580c <prvPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

static void prvPortStartFirstTask( void )
{
	__asm volatile(
 800580c:	4852      	ldr	r0, [pc, #328]	; (8005958 <xPortStartScheduler+0x30>)
 800580e:	6800      	ldr	r0, [r0, #0]
 8005810:	6800      	ldr	r0, [r0, #0]
 8005812:	f380 8808 	msr	MSP, r0
 8005816:	b662      	cpsie	i
 8005818:	df00      	svc	0
 800581a:	bf00      	nop

0800581c <pxPortInitialiseStack>:
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */
	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 800581c:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) pxCode;	/* PC */
 8005820:	e900 000a 	stmdb	r0, {r1, r3}
	pxTopOfStack--;
	*pxTopOfStack = 0;	/* LR */
 8005824:	2300      	movs	r3, #0
 8005826:	f840 3c0c 	str.w	r3, [r0, #-12]
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
	*pxTopOfStack = ( portSTACK_TYPE ) pvParameters;	/* R0 */
 800582a:	f840 2c20 	str.w	r2, [r0, #-32]
	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */

	return pxTopOfStack;
}
 800582e:	3840      	subs	r0, #64	; 0x40
 8005830:	4770      	bx	lr

08005832 <SVC_Handler>:
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
 8005832:	4b07      	ldr	r3, [pc, #28]	; (8005850 <pxCurrentTCBConst2>)
 8005834:	6819      	ldr	r1, [r3, #0]
 8005836:	6808      	ldr	r0, [r1, #0]
 8005838:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 800583c:	f380 8809 	msr	PSP, r0
 8005840:	f04f 0000 	mov.w	r0, #0
 8005844:	f380 8811 	msr	BASEPRI, r0
 8005848:	f04e 0e0d 	orr.w	lr, lr, #13
 800584c:	4770      	bx	lr
 800584e:	bf00      	nop

08005850 <pxCurrentTCBConst2>:
 8005850:	20002a78 	.word	0x20002a78

08005854 <vPortEndScheduler>:
	return 0;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
 8005854:	4770      	bx	lr

08005856 <vPortYield>:
/*-----------------------------------------------------------*/

void vPortYield( void )
{
	/* Set a PendSV to request a context switch. */
	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 8005856:	4b04      	ldr	r3, [pc, #16]	; (8005868 <vPortYield+0x12>)
 8005858:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800585c:	601a      	str	r2, [r3, #0]

	/* Barriers are normally not required but do ensure the code is completely
	within the specified behaviour for the architecture. */
	__asm volatile( "dsb" );
 800585e:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
 8005862:	f3bf 8f6f 	isb	sy
 8005866:	4770      	bx	lr
 8005868:	e000ed04 	.word	0xe000ed04

0800586c <ulPortSetInterruptMask>:
}
/*-----------------------------------------------------------*/

__attribute__(( naked )) unsigned long ulPortSetInterruptMask( void )
{
	__asm volatile														\
 800586c:	f3ef 8011 	mrs	r0, BASEPRI
 8005870:	f04f 0150 	mov.w	r1, #80	; 0x50
 8005874:	f381 8811 	msr	BASEPRI, r1
 8005878:	4770      	bx	lr
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return 0;
}
 800587a:	2000      	movs	r0, #0

0800587c <vPortEnterCritical>:
	__asm volatile( "isb" );
}
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
 800587c:	b508      	push	{r3, lr}
	portDISABLE_INTERRUPTS();
 800587e:	f7ff fff5 	bl	800586c <ulPortSetInterruptMask>
	uxCriticalNesting++;
 8005882:	4b04      	ldr	r3, [pc, #16]	; (8005894 <vPortEnterCritical+0x18>)
 8005884:	681a      	ldr	r2, [r3, #0]
 8005886:	3201      	adds	r2, #1
 8005888:	601a      	str	r2, [r3, #0]
	__asm volatile( "dsb" );
 800588a:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
 800588e:	f3bf 8f6f 	isb	sy
 8005892:	bd08      	pop	{r3, pc}
 8005894:	2000002c 	.word	0x2000002c

08005898 <vPortClearInterruptMask>:
}
/*-----------------------------------------------------------*/

__attribute__(( naked )) void vPortClearInterruptMask( unsigned long ulNewMaskValue )
{
	__asm volatile													\
 8005898:	f380 8811 	msr	BASEPRI, r0
 800589c:	4770      	bx	lr

0800589e <vPortExitCritical>:
}
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
	uxCriticalNesting--;
 800589e:	4b04      	ldr	r3, [pc, #16]	; (80058b0 <vPortExitCritical+0x12>)
 80058a0:	6818      	ldr	r0, [r3, #0]
 80058a2:	3801      	subs	r0, #1
 80058a4:	6018      	str	r0, [r3, #0]
	if( uxCriticalNesting == 0 )
 80058a6:	b908      	cbnz	r0, 80058ac <vPortExitCritical+0xe>
	{
		portENABLE_INTERRUPTS();
 80058a8:	f7ff bff6 	b.w	8005898 <vPortClearInterruptMask>
 80058ac:	4770      	bx	lr
 80058ae:	bf00      	nop
 80058b0:	2000002c 	.word	0x2000002c

080058b4 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
 80058b4:	f3ef 8009 	mrs	r0, PSP
 80058b8:	4b0c      	ldr	r3, [pc, #48]	; (80058ec <pxCurrentTCBConst>)
 80058ba:	681a      	ldr	r2, [r3, #0]
 80058bc:	e920 0ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 80058c0:	6010      	str	r0, [r2, #0]
 80058c2:	e92d 4008 	stmdb	sp!, {r3, lr}
 80058c6:	f04f 0050 	mov.w	r0, #80	; 0x50
 80058ca:	f380 8811 	msr	BASEPRI, r0
 80058ce:	f001 f8cf 	bl	8006a70 <vTaskSwitchContext>
 80058d2:	f04f 0000 	mov.w	r0, #0
 80058d6:	f380 8811 	msr	BASEPRI, r0
 80058da:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 80058de:	6819      	ldr	r1, [r3, #0]
 80058e0:	6808      	ldr	r0, [r1, #0]
 80058e2:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 80058e6:	f380 8809 	msr	PSP, r0
 80058ea:	4770      	bx	lr

080058ec <pxCurrentTCBConst>:
 80058ec:	20002a78 	.word	0x20002a78

080058f0 <SysTick_Handler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 80058f0:	b508      	push	{r3, lr}
	/* If using preemption, also force a context switch. */
	#if configUSE_PREEMPTION == 1
		portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 80058f2:	4b06      	ldr	r3, [pc, #24]	; (800590c <SysTick_Handler+0x1c>)
 80058f4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80058f8:	601a      	str	r2, [r3, #0]
	to generate the tick interrupt. */
	#if configUSE_TICKLESS_IDLE == 1
		portNVIC_SYSTICK_LOAD_REG = ulTimerReloadValueForOneTick;
	#endif

	( void ) portSET_INTERRUPT_MASK_FROM_ISR();
 80058fa:	f7ff ffb7 	bl	800586c <ulPortSetInterruptMask>
	{
		vTaskIncrementTick();
 80058fe:	f000 ff69 	bl	80067d4 <vTaskIncrementTick>
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( 0 );
 8005902:	2000      	movs	r0, #0
}
 8005904:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

	( void ) portSET_INTERRUPT_MASK_FROM_ISR();
	{
		vTaskIncrementTick();
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( 0 );
 8005908:	f7ff bfc6 	b.w	8005898 <vPortClearInterruptMask>
 800590c:	e000ed04 	.word	0xe000ed04

08005910 <vPortSetupTimerInterrupt>:
		ulStoppedTimerCompensation = 45UL / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
	}
	#endif /* configUSE_TICKLESS_IDLE */

	/* Configure SysTick to interrupt at the requested rate. */
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;;
 8005910:	4a03      	ldr	r2, [pc, #12]	; (8005920 <vPortSetupTimerInterrupt+0x10>)
 8005912:	4b04      	ldr	r3, [pc, #16]	; (8005924 <vPortSetupTimerInterrupt+0x14>)
 8005914:	601a      	str	r2, [r3, #0]
	portNVIC_SYSTICK_CTRL_REG = portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT;
 8005916:	2207      	movs	r2, #7
 8005918:	f843 2c04 	str.w	r2, [r3, #-4]
 800591c:	4770      	bx	lr
 800591e:	bf00      	nop
 8005920:	0001193f 	.word	0x0001193f
 8005924:	e000e014 	.word	0xe000e014

08005928 <xPortStartScheduler>:
	/* configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to 0.
	See http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
	configASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );

	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 8005928:	4b09      	ldr	r3, [pc, #36]	; (8005950 <xPortStartScheduler+0x28>)

/*
 * See header file for description.
 */
portBASE_TYPE xPortStartScheduler( void )
{
 800592a:	b510      	push	{r4, lr}
	/* configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to 0.
	See http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
	configASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );

	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 800592c:	681a      	ldr	r2, [r3, #0]
	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	vPortSetupTimerInterrupt();

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
 800592e:	2400      	movs	r4, #0
	/* configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to 0.
	See http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
	configASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );

	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 8005930:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 8005934:	601a      	str	r2, [r3, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 8005936:	681a      	ldr	r2, [r3, #0]
 8005938:	f042 4270 	orr.w	r2, r2, #4026531840	; 0xf0000000
 800593c:	601a      	str	r2, [r3, #0]

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	vPortSetupTimerInterrupt();
 800593e:	f7ff ffe7 	bl	8005910 <vPortSetupTimerInterrupt>

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
 8005942:	4b04      	ldr	r3, [pc, #16]	; (8005954 <xPortStartScheduler+0x2c>)
 8005944:	601c      	str	r4, [r3, #0]

	/* Start the first task. */
	prvPortStartFirstTask();
 8005946:	f7ff ff61 	bl	800580c <prvPortStartFirstTask>

	/* Should not get here! */
	return 0;
}
 800594a:	4620      	mov	r0, r4
 800594c:	bd10      	pop	{r4, pc}
 800594e:	bf00      	nop
 8005950:	e000ed20 	.word	0xe000ed20
 8005954:	2000002c 	.word	0x2000002c
 8005958:	e000ed08 	.word	0xe000ed08

0800595c <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
 800595c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8005960:	4680      	mov	r8, r0
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
 8005962:	2038      	movs	r0, #56	; 0x38
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
 8005964:	468a      	mov	sl, r1
 8005966:	4691      	mov	r9, r2
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
 8005968:	f7ff ff0a 	bl	8005780 <pvPortMalloc>
	if( pxCoRoutine )
 800596c:	4604      	mov	r4, r0
 800596e:	2800      	cmp	r0, #0
 8005970:	d044      	beq.n	80059fc <xCoRoutineCreate+0xa0>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
 8005972:	4d24      	ldr	r5, [pc, #144]	; (8005a04 <xCoRoutineCreate+0xa8>)
 8005974:	682b      	ldr	r3, [r5, #0]
 8005976:	b9c3      	cbnz	r3, 80059aa <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
 8005978:	4628      	mov	r0, r5
 800597a:	f840 4b04 	str.w	r4, [r0], #4
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
 800597e:	f000 f903 	bl	8005b88 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
 8005982:	f105 062c 	add.w	r6, r5, #44	; 0x2c
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
 8005986:	f105 0018 	add.w	r0, r5, #24
 800598a:	f000 f8fd 	bl	8005b88 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
 800598e:	f105 0740 	add.w	r7, r5, #64	; 0x40
	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
 8005992:	4630      	mov	r0, r6
 8005994:	f000 f8f8 	bl	8005b88 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
 8005998:	4638      	mov	r0, r7
 800599a:	f000 f8f5 	bl	8005b88 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
 800599e:	f105 0054 	add.w	r0, r5, #84	; 0x54
 80059a2:	f000 f8f1 	bl	8005b88 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
 80059a6:	66ae      	str	r6, [r5, #104]	; 0x68
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
 80059a8:	66ef      	str	r7, [r5, #108]	; 0x6c

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
		pxCoRoutine->uxPriority = uxPriority;
		pxCoRoutine->uxIndex = uxIndex;
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
 80059aa:	4625      	mov	r5, r4
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
 80059ac:	2300      	movs	r3, #0
 80059ae:	f1ba 0f01 	cmp.w	sl, #1
 80059b2:	bf34      	ite	cc
 80059b4:	4656      	movcc	r6, sl
 80059b6:	2601      	movcs	r6, #1
		pxCoRoutine->uxPriority = uxPriority;
		pxCoRoutine->uxIndex = uxIndex;
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
 80059b8:	f845 8b04 	str.w	r8, [r5], #4
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
 80059bc:	86a3      	strh	r3, [r4, #52]	; 0x34
		pxCoRoutine->uxPriority = uxPriority;
 80059be:	62e6      	str	r6, [r4, #44]	; 0x2c
		pxCoRoutine->uxIndex = uxIndex;
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
 80059c0:	4628      	mov	r0, r5
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
		pxCoRoutine->uxPriority = uxPriority;
		pxCoRoutine->uxIndex = uxIndex;
 80059c2:	f8c4 9030 	str.w	r9, [r4, #48]	; 0x30
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
 80059c6:	f000 f8ea 	bl	8005b9e <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
 80059ca:	f104 0018 	add.w	r0, r4, #24
 80059ce:	f000 f8e6 	bl	8005b9e <vListInitialiseItem>
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
 80059d2:	4a0c      	ldr	r2, [pc, #48]	; (8005a04 <xCoRoutineCreate+0xa8>)
 80059d4:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80059d6:	6f11      	ldr	r1, [r2, #112]	; 0x70
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
 80059d8:	f1c6 0605 	rsb	r6, r6, #5

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
 80059dc:	428b      	cmp	r3, r1
 80059de:	bf88      	it	hi
 80059e0:	6713      	strhi	r3, [r2, #112]	; 0x70
 80059e2:	4a09      	ldr	r2, [pc, #36]	; (8005a08 <xCoRoutineCreate+0xac>)
 80059e4:	2014      	movs	r0, #20
 80059e6:	fb00 2003 	mla	r0, r0, r3, r2
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
 80059ea:	6124      	str	r4, [r4, #16]
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
 80059ec:	6264      	str	r4, [r4, #36]	; 0x24

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
 80059ee:	61a6      	str	r6, [r4, #24]

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
 80059f0:	4629      	mov	r1, r5
 80059f2:	f000 f8d7 	bl	8005ba4 <vListInsertEnd>

		xReturn = pdPASS;
 80059f6:	2001      	movs	r0, #1
 80059f8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 80059fc:	f04f 30ff 	mov.w	r0, #4294967295
	}

	return xReturn;
}
 8005a00:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8005a04:	200029f8 	.word	0x200029f8
 8005a08:	200029fc 	.word	0x200029fc

08005a0c <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
 8005a0c:	b570      	push	{r4, r5, r6, lr}
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
 8005a0e:	4c0d      	ldr	r4, [pc, #52]	; (8005a44 <vCoRoutineAddToDelayedList+0x38>)
	return xReturn;
}
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
 8005a10:	460d      	mov	r5, r1
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
 8005a12:	6f66      	ldr	r6, [r4, #116]	; 0x74
 8005a14:	1986      	adds	r6, r0, r6

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	uxListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
 8005a16:	6820      	ldr	r0, [r4, #0]
 8005a18:	3004      	adds	r0, #4
 8005a1a:	f000 f8e8 	bl	8005bee <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xCoRoutineTickCount )
 8005a1e:	6f63      	ldr	r3, [r4, #116]	; 0x74
	ourselves to the blocked list as the same list item is used for
	both lists. */
	uxListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
 8005a20:	6821      	ldr	r1, [r4, #0]

	if( xTimeToWake < xCoRoutineTickCount )
 8005a22:	429e      	cmp	r6, r3
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
 8005a24:	bf34      	ite	cc
 8005a26:	6ee0      	ldrcc	r0, [r4, #108]	; 0x6c
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
 8005a28:	6ea0      	ldrcs	r0, [r4, #104]	; 0x68
	ourselves to the blocked list as the same list item is used for
	both lists. */
	uxListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
 8005a2a:	f841 6f04 	str.w	r6, [r1, #4]!
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
 8005a2e:	f000 f8c6 	bl	8005bbe <vListInsert>
	}

	if( pxEventList )
 8005a32:	b135      	cbz	r5, 8005a42 <vCoRoutineAddToDelayedList+0x36>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
 8005a34:	6821      	ldr	r1, [r4, #0]
 8005a36:	4628      	mov	r0, r5
 8005a38:	3118      	adds	r1, #24
	}
}
 8005a3a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}

	if( pxEventList )
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
 8005a3e:	f000 b8be 	b.w	8005bbe <vListInsert>
 8005a42:	bd70      	pop	{r4, r5, r6, pc}
 8005a44:	200029f8 	.word	0x200029f8

08005a48 <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
 8005a48:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
 8005a4c:	4d41      	ldr	r5, [pc, #260]	; (8005b54 <vCoRoutineSchedule+0x10c>)
			uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();

		uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
 8005a4e:	f04f 0814 	mov.w	r8, #20
 8005a52:	1d2f      	adds	r7, r5, #4
 8005a54:	e018      	b.n	8005a88 <vCoRoutineSchedule+0x40>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
 8005a56:	f7ff ff09 	bl	800586c <ulPortSetInterruptMask>
		{
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
 8005a5a:	6e2b      	ldr	r3, [r5, #96]	; 0x60
 8005a5c:	68dc      	ldr	r4, [r3, #12]
			uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
 8005a5e:	f104 0018 	add.w	r0, r4, #24
 8005a62:	f000 f8c4 	bl	8005bee <uxListRemove>
		}
		portENABLE_INTERRUPTS();

		uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
 8005a66:	1d26      	adds	r6, r4, #4
		portDISABLE_INTERRUPTS();
		{
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
			uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();
 8005a68:	2000      	movs	r0, #0
 8005a6a:	f7ff ff15 	bl	8005898 <vPortClearInterruptMask>

		uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
 8005a6e:	4630      	mov	r0, r6
 8005a70:	f000 f8bd 	bl	8005bee <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
 8005a74:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8005a76:	6f2a      	ldr	r2, [r5, #112]	; 0x70
 8005a78:	4631      	mov	r1, r6
 8005a7a:	4290      	cmp	r0, r2
 8005a7c:	bf88      	it	hi
 8005a7e:	6728      	strhi	r0, [r5, #112]	; 0x70
 8005a80:	fb08 7000 	mla	r0, r8, r0, r7
 8005a84:	f000 f88e 	bl	8005ba4 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
 8005a88:	6d6b      	ldr	r3, [r5, #84]	; 0x54
 8005a8a:	4c32      	ldr	r4, [pc, #200]	; (8005b54 <vCoRoutineSchedule+0x10c>)
 8005a8c:	2b00      	cmp	r3, #0
 8005a8e:	d1e2      	bne.n	8005a56 <vCoRoutineSchedule+0xe>

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
 8005a90:	f000 fe82 	bl	8006798 <xTaskGetTickCount>
 8005a94:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
					uxListRemove( &( pxCRCB->xEventListItem ) );
				}
			}
			portENABLE_INTERRUPTS();

			prvAddCoRoutineToReadyQueue( pxCRCB );
 8005a96:	1d27      	adds	r7, r4, #4

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
 8005a98:	1ac0      	subs	r0, r0, r3
 8005a9a:	67a0      	str	r0, [r4, #120]	; 0x78
 8005a9c:	e030      	b.n	8005b00 <vCoRoutineSchedule+0xb8>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
 8005a9e:	6f62      	ldr	r2, [r4, #116]	; 0x74
		xPassedTicks--;
 8005aa0:	3b01      	subs	r3, #1
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
 8005aa2:	3201      	adds	r2, #1
 8005aa4:	6762      	str	r2, [r4, #116]	; 0x74
		xPassedTicks--;
 8005aa6:	67a3      	str	r3, [r4, #120]	; 0x78

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
 8005aa8:	bb22      	cbnz	r2, 8005af4 <vCoRoutineSchedule+0xac>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
 8005aaa:	6ea2      	ldr	r2, [r4, #104]	; 0x68
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
 8005aac:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
			pxOverflowDelayedCoRoutineList = pxTemp;
 8005aae:	66e2      	str	r2, [r4, #108]	; 0x6c
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
 8005ab0:	66a3      	str	r3, [r4, #104]	; 0x68
 8005ab2:	e01f      	b.n	8005af4 <vCoRoutineSchedule+0xac>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
 8005ab4:	68db      	ldr	r3, [r3, #12]

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
 8005ab6:	6f62      	ldr	r2, [r4, #116]	; 0x74
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
 8005ab8:	68dd      	ldr	r5, [r3, #12]

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
 8005aba:	686b      	ldr	r3, [r5, #4]
 8005abc:	429a      	cmp	r2, r3
 8005abe:	d31f      	bcc.n	8005b00 <vCoRoutineSchedule+0xb8>
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				uxListRemove( &( pxCRCB->xGenericListItem ) );
 8005ac0:	1d2e      	adds	r6, r5, #4
			{
				/* Timeout not yet expired. */
				break;
			}

			portDISABLE_INTERRUPTS();
 8005ac2:	f7ff fed3 	bl	800586c <ulPortSetInterruptMask>
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				uxListRemove( &( pxCRCB->xGenericListItem ) );
 8005ac6:	4630      	mov	r0, r6
 8005ac8:	f000 f891 	bl	8005bee <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pvContainer )
 8005acc:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8005ace:	b11b      	cbz	r3, 8005ad8 <vCoRoutineSchedule+0x90>
				{
					uxListRemove( &( pxCRCB->xEventListItem ) );
 8005ad0:	f105 0018 	add.w	r0, r5, #24
 8005ad4:	f000 f88b 	bl	8005bee <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
 8005ad8:	2000      	movs	r0, #0
 8005ada:	f7ff fedd 	bl	8005898 <vPortClearInterruptMask>

			prvAddCoRoutineToReadyQueue( pxCRCB );
 8005ade:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
 8005ae0:	6f22      	ldr	r2, [r4, #112]	; 0x70
 8005ae2:	4631      	mov	r1, r6
 8005ae4:	4290      	cmp	r0, r2
 8005ae6:	bf88      	it	hi
 8005ae8:	6720      	strhi	r0, [r4, #112]	; 0x70
 8005aea:	fb08 7000 	mla	r0, r8, r0, r7
 8005aee:	f000 f859 	bl	8005ba4 <vListInsertEnd>
 8005af2:	e001      	b.n	8005af8 <vCoRoutineSchedule+0xb0>
 8005af4:	f04f 0814 	mov.w	r8, #20
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
 8005af8:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 8005afa:	681a      	ldr	r2, [r3, #0]
 8005afc:	2a00      	cmp	r2, #0
 8005afe:	d1d9      	bne.n	8005ab4 <vCoRoutineSchedule+0x6c>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
 8005b00:	6fa3      	ldr	r3, [r4, #120]	; 0x78
 8005b02:	4a14      	ldr	r2, [pc, #80]	; (8005b54 <vCoRoutineSchedule+0x10c>)
 8005b04:	2b00      	cmp	r3, #0
 8005b06:	d1ca      	bne.n	8005a9e <vCoRoutineSchedule+0x56>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
 8005b08:	6f53      	ldr	r3, [r2, #116]	; 0x74

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
 8005b0a:	2514      	movs	r5, #20

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
 8005b0c:	67d3      	str	r3, [r2, #124]	; 0x7c
 8005b0e:	6f13      	ldr	r3, [r2, #112]	; 0x70
 8005b10:	e004      	b.n	8005b1c <vCoRoutineSchedule+0xd4>
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
 8005b12:	b913      	cbnz	r3, 8005b1a <vCoRoutineSchedule+0xd2>
 8005b14:	670b      	str	r3, [r1, #112]	; 0x70
 8005b16:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
 8005b1a:	3b01      	subs	r3, #1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
 8005b1c:	fb05 f003 	mul.w	r0, r5, r3
 8005b20:	1814      	adds	r4, r2, r0
 8005b22:	6864      	ldr	r4, [r4, #4]
 8005b24:	490b      	ldr	r1, [pc, #44]	; (8005b54 <vCoRoutineSchedule+0x10c>)
 8005b26:	2c00      	cmp	r4, #0
 8005b28:	d0f3      	beq.n	8005b12 <vCoRoutineSchedule+0xca>
 8005b2a:	670b      	str	r3, [r1, #112]	; 0x70
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
 8005b2c:	1d0b      	adds	r3, r1, #4
 8005b2e:	181b      	adds	r3, r3, r0
 8005b30:	685a      	ldr	r2, [r3, #4]
 8005b32:	f103 0108 	add.w	r1, r3, #8
 8005b36:	6852      	ldr	r2, [r2, #4]
 8005b38:	428a      	cmp	r2, r1
 8005b3a:	605a      	str	r2, [r3, #4]
 8005b3c:	bf04      	itt	eq
 8005b3e:	6852      	ldreq	r2, [r2, #4]
 8005b40:	605a      	streq	r2, [r3, #4]
 8005b42:	685b      	ldr	r3, [r3, #4]
 8005b44:	68d8      	ldr	r0, [r3, #12]
 8005b46:	4b03      	ldr	r3, [pc, #12]	; (8005b54 <vCoRoutineSchedule+0x10c>)

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
 8005b48:	6b01      	ldr	r1, [r0, #48]	; 0x30
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
 8005b4a:	6018      	str	r0, [r3, #0]

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
 8005b4c:	6803      	ldr	r3, [r0, #0]
 8005b4e:	4798      	blx	r3
 8005b50:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8005b54:	200029f8 	.word	0x200029f8

08005b58 <xCoRoutineRemoveFromEventList>:
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 8005b58:	68c3      	ldr	r3, [r0, #12]
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
 8005b5a:	b570      	push	{r4, r5, r6, lr}
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 8005b5c:	68dc      	ldr	r4, [r3, #12]
	uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
 8005b5e:	4d09      	ldr	r5, [pc, #36]	; (8005b84 <xCoRoutineRemoveFromEventList+0x2c>)

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
	uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
 8005b60:	f104 0618 	add.w	r6, r4, #24
 8005b64:	4630      	mov	r0, r6
 8005b66:	f000 f842 	bl	8005bee <uxListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
 8005b6a:	f105 0054 	add.w	r0, r5, #84	; 0x54
 8005b6e:	4631      	mov	r1, r6
 8005b70:	f000 f818 	bl	8005ba4 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
 8005b74:	682b      	ldr	r3, [r5, #0]
 8005b76:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8005b78:	6adb      	ldr	r3, [r3, #44]	; 0x2c
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
 8005b7a:	4298      	cmp	r0, r3
 8005b7c:	bf34      	ite	cc
 8005b7e:	2000      	movcc	r0, #0
 8005b80:	2001      	movcs	r0, #1
 8005b82:	bd70      	pop	{r4, r5, r6, pc}
 8005b84:	200029f8 	.word	0x200029f8

08005b88 <vListInitialise>:
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
 8005b88:	f100 0308 	add.w	r3, r0, #8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8005b8c:	f04f 32ff 	mov.w	r2, #4294967295
 8005b90:	6082      	str	r2, [r0, #8]
void vListInitialise( xList *pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
 8005b92:	6043      	str	r3, [r0, #4]
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
 8005b94:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
 8005b96:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
 8005b98:	2300      	movs	r3, #0
 8005b9a:	6003      	str	r3, [r0, #0]
 8005b9c:	4770      	bx	lr

08005b9e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 8005b9e:	2300      	movs	r3, #0
 8005ba0:	6103      	str	r3, [r0, #16]
 8005ba2:	4770      	bx	lr

08005ba4 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
 8005ba4:	6843      	ldr	r3, [r0, #4]

	pxNewListItem->pxNext = pxIndex->pxNext;
 8005ba6:	685a      	ldr	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxList->pxIndex;
 8005ba8:	608b      	str	r3, [r1, #8]
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;

	pxNewListItem->pxNext = pxIndex->pxNext;
 8005baa:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxPrevious = pxList->pxIndex;
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
 8005bac:	685a      	ldr	r2, [r3, #4]
 8005bae:	6091      	str	r1, [r2, #8]
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
 8005bb0:	6059      	str	r1, [r3, #4]
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8005bb2:	6803      	ldr	r3, [r0, #0]

	pxNewListItem->pxNext = pxIndex->pxNext;
	pxNewListItem->pxPrevious = pxList->pxIndex;
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
 8005bb4:	6041      	str	r1, [r0, #4]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8005bb6:	3301      	adds	r3, #1
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 8005bb8:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
 8005bba:	6003      	str	r3, [r0, #0]
 8005bbc:	4770      	bx	lr

08005bbe <vListInsert>:
{
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
 8005bbe:	680a      	ldr	r2, [r1, #0]
	( pxList->uxNumberOfItems )++;
}
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
 8005bc0:	b510      	push	{r4, lr}
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 8005bc2:	1c53      	adds	r3, r2, #1
 8005bc4:	d101      	bne.n	8005bca <vListInsert+0xc>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 8005bc6:	6903      	ldr	r3, [r0, #16]
 8005bc8:	e007      	b.n	8005bda <vListInsert+0x1c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
 8005bca:	f100 0308 	add.w	r3, r0, #8
 8005bce:	e000      	b.n	8005bd2 <vListInsert+0x14>
 8005bd0:	685b      	ldr	r3, [r3, #4]
 8005bd2:	685c      	ldr	r4, [r3, #4]
 8005bd4:	6824      	ldr	r4, [r4, #0]
 8005bd6:	4294      	cmp	r4, r2
 8005bd8:	d9fa      	bls.n	8005bd0 <vListInsert+0x12>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 8005bda:	685a      	ldr	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxIterator;
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 8005bdc:	6108      	str	r0, [r1, #16]
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
 8005bde:	6091      	str	r1, [r2, #8]
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 8005be0:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
	pxNewListItem->pxPrevious = pxIterator;
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
 8005be2:	6059      	str	r1, [r3, #4]
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
	pxNewListItem->pxPrevious = pxIterator;
 8005be4:	608b      	str	r3, [r1, #8]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8005be6:	6803      	ldr	r3, [r0, #0]
 8005be8:	3301      	adds	r3, #1
 8005bea:	6003      	str	r3, [r0, #0]
 8005bec:	bd10      	pop	{r4, pc}

08005bee <uxListRemove>:

unsigned portBASE_TYPE uxListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8005bee:	6843      	ldr	r3, [r0, #4]
 8005bf0:	6882      	ldr	r2, [r0, #8]
 8005bf2:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 8005bf4:	6882      	ldr	r2, [r0, #8]
 8005bf6:	6053      	str	r3, [r2, #4]

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
 8005bf8:	6903      	ldr	r3, [r0, #16]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 8005bfa:	6859      	ldr	r1, [r3, #4]
 8005bfc:	4281      	cmp	r1, r0
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 8005bfe:	bf08      	it	eq
 8005c00:	605a      	streq	r2, [r3, #4]
	}

	pxItemToRemove->pvContainer = NULL;
 8005c02:	2200      	movs	r2, #0
 8005c04:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
 8005c06:	681a      	ldr	r2, [r3, #0]
 8005c08:	3a01      	subs	r2, #1
 8005c0a:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
 8005c0c:	6818      	ldr	r0, [r3, #0]
}
 8005c0e:	4770      	bx	lr

08005c10 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQUEUE *pxQueue )
{
 8005c10:	b538      	push	{r3, r4, r5, lr}
 8005c12:	4604      	mov	r4, r0
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8005c14:	f104 0524 	add.w	r5, r4, #36	; 0x24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
 8005c18:	f7ff fe30 	bl	800587c <vPortEnterCritical>
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 8005c1c:	e00a      	b.n	8005c34 <prvUnlockQueue+0x24>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8005c1e:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8005c20:	b15b      	cbz	r3, 8005c3a <prvUnlockQueue+0x2a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8005c22:	4628      	mov	r0, r5
 8005c24:	f000 ffe6 	bl	8006bf4 <xTaskRemoveFromEventList>
 8005c28:	b108      	cbz	r0, 8005c2e <prvUnlockQueue+0x1e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
 8005c2a:	f001 f855 	bl	8006cd8 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
 8005c2e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8005c30:	3b01      	subs	r3, #1
 8005c32:	64a3      	str	r3, [r4, #72]	; 0x48
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 8005c34:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8005c36:	2b00      	cmp	r3, #0
 8005c38:	dcf1      	bgt.n	8005c1e <prvUnlockQueue+0xe>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
 8005c3a:	f04f 33ff 	mov.w	r3, #4294967295
 8005c3e:	64a3      	str	r3, [r4, #72]	; 0x48
	}
	taskEXIT_CRITICAL();
 8005c40:	f7ff fe2d 	bl	800589e <vPortExitCritical>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8005c44:	f104 0510 	add.w	r5, r4, #16
		pxQueue->xTxLock = queueUNLOCKED;
	}
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
 8005c48:	f7ff fe18 	bl	800587c <vPortEnterCritical>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 8005c4c:	e00a      	b.n	8005c64 <prvUnlockQueue+0x54>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8005c4e:	6923      	ldr	r3, [r4, #16]
 8005c50:	b15b      	cbz	r3, 8005c6a <prvUnlockQueue+0x5a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8005c52:	4628      	mov	r0, r5
 8005c54:	f000 ffce 	bl	8006bf4 <xTaskRemoveFromEventList>
 8005c58:	b108      	cbz	r0, 8005c5e <prvUnlockQueue+0x4e>
				{
					vTaskMissedYield();
 8005c5a:	f001 f83d 	bl	8006cd8 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
 8005c5e:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8005c60:	3b01      	subs	r3, #1
 8005c62:	6463      	str	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 8005c64:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8005c66:	2b00      	cmp	r3, #0
 8005c68:	dcf1      	bgt.n	8005c4e <prvUnlockQueue+0x3e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
 8005c6a:	f04f 33ff 	mov.w	r3, #4294967295
 8005c6e:	6463      	str	r3, [r4, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
}
 8005c70:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
	}
	taskEXIT_CRITICAL();
 8005c74:	f7ff be13 	b.w	800589e <vPortExitCritical>

08005c78 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
 8005c78:	b570      	push	{r4, r5, r6, lr}
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
 8005c7a:	6804      	ldr	r4, [r0, #0]
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
 8005c7c:	4603      	mov	r3, r0
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
 8005c7e:	b16c      	cbz	r4, 8005c9c <prvCopyDataFromQueue+0x24>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
 8005c80:	68c5      	ldr	r5, [r0, #12]
 8005c82:	6c02      	ldr	r2, [r0, #64]	; 0x40
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
 8005c84:	6846      	ldr	r6, [r0, #4]

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
 8005c86:	18ad      	adds	r5, r5, r2
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
 8005c88:	42b5      	cmp	r5, r6

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
 8005c8a:	60c5      	str	r5, [r0, #12]
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
 8005c8c:	bf28      	it	cs
 8005c8e:	60c4      	strcs	r4, [r0, #12]
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
 8005c90:	4608      	mov	r0, r1
 8005c92:	68d9      	ldr	r1, [r3, #12]
	}
}
 8005c94:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
 8005c98:	f002 b84a 	b.w	8007d30 <memcpy>
 8005c9c:	bd70      	pop	{r4, r5, r6, pc}

08005c9e <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
 8005c9e:	b538      	push	{r3, r4, r5, lr}
 8005ca0:	4613      	mov	r3, r2
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
 8005ca2:	6c02      	ldr	r2, [r0, #64]	; 0x40

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
 8005ca4:	4604      	mov	r4, r0
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
 8005ca6:	b932      	cbnz	r2, 8005cb6 <prvCopyDataToQueue+0x18>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8005ca8:	6805      	ldr	r5, [r0, #0]
 8005caa:	bb05      	cbnz	r5, 8005cee <prvCopyDataToQueue+0x50>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 8005cac:	6840      	ldr	r0, [r0, #4]
 8005cae:	f001 f865 	bl	8006d7c <vTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
 8005cb2:	6065      	str	r5, [r4, #4]
 8005cb4:	e01b      	b.n	8005cee <prvCopyDataToQueue+0x50>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
 8005cb6:	b963      	cbnz	r3, 8005cd2 <prvCopyDataToQueue+0x34>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
 8005cb8:	6880      	ldr	r0, [r0, #8]
 8005cba:	f002 f839 	bl	8007d30 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 8005cbe:	68a2      	ldr	r2, [r4, #8]
 8005cc0:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8005cc2:	18d3      	adds	r3, r2, r3
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
 8005cc4:	6862      	ldr	r2, [r4, #4]
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 8005cc6:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
 8005cc8:	4293      	cmp	r3, r2
 8005cca:	d310      	bcc.n	8005cee <prvCopyDataToQueue+0x50>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
 8005ccc:	6823      	ldr	r3, [r4, #0]
 8005cce:	60a3      	str	r3, [r4, #8]
 8005cd0:	e00d      	b.n	8005cee <prvCopyDataToQueue+0x50>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
 8005cd2:	68c0      	ldr	r0, [r0, #12]
 8005cd4:	f002 f82c 	bl	8007d30 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
 8005cd8:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8005cda:	68e2      	ldr	r2, [r4, #12]
 8005cdc:	425b      	negs	r3, r3
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
 8005cde:	6821      	ldr	r1, [r4, #0]
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
 8005ce0:	18d2      	adds	r2, r2, r3
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
 8005ce2:	428a      	cmp	r2, r1
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
 8005ce4:	60e2      	str	r2, [r4, #12]
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
 8005ce6:	d202      	bcs.n	8005cee <prvCopyDataToQueue+0x50>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 8005ce8:	6862      	ldr	r2, [r4, #4]
 8005cea:	18d3      	adds	r3, r2, r3
 8005cec:	60e3      	str	r3, [r4, #12]
		}
	}

	++( pxQueue->uxMessagesWaiting );
 8005cee:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8005cf0:	3301      	adds	r3, #1
 8005cf2:	63a3      	str	r3, [r4, #56]	; 0x38
 8005cf4:	bd38      	pop	{r3, r4, r5, pc}

08005cf6 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

portBASE_TYPE xQueueGenericReset( xQueueHandle xQueue, portBASE_TYPE xNewQueue )
{
 8005cf6:	b538      	push	{r3, r4, r5, lr}
 8005cf8:	460d      	mov	r5, r1
xQUEUE *pxQueue;

	pxQueue = ( xQUEUE * ) xQueue;
	configASSERT( pxQueue );
 8005cfa:	4604      	mov	r4, r0
 8005cfc:	b910      	cbnz	r0, 8005d04 <xQueueGenericReset+0xe>
 8005cfe:	f7ff fdb5 	bl	800586c <ulPortSetInterruptMask>
 8005d02:	e7fe      	b.n	8005d02 <xQueueGenericReset+0xc>

	taskENTER_CRITICAL();
 8005d04:	f7ff fdba 	bl	800587c <vPortEnterCritical>
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 8005d08:	6823      	ldr	r3, [r4, #0]
 8005d0a:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 8005d0c:	6c22      	ldr	r2, [r4, #64]	; 0x40
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
		pxQueue->pcWriteTo = pxQueue->pcHead;
 8005d0e:	60a3      	str	r3, [r4, #8]
	pxQueue = ( xQUEUE * ) xQueue;
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 8005d10:	fb00 3102 	mla	r1, r0, r2, r3
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
 8005d14:	3801      	subs	r0, #1
 8005d16:	fb02 3300 	mla	r3, r2, r0, r3
	pxQueue = ( xQUEUE * ) xQueue;
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 8005d1a:	6061      	str	r1, [r4, #4]
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
 8005d1c:	60e3      	str	r3, [r4, #12]
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
 8005d1e:	2100      	movs	r1, #0
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
		pxQueue->xRxLock = queueUNLOCKED;
 8005d20:	f04f 33ff 	mov.w	r3, #4294967295
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
 8005d24:	63a1      	str	r1, [r4, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
		pxQueue->xRxLock = queueUNLOCKED;
 8005d26:	6463      	str	r3, [r4, #68]	; 0x44
		pxQueue->xTxLock = queueUNLOCKED;
 8005d28:	64a3      	str	r3, [r4, #72]	; 0x48

		if( xNewQueue == pdFALSE )
 8005d2a:	b955      	cbnz	r5, 8005d42 <xQueueGenericReset+0x4c>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to	write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8005d2c:	6923      	ldr	r3, [r4, #16]
 8005d2e:	b183      	cbz	r3, 8005d52 <xQueueGenericReset+0x5c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 8005d30:	f104 0010 	add.w	r0, r4, #16
 8005d34:	f000 ff5e 	bl	8006bf4 <xTaskRemoveFromEventList>
 8005d38:	2801      	cmp	r0, #1
 8005d3a:	d10a      	bne.n	8005d52 <xQueueGenericReset+0x5c>
				{
					portYIELD_WITHIN_API();
 8005d3c:	f7ff fd8b 	bl	8005856 <vPortYield>
 8005d40:	e007      	b.n	8005d52 <xQueueGenericReset+0x5c>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 8005d42:	f104 0010 	add.w	r0, r4, #16
 8005d46:	f7ff ff1f 	bl	8005b88 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 8005d4a:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8005d4e:	f7ff ff1b 	bl	8005b88 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
 8005d52:	f7ff fda4 	bl	800589e <vPortExitCritical>

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
 8005d56:	2001      	movs	r0, #1
 8005d58:	bd38      	pop	{r3, r4, r5, pc}

08005d5a <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
 8005d5a:	b570      	push	{r4, r5, r6, lr}
 8005d5c:	460e      	mov	r6, r1
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
 8005d5e:	4605      	mov	r5, r0
 8005d60:	b180      	cbz	r0, 8005d84 <xQueueGenericCreate+0x2a>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
 8005d62:	204c      	movs	r0, #76	; 0x4c
 8005d64:	f7ff fd0c 	bl	8005780 <pvPortMalloc>
		if( pxNewQueue != NULL )
 8005d68:	4604      	mov	r4, r0
 8005d6a:	b158      	cbz	r0, 8005d84 <xQueueGenericCreate+0x2a>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
 8005d6c:	fb05 f006 	mul.w	r0, r5, r6

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
 8005d70:	3001      	adds	r0, #1
 8005d72:	f7ff fd05 	bl	8005780 <pvPortMalloc>
 8005d76:	6020      	str	r0, [r4, #0]
			if( pxNewQueue->pcHead != NULL )
 8005d78:	b938      	cbnz	r0, 8005d8a <xQueueGenericCreate+0x30>
				xReturn = pxNewQueue;
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
 8005d7a:	4620      	mov	r0, r4
 8005d7c:	f7ff fd2e 	bl	80057dc <vPortFree>
 8005d80:	e000      	b.n	8005d84 <xQueueGenericCreate+0x2a>
 8005d82:	e7fe      	b.n	8005d82 <xQueueGenericCreate+0x28>
			}
		}
	}

	configASSERT( xReturn );
 8005d84:	f7ff fd72 	bl	800586c <ulPortSetInterruptMask>
 8005d88:	e7fb      	b.n	8005d82 <xQueueGenericCreate+0x28>
			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
			if( pxNewQueue->pcHead != NULL )
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
 8005d8a:	63e5      	str	r5, [r4, #60]	; 0x3c
				pxNewQueue->uxItemSize = uxItemSize;
 8005d8c:	6426      	str	r6, [r4, #64]	; 0x40
				xQueueGenericReset( pxNewQueue, pdTRUE );
 8005d8e:	4620      	mov	r0, r4
 8005d90:	2101      	movs	r1, #1
 8005d92:	f7ff ffb0 	bl	8005cf6 <xQueueGenericReset>
	}

	configASSERT( xReturn );

	return xReturn;
}
 8005d96:	4620      	mov	r0, r4
 8005d98:	bd70      	pop	{r4, r5, r6, pc}

08005d9a <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
 8005d9a:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8005d9e:	b085      	sub	sp, #20
 8005da0:	460d      	mov	r5, r1
 8005da2:	9201      	str	r2, [sp, #4]
 8005da4:	4699      	mov	r9, r3
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
xTimeOutType xTimeOut;
xQUEUE *pxQueue;

	pxQueue = ( xQUEUE * ) xQueue;
	configASSERT( pxQueue );
 8005da6:	4604      	mov	r4, r0
 8005da8:	b910      	cbnz	r0, 8005db0 <xQueueGenericSend+0x16>
 8005daa:	f7ff fd5f 	bl	800586c <ulPortSetInterruptMask>
 8005dae:	e7fe      	b.n	8005dae <xQueueGenericSend+0x14>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
 8005db0:	b929      	cbnz	r1, 8005dbe <xQueueGenericSend+0x24>
 8005db2:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8005db4:	b12b      	cbz	r3, 8005dc2 <xQueueGenericSend+0x28>
 8005db6:	e065      	b.n	8005e84 <xQueueGenericSend+0xea>
 8005db8:	e7fe      	b.n	8005db8 <xQueueGenericSend+0x1e>
 8005dba:	2601      	movs	r6, #1
 8005dbc:	e003      	b.n	8005dc6 <xQueueGenericSend+0x2c>
 8005dbe:	2600      	movs	r6, #0
 8005dc0:	e000      	b.n	8005dc4 <xQueueGenericSend+0x2a>
 8005dc2:	460e      	mov	r6, r1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
 8005dc4:	2700      	movs	r7, #0
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
 8005dc6:	f7ff fd59 	bl	800587c <vPortEnterCritical>
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 8005dca:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8005dcc:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8005dce:	429a      	cmp	r2, r3
 8005dd0:	d212      	bcs.n	8005df8 <xQueueGenericSend+0x5e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 8005dd2:	4620      	mov	r0, r4
 8005dd4:	4629      	mov	r1, r5
 8005dd6:	464a      	mov	r2, r9
 8005dd8:	f7ff ff61 	bl	8005c9e <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8005ddc:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8005dde:	b13b      	cbz	r3, 8005df0 <xQueueGenericSend+0x56>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 8005de0:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8005de4:	f000 ff06 	bl	8006bf4 <xTaskRemoveFromEventList>
 8005de8:	2801      	cmp	r0, #1
 8005dea:	d101      	bne.n	8005df0 <xQueueGenericSend+0x56>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							portYIELD_WITHIN_API();
 8005dec:	f7ff fd33 	bl	8005856 <vPortYield>
						}
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
 8005df0:	f7ff fd55 	bl	800589e <vPortExitCritical>

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
 8005df4:	2001      	movs	r0, #1
 8005df6:	e048      	b.n	8005e8a <xQueueGenericSend+0xf0>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
 8005df8:	f8dd 8004 	ldr.w	r8, [sp, #4]
 8005dfc:	f1b8 0f00 	cmp.w	r8, #0
 8005e00:	d102      	bne.n	8005e08 <xQueueGenericSend+0x6e>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 8005e02:	f7ff fd4c 	bl	800589e <vPortExitCritical>
 8005e06:	e03b      	b.n	8005e80 <xQueueGenericSend+0xe6>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
 8005e08:	b916      	cbnz	r6, 8005e10 <xQueueGenericSend+0x76>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
 8005e0a:	a802      	add	r0, sp, #8
 8005e0c:	f000 ff24 	bl	8006c58 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
 8005e10:	f7ff fd45 	bl	800589e <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 8005e14:	f000 fcb6 	bl	8006784 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 8005e18:	f7ff fd30 	bl	800587c <vPortEnterCritical>
 8005e1c:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8005e1e:	3301      	adds	r3, #1
 8005e20:	bf08      	it	eq
 8005e22:	6467      	streq	r7, [r4, #68]	; 0x44
 8005e24:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8005e26:	3301      	adds	r3, #1
 8005e28:	bf08      	it	eq
 8005e2a:	64a7      	streq	r7, [r4, #72]	; 0x48
 8005e2c:	f7ff fd37 	bl	800589e <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8005e30:	a802      	add	r0, sp, #8
 8005e32:	a901      	add	r1, sp, #4
 8005e34:	f000 ff1e 	bl	8006c74 <xTaskCheckForTimeOut>
 8005e38:	b9e8      	cbnz	r0, 8005e76 <xQueueGenericSend+0xdc>

static signed portBASE_TYPE prvIsQueueFull( const xQUEUE *pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
 8005e3a:	f7ff fd1f 	bl	800587c <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 8005e3e:	f8d4 8038 	ldr.w	r8, [r4, #56]	; 0x38
 8005e42:	6be6      	ldr	r6, [r4, #60]	; 0x3c
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 8005e44:	f7ff fd2b 	bl	800589e <vPortExitCritical>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 8005e48:	45b0      	cmp	r8, r6
 8005e4a:	d10e      	bne.n	8005e6a <xQueueGenericSend+0xd0>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 8005e4c:	f104 0010 	add.w	r0, r4, #16
 8005e50:	9901      	ldr	r1, [sp, #4]
 8005e52:	f000 fe95 	bl	8006b80 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
 8005e56:	4620      	mov	r0, r4
 8005e58:	f7ff feda 	bl	8005c10 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
 8005e5c:	f000 fd22 	bl	80068a4 <xTaskResumeAll>
 8005e60:	2800      	cmp	r0, #0
 8005e62:	d1aa      	bne.n	8005dba <xQueueGenericSend+0x20>
				{
					portYIELD_WITHIN_API();
 8005e64:	f7ff fcf7 	bl	8005856 <vPortYield>
 8005e68:	e7a7      	b.n	8005dba <xQueueGenericSend+0x20>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
 8005e6a:	4620      	mov	r0, r4
 8005e6c:	f7ff fed0 	bl	8005c10 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 8005e70:	f000 fd18 	bl	80068a4 <xTaskResumeAll>
 8005e74:	e7a1      	b.n	8005dba <xQueueGenericSend+0x20>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
 8005e76:	4620      	mov	r0, r4
 8005e78:	f7ff feca 	bl	8005c10 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 8005e7c:	f000 fd12 	bl	80068a4 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
 8005e80:	2000      	movs	r0, #0
 8005e82:	e002      	b.n	8005e8a <xQueueGenericSend+0xf0>
xTimeOutType xTimeOut;
xQUEUE *pxQueue;

	pxQueue = ( xQUEUE * ) xQueue;
	configASSERT( pxQueue );
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
 8005e84:	f7ff fcf2 	bl	800586c <ulPortSetInterruptMask>
 8005e88:	e796      	b.n	8005db8 <xQueueGenericSend+0x1e>
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
 8005e8a:	b005      	add	sp, #20
 8005e8c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

08005e90 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( unsigned char ucQueueType )
	{
 8005e90:	b538      	push	{r3, r4, r5, lr}
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
 8005e92:	204c      	movs	r0, #76	; 0x4c
 8005e94:	f7ff fc74 	bl	8005780 <pvPortMalloc>
		if( pxNewQueue != NULL )
 8005e98:	4604      	mov	r4, r0
 8005e9a:	b108      	cbz	r0, 8005ea0 <xQueueCreateMutex+0x10>
 8005e9c:	e003      	b.n	8005ea6 <xQueueCreateMutex+0x16>
 8005e9e:	e7fe      	b.n	8005e9e <xQueueCreateMutex+0xe>
		else
		{
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
 8005ea0:	f7ff fce4 	bl	800586c <ulPortSetInterruptMask>
 8005ea4:	e7fb      	b.n	8005e9e <xQueueCreateMutex+0xe>

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
 8005ea6:	2301      	movs	r3, #1
		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
		if( pxNewQueue != NULL )
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
 8005ea8:	2500      	movs	r5, #0

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
 8005eaa:	63c3      	str	r3, [r0, #60]	; 0x3c
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
			pxNewQueue->xRxLock = queueUNLOCKED;
 8005eac:	f04f 33ff 	mov.w	r3, #4294967295
			pxNewQueue->pcReadFrom = NULL;

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
 8005eb0:	6385      	str	r5, [r0, #56]	; 0x38
		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
		if( pxNewQueue != NULL )
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
 8005eb2:	6045      	str	r5, [r0, #4]
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
			pxNewQueue->xRxLock = queueUNLOCKED;
 8005eb4:	6443      	str	r3, [r0, #68]	; 0x44
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
		if( pxNewQueue != NULL )
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 8005eb6:	6005      	str	r5, [r0, #0]
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
			pxNewQueue->xRxLock = queueUNLOCKED;
			pxNewQueue->xTxLock = queueUNLOCKED;
 8005eb8:	6483      	str	r3, [r0, #72]	; 0x48
			pxNewQueue->pxMutexHolder = NULL;
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
 8005eba:	6085      	str	r5, [r0, #8]
			pxNewQueue->pcReadFrom = NULL;
 8005ebc:	60c5      	str	r5, [r0, #12]
			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
 8005ebe:	6405      	str	r5, [r0, #64]	; 0x40
				pxNewQueue->pxQueueSetContainer = NULL;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
 8005ec0:	3010      	adds	r0, #16
 8005ec2:	f7ff fe61 	bl	8005b88 <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
 8005ec6:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8005eca:	f7ff fe5d 	bl	8005b88 <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
 8005ece:	4620      	mov	r0, r4
 8005ed0:	4629      	mov	r1, r5
 8005ed2:	462a      	mov	r2, r5
 8005ed4:	462b      	mov	r3, r5
 8005ed6:	f7ff ff60 	bl	8005d9a <xQueueGenericSend>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
 8005eda:	4620      	mov	r0, r4
 8005edc:	bd38      	pop	{r3, r4, r5, pc}

08005ede <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle xQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
 8005ede:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8005ee2:	460e      	mov	r6, r1
 8005ee4:	4615      	mov	r5, r2
 8005ee6:	4698      	mov	r8, r3
signed portBASE_TYPE xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;
xQUEUE *pxQueue;

	pxQueue = ( xQUEUE * ) xQueue;
	configASSERT( pxQueue );
 8005ee8:	4604      	mov	r4, r0
 8005eea:	b910      	cbnz	r0, 8005ef2 <xQueueGenericSendFromISR+0x14>
 8005eec:	f7ff fcbe 	bl	800586c <ulPortSetInterruptMask>
 8005ef0:	e7fe      	b.n	8005ef0 <xQueueGenericSendFromISR+0x12>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
 8005ef2:	b9f9      	cbnz	r1, 8005f34 <xQueueGenericSendFromISR+0x56>
 8005ef4:	6c01      	ldr	r1, [r0, #64]	; 0x40
 8005ef6:	b1e9      	cbz	r1, 8005f34 <xQueueGenericSendFromISR+0x56>
 8005ef8:	e019      	b.n	8005f2e <xQueueGenericSendFromISR+0x50>
 8005efa:	e7fe      	b.n	8005efa <xQueueGenericSendFromISR+0x1c>
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 8005efc:	4620      	mov	r0, r4
 8005efe:	4631      	mov	r1, r6
 8005f00:	4642      	mov	r2, r8
 8005f02:	f7ff fecc 	bl	8005c9e <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
 8005f06:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8005f08:	3301      	adds	r3, #1
 8005f0a:	d10b      	bne.n	8005f24 <xQueueGenericSendFromISR+0x46>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8005f0c:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8005f0e:	b903      	cbnz	r3, 8005f12 <xQueueGenericSendFromISR+0x34>
 8005f10:	e00b      	b.n	8005f2a <xQueueGenericSendFromISR+0x4c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8005f12:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8005f16:	f000 fe6d 	bl	8006bf4 <xTaskRemoveFromEventList>
 8005f1a:	b130      	cbz	r0, 8005f2a <xQueueGenericSendFromISR+0x4c>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
 8005f1c:	b12d      	cbz	r5, 8005f2a <xQueueGenericSendFromISR+0x4c>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
 8005f1e:	2401      	movs	r4, #1
 8005f20:	602c      	str	r4, [r5, #0]
 8005f22:	e00f      	b.n	8005f44 <xQueueGenericSendFromISR+0x66>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
 8005f24:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8005f26:	3301      	adds	r3, #1
 8005f28:	64a3      	str	r3, [r4, #72]	; 0x48
			}

			xReturn = pdPASS;
 8005f2a:	2401      	movs	r4, #1
 8005f2c:	e00a      	b.n	8005f44 <xQueueGenericSendFromISR+0x66>
unsigned portBASE_TYPE uxSavedInterruptStatus;
xQUEUE *pxQueue;

	pxQueue = ( xQUEUE * ) xQueue;
	configASSERT( pxQueue );
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
 8005f2e:	f7ff fc9d 	bl	800586c <ulPortSetInterruptMask>
 8005f32:	e7e2      	b.n	8005efa <xQueueGenericSendFromISR+0x1c>
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 8005f34:	f7ff fc9a 	bl	800586c <ulPortSetInterruptMask>
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 8005f38:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8005f3a:	6be1      	ldr	r1, [r4, #60]	; 0x3c
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 8005f3c:	4607      	mov	r7, r0
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 8005f3e:	428b      	cmp	r3, r1
 8005f40:	d3dc      	bcc.n	8005efc <xQueueGenericSendFromISR+0x1e>
			xReturn = pdPASS;
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
 8005f42:	2400      	movs	r4, #0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 8005f44:	4638      	mov	r0, r7
 8005f46:	f7ff fca7 	bl	8005898 <vPortClearInterruptMask>

	return xReturn;
}
 8005f4a:	4620      	mov	r0, r4
 8005f4c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08005f50 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle xQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
 8005f50:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8005f54:	b085      	sub	sp, #20
 8005f56:	460d      	mov	r5, r1
 8005f58:	9201      	str	r2, [sp, #4]
 8005f5a:	4699      	mov	r9, r3
xTimeOutType xTimeOut;
signed char *pcOriginalReadPosition;
xQUEUE *pxQueue;

	pxQueue = ( xQUEUE * ) xQueue;
	configASSERT( pxQueue );
 8005f5c:	4604      	mov	r4, r0
 8005f5e:	b910      	cbnz	r0, 8005f66 <xQueueGenericReceive+0x16>
 8005f60:	f7ff fc84 	bl	800586c <ulPortSetInterruptMask>
 8005f64:	e7fe      	b.n	8005f64 <xQueueGenericReceive+0x14>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
 8005f66:	b929      	cbnz	r1, 8005f74 <xQueueGenericReceive+0x24>
 8005f68:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8005f6a:	b12b      	cbz	r3, 8005f78 <xQueueGenericReceive+0x28>
 8005f6c:	e07e      	b.n	800606c <xQueueGenericReceive+0x11c>
 8005f6e:	e7fe      	b.n	8005f6e <xQueueGenericReceive+0x1e>
 8005f70:	2601      	movs	r6, #1
 8005f72:	e003      	b.n	8005f7c <xQueueGenericReceive+0x2c>
 8005f74:	2600      	movs	r6, #0
 8005f76:	e000      	b.n	8005f7a <xQueueGenericReceive+0x2a>
 8005f78:	460e      	mov	r6, r1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
 8005f7a:	2700      	movs	r7, #0
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
 8005f7c:	f7ff fc7e 	bl	800587c <vPortEnterCritical>
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 8005f80:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8005f82:	b33b      	cbz	r3, 8005fd4 <xQueueGenericReceive+0x84>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );
 8005f84:	4620      	mov	r0, r4
 8005f86:	4629      	mov	r1, r5
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
 8005f88:	68e6      	ldr	r6, [r4, #12]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
 8005f8a:	f7ff fe75 	bl	8005c78 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
 8005f8e:	f1b9 0f00 	cmp.w	r9, #0
 8005f92:	d112      	bne.n	8005fba <xQueueGenericReceive+0x6a>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
 8005f94:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8005f96:	3b01      	subs	r3, #1
 8005f98:	63a3      	str	r3, [r4, #56]	; 0x38

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8005f9a:	6823      	ldr	r3, [r4, #0]
 8005f9c:	b913      	cbnz	r3, 8005fa4 <xQueueGenericReceive+0x54>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
 8005f9e:	f000 fea3 	bl	8006ce8 <xTaskGetCurrentTaskHandle>
 8005fa2:	6060      	str	r0, [r4, #4]
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8005fa4:	6923      	ldr	r3, [r4, #16]
 8005fa6:	b18b      	cbz	r3, 8005fcc <xQueueGenericReceive+0x7c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 8005fa8:	f104 0010 	add.w	r0, r4, #16
 8005fac:	f000 fe22 	bl	8006bf4 <xTaskRemoveFromEventList>
 8005fb0:	2801      	cmp	r0, #1
 8005fb2:	d10b      	bne.n	8005fcc <xQueueGenericReceive+0x7c>
						{
							portYIELD_WITHIN_API();
 8005fb4:	f7ff fc4f 	bl	8005856 <vPortYield>
 8005fb8:	e008      	b.n	8005fcc <xQueueGenericReceive+0x7c>
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8005fba:	6a63      	ldr	r3, [r4, #36]	; 0x24
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
 8005fbc:	60e6      	str	r6, [r4, #12]

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8005fbe:	b12b      	cbz	r3, 8005fcc <xQueueGenericReceive+0x7c>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8005fc0:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8005fc4:	f000 fe16 	bl	8006bf4 <xTaskRemoveFromEventList>
 8005fc8:	2800      	cmp	r0, #0
 8005fca:	d1f3      	bne.n	8005fb4 <xQueueGenericReceive+0x64>
							portYIELD_WITHIN_API();
						}
					}
				}

				taskEXIT_CRITICAL();
 8005fcc:	f7ff fc67 	bl	800589e <vPortExitCritical>
				return pdPASS;
 8005fd0:	2001      	movs	r0, #1
 8005fd2:	e04e      	b.n	8006072 <xQueueGenericReceive+0x122>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
 8005fd4:	f8dd 8004 	ldr.w	r8, [sp, #4]
 8005fd8:	f1b8 0f00 	cmp.w	r8, #0
 8005fdc:	d102      	bne.n	8005fe4 <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 8005fde:	f7ff fc5e 	bl	800589e <vPortExitCritical>
 8005fe2:	e041      	b.n	8006068 <xQueueGenericReceive+0x118>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
 8005fe4:	b916      	cbnz	r6, 8005fec <xQueueGenericReceive+0x9c>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
 8005fe6:	a802      	add	r0, sp, #8
 8005fe8:	f000 fe36 	bl	8006c58 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
 8005fec:	f7ff fc57 	bl	800589e <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 8005ff0:	f000 fbc8 	bl	8006784 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 8005ff4:	f7ff fc42 	bl	800587c <vPortEnterCritical>
 8005ff8:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8005ffa:	3301      	adds	r3, #1
 8005ffc:	bf08      	it	eq
 8005ffe:	6467      	streq	r7, [r4, #68]	; 0x44
 8006000:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8006002:	3301      	adds	r3, #1
 8006004:	bf08      	it	eq
 8006006:	64a7      	streq	r7, [r4, #72]	; 0x48
 8006008:	f7ff fc49 	bl	800589e <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 800600c:	a802      	add	r0, sp, #8
 800600e:	a901      	add	r1, sp, #4
 8006010:	f000 fe30 	bl	8006c74 <xTaskCheckForTimeOut>
 8006014:	bb18      	cbnz	r0, 800605e <xQueueGenericReceive+0x10e>

static signed portBASE_TYPE prvIsQueueEmpty( const xQUEUE *pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
 8006016:	f7ff fc31 	bl	800587c <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == 0 )
 800601a:	6ba6      	ldr	r6, [r4, #56]	; 0x38
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 800601c:	f7ff fc3f 	bl	800589e <vPortExitCritical>
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 8006020:	b9be      	cbnz	r6, 8006052 <xQueueGenericReceive+0x102>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8006022:	6823      	ldr	r3, [r4, #0]
 8006024:	b933      	cbnz	r3, 8006034 <xQueueGenericReceive+0xe4>
					{
						portENTER_CRITICAL();
 8006026:	f7ff fc29 	bl	800587c <vPortEnterCritical>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 800602a:	6860      	ldr	r0, [r4, #4]
 800602c:	f000 fe70 	bl	8006d10 <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
 8006030:	f7ff fc35 	bl	800589e <vPortExitCritical>
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 8006034:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8006038:	9901      	ldr	r1, [sp, #4]
 800603a:	f000 fda1 	bl	8006b80 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 800603e:	4620      	mov	r0, r4
 8006040:	f7ff fde6 	bl	8005c10 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 8006044:	f000 fc2e 	bl	80068a4 <xTaskResumeAll>
 8006048:	2800      	cmp	r0, #0
 800604a:	d191      	bne.n	8005f70 <xQueueGenericReceive+0x20>
				{
					portYIELD_WITHIN_API();
 800604c:	f7ff fc03 	bl	8005856 <vPortYield>
 8006050:	e78e      	b.n	8005f70 <xQueueGenericReceive+0x20>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
 8006052:	4620      	mov	r0, r4
 8006054:	f7ff fddc 	bl	8005c10 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 8006058:	f000 fc24 	bl	80068a4 <xTaskResumeAll>
 800605c:	e788      	b.n	8005f70 <xQueueGenericReceive+0x20>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
 800605e:	4620      	mov	r0, r4
 8006060:	f7ff fdd6 	bl	8005c10 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 8006064:	f000 fc1e 	bl	80068a4 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
 8006068:	2000      	movs	r0, #0
 800606a:	e002      	b.n	8006072 <xQueueGenericReceive+0x122>
signed char *pcOriginalReadPosition;
xQUEUE *pxQueue;

	pxQueue = ( xQUEUE * ) xQueue;
	configASSERT( pxQueue );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
 800606c:	f7ff fbfe 	bl	800586c <ulPortSetInterruptMask>
 8006070:	e77d      	b.n	8005f6e <xQueueGenericReceive+0x1e>
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
 8006072:	b005      	add	sp, #20
 8006074:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

08006078 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle xQueue, void * const pvBuffer, signed portBASE_TYPE *pxHigherPriorityTaskWoken )
{
 8006078:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800607a:	460e      	mov	r6, r1
 800607c:	4615      	mov	r5, r2
signed portBASE_TYPE xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;
xQUEUE *pxQueue;

	pxQueue = ( xQUEUE * ) xQueue;
	configASSERT( pxQueue );
 800607e:	4604      	mov	r4, r0
 8006080:	b910      	cbnz	r0, 8006088 <xQueueReceiveFromISR+0x10>
 8006082:	f7ff fbf3 	bl	800586c <ulPortSetInterruptMask>
 8006086:	e7fe      	b.n	8006086 <xQueueReceiveFromISR+0xe>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
 8006088:	bb09      	cbnz	r1, 80060ce <xQueueReceiveFromISR+0x56>
 800608a:	6c03      	ldr	r3, [r0, #64]	; 0x40
 800608c:	b1fb      	cbz	r3, 80060ce <xQueueReceiveFromISR+0x56>
 800608e:	e01b      	b.n	80060c8 <xQueueReceiveFromISR+0x50>
 8006090:	e7fe      	b.n	8006090 <xQueueReceiveFromISR+0x18>
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
 8006092:	4620      	mov	r0, r4
 8006094:	4631      	mov	r1, r6
 8006096:	f7ff fdef 	bl	8005c78 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
 800609a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800609c:	3b01      	subs	r3, #1
 800609e:	63a3      	str	r3, [r4, #56]	; 0x38

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
 80060a0:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80060a2:	3301      	adds	r3, #1
 80060a4:	d10b      	bne.n	80060be <xQueueReceiveFromISR+0x46>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80060a6:	6923      	ldr	r3, [r4, #16]
 80060a8:	b903      	cbnz	r3, 80060ac <xQueueReceiveFromISR+0x34>
 80060aa:	e00b      	b.n	80060c4 <xQueueReceiveFromISR+0x4c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80060ac:	f104 0010 	add.w	r0, r4, #16
 80060b0:	f000 fda0 	bl	8006bf4 <xTaskRemoveFromEventList>
 80060b4:	b130      	cbz	r0, 80060c4 <xQueueReceiveFromISR+0x4c>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
 80060b6:	b12d      	cbz	r5, 80060c4 <xQueueReceiveFromISR+0x4c>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
 80060b8:	2401      	movs	r4, #1
 80060ba:	602c      	str	r4, [r5, #0]
 80060bc:	e00e      	b.n	80060dc <xQueueReceiveFromISR+0x64>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
 80060be:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80060c0:	3301      	adds	r3, #1
 80060c2:	6463      	str	r3, [r4, #68]	; 0x44
			}

			xReturn = pdPASS;
 80060c4:	2401      	movs	r4, #1
 80060c6:	e009      	b.n	80060dc <xQueueReceiveFromISR+0x64>
unsigned portBASE_TYPE uxSavedInterruptStatus;
xQUEUE *pxQueue;

	pxQueue = ( xQUEUE * ) xQueue;
	configASSERT( pxQueue );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );
 80060c8:	f7ff fbd0 	bl	800586c <ulPortSetInterruptMask>
 80060cc:	e7e0      	b.n	8006090 <xQueueReceiveFromISR+0x18>

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 80060ce:	f7ff fbcd 	bl	800586c <ulPortSetInterruptMask>
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 80060d2:	6ba3      	ldr	r3, [r4, #56]	; 0x38

	pxQueue = ( xQUEUE * ) xQueue;
	configASSERT( pxQueue );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 80060d4:	4607      	mov	r7, r0
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 80060d6:	2b00      	cmp	r3, #0
 80060d8:	d1db      	bne.n	8006092 <xQueueReceiveFromISR+0x1a>

			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
 80060da:	461c      	mov	r4, r3
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 80060dc:	4638      	mov	r0, r7
 80060de:	f7ff fbdb 	bl	8005898 <vPortClearInterruptMask>

	return xReturn;
}
 80060e2:	4620      	mov	r0, r4
 80060e4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080060e6 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle xQueue )
{
 80060e6:	b510      	push	{r4, lr}
unsigned portBASE_TYPE uxReturn;

	configASSERT( xQueue );
 80060e8:	4604      	mov	r4, r0
 80060ea:	b910      	cbnz	r0, 80060f2 <uxQueueMessagesWaiting+0xc>
 80060ec:	f7ff fbbe 	bl	800586c <ulPortSetInterruptMask>
 80060f0:	e7fe      	b.n	80060f0 <uxQueueMessagesWaiting+0xa>

	taskENTER_CRITICAL();
 80060f2:	f7ff fbc3 	bl	800587c <vPortEnterCritical>
		uxReturn = ( ( xQUEUE * ) xQueue )->uxMessagesWaiting;
 80060f6:	6ba4      	ldr	r4, [r4, #56]	; 0x38
	taskEXIT_CRITICAL();
 80060f8:	f7ff fbd1 	bl	800589e <vPortExitCritical>

	return uxReturn;
}
 80060fc:	4620      	mov	r0, r4
 80060fe:	bd10      	pop	{r4, pc}

08006100 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle xQueue )
{
 8006100:	b508      	push	{r3, lr}
unsigned portBASE_TYPE uxReturn;

	configASSERT( xQueue );
 8006102:	b910      	cbnz	r0, 800610a <uxQueueMessagesWaitingFromISR+0xa>
 8006104:	f7ff fbb2 	bl	800586c <ulPortSetInterruptMask>
 8006108:	e7fe      	b.n	8006108 <uxQueueMessagesWaitingFromISR+0x8>

	uxReturn = ( ( xQUEUE * ) xQueue )->uxMessagesWaiting;
 800610a:	6b80      	ldr	r0, [r0, #56]	; 0x38

	return uxReturn;
}
 800610c:	bd08      	pop	{r3, pc}

0800610e <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle xQueue )
{
 800610e:	b510      	push	{r4, lr}
xQUEUE *pxQueue;

	pxQueue = ( xQUEUE * ) xQueue;
	configASSERT( pxQueue );
 8006110:	4604      	mov	r4, r0
 8006112:	b910      	cbnz	r0, 800611a <vQueueDelete+0xc>
 8006114:	f7ff fbaa 	bl	800586c <ulPortSetInterruptMask>
 8006118:	e7fe      	b.n	8006118 <vQueueDelete+0xa>
	#if ( configQUEUE_REGISTRY_SIZE > 0 )
	{
		prvQueueUnregisterQueue( pxQueue );
	}
	#endif
	vPortFree( pxQueue->pcHead );
 800611a:	6800      	ldr	r0, [r0, #0]
 800611c:	f7ff fb5e 	bl	80057dc <vPortFree>
	vPortFree( pxQueue );
 8006120:	4620      	mov	r0, r4
}
 8006122:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	{
		prvQueueUnregisterQueue( pxQueue );
	}
	#endif
	vPortFree( pxQueue->pcHead );
	vPortFree( pxQueue );
 8006126:	f7ff bb59 	b.w	80057dc <vPortFree>

0800612a <xQueueIsQueueEmptyFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle xQueue )
{
 800612a:	b508      	push	{r3, lr}
signed portBASE_TYPE xReturn;

	configASSERT( xQueue );
 800612c:	b910      	cbnz	r0, 8006134 <xQueueIsQueueEmptyFromISR+0xa>
 800612e:	f7ff fb9d 	bl	800586c <ulPortSetInterruptMask>
 8006132:	e7fe      	b.n	8006132 <xQueueIsQueueEmptyFromISR+0x8>
	if( ( ( xQUEUE * ) xQueue )->uxMessagesWaiting == 0 )
 8006134:	6b80      	ldr	r0, [r0, #56]	; 0x38
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
 8006136:	f1d0 0001 	rsbs	r0, r0, #1
 800613a:	bf38      	it	cc
 800613c:	2000      	movcc	r0, #0
 800613e:	bd08      	pop	{r3, pc}

08006140 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle xQueue )
{
 8006140:	b508      	push	{r3, lr}
signed portBASE_TYPE xReturn;

	configASSERT( xQueue );
 8006142:	b910      	cbnz	r0, 800614a <xQueueIsQueueFullFromISR+0xa>
 8006144:	f7ff fb92 	bl	800586c <ulPortSetInterruptMask>
 8006148:	e7fe      	b.n	8006148 <xQueueIsQueueFullFromISR+0x8>
	if( ( ( xQUEUE * ) xQueue )->uxMessagesWaiting == ( ( xQUEUE * ) xQueue )->uxLength )
 800614a:	6b82      	ldr	r2, [r0, #56]	; 0x38
 800614c:	6bc0      	ldr	r0, [r0, #60]	; 0x3c
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
 800614e:	1a13      	subs	r3, r2, r0
 8006150:	4258      	negs	r0, r3
 8006152:	4158      	adcs	r0, r3
 8006154:	bd08      	pop	{r3, pc}

08006156 <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	signed portBASE_TYPE xQueueCRSend( xQueueHandle xQueue, const void *pvItemToQueue, portTickType xTicksToWait )
	{
 8006156:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800615a:	4604      	mov	r4, r0
 800615c:	460e      	mov	r6, r1
 800615e:	4615      	mov	r5, r2
		pxQueue = ( xQUEUE * ) xQueue;

		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
 8006160:	f7ff fb84 	bl	800586c <ulPortSetInterruptMask>

static signed portBASE_TYPE prvIsQueueFull( const xQUEUE *pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
 8006164:	f7ff fb8a 	bl	800587c <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 8006168:	f8d4 8038 	ldr.w	r8, [r4, #56]	; 0x38
 800616c:	6be7      	ldr	r7, [r4, #60]	; 0x3c
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
 800616e:	f7ff fb96 	bl	800589e <vPortExitCritical>
		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 8006172:	45b8      	cmp	r8, r7
 8006174:	d10f      	bne.n	8006196 <xQueueCRSend+0x40>
				posting? */
				if( xTicksToWait > ( portTickType ) 0 )
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
 8006176:	4628      	mov	r0, r5
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				/* The queue is full - do we want to block or just leave without
				posting? */
				if( xTicksToWait > ( portTickType ) 0 )
 8006178:	b14d      	cbz	r5, 800618e <xQueueCRSend+0x38>
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
 800617a:	f104 0110 	add.w	r1, r4, #16
 800617e:	f7ff fc45 	bl	8005a0c <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
 8006182:	2000      	movs	r0, #0
 8006184:	f7ff fb88 	bl	8005898 <vPortClearInterruptMask>
					return errQUEUE_BLOCKED;
 8006188:	f06f 0403 	mvn.w	r4, #3
 800618c:	e022      	b.n	80061d4 <xQueueCRSend+0x7e>
				}
				else
				{
					portENABLE_INTERRUPTS();
 800618e:	f7ff fb83 	bl	8005898 <vPortClearInterruptMask>
					return errQUEUE_FULL;
 8006192:	462c      	mov	r4, r5
 8006194:	e01e      	b.n	80061d4 <xQueueCRSend+0x7e>
				}
			}
		}
		portENABLE_INTERRUPTS();
 8006196:	2000      	movs	r0, #0
 8006198:	f7ff fb7e 	bl	8005898 <vPortClearInterruptMask>

		portDISABLE_INTERRUPTS();
 800619c:	f7ff fb66 	bl	800586c <ulPortSetInterruptMask>
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 80061a0:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 80061a2:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80061a4:	429a      	cmp	r2, r3
 80061a6:	d211      	bcs.n	80061cc <xQueueCRSend+0x76>
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
 80061a8:	4620      	mov	r0, r4
 80061aa:	4631      	mov	r1, r6
 80061ac:	2200      	movs	r2, #0
 80061ae:	f7ff fd76 	bl	8005c9e <prvCopyDataToQueue>
				xReturn = pdPASS;

				/* Were any co-routines waiting for data to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 80061b2:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80061b4:	b90b      	cbnz	r3, 80061ba <xQueueCRSend+0x64>
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
				xReturn = pdPASS;
 80061b6:	2401      	movs	r4, #1
 80061b8:	e009      	b.n	80061ce <xQueueCRSend+0x78>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80061ba:	f104 0024 	add.w	r0, r4, #36	; 0x24
 80061be:	f7ff fccb 	bl	8005b58 <xCoRoutineRemoveFromEventList>
 80061c2:	2800      	cmp	r0, #0
 80061c4:	d0f7      	beq.n	80061b6 <xQueueCRSend+0x60>
					{
						/* The co-routine waiting has a higher priority so record
						that a yield might be appropriate. */
						xReturn = errQUEUE_YIELD;
 80061c6:	f06f 0404 	mvn.w	r4, #4
 80061ca:	e000      	b.n	80061ce <xQueueCRSend+0x78>
					}
				}
			}
			else
			{
				xReturn = errQUEUE_FULL;
 80061cc:	2400      	movs	r4, #0
			}
		}
		portENABLE_INTERRUPTS();
 80061ce:	2000      	movs	r0, #0
 80061d0:	f7ff fb62 	bl	8005898 <vPortClearInterruptMask>

		return xReturn;
	}
 80061d4:	4620      	mov	r0, r4
 80061d6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

080061da <xQueueCRReceive>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	signed portBASE_TYPE xQueueCRReceive( xQueueHandle xQueue, void *pvBuffer, portTickType xTicksToWait )
	{
 80061da:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80061dc:	4604      	mov	r4, r0
 80061de:	460f      	mov	r7, r1
 80061e0:	4615      	mov	r5, r2
		pxQueue = ( xQUEUE * ) xQueue;

		/* If the queue is already empty we may have to block.  A critical section
		is required to prevent an interrupt adding something to the queue
		between the check to see if the queue is empty and blocking on the queue. */
		portDISABLE_INTERRUPTS();
 80061e2:	f7ff fb43 	bl	800586c <ulPortSetInterruptMask>
		{
			if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 )
 80061e6:	6ba6      	ldr	r6, [r4, #56]	; 0x38
 80061e8:	b97e      	cbnz	r6, 800620a <xQueueCRReceive+0x30>
				leave with nothing? */
				if( xTicksToWait > ( portTickType ) 0 )
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
 80061ea:	4628      	mov	r0, r5
		{
			if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 )
			{
				/* There are no messages in the queue, do we want to block or just
				leave with nothing? */
				if( xTicksToWait > ( portTickType ) 0 )
 80061ec:	b14d      	cbz	r5, 8006202 <xQueueCRReceive+0x28>
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
 80061ee:	f104 0124 	add.w	r1, r4, #36	; 0x24
 80061f2:	f7ff fc0b 	bl	8005a0c <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
 80061f6:	4630      	mov	r0, r6
 80061f8:	f7ff fb4e 	bl	8005898 <vPortClearInterruptMask>
					return errQUEUE_BLOCKED;
 80061fc:	f06f 0403 	mvn.w	r4, #3
 8006200:	e02c      	b.n	800625c <xQueueCRReceive+0x82>
				}
				else
				{
					portENABLE_INTERRUPTS();
 8006202:	f7ff fb49 	bl	8005898 <vPortClearInterruptMask>
					return errQUEUE_FULL;
 8006206:	462c      	mov	r4, r5
 8006208:	e028      	b.n	800625c <xQueueCRReceive+0x82>
				}
			}
		}
		portENABLE_INTERRUPTS();
 800620a:	2000      	movs	r0, #0
 800620c:	f7ff fb44 	bl	8005898 <vPortClearInterruptMask>

		portDISABLE_INTERRUPTS();
 8006210:	f7ff fb2c 	bl	800586c <ulPortSetInterruptMask>
		{
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 8006214:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8006216:	b1eb      	cbz	r3, 8006254 <xQueueCRReceive+0x7a>
			{
				/* Data is available from the queue. */
				pxQueue->pcReadFrom += pxQueue->uxItemSize;
 8006218:	68e3      	ldr	r3, [r4, #12]
 800621a:	6c22      	ldr	r2, [r4, #64]	; 0x40
				if( pxQueue->pcReadFrom >= pxQueue->pcTail )
 800621c:	6861      	ldr	r1, [r4, #4]
		portDISABLE_INTERRUPTS();
		{
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
			{
				/* Data is available from the queue. */
				pxQueue->pcReadFrom += pxQueue->uxItemSize;
 800621e:	189b      	adds	r3, r3, r2
				if( pxQueue->pcReadFrom >= pxQueue->pcTail )
 8006220:	428b      	cmp	r3, r1
		portDISABLE_INTERRUPTS();
		{
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
			{
				/* Data is available from the queue. */
				pxQueue->pcReadFrom += pxQueue->uxItemSize;
 8006222:	60e3      	str	r3, [r4, #12]
				if( pxQueue->pcReadFrom >= pxQueue->pcTail )
				{
					pxQueue->pcReadFrom = pxQueue->pcHead;
 8006224:	bf28      	it	cs
 8006226:	6823      	ldrcs	r3, [r4, #0]
				}
				--( pxQueue->uxMessagesWaiting );
				memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
 8006228:	4638      	mov	r0, r7
			{
				/* Data is available from the queue. */
				pxQueue->pcReadFrom += pxQueue->uxItemSize;
				if( pxQueue->pcReadFrom >= pxQueue->pcTail )
				{
					pxQueue->pcReadFrom = pxQueue->pcHead;
 800622a:	bf28      	it	cs
 800622c:	60e3      	strcs	r3, [r4, #12]
				}
				--( pxQueue->uxMessagesWaiting );
 800622e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
				memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
 8006230:	68e1      	ldr	r1, [r4, #12]
				pxQueue->pcReadFrom += pxQueue->uxItemSize;
				if( pxQueue->pcReadFrom >= pxQueue->pcTail )
				{
					pxQueue->pcReadFrom = pxQueue->pcHead;
				}
				--( pxQueue->uxMessagesWaiting );
 8006232:	3b01      	subs	r3, #1
 8006234:	63a3      	str	r3, [r4, #56]	; 0x38
				memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
 8006236:	f001 fd7b 	bl	8007d30 <memcpy>

				xReturn = pdPASS;

				/* Were any co-routines waiting for space to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800623a:	6923      	ldr	r3, [r4, #16]
 800623c:	b90b      	cbnz	r3, 8006242 <xQueueCRReceive+0x68>
					pxQueue->pcReadFrom = pxQueue->pcHead;
				}
				--( pxQueue->uxMessagesWaiting );
				memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

				xReturn = pdPASS;
 800623e:	2401      	movs	r4, #1
 8006240:	e009      	b.n	8006256 <xQueueCRReceive+0x7c>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8006242:	f104 0010 	add.w	r0, r4, #16
 8006246:	f7ff fc87 	bl	8005b58 <xCoRoutineRemoveFromEventList>
 800624a:	2800      	cmp	r0, #0
 800624c:	d0f7      	beq.n	800623e <xQueueCRReceive+0x64>
					{
						xReturn = errQUEUE_YIELD;
 800624e:	f06f 0404 	mvn.w	r4, #4
 8006252:	e000      	b.n	8006256 <xQueueCRReceive+0x7c>
					}
				}
			}
			else
			{
				xReturn = pdFAIL;
 8006254:	461c      	mov	r4, r3
			}
		}
		portENABLE_INTERRUPTS();
 8006256:	2000      	movs	r0, #0
 8006258:	f7ff fb1e 	bl	8005898 <vPortClearInterruptMask>

		return xReturn;
	}
 800625c:	4620      	mov	r0, r4
 800625e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08006260 <xQueueCRSendFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	signed portBASE_TYPE xQueueCRSendFromISR( xQueueHandle xQueue, const void *pvItemToQueue, signed portBASE_TYPE xCoRoutinePreviouslyWoken )
	{
 8006260:	b538      	push	{r3, r4, r5, lr}
 8006262:	4615      	mov	r5, r2

		pxQueue = ( xQUEUE * ) xQueue;

		/* Cannot block within an ISR so if there is no space on the queue then
		exit without doing anything. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 8006264:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 8006266:	6b82      	ldr	r2, [r0, #56]	; 0x38
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	signed portBASE_TYPE xQueueCRSendFromISR( xQueueHandle xQueue, const void *pvItemToQueue, signed portBASE_TYPE xCoRoutinePreviouslyWoken )
	{
 8006268:	4604      	mov	r4, r0

		pxQueue = ( xQUEUE * ) xQueue;

		/* Cannot block within an ISR so if there is no space on the queue then
		exit without doing anything. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 800626a:	429a      	cmp	r2, r3
 800626c:	d20c      	bcs.n	8006288 <xQueueCRSendFromISR+0x28>
		{
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
 800626e:	2200      	movs	r2, #0
 8006270:	f7ff fd15 	bl	8005c9e <prvCopyDataToQueue>

			/* We only want to wake one co-routine per ISR, so check that a
			co-routine has not already been woken. */
			if( xCoRoutinePreviouslyWoken == pdFALSE )
 8006274:	b945      	cbnz	r5, 8006288 <xQueueCRSendFromISR+0x28>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8006276:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8006278:	b133      	cbz	r3, 8006288 <xQueueCRSendFromISR+0x28>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800627a:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800627e:	f7ff fc6b 	bl	8005b58 <xCoRoutineRemoveFromEventList>
 8006282:	1c05      	adds	r5, r0, #0
 8006284:	bf18      	it	ne
 8006286:	2501      	movne	r5, #1
				}
			}
		}

		return xCoRoutinePreviouslyWoken;
	}
 8006288:	4628      	mov	r0, r5
 800628a:	bd38      	pop	{r3, r4, r5, pc}

0800628c <xQueueCRReceiveFromISR>:

		pxQueue = ( xQUEUE * ) xQueue;

		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 800628c:	6b83      	ldr	r3, [r0, #56]	; 0x38
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	signed portBASE_TYPE xQueueCRReceiveFromISR( xQueueHandle xQueue, void *pvBuffer, signed portBASE_TYPE *pxCoRoutineWoken )
	{
 800628e:	b570      	push	{r4, r5, r6, lr}
 8006290:	4604      	mov	r4, r0
 8006292:	4615      	mov	r5, r2

		pxQueue = ( xQUEUE * ) xQueue;

		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 8006294:	b1fb      	cbz	r3, 80062d6 <xQueueCRReceiveFromISR+0x4a>
		{
			/* Copy the data from the queue. */
			pxQueue->pcReadFrom += pxQueue->uxItemSize;
 8006296:	68c3      	ldr	r3, [r0, #12]
 8006298:	6c02      	ldr	r2, [r0, #64]	; 0x40
			if( pxQueue->pcReadFrom >= pxQueue->pcTail )
 800629a:	6846      	ldr	r6, [r0, #4]
		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
		{
			/* Copy the data from the queue. */
			pxQueue->pcReadFrom += pxQueue->uxItemSize;
 800629c:	189b      	adds	r3, r3, r2
			if( pxQueue->pcReadFrom >= pxQueue->pcTail )
 800629e:	42b3      	cmp	r3, r6
		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
		{
			/* Copy the data from the queue. */
			pxQueue->pcReadFrom += pxQueue->uxItemSize;
 80062a0:	60c3      	str	r3, [r0, #12]
			if( pxQueue->pcReadFrom >= pxQueue->pcTail )
			{
				pxQueue->pcReadFrom = pxQueue->pcHead;
 80062a2:	bf24      	itt	cs
 80062a4:	6803      	ldrcs	r3, [r0, #0]
 80062a6:	60c3      	strcs	r3, [r0, #12]
			}
			--( pxQueue->uxMessagesWaiting );
 80062a8:	6b83      	ldr	r3, [r0, #56]	; 0x38
 80062aa:	3b01      	subs	r3, #1
 80062ac:	6383      	str	r3, [r0, #56]	; 0x38
			memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
 80062ae:	4608      	mov	r0, r1
 80062b0:	68e1      	ldr	r1, [r4, #12]
 80062b2:	f001 fd3d 	bl	8007d30 <memcpy>

			if( ( *pxCoRoutineWoken ) == pdFALSE )
 80062b6:	682b      	ldr	r3, [r5, #0]
 80062b8:	b10b      	cbz	r3, 80062be <xQueueCRReceiveFromISR+0x32>
						*pxCoRoutineWoken = pdTRUE;
					}
				}
			}

			xReturn = pdPASS;
 80062ba:	2001      	movs	r0, #1
 80062bc:	bd70      	pop	{r4, r5, r6, pc}
			--( pxQueue->uxMessagesWaiting );
			memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );

			if( ( *pxCoRoutineWoken ) == pdFALSE )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80062be:	6923      	ldr	r3, [r4, #16]
 80062c0:	2b00      	cmp	r3, #0
 80062c2:	d0fa      	beq.n	80062ba <xQueueCRReceiveFromISR+0x2e>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80062c4:	f104 0010 	add.w	r0, r4, #16
 80062c8:	f7ff fc46 	bl	8005b58 <xCoRoutineRemoveFromEventList>
 80062cc:	2800      	cmp	r0, #0
 80062ce:	d0f4      	beq.n	80062ba <xQueueCRReceiveFromISR+0x2e>
					{
						*pxCoRoutineWoken = pdTRUE;
 80062d0:	2001      	movs	r0, #1
 80062d2:	6028      	str	r0, [r5, #0]
 80062d4:	bd70      	pop	{r4, r5, r6, pc}

			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
 80062d6:	4618      	mov	r0, r3
		}

		return xReturn;
	}
 80062d8:	bd70      	pop	{r4, r5, r6, pc}

080062da <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( xQueueHandle xQueue, portTickType xTicksToWait )
	{
 80062da:	b538      	push	{r3, r4, r5, lr}
 80062dc:	4604      	mov	r4, r0
 80062de:	460d      	mov	r5, r1
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
 80062e0:	f7ff facc 	bl	800587c <vPortEnterCritical>
 80062e4:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80062e6:	3301      	adds	r3, #1
 80062e8:	d101      	bne.n	80062ee <vQueueWaitForMessageRestricted+0x14>
 80062ea:	2300      	movs	r3, #0
 80062ec:	6463      	str	r3, [r4, #68]	; 0x44
 80062ee:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 80062f0:	3301      	adds	r3, #1
 80062f2:	d101      	bne.n	80062f8 <vQueueWaitForMessageRestricted+0x1e>
 80062f4:	2300      	movs	r3, #0
 80062f6:	64a3      	str	r3, [r4, #72]	; 0x48
 80062f8:	f7ff fad1 	bl	800589e <vPortExitCritical>
		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0U )
 80062fc:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80062fe:	b923      	cbnz	r3, 800630a <vQueueWaitForMessageRestricted+0x30>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 8006300:	f104 0024 	add.w	r0, r4, #36	; 0x24
 8006304:	4629      	mov	r1, r5
 8006306:	f000 fc5d 	bl	8006bc4 <vTaskPlaceOnEventListRestricted>
		}
		prvUnlockQueue( pxQueue );
 800630a:	4620      	mov	r0, r4
	}
 800630c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0U )
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
		}
		prvUnlockQueue( pxQueue );
 8006310:	f7ff bc7e 	b.w	8005c10 <prvUnlockQueue>

08006314 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 8006314:	4b0c      	ldr	r3, [pc, #48]	; (8006348 <prvAddCurrentTaskToDelayedList+0x34>)
	#endif /* vTaskDelete */
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
 8006316:	b510      	push	{r4, lr}
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 8006318:	681a      	ldr	r2, [r3, #0]
	#endif /* vTaskDelete */
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
 800631a:	4604      	mov	r4, r0
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 800631c:	6050      	str	r0, [r2, #4]

	if( xTimeToWake < xTickCount )
 800631e:	685a      	ldr	r2, [r3, #4]
 8006320:	4290      	cmp	r0, r2
 8006322:	d206      	bcs.n	8006332 <prvAddCurrentTaskToDelayedList+0x1e>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 8006324:	6898      	ldr	r0, [r3, #8]
 8006326:	6819      	ldr	r1, [r3, #0]
 8006328:	3104      	adds	r1, #4
		if( xTimeToWake < xNextTaskUnblockTime )
		{
			xNextTaskUnblockTime = xTimeToWake;
		}
	}
}
 800632a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 800632e:	f7ff bc46 	b.w	8005bbe <vListInsert>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 8006332:	68d8      	ldr	r0, [r3, #12]
 8006334:	6819      	ldr	r1, [r3, #0]
 8006336:	3104      	adds	r1, #4
 8006338:	f7ff fc41 	bl	8005bbe <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
 800633c:	4b03      	ldr	r3, [pc, #12]	; (800634c <prvAddCurrentTaskToDelayedList+0x38>)
 800633e:	681a      	ldr	r2, [r3, #0]
 8006340:	4294      	cmp	r4, r2
		{
			xNextTaskUnblockTime = xTimeToWake;
 8006342:	bf38      	it	cc
 8006344:	601c      	strcc	r4, [r3, #0]
 8006346:	bd10      	pop	{r4, pc}
 8006348:	20002a78 	.word	0x20002a78
 800634c:	20000030 	.word	0x20000030

08006350 <xTaskGenericCreate>:
#endif

/*lint +e956 */

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
 8006350:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006354:	9e0a      	ldr	r6, [sp, #40]	; 0x28
 8006356:	4688      	mov	r8, r1
 8006358:	4617      	mov	r7, r2
 800635a:	469b      	mov	fp, r3
 800635c:	f8dd 902c 	ldr.w	r9, [sp, #44]	; 0x2c
 8006360:	9d0c      	ldr	r5, [sp, #48]	; 0x30
signed portBASE_TYPE xReturn;
tskTCB * pxNewTCB;

	configASSERT( pxTaskCode );
 8006362:	4682      	mov	sl, r0
 8006364:	b910      	cbnz	r0, 800636c <xTaskGenericCreate+0x1c>
 8006366:	f7ff fa81 	bl	800586c <ulPortSetInterruptMask>
 800636a:	e7fe      	b.n	800636a <xTaskGenericCreate+0x1a>
	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
 800636c:	2e04      	cmp	r6, #4
 800636e:	d902      	bls.n	8006376 <xTaskGenericCreate+0x26>
 8006370:	f7ff fa7c 	bl	800586c <ulPortSetInterruptMask>
 8006374:	e7fe      	b.n	8006374 <xTaskGenericCreate+0x24>
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 8006376:	2044      	movs	r0, #68	; 0x44
 8006378:	f7ff fa02 	bl	8005780 <pvPortMalloc>

	if( pxNewTCB != NULL )
 800637c:	4604      	mov	r4, r0
 800637e:	2800      	cmp	r0, #0
 8006380:	f000 80a4 	beq.w	80064cc <xTaskGenericCreate+0x17c>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
 8006384:	b91d      	cbnz	r5, 800638e <xTaskGenericCreate+0x3e>
 8006386:	00b8      	lsls	r0, r7, #2
 8006388:	f7ff f9fa 	bl	8005780 <pvPortMalloc>
 800638c:	4605      	mov	r5, r0
 800638e:	6325      	str	r5, [r4, #48]	; 0x30

		if( pxNewTCB->pxStack == NULL )
 8006390:	b91d      	cbnz	r5, 800639a <xTaskGenericCreate+0x4a>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
 8006392:	4620      	mov	r0, r4
 8006394:	f7ff fa22 	bl	80057dc <vPortFree>
 8006398:	e098      	b.n	80064cc <xTaskGenericCreate+0x17c>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
 800639a:	00ba      	lsls	r2, r7, #2
 800639c:	21a5      	movs	r1, #165	; 0xa5
 800639e:	4628      	mov	r0, r5
 80063a0:	f001 fd80 	bl	8007ea4 <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
 80063a4:	6b23      	ldr	r3, [r4, #48]	; 0x30
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
 80063a6:	4641      	mov	r1, r8
 80063a8:	220a      	movs	r2, #10
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
 80063aa:	3f01      	subs	r7, #1
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
 80063ac:	f104 0034 	add.w	r0, r4, #52	; 0x34
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
 80063b0:	eb03 0787 	add.w	r7, r3, r7, lsl #2
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 80063b4:	f104 0804 	add.w	r8, r4, #4
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
 80063b8:	f001 fdda 	bl	8007f70 <strncpy>
	}
	#endif /* configMAX_TASK_NAME_LEN */
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
 80063bc:	2300      	movs	r3, #0
 80063be:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 80063c2:	4640      	mov	r0, r8
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
 80063c4:	62e6      	str	r6, [r4, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
 80063c6:	6426      	str	r6, [r4, #64]	; 0x40
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 80063c8:	f7ff fbe9 	bl	8005b9e <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 80063cc:	f104 0018 	add.w	r0, r4, #24
 80063d0:	f7ff fbe5 	bl	8005b9e <vListInitialiseItem>
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK  ) );
 80063d4:	f027 0707 	bic.w	r7, r7, #7
	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
 80063d8:	f1c6 0305 	rsb	r3, r6, #5
 80063dc:	61a3      	str	r3, [r4, #24]
	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
	vListInitialiseItem( &( pxTCB->xEventListItem ) );

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 80063de:	6124      	str	r4, [r4, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 80063e0:	6264      	str	r4, [r4, #36]	; 0x24
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 80063e2:	4638      	mov	r0, r7
 80063e4:	4651      	mov	r1, sl
 80063e6:	465a      	mov	r2, fp
 80063e8:	f7ff fa18 	bl	800581c <pxPortInitialiseStack>
		}
		#endif /* portUSING_MPU_WRAPPERS */

		/* Check the alignment of the initialised stack. */
		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
 80063ec:	0743      	lsls	r3, r0, #29
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 80063ee:	6020      	str	r0, [r4, #0]
		}
		#endif /* portUSING_MPU_WRAPPERS */

		/* Check the alignment of the initialised stack. */
		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
 80063f0:	d002      	beq.n	80063f8 <xTaskGenericCreate+0xa8>
 80063f2:	f7ff fa3b 	bl	800586c <ulPortSetInterruptMask>
 80063f6:	e7fe      	b.n	80063f6 <xTaskGenericCreate+0xa6>

		if( ( void * ) pxCreatedTask != NULL )
 80063f8:	f1b9 0f00 	cmp.w	r9, #0
 80063fc:	d001      	beq.n	8006402 <xTaskGenericCreate+0xb2>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 80063fe:	f8c9 4000 	str.w	r4, [r9]
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
 8006402:	f7ff fa3b 	bl	800587c <vPortEnterCritical>
		{
			uxCurrentNumberOfTasks++;
 8006406:	4b33      	ldr	r3, [pc, #204]	; (80064d4 <xTaskGenericCreate+0x184>)
 8006408:	691a      	ldr	r2, [r3, #16]
 800640a:	3201      	adds	r2, #1
 800640c:	611a      	str	r2, [r3, #16]
			if( pxCurrentTCB == NULL )
 800640e:	681f      	ldr	r7, [r3, #0]
 8006410:	bb4f      	cbnz	r7, 8006466 <xTaskGenericCreate+0x116>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
 8006412:	601c      	str	r4, [r3, #0]

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 8006414:	691a      	ldr	r2, [r3, #16]
 8006416:	2a01      	cmp	r2, #1
 8006418:	d12d      	bne.n	8006476 <xTaskGenericCreate+0x126>
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 800641a:	f103 0914 	add.w	r9, r3, #20
 800641e:	f04f 0a14 	mov.w	sl, #20
 8006422:	fb0a 9007 	mla	r0, sl, r7, r9

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 8006426:	3701      	adds	r7, #1
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 8006428:	f7ff fbae 	bl	8005b88 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 800642c:	2f05      	cmp	r7, #5
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 800642e:	4d29      	ldr	r5, [pc, #164]	; (80064d4 <xTaskGenericCreate+0x184>)

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 8006430:	d1f7      	bne.n	8006422 <xTaskGenericCreate+0xd2>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
 8006432:	f105 0978 	add.w	r9, r5, #120	; 0x78
 8006436:	4648      	mov	r0, r9
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
 8006438:	f105 078c 	add.w	r7, r5, #140	; 0x8c
	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
 800643c:	f7ff fba4 	bl	8005b88 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
 8006440:	4638      	mov	r0, r7
 8006442:	f7ff fba1 	bl	8005b88 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
 8006446:	f105 00a0 	add.w	r0, r5, #160	; 0xa0
 800644a:	f7ff fb9d 	bl	8005b88 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
 800644e:	f105 00b4 	add.w	r0, r5, #180	; 0xb4
 8006452:	f7ff fb99 	bl	8005b88 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
 8006456:	f105 00c8 	add.w	r0, r5, #200	; 0xc8
 800645a:	f7ff fb95 	bl	8005b88 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 800645e:	f8c5 900c 	str.w	r9, [r5, #12]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 8006462:	60af      	str	r7, [r5, #8]
 8006464:	e007      	b.n	8006476 <xTaskGenericCreate+0x126>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
 8006466:	f8d3 20dc 	ldr.w	r2, [r3, #220]	; 0xdc
 800646a:	b922      	cbnz	r2, 8006476 <xTaskGenericCreate+0x126>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
 800646c:	681a      	ldr	r2, [r3, #0]
 800646e:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8006470:	42b2      	cmp	r2, r6
					{
						pxCurrentTCB = pxNewTCB;
 8006472:	bf98      	it	ls
 8006474:	601c      	strls	r4, [r3, #0]
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 8006476:	4a17      	ldr	r2, [pc, #92]	; (80064d4 <xTaskGenericCreate+0x184>)
 8006478:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800647a:	f8d2 10e0 	ldr.w	r1, [r2, #224]	; 0xe0
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyQueue( pxNewTCB );
 800647e:	4c15      	ldr	r4, [pc, #84]	; (80064d4 <xTaskGenericCreate+0x184>)
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 8006480:	428b      	cmp	r3, r1
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
			}

			uxTaskNumber++;
 8006482:	f8d2 10e4 	ldr.w	r1, [r2, #228]	; 0xe4

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
 8006486:	bf88      	it	hi
 8006488:	f8c2 30e0 	strhi.w	r3, [r2, #224]	; 0xe0
			}

			uxTaskNumber++;
 800648c:	3101      	adds	r1, #1
 800648e:	f8c2 10e4 	str.w	r1, [r2, #228]	; 0xe4
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyQueue( pxNewTCB );
 8006492:	f8d2 20e8 	ldr.w	r2, [r2, #232]	; 0xe8
 8006496:	4641      	mov	r1, r8
 8006498:	4293      	cmp	r3, r2
 800649a:	bf84      	itt	hi
 800649c:	4a0d      	ldrhi	r2, [pc, #52]	; (80064d4 <xTaskGenericCreate+0x184>)
 800649e:	f8c2 30e8 	strhi.w	r3, [r2, #232]	; 0xe8
 80064a2:	f104 0214 	add.w	r2, r4, #20
 80064a6:	2014      	movs	r0, #20
 80064a8:	fb00 2003 	mla	r0, r0, r3, r2
 80064ac:	f7ff fb7a 	bl	8005ba4 <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
 80064b0:	f7ff f9f5 	bl	800589e <vPortExitCritical>
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
 80064b4:	f8d4 30dc 	ldr.w	r3, [r4, #220]	; 0xdc
 80064b8:	b12b      	cbz	r3, 80064c6 <xTaskGenericCreate+0x176>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
 80064ba:	6823      	ldr	r3, [r4, #0]
 80064bc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80064be:	42b3      	cmp	r3, r6
 80064c0:	d201      	bcs.n	80064c6 <xTaskGenericCreate+0x176>
			{
				portYIELD_WITHIN_API();
 80064c2:	f7ff f9c8 	bl	8005856 <vPortYield>
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
 80064c6:	2001      	movs	r0, #1
 80064c8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 80064cc:	f04f 30ff 	mov.w	r0, #4294967295
			}
		}
	}

	return xReturn;
}
 80064d0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80064d4:	20002a78 	.word	0x20002a78

080064d8 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle xTaskToDelete )
	{
 80064d8:	b570      	push	{r4, r5, r6, lr}
 80064da:	4605      	mov	r5, r0
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
 80064dc:	f7ff f9ce 	bl	800587c <vPortEnterCritical>
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( xTaskToDelete == pxCurrentTCB )
 80064e0:	4b16      	ldr	r3, [pc, #88]	; (800653c <vTaskDelete+0x64>)
 80064e2:	681a      	ldr	r2, [r3, #0]
 80064e4:	4295      	cmp	r5, r2
 80064e6:	d001      	beq.n	80064ec <vTaskDelete+0x14>
			{
				xTaskToDelete = NULL;
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 80064e8:	462c      	mov	r4, r5
 80064ea:	b915      	cbnz	r5, 80064f2 <vTaskDelete+0x1a>
 80064ec:	681c      	ldr	r4, [r3, #0]
 80064ee:	2500      	movs	r5, #0
 80064f0:	e7ff      	b.n	80064f2 <vTaskDelete+0x1a>

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
 80064f2:	1d26      	adds	r6, r4, #4
 80064f4:	4630      	mov	r0, r6
 80064f6:	f7ff fb7a 	bl	8005bee <uxListRemove>
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
			}

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
 80064fa:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80064fc:	b11b      	cbz	r3, 8006506 <vTaskDelete+0x2e>
			{
				uxListRemove( &( pxTCB->xEventListItem ) );
 80064fe:	f104 0018 	add.w	r0, r4, #24
 8006502:	f7ff fb74 	bl	8005bee <uxListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
 8006506:	4c0d      	ldr	r4, [pc, #52]	; (800653c <vTaskDelete+0x64>)
 8006508:	4631      	mov	r1, r6
 800650a:	f104 00b4 	add.w	r0, r4, #180	; 0xb4
 800650e:	f7ff fb49 	bl	8005ba4 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
 8006512:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
 8006516:	3301      	adds	r3, #1
 8006518:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
 800651c:	f8d4 30e4 	ldr.w	r3, [r4, #228]	; 0xe4
 8006520:	3301      	adds	r3, #1
 8006522:	f8c4 30e4 	str.w	r3, [r4, #228]	; 0xe4

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
 8006526:	f7ff f9ba 	bl	800589e <vPortExitCritical>

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
 800652a:	f8d4 30dc 	ldr.w	r3, [r4, #220]	; 0xdc
 800652e:	b123      	cbz	r3, 800653a <vTaskDelete+0x62>
		{
			if( ( void * ) xTaskToDelete == NULL )
 8006530:	b91d      	cbnz	r5, 800653a <vTaskDelete+0x62>
			{
				portYIELD_WITHIN_API();
			}
		}
	}
 8006532:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
		{
			if( ( void * ) xTaskToDelete == NULL )
			{
				portYIELD_WITHIN_API();
 8006536:	f7ff b98e 	b.w	8005856 <vPortYield>
 800653a:	bd70      	pop	{r4, r5, r6, pc}
 800653c:	20002a78 	.word	0x20002a78

08006540 <uxTaskPriorityGet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle xTask )
	{
 8006540:	b510      	push	{r4, lr}
 8006542:	4604      	mov	r4, r0
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxReturn;

		taskENTER_CRITICAL();
 8006544:	f7ff f99a 	bl	800587c <vPortEnterCritical>
		{
			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( xTask );
 8006548:	b90c      	cbnz	r4, 800654e <uxTaskPriorityGet+0xe>
 800654a:	4b03      	ldr	r3, [pc, #12]	; (8006558 <uxTaskPriorityGet+0x18>)
 800654c:	681c      	ldr	r4, [r3, #0]
			uxReturn = pxTCB->uxPriority;
 800654e:	6ae4      	ldr	r4, [r4, #44]	; 0x2c
		}
		taskEXIT_CRITICAL();
 8006550:	f7ff f9a5 	bl	800589e <vPortExitCritical>

		return uxReturn;
	}
 8006554:	4620      	mov	r0, r4
 8006556:	bd10      	pop	{r4, pc}
 8006558:	20002a78 	.word	0x20002a78

0800655c <vTaskPrioritySet>:
	{
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxCurrentPriority, uxPriorityUsedOnEntry;
	portBASE_TYPE xYieldRequired = pdFALSE;

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
 800655c:	2904      	cmp	r1, #4
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( xTaskHandle xTask, unsigned portBASE_TYPE uxNewPriority )
	{
 800655e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8006562:	4605      	mov	r5, r0
 8006564:	460e      	mov	r6, r1
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxCurrentPriority, uxPriorityUsedOnEntry;
	portBASE_TYPE xYieldRequired = pdFALSE;

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
 8006566:	d902      	bls.n	800656e <vTaskPrioritySet+0x12>
 8006568:	f7ff f980 	bl	800586c <ulPortSetInterruptMask>
 800656c:	e7fe      	b.n	800656c <vTaskPrioritySet+0x10>
		if( uxNewPriority >= configMAX_PRIORITIES )
		{
			uxNewPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
		}

		taskENTER_CRITICAL();
 800656e:	f7ff f985 	bl	800587c <vPortEnterCritical>
		{
			if( xTask == ( xTaskHandle ) pxCurrentTCB )
 8006572:	4b20      	ldr	r3, [pc, #128]	; (80065f4 <vTaskPrioritySet+0x98>)
 8006574:	681a      	ldr	r2, [r3, #0]
 8006576:	4295      	cmp	r5, r2
 8006578:	d000      	beq.n	800657c <vTaskPrioritySet+0x20>
				xTask = NULL;
			}

			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( xTask );
 800657a:	b915      	cbnz	r5, 8006582 <vTaskPrioritySet+0x26>
 800657c:	681c      	ldr	r4, [r3, #0]
 800657e:	2500      	movs	r5, #0
 8006580:	e000      	b.n	8006584 <vTaskPrioritySet+0x28>
 8006582:	462c      	mov	r4, r5

			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

			#if ( configUSE_MUTEXES == 1 )
			{
				uxCurrentPriority = pxTCB->uxBasePriority;
 8006584:	6c23      	ldr	r3, [r4, #64]	; 0x40
			{
				uxCurrentPriority = pxTCB->uxPriority;
			}
			#endif

			if( uxCurrentPriority != uxNewPriority )
 8006586:	42b3      	cmp	r3, r6
 8006588:	d02f      	beq.n	80065ea <vTaskPrioritySet+0x8e>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentPriority )
 800658a:	429e      	cmp	r6, r3
 800658c:	d903      	bls.n	8006596 <vTaskPrioritySet+0x3a>
				{
					if( xTask != NULL )
 800658e:	3500      	adds	r5, #0
 8006590:	bf18      	it	ne
 8006592:	2501      	movne	r5, #1
 8006594:	e003      	b.n	800659e <vTaskPrioritySet+0x42>
						there would be no need to switch as it must have already
						been the highest priority task. */
						xYieldRequired = pdTRUE;
					}
				}
				else if( xTask == NULL )
 8006596:	f1d5 0501 	rsbs	r5, r5, #1
 800659a:	bf38      	it	cc
 800659c:	2500      	movcc	r5, #0

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 800659e:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
					{
						pxTCB->uxPriority = uxNewPriority;
					}

					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
 80065a0:	6426      	str	r6, [r4, #64]	; 0x40

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 80065a2:	4293      	cmp	r3, r2
					{
						pxTCB->uxPriority = uxNewPriority;
 80065a4:	bf08      	it	eq
 80065a6:	62e6      	streq	r6, [r4, #44]	; 0x2c
				{
					pxTCB->uxPriority = uxNewPriority;
				}
				#endif

				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) uxNewPriority ) );
 80065a8:	f1c6 0605 	rsb	r6, r6, #5
 80065ac:	61a6      	str	r6, [r4, #24]

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the queue appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericListItem ) ) )
 80065ae:	4e11      	ldr	r6, [pc, #68]	; (80065f4 <vTaskPrioritySet+0x98>)
 80065b0:	2214      	movs	r2, #20
 80065b2:	f106 0014 	add.w	r0, r6, #20
 80065b6:	fb02 0303 	mla	r3, r2, r3, r0
 80065ba:	6962      	ldr	r2, [r4, #20]
 80065bc:	4680      	mov	r8, r0
 80065be:	429a      	cmp	r2, r3
 80065c0:	d110      	bne.n	80065e4 <vTaskPrioritySet+0x88>
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
 80065c2:	1d27      	adds	r7, r4, #4
 80065c4:	4638      	mov	r0, r7
 80065c6:	f7ff fb12 	bl	8005bee <uxListRemove>
					{
						taskRESET_READY_PRIORITY( uxPriorityUsedOnEntry );
					}
					prvAddTaskToReadyQueue( pxTCB );
 80065ca:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80065cc:	f8d6 20e8 	ldr.w	r2, [r6, #232]	; 0xe8
 80065d0:	4639      	mov	r1, r7
 80065d2:	4293      	cmp	r3, r2
 80065d4:	bf88      	it	hi
 80065d6:	f8c6 30e8 	strhi.w	r3, [r6, #232]	; 0xe8
 80065da:	2014      	movs	r0, #20
 80065dc:	fb00 8003 	mla	r0, r0, r3, r8
 80065e0:	f7ff fae0 	bl	8005ba4 <vListInsertEnd>
				}

				if( xYieldRequired == pdTRUE )
 80065e4:	b10d      	cbz	r5, 80065ea <vTaskPrioritySet+0x8e>
				{
					portYIELD_WITHIN_API();
 80065e6:	f7ff f936 	bl	8005856 <vPortYield>
		taskEXIT_CRITICAL();

		/* Remove compiler warning about unused parameter when the port
		optimised task selection is not being used. */
		( void ) uxPriorityUsedOnEntry;
	}
 80065ea:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
				{
					portYIELD_WITHIN_API();
				}
			}
		}
		taskEXIT_CRITICAL();
 80065ee:	f7ff b956 	b.w	800589e <vPortExitCritical>
 80065f2:	bf00      	nop
 80065f4:	20002a78 	.word	0x20002a78

080065f8 <xTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
 80065f8:	b508      	push	{r3, lr}
	portBASE_TYPE xReturn = pdFALSE;
	const tskTCB * const pxTCB = ( tskTCB * ) xTask;

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );
 80065fa:	b910      	cbnz	r0, 8006602 <xTaskIsTaskSuspended+0xa>
 80065fc:	f7ff f936 	bl	800586c <ulPortSetInterruptMask>
 8006600:	e7fe      	b.n	8006600 <xTaskIsTaskSuspended+0x8>

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
 8006602:	6943      	ldr	r3, [r0, #20]
 8006604:	4a07      	ldr	r2, [pc, #28]	; (8006624 <xTaskIsTaskSuspended+0x2c>)
 8006606:	4293      	cmp	r3, r2
 8006608:	d109      	bne.n	800661e <xTaskIsTaskSuspended+0x26>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
 800660a:	6a80      	ldr	r0, [r0, #40]	; 0x28
 800660c:	f1a2 0328 	sub.w	r3, r2, #40	; 0x28
 8006610:	4298      	cmp	r0, r3
 8006612:	d004      	beq.n	800661e <xTaskIsTaskSuspended+0x26>
			{
				/* Is it in the suspended list because it is in the
				Suspended state?  It is possible to be in the suspended
				list because it is blocked on a task with no timeout
				specified. */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
 8006614:	f1d0 0001 	rsbs	r0, r0, #1
 8006618:	bf38      	it	cc
 800661a:	2000      	movcc	r0, #0
 800661c:	bd08      	pop	{r3, pc}

#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
	portBASE_TYPE xReturn = pdFALSE;
 800661e:	2000      	movs	r0, #0
				}
			}
		}

		return xReturn;
	}
 8006620:	bd08      	pop	{r3, pc}
 8006622:	bf00      	nop
 8006624:	20002b40 	.word	0x20002b40

08006628 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( xTaskHandle xTaskToResume )
	{
 8006628:	b570      	push	{r4, r5, r6, lr}
	tskTCB *pxTCB;

		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );
 800662a:	4604      	mov	r4, r0
 800662c:	b910      	cbnz	r0, 8006634 <vTaskResume+0xc>
 800662e:	f7ff f91d 	bl	800586c <ulPortSetInterruptMask>
 8006632:	e7fe      	b.n	8006632 <vTaskResume+0xa>
		it in the ready list. */
		pxTCB = ( tskTCB * ) xTaskToResume;

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 8006634:	4d15      	ldr	r5, [pc, #84]	; (800668c <vTaskResume+0x64>)
 8006636:	682b      	ldr	r3, [r5, #0]
 8006638:	4298      	cmp	r0, r3
 800663a:	d025      	beq.n	8006688 <vTaskResume+0x60>
		{
			taskENTER_CRITICAL();
 800663c:	f7ff f91e 	bl	800587c <vPortEnterCritical>
			{
				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 8006640:	4620      	mov	r0, r4
 8006642:	f7ff ffd9 	bl	80065f8 <xTaskIsTaskSuspended>
 8006646:	2801      	cmp	r0, #1
 8006648:	d11a      	bne.n	8006680 <vTaskResume+0x58>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					uxListRemove(  &( pxTCB->xGenericListItem ) );
 800664a:	1d26      	adds	r6, r4, #4
 800664c:	4630      	mov	r0, r6
 800664e:	f7ff face 	bl	8005bee <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
 8006652:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8006654:	f8d5 20e8 	ldr.w	r2, [r5, #232]	; 0xe8
 8006658:	4631      	mov	r1, r6
 800665a:	4293      	cmp	r3, r2
 800665c:	bf88      	it	hi
 800665e:	f8c5 30e8 	strhi.w	r3, [r5, #232]	; 0xe8
 8006662:	4d0a      	ldr	r5, [pc, #40]	; (800668c <vTaskResume+0x64>)
 8006664:	2014      	movs	r0, #20
 8006666:	f105 0214 	add.w	r2, r5, #20
 800666a:	fb00 2003 	mla	r0, r0, r3, r2
 800666e:	f7ff fa99 	bl	8005ba4 <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8006672:	682b      	ldr	r3, [r5, #0]
 8006674:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8006676:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006678:	429a      	cmp	r2, r3
 800667a:	d301      	bcc.n	8006680 <vTaskResume+0x58>
					{
						/* This yield may not cause the task just resumed to run, but
						will leave the lists in the correct state for the next yield. */
						portYIELD_WITHIN_API();
 800667c:	f7ff f8eb 	bl	8005856 <vPortYield>
					}
				}
			}
			taskEXIT_CRITICAL();
		}
	}
 8006680:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
						will leave the lists in the correct state for the next yield. */
						portYIELD_WITHIN_API();
					}
				}
			}
			taskEXIT_CRITICAL();
 8006684:	f7ff b90b 	b.w	800589e <vPortExitCritical>
 8006688:	bd70      	pop	{r4, r5, r6, pc}
 800668a:	bf00      	nop
 800668c:	20002a78 	.word	0x20002a78

08006690 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle xTaskToResume )
	{
 8006690:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	portBASE_TYPE xYieldRequired = pdFALSE;
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxSavedInterruptStatus;

		configASSERT( xTaskToResume );
 8006694:	4604      	mov	r4, r0
 8006696:	b910      	cbnz	r0, 800669e <xTaskResumeFromISR+0xe>
 8006698:	f7ff f8e8 	bl	800586c <ulPortSetInterruptMask>
 800669c:	e7fe      	b.n	800669c <xTaskResumeFromISR+0xc>

		pxTCB = ( tskTCB * ) xTaskToResume;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 800669e:	f7ff f8e5 	bl	800586c <ulPortSetInterruptMask>
 80066a2:	4680      	mov	r8, r0
		{
			if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 80066a4:	4620      	mov	r0, r4
 80066a6:	f7ff ffa7 	bl	80065f8 <xTaskIsTaskSuspended>
 80066aa:	2801      	cmp	r0, #1
 80066ac:	d123      	bne.n	80066f6 <xTaskResumeFromISR+0x66>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 80066ae:	4d15      	ldr	r5, [pc, #84]	; (8006704 <xTaskResumeFromISR+0x74>)
 80066b0:	f8d5 30f0 	ldr.w	r3, [r5, #240]	; 0xf0
 80066b4:	b9cb      	cbnz	r3, 80066ea <xTaskResumeFromISR+0x5a>
				{
					xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
 80066b6:	682a      	ldr	r2, [r5, #0]
 80066b8:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80066ba:	6ad6      	ldr	r6, [r2, #44]	; 0x2c
 80066bc:	42b3      	cmp	r3, r6
 80066be:	bf34      	ite	cc
 80066c0:	2600      	movcc	r6, #0
 80066c2:	2601      	movcs	r6, #1
					uxListRemove(  &( pxTCB->xGenericListItem ) );
 80066c4:	1d27      	adds	r7, r4, #4
 80066c6:	4638      	mov	r0, r7
 80066c8:	f7ff fa91 	bl	8005bee <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
 80066cc:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80066ce:	f8d5 20e8 	ldr.w	r2, [r5, #232]	; 0xe8
 80066d2:	4639      	mov	r1, r7
 80066d4:	4293      	cmp	r3, r2
 80066d6:	4a0c      	ldr	r2, [pc, #48]	; (8006708 <xTaskResumeFromISR+0x78>)
 80066d8:	bf88      	it	hi
 80066da:	f8c5 30e8 	strhi.w	r3, [r5, #232]	; 0xe8
 80066de:	2014      	movs	r0, #20
 80066e0:	fb00 2003 	mla	r0, r0, r3, r2
 80066e4:	f7ff fa5e 	bl	8005ba4 <vListInsertEnd>
 80066e8:	e006      	b.n	80066f8 <xTaskResumeFromISR+0x68>
				else
				{
					/* We cannot access the delayed or ready lists, so will hold this
					task pending until the scheduler is resumed, at which point a
					yield will be performed if necessary. */
					vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 80066ea:	f105 00a0 	add.w	r0, r5, #160	; 0xa0
 80066ee:	f104 0118 	add.w	r1, r4, #24
 80066f2:	f7ff fa57 	bl	8005ba4 <vListInsertEnd>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle xTaskToResume )
	{
	portBASE_TYPE xYieldRequired = pdFALSE;
 80066f6:	2600      	movs	r6, #0
					yield will be performed if necessary. */
					vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 80066f8:	4640      	mov	r0, r8
 80066fa:	f7ff f8cd 	bl	8005898 <vPortClearInterruptMask>

		return xYieldRequired;
	}
 80066fe:	4630      	mov	r0, r6
 8006700:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8006704:	20002a78 	.word	0x20002a78
 8006708:	20002a8c 	.word	0x20002a8c

0800670c <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
 800670c:	b530      	push	{r4, r5, lr}
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
 800670e:	2400      	movs	r4, #0

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
 8006710:	b085      	sub	sp, #20
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
 8006712:	9400      	str	r4, [sp, #0]
 8006714:	9401      	str	r4, [sp, #4]
 8006716:	9402      	str	r4, [sp, #8]
 8006718:	9403      	str	r4, [sp, #12]
 800671a:	4810      	ldr	r0, [pc, #64]	; (800675c <vTaskStartScheduler+0x50>)
 800671c:	4910      	ldr	r1, [pc, #64]	; (8006760 <vTaskStartScheduler+0x54>)
 800671e:	f44f 72a0 	mov.w	r2, #320	; 0x140
 8006722:	4623      	mov	r3, r4
 8006724:	f7ff fe14 	bl	8006350 <xTaskGenericCreate>
	}
	#endif /* INCLUDE_xTaskGetIdleTaskHandle */

	#if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
 8006728:	2801      	cmp	r0, #1
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
 800672a:	4605      	mov	r5, r0
	}
	#endif /* INCLUDE_xTaskGetIdleTaskHandle */

	#if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
 800672c:	d10f      	bne.n	800674e <vTaskStartScheduler+0x42>
		{
			xReturn = xTimerCreateTimerTask();
 800672e:	f000 fb85 	bl	8006e3c <xTimerCreateTimerTask>
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
 8006732:	2801      	cmp	r0, #1

	#if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
		{
			xReturn = xTimerCreateTimerTask();
 8006734:	4605      	mov	r5, r0
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
 8006736:	d10a      	bne.n	800674e <vTaskStartScheduler+0x42>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
 8006738:	f7ff f898 	bl	800586c <ulPortSetInterruptMask>

		xSchedulerRunning = pdTRUE;
 800673c:	4b09      	ldr	r3, [pc, #36]	; (8006764 <vTaskStartScheduler+0x58>)
 800673e:	f8c3 50dc 	str.w	r5, [r3, #220]	; 0xdc
		xTickCount = ( portTickType ) 0U;
 8006742:	605c      	str	r4, [r3, #4]
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
 8006744:	b005      	add	sp, #20
 8006746:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
 800674a:	f7ff b8ed 	b.w	8005928 <xPortStartScheduler>
	else
	{
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
 800674e:	b915      	cbnz	r5, 8006756 <vTaskStartScheduler+0x4a>
 8006750:	f7ff f88c 	bl	800586c <ulPortSetInterruptMask>
 8006754:	e7fe      	b.n	8006754 <vTaskStartScheduler+0x48>
	}
}
 8006756:	b005      	add	sp, #20
 8006758:	bd30      	pop	{r4, r5, pc}
 800675a:	bf00      	nop
 800675c:	08006971 	.word	0x08006971
 8006760:	0800aa02 	.word	0x0800aa02
 8006764:	20002a78 	.word	0x20002a78

08006768 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
 8006768:	b508      	push	{r3, lr}
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
 800676a:	f7ff f87f 	bl	800586c <ulPortSetInterruptMask>
	xSchedulerRunning = pdFALSE;
 800676e:	4b04      	ldr	r3, [pc, #16]	; (8006780 <vTaskEndScheduler+0x18>)
 8006770:	2200      	movs	r2, #0
 8006772:	f8c3 20dc 	str.w	r2, [r3, #220]	; 0xdc
	vPortEndScheduler();
}
 8006776:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
	xSchedulerRunning = pdFALSE;
	vPortEndScheduler();
 800677a:	f7ff b86b 	b.w	8005854 <vPortEndScheduler>
 800677e:	bf00      	nop
 8006780:	20002a78 	.word	0x20002a78

08006784 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
 8006784:	4b03      	ldr	r3, [pc, #12]	; (8006794 <vTaskSuspendAll+0x10>)
 8006786:	f8d3 20f0 	ldr.w	r2, [r3, #240]	; 0xf0
 800678a:	3201      	adds	r2, #1
 800678c:	f8c3 20f0 	str.w	r2, [r3, #240]	; 0xf0
 8006790:	4770      	bx	lr
 8006792:	bf00      	nop
 8006794:	20002a78 	.word	0x20002a78

08006798 <xTaskGetTickCount>:
	return xAlreadyYielded;
}
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCount( void )
{
 8006798:	b510      	push	{r4, lr}
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
 800679a:	f7ff f86f 	bl	800587c <vPortEnterCritical>
	{
		xTicks = xTickCount;
 800679e:	4b03      	ldr	r3, [pc, #12]	; (80067ac <xTaskGetTickCount+0x14>)
 80067a0:	685c      	ldr	r4, [r3, #4]
	}
	taskEXIT_CRITICAL();
 80067a2:	f7ff f87c 	bl	800589e <vPortExitCritical>

	return xTicks;
}
 80067a6:	4620      	mov	r0, r4
 80067a8:	bd10      	pop	{r4, pc}
 80067aa:	bf00      	nop
 80067ac:	20002a78 	.word	0x20002a78

080067b0 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
 80067b0:	b510      	push	{r4, lr}
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 80067b2:	f7ff f85b 	bl	800586c <ulPortSetInterruptMask>
	xReturn = xTickCount;
 80067b6:	4b03      	ldr	r3, [pc, #12]	; (80067c4 <xTaskGetTickCountFromISR+0x14>)
 80067b8:	685c      	ldr	r4, [r3, #4]
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
 80067ba:	f7ff f86d 	bl	8005898 <vPortClearInterruptMask>

	return xReturn;
}
 80067be:	4620      	mov	r0, r4
 80067c0:	bd10      	pop	{r4, pc}
 80067c2:	bf00      	nop
 80067c4:	20002a78 	.word	0x20002a78

080067c8 <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
 80067c8:	4b01      	ldr	r3, [pc, #4]	; (80067d0 <uxTaskGetNumberOfTasks+0x8>)
 80067ca:	6918      	ldr	r0, [r3, #16]
}
 80067cc:	4770      	bx	lr
 80067ce:	bf00      	nop
 80067d0:	20002a78 	.word	0x20002a78

080067d4 <vTaskIncrementTick>:

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 80067d4:	4b31      	ldr	r3, [pc, #196]	; (800689c <vTaskIncrementTick+0xc8>)

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
 80067d6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 80067da:	f8d3 20f0 	ldr.w	r2, [r3, #240]	; 0xf0
 80067de:	2a00      	cmp	r2, #0
 80067e0:	d154      	bne.n	800688c <vTaskIncrementTick+0xb8>
	{
		++xTickCount;
 80067e2:	685a      	ldr	r2, [r3, #4]
 80067e4:	3201      	adds	r2, #1
 80067e6:	605a      	str	r2, [r3, #4]
		if( xTickCount == ( portTickType ) 0U )
 80067e8:	685a      	ldr	r2, [r3, #4]
 80067ea:	b9d2      	cbnz	r2, 8006822 <vTaskIncrementTick+0x4e>
			xList *pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
 80067ec:	68da      	ldr	r2, [r3, #12]
 80067ee:	6812      	ldr	r2, [r2, #0]
 80067f0:	b112      	cbz	r2, 80067f8 <vTaskIncrementTick+0x24>
 80067f2:	f7ff f83b 	bl	800586c <ulPortSetInterruptMask>
 80067f6:	e7fe      	b.n	80067f6 <vTaskIncrementTick+0x22>

			pxTemp = pxDelayedTaskList;
 80067f8:	68da      	ldr	r2, [r3, #12]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
 80067fa:	6899      	ldr	r1, [r3, #8]
 80067fc:	60d9      	str	r1, [r3, #12]
			pxOverflowDelayedTaskList = pxTemp;
 80067fe:	609a      	str	r2, [r3, #8]
			xNumOfOverflows++;
 8006800:	f8d3 20f4 	ldr.w	r2, [r3, #244]	; 0xf4
 8006804:	3201      	adds	r2, #1
 8006806:	f8c3 20f4 	str.w	r2, [r3, #244]	; 0xf4

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 800680a:	68da      	ldr	r2, [r3, #12]
 800680c:	6811      	ldr	r1, [r2, #0]
 800680e:	4a24      	ldr	r2, [pc, #144]	; (80068a0 <vTaskIncrementTick+0xcc>)
 8006810:	b911      	cbnz	r1, 8006818 <vTaskIncrementTick+0x44>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
 8006812:	f04f 33ff 	mov.w	r3, #4294967295
 8006816:	e003      	b.n	8006820 <vTaskIncrementTick+0x4c>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8006818:	68db      	ldr	r3, [r3, #12]
 800681a:	68db      	ldr	r3, [r3, #12]
 800681c:	68db      	ldr	r3, [r3, #12]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 800681e:	685b      	ldr	r3, [r3, #4]
 8006820:	6013      	str	r3, [r2, #0]
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
 8006822:	4c1e      	ldr	r4, [pc, #120]	; (800689c <vTaskIncrementTick+0xc8>)
 8006824:	4b1e      	ldr	r3, [pc, #120]	; (80068a0 <vTaskIncrementTick+0xcc>)
 8006826:	6862      	ldr	r2, [r4, #4]
 8006828:	681b      	ldr	r3, [r3, #0]
 800682a:	429a      	cmp	r2, r3
 800682c:	d333      	bcc.n	8006896 <vTaskIncrementTick+0xc2>
 800682e:	f104 0714 	add.w	r7, r4, #20
 8006832:	f04f 0814 	mov.w	r8, #20
 8006836:	68e3      	ldr	r3, [r4, #12]
 8006838:	681b      	ldr	r3, [r3, #0]
 800683a:	b92b      	cbnz	r3, 8006848 <vTaskIncrementTick+0x74>
 800683c:	4b18      	ldr	r3, [pc, #96]	; (80068a0 <vTaskIncrementTick+0xcc>)
 800683e:	f04f 32ff 	mov.w	r2, #4294967295
 8006842:	601a      	str	r2, [r3, #0]
 8006844:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8006848:	68e3      	ldr	r3, [r4, #12]
 800684a:	68db      	ldr	r3, [r3, #12]
 800684c:	68dd      	ldr	r5, [r3, #12]
 800684e:	6862      	ldr	r2, [r4, #4]
 8006850:	686b      	ldr	r3, [r5, #4]
 8006852:	429a      	cmp	r2, r3
 8006854:	d203      	bcs.n	800685e <vTaskIncrementTick+0x8a>
 8006856:	4a12      	ldr	r2, [pc, #72]	; (80068a0 <vTaskIncrementTick+0xcc>)
 8006858:	6013      	str	r3, [r2, #0]
 800685a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800685e:	1d2e      	adds	r6, r5, #4
 8006860:	4630      	mov	r0, r6
 8006862:	f7ff f9c4 	bl	8005bee <uxListRemove>
 8006866:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8006868:	b11b      	cbz	r3, 8006872 <vTaskIncrementTick+0x9e>
 800686a:	f105 0018 	add.w	r0, r5, #24
 800686e:	f7ff f9be 	bl	8005bee <uxListRemove>
 8006872:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
 8006874:	f8d4 20e8 	ldr.w	r2, [r4, #232]	; 0xe8
 8006878:	4631      	mov	r1, r6
 800687a:	4290      	cmp	r0, r2
 800687c:	bf88      	it	hi
 800687e:	f8c4 00e8 	strhi.w	r0, [r4, #232]	; 0xe8
 8006882:	fb08 7000 	mla	r0, r8, r0, r7
 8006886:	f7ff f98d 	bl	8005ba4 <vListInsertEnd>
 800688a:	e7d4      	b.n	8006836 <vTaskIncrementTick+0x62>
	}
	else
	{
		++uxMissedTicks;
 800688c:	f8d3 20f8 	ldr.w	r2, [r3, #248]	; 0xf8
 8006890:	3201      	adds	r2, #1
 8006892:	f8c3 20f8 	str.w	r2, [r3, #248]	; 0xf8
 8006896:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800689a:	bf00      	nop
 800689c:	20002a78 	.word	0x20002a78
 80068a0:	20000030 	.word	0x20000030

080068a4 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
 80068a4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;

	/* If uxSchedulerSuspended is zero then this function does not match a
	previous call to vTaskSuspendAll(). */
	configASSERT( uxSchedulerSuspended );
 80068a8:	4c30      	ldr	r4, [pc, #192]	; (800696c <xTaskResumeAll+0xc8>)
 80068aa:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
 80068ae:	b913      	cbnz	r3, 80068b6 <xTaskResumeAll+0x12>
 80068b0:	f7fe ffdc 	bl	800586c <ulPortSetInterruptMask>
 80068b4:	e7fe      	b.n	80068b4 <xTaskResumeAll+0x10>
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
 80068b6:	f7fe ffe1 	bl	800587c <vPortEnterCritical>
	{
		--uxSchedulerSuspended;
 80068ba:	f8d4 30f0 	ldr.w	r3, [r4, #240]	; 0xf0
 80068be:	3b01      	subs	r3, #1
 80068c0:	f8c4 30f0 	str.w	r3, [r4, #240]	; 0xf0

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 80068c4:	f8d4 60f0 	ldr.w	r6, [r4, #240]	; 0xf0
 80068c8:	b10e      	cbz	r6, 80068ce <xTaskResumeAll+0x2a>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 80068ca:	2400      	movs	r4, #0
 80068cc:	e049      	b.n	8006962 <xTaskResumeAll+0xbe>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
 80068ce:	6923      	ldr	r3, [r4, #16]
 80068d0:	b9f3      	cbnz	r3, 8006910 <xTaskResumeAll+0x6c>
 80068d2:	e7fa      	b.n	80068ca <xTaskResumeAll+0x26>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
 80068d4:	f8d4 30ac 	ldr.w	r3, [r4, #172]	; 0xac
 80068d8:	68dd      	ldr	r5, [r3, #12]
					uxListRemove( &( pxTCB->xEventListItem ) );
					uxListRemove( &( pxTCB->xGenericListItem ) );
 80068da:	1d2f      	adds	r7, r5, #4
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					uxListRemove( &( pxTCB->xEventListItem ) );
 80068dc:	f105 0018 	add.w	r0, r5, #24
 80068e0:	f7ff f985 	bl	8005bee <uxListRemove>
					uxListRemove( &( pxTCB->xGenericListItem ) );
 80068e4:	4638      	mov	r0, r7
 80068e6:	f7ff f982 	bl	8005bee <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
 80068ea:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
 80068ec:	f8d4 20e8 	ldr.w	r2, [r4, #232]	; 0xe8
 80068f0:	4639      	mov	r1, r7
 80068f2:	4290      	cmp	r0, r2
 80068f4:	bf88      	it	hi
 80068f6:	f8c4 00e8 	strhi.w	r0, [r4, #232]	; 0xe8
 80068fa:	fb09 8000 	mla	r0, r9, r0, r8
 80068fe:	f7ff f951 	bl	8005ba4 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8006902:	6823      	ldr	r3, [r4, #0]
 8006904:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 8006906:	6adb      	ldr	r3, [r3, #44]	; 0x2c
					{
						xYieldRequired = pdTRUE;
 8006908:	429a      	cmp	r2, r3
 800690a:	bf28      	it	cs
 800690c:	2601      	movcs	r6, #1
 800690e:	e003      	b.n	8006918 <xTaskResumeAll+0x74>
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					uxListRemove( &( pxTCB->xEventListItem ) );
					uxListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
 8006910:	f104 0814 	add.w	r8, r4, #20
 8006914:	f04f 0914 	mov.w	r9, #20
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
 8006918:	f8d4 20a0 	ldr.w	r2, [r4, #160]	; 0xa0
 800691c:	4b13      	ldr	r3, [pc, #76]	; (800696c <xTaskResumeAll+0xc8>)
 800691e:	2a00      	cmp	r2, #0
 8006920:	d1d8      	bne.n	80068d4 <xTaskResumeAll+0x30>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 8006922:	f8d3 20f8 	ldr.w	r2, [r3, #248]	; 0xf8
 8006926:	b942      	cbnz	r2, 800693a <xTaskResumeAll+0x96>
 8006928:	e014      	b.n	8006954 <xTaskResumeAll+0xb0>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
 800692a:	f7ff ff53 	bl	80067d4 <vTaskIncrementTick>
						--uxMissedTicks;
 800692e:	f8d4 30f8 	ldr.w	r3, [r4, #248]	; 0xf8
 8006932:	3b01      	subs	r3, #1
 8006934:	f8c4 30f8 	str.w	r3, [r4, #248]	; 0xf8
 8006938:	e000      	b.n	800693c <xTaskResumeAll+0x98>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
 800693a:	461c      	mov	r4, r3
 800693c:	f8d4 30f8 	ldr.w	r3, [r4, #248]	; 0xf8
 8006940:	2b00      	cmp	r3, #0
 8006942:	d1f2      	bne.n	800692a <xTaskResumeAll+0x86>
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
 8006944:	4b09      	ldr	r3, [pc, #36]	; (800696c <xTaskResumeAll+0xc8>)
 8006946:	2200      	movs	r2, #0
 8006948:	f8c3 20fc 	str.w	r2, [r3, #252]	; 0xfc
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
 800694c:	2401      	movs	r4, #1
					xMissedYield = pdFALSE;
					portYIELD_WITHIN_API();
 800694e:	f7fe ff82 	bl	8005856 <vPortYield>
 8006952:	e006      	b.n	8006962 <xTaskResumeAll+0xbe>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 8006954:	2e01      	cmp	r6, #1
 8006956:	d0f5      	beq.n	8006944 <xTaskResumeAll+0xa0>
 8006958:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
 800695c:	2b01      	cmp	r3, #1
 800695e:	d1b4      	bne.n	80068ca <xTaskResumeAll+0x26>
 8006960:	e7f0      	b.n	8006944 <xTaskResumeAll+0xa0>
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
 8006962:	f7fe ff9c 	bl	800589e <vPortExitCritical>

	return xAlreadyYielded;
}
 8006966:	4620      	mov	r0, r4
 8006968:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800696c:	20002a78 	.word	0x20002a78

08006970 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
 8006970:	b538      	push	{r3, r4, r5, lr}
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
 8006972:	4c16      	ldr	r4, [pc, #88]	; (80069cc <prvIdleTask+0x5c>)
 8006974:	e01e      	b.n	80069b4 <prvIdleTask+0x44>
		{
			vTaskSuspendAll();
 8006976:	f7ff ff05 	bl	8006784 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 800697a:	f8d4 50b4 	ldr.w	r5, [r4, #180]	; 0xb4
			xTaskResumeAll();
 800697e:	f7ff ff91 	bl	80068a4 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
 8006982:	b1bd      	cbz	r5, 80069b4 <prvIdleTask+0x44>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
 8006984:	f7fe ff7a 	bl	800587c <vPortEnterCritical>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
 8006988:	f8d4 30c0 	ldr.w	r3, [r4, #192]	; 0xc0
 800698c:	68dd      	ldr	r5, [r3, #12]
					uxListRemove( &( pxTCB->xGenericListItem ) );
 800698e:	1d28      	adds	r0, r5, #4
 8006990:	f7ff f92d 	bl	8005bee <uxListRemove>
					--uxCurrentNumberOfTasks;
 8006994:	6923      	ldr	r3, [r4, #16]
 8006996:	3b01      	subs	r3, #1
 8006998:	6123      	str	r3, [r4, #16]
					--uxTasksDeleted;
 800699a:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
 800699e:	3b01      	subs	r3, #1
 80069a0:	f8c4 30ec 	str.w	r3, [r4, #236]	; 0xec
				}
				taskEXIT_CRITICAL();
 80069a4:	f7fe ff7b 	bl	800589e <vPortExitCritical>
		want to allocate and clean RAM statically. */
		portCLEAN_UP_TCB( pxTCB );

		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
 80069a8:	6b28      	ldr	r0, [r5, #48]	; 0x30
 80069aa:	f7fe ff17 	bl	80057dc <vPortFree>
		vPortFree( pxTCB );
 80069ae:	4628      	mov	r0, r5
 80069b0:	f7fe ff14 	bl	80057dc <vPortFree>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
 80069b4:	f8d4 30ec 	ldr.w	r3, [r4, #236]	; 0xec
 80069b8:	2b00      	cmp	r3, #0
 80069ba:	d1dc      	bne.n	8006976 <prvIdleTask+0x6>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
 80069bc:	6963      	ldr	r3, [r4, #20]
 80069be:	2b01      	cmp	r3, #1
 80069c0:	d901      	bls.n	80069c6 <prvIdleTask+0x56>
			{
				taskYIELD();
 80069c2:	f7fe ff48 	bl	8005856 <vPortYield>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
 80069c6:	f7fb fae3 	bl	8001f90 <vApplicationIdleHook>
				}
				xTaskResumeAll();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
 80069ca:	e7f3      	b.n	80069b4 <prvIdleTask+0x44>
 80069cc:	20002a78 	.word	0x20002a78

080069d0 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
 80069d0:	b510      	push	{r4, lr}
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
 80069d2:	4604      	mov	r4, r0
 80069d4:	b918      	cbnz	r0, 80069de <vTaskDelay+0xe>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
 80069d6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
 80069da:	f7fe bf3c 	b.w	8005856 <vPortYield>
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
		{
			vTaskSuspendAll();
 80069de:	f7ff fed1 	bl	8006784 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
 80069e2:	4b07      	ldr	r3, [pc, #28]	; (8006a00 <vTaskDelay+0x30>)
 80069e4:	685a      	ldr	r2, [r3, #4]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
 80069e6:	6818      	ldr	r0, [r3, #0]
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
 80069e8:	18a4      	adds	r4, r4, r2

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
 80069ea:	3004      	adds	r0, #4
 80069ec:	f7ff f8ff 	bl	8005bee <uxListRemove>
					/* The current task must be in a ready list, so there is
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
 80069f0:	4620      	mov	r0, r4
 80069f2:	f7ff fc8f 	bl	8006314 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
 80069f6:	f7ff ff55 	bl	80068a4 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 80069fa:	2800      	cmp	r0, #0
 80069fc:	d0eb      	beq.n	80069d6 <vTaskDelay+0x6>
		{
			portYIELD_WITHIN_API();
		}
	}
 80069fe:	bd10      	pop	{r4, pc}
 8006a00:	20002a78 	.word	0x20002a78

08006a04 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
 8006a04:	b538      	push	{r3, r4, r5, lr}
 8006a06:	460c      	mov	r4, r1
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
 8006a08:	4605      	mov	r5, r0
 8006a0a:	b910      	cbnz	r0, 8006a12 <vTaskDelayUntil+0xe>
 8006a0c:	f7fe ff2e 	bl	800586c <ulPortSetInterruptMask>
 8006a10:	e7fe      	b.n	8006a10 <vTaskDelayUntil+0xc>
		configASSERT( ( xTimeIncrement > 0U ) );
 8006a12:	b911      	cbnz	r1, 8006a1a <vTaskDelayUntil+0x16>
 8006a14:	f7fe ff2a 	bl	800586c <ulPortSetInterruptMask>
 8006a18:	e7fe      	b.n	8006a18 <vTaskDelayUntil+0x14>

		vTaskSuspendAll();
 8006a1a:	f7ff feb3 	bl	8006784 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;

			if( xTickCount < *pxPreviousWakeTime )
 8006a1e:	4a13      	ldr	r2, [pc, #76]	; (8006a6c <vTaskDelayUntil+0x68>)
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 8006a20:	682b      	ldr	r3, [r5, #0]

			if( xTickCount < *pxPreviousWakeTime )
 8006a22:	6851      	ldr	r1, [r2, #4]
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 8006a24:	191c      	adds	r4, r3, r4

			if( xTickCount < *pxPreviousWakeTime )
 8006a26:	4299      	cmp	r1, r3
 8006a28:	d202      	bcs.n	8006a30 <vTaskDelayUntil+0x2c>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
 8006a2a:	429c      	cmp	r4, r3
 8006a2c:	d208      	bcs.n	8006a40 <vTaskDelayUntil+0x3c>
 8006a2e:	e001      	b.n	8006a34 <vTaskDelayUntil+0x30>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
 8006a30:	429c      	cmp	r4, r3
 8006a32:	d307      	bcc.n	8006a44 <vTaskDelayUntil+0x40>
 8006a34:	6853      	ldr	r3, [r2, #4]
 8006a36:	429c      	cmp	r4, r3
 8006a38:	bf94      	ite	ls
 8006a3a:	2300      	movls	r3, #0
 8006a3c:	2301      	movhi	r3, #1
 8006a3e:	e002      	b.n	8006a46 <vTaskDelayUntil+0x42>
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
 8006a40:	2300      	movs	r3, #0
 8006a42:	e000      	b.n	8006a46 <vTaskDelayUntil+0x42>
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
				{
					xShouldDelay = pdTRUE;
 8006a44:	2301      	movs	r3, #1
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
 8006a46:	602c      	str	r4, [r5, #0]

			if( xShouldDelay != pdFALSE )
 8006a48:	b13b      	cbz	r3, 8006a5a <vTaskDelayUntil+0x56>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
 8006a4a:	4b08      	ldr	r3, [pc, #32]	; (8006a6c <vTaskDelayUntil+0x68>)
 8006a4c:	6818      	ldr	r0, [r3, #0]
 8006a4e:	3004      	adds	r0, #4
 8006a50:	f7ff f8cd 	bl	8005bee <uxListRemove>
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
 8006a54:	4620      	mov	r0, r4
 8006a56:	f7ff fc5d 	bl	8006314 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
 8006a5a:	f7ff ff23 	bl	80068a4 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 8006a5e:	b918      	cbnz	r0, 8006a68 <vTaskDelayUntil+0x64>
		{
			portYIELD_WITHIN_API();
		}
	}
 8006a60:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
 8006a64:	f7fe bef7 	b.w	8005856 <vPortYield>
 8006a68:	bd38      	pop	{r3, r4, r5, pc}
 8006a6a:	bf00      	nop
 8006a6c:	20002a78 	.word	0x20002a78

08006a70 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
 8006a70:	b538      	push	{r3, r4, r5, lr}
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 8006a72:	4b26      	ldr	r3, [pc, #152]	; (8006b0c <vTaskSwitchContext+0x9c>)
 8006a74:	f8d3 20f0 	ldr.w	r2, [r3, #240]	; 0xf0
 8006a78:	461c      	mov	r4, r3
 8006a7a:	b11a      	cbz	r2, 8006a84 <vTaskSwitchContext+0x14>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
 8006a7c:	2201      	movs	r2, #1
 8006a7e:	f8c3 20fc 	str.w	r2, [r3, #252]	; 0xfc
 8006a82:	bd38      	pop	{r3, r4, r5, pc}
				pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
				ulTaskSwitchedInTime = ulTotalRunTime;
		}
		#endif /* configGENERATE_RUN_TIME_STATS */

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
 8006a84:	681a      	ldr	r2, [r3, #0]
 8006a86:	681b      	ldr	r3, [r3, #0]
 8006a88:	6812      	ldr	r2, [r2, #0]
 8006a8a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8006a8c:	429a      	cmp	r2, r3
 8006a8e:	d804      	bhi.n	8006a9a <vTaskSwitchContext+0x2a>
 8006a90:	6820      	ldr	r0, [r4, #0]
 8006a92:	6821      	ldr	r1, [r4, #0]
 8006a94:	3134      	adds	r1, #52	; 0x34
 8006a96:	f7fb fa7a 	bl	8001f8e <vApplicationStackOverflowHook>
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
 8006a9a:	6823      	ldr	r3, [r4, #0]
 8006a9c:	491c      	ldr	r1, [pc, #112]	; (8006b10 <vTaskSwitchContext+0xa0>)
 8006a9e:	6b18      	ldr	r0, [r3, #48]	; 0x30
 8006aa0:	2214      	movs	r2, #20
 8006aa2:	4d1a      	ldr	r5, [pc, #104]	; (8006b0c <vTaskSwitchContext+0x9c>)
 8006aa4:	f001 f912 	bl	8007ccc <memcmp>
 8006aa8:	b188      	cbz	r0, 8006ace <vTaskSwitchContext+0x5e>
 8006aaa:	6828      	ldr	r0, [r5, #0]
 8006aac:	6829      	ldr	r1, [r5, #0]
 8006aae:	3134      	adds	r1, #52	; 0x34
 8006ab0:	f7fb fa6d 	bl	8001f8e <vApplicationStackOverflowHook>
 8006ab4:	e00b      	b.n	8006ace <vTaskSwitchContext+0x5e>

		taskSELECT_HIGHEST_PRIORITY_TASK();
 8006ab6:	f8d2 30e8 	ldr.w	r3, [r2, #232]	; 0xe8
 8006aba:	b913      	cbnz	r3, 8006ac2 <vTaskSwitchContext+0x52>
 8006abc:	f7fe fed6 	bl	800586c <ulPortSetInterruptMask>
 8006ac0:	e7fe      	b.n	8006ac0 <vTaskSwitchContext+0x50>
 8006ac2:	f8d2 30e8 	ldr.w	r3, [r2, #232]	; 0xe8
 8006ac6:	3b01      	subs	r3, #1
 8006ac8:	f8c2 30e8 	str.w	r3, [r2, #232]	; 0xe8
 8006acc:	e001      	b.n	8006ad2 <vTaskSwitchContext+0x62>
 8006ace:	4a0f      	ldr	r2, [pc, #60]	; (8006b0c <vTaskSwitchContext+0x9c>)
 8006ad0:	2014      	movs	r0, #20
 8006ad2:	f8d2 30e8 	ldr.w	r3, [r2, #232]	; 0xe8
 8006ad6:	490d      	ldr	r1, [pc, #52]	; (8006b0c <vTaskSwitchContext+0x9c>)
 8006ad8:	fb00 2303 	mla	r3, r0, r3, r2
 8006adc:	695b      	ldr	r3, [r3, #20]
 8006ade:	2b00      	cmp	r3, #0
 8006ae0:	d0e9      	beq.n	8006ab6 <vTaskSwitchContext+0x46>
 8006ae2:	f8d1 30e8 	ldr.w	r3, [r1, #232]	; 0xe8
 8006ae6:	2214      	movs	r2, #20
 8006ae8:	3114      	adds	r1, #20
 8006aea:	fb02 1303 	mla	r3, r2, r3, r1
 8006aee:	685a      	ldr	r2, [r3, #4]
 8006af0:	f103 0108 	add.w	r1, r3, #8
 8006af4:	6852      	ldr	r2, [r2, #4]
 8006af6:	428a      	cmp	r2, r1
 8006af8:	605a      	str	r2, [r3, #4]
 8006afa:	bf04      	itt	eq
 8006afc:	6852      	ldreq	r2, [r2, #4]
 8006afe:	605a      	streq	r2, [r3, #4]
 8006b00:	685b      	ldr	r3, [r3, #4]
 8006b02:	68da      	ldr	r2, [r3, #12]
 8006b04:	4b01      	ldr	r3, [pc, #4]	; (8006b0c <vTaskSwitchContext+0x9c>)
 8006b06:	601a      	str	r2, [r3, #0]
 8006b08:	bd38      	pop	{r3, r4, r5, pc}
 8006b0a:	bf00      	nop
 8006b0c:	20002a78 	.word	0x20002a78
 8006b10:	0800a580 	.word	0x0800a580

08006b14 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( xTaskHandle xTaskToSuspend )
	{
 8006b14:	b570      	push	{r4, r5, r6, lr}
 8006b16:	4604      	mov	r4, r0
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
 8006b18:	f7fe feb0 	bl	800587c <vPortEnterCritical>
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( xTaskToSuspend == ( xTaskHandle ) pxCurrentTCB )
 8006b1c:	4b17      	ldr	r3, [pc, #92]	; (8006b7c <vTaskSuspend+0x68>)
 8006b1e:	681a      	ldr	r2, [r3, #0]
 8006b20:	4294      	cmp	r4, r2
 8006b22:	d001      	beq.n	8006b28 <vTaskSuspend+0x14>
			{
				xTaskToSuspend = NULL;
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 8006b24:	4625      	mov	r5, r4
 8006b26:	b914      	cbnz	r4, 8006b2e <vTaskSuspend+0x1a>
 8006b28:	681d      	ldr	r5, [r3, #0]
 8006b2a:	2400      	movs	r4, #0
 8006b2c:	e7ff      	b.n	8006b2e <vTaskSuspend+0x1a>

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the	suspended list. */
			if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
 8006b2e:	1d2e      	adds	r6, r5, #4
 8006b30:	4630      	mov	r0, r6
 8006b32:	f7ff f85c 	bl	8005bee <uxListRemove>
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
			}

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
 8006b36:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8006b38:	b11b      	cbz	r3, 8006b42 <vTaskSuspend+0x2e>
			{
				uxListRemove( &( pxTCB->xEventListItem ) );
 8006b3a:	f105 0018 	add.w	r0, r5, #24
 8006b3e:	f7ff f856 	bl	8005bee <uxListRemove>
			}

			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
 8006b42:	4d0e      	ldr	r5, [pc, #56]	; (8006b7c <vTaskSuspend+0x68>)
 8006b44:	4631      	mov	r1, r6
 8006b46:	f105 00c8 	add.w	r0, r5, #200	; 0xc8
 8006b4a:	f7ff f82b 	bl	8005ba4 <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
 8006b4e:	f7fe fea6 	bl	800589e <vPortExitCritical>

		if( ( void * ) xTaskToSuspend == NULL )
 8006b52:	2c00      	cmp	r4, #0
 8006b54:	d111      	bne.n	8006b7a <vTaskSuspend+0x66>
		{
			if( xSchedulerRunning != pdFALSE )
 8006b56:	f8d5 30dc 	ldr.w	r3, [r5, #220]	; 0xdc
 8006b5a:	b11b      	cbz	r3, 8006b64 <vTaskSuspend+0x50>
				{
					vTaskSwitchContext();
				}
			}
		}
	}
 8006b5c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		if( ( void * ) xTaskToSuspend == NULL )
		{
			if( xSchedulerRunning != pdFALSE )
			{
				/* We have just suspended the current task. */
				portYIELD_WITHIN_API();
 8006b60:	f7fe be79 	b.w	8005856 <vPortYield>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
 8006b64:	f8d5 20c8 	ldr.w	r2, [r5, #200]	; 0xc8
 8006b68:	692b      	ldr	r3, [r5, #16]
 8006b6a:	429a      	cmp	r2, r3
 8006b6c:	d101      	bne.n	8006b72 <vTaskSuspend+0x5e>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
 8006b6e:	602c      	str	r4, [r5, #0]
 8006b70:	bd70      	pop	{r4, r5, r6, pc}
				{
					vTaskSwitchContext();
				}
			}
		}
	}
 8006b72:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
					is. */
					pxCurrentTCB = NULL;
				}
				else
				{
					vTaskSwitchContext();
 8006b76:	f7ff bf7b 	b.w	8006a70 <vTaskSwitchContext>
 8006b7a:	bd70      	pop	{r4, r5, r6, pc}
 8006b7c:	20002a78 	.word	0x20002a78

08006b80 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
 8006b80:	b538      	push	{r3, r4, r5, lr}
 8006b82:	460d      	mov	r5, r1
portTickType xTimeToWake;

	configASSERT( pxEventList );
 8006b84:	b910      	cbnz	r0, 8006b8c <vTaskPlaceOnEventList+0xc>
 8006b86:	f7fe fe71 	bl	800586c <ulPortSetInterruptMask>
 8006b8a:	e7fe      	b.n	8006b8a <vTaskPlaceOnEventList+0xa>
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
 8006b8c:	4c0c      	ldr	r4, [pc, #48]	; (8006bc0 <vTaskPlaceOnEventList+0x40>)
 8006b8e:	6821      	ldr	r1, [r4, #0]
 8006b90:	3118      	adds	r1, #24
 8006b92:	f7ff f814 	bl	8005bbe <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
 8006b96:	6820      	ldr	r0, [r4, #0]
 8006b98:	3004      	adds	r0, #4
 8006b9a:	f7ff f828 	bl	8005bee <uxListRemove>
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
 8006b9e:	1c6a      	adds	r2, r5, #1
 8006ba0:	d107      	bne.n	8006bb2 <vTaskPlaceOnEventList+0x32>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 8006ba2:	4620      	mov	r0, r4
 8006ba4:	f850 1bc8 	ldr.w	r1, [r0], #200
 8006ba8:	3104      	adds	r1, #4
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 8006baa:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		if( xTicksToWait == portMAX_DELAY )
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 8006bae:	f7fe bff9 	b.w	8005ba4 <vListInsertEnd>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
 8006bb2:	6860      	ldr	r0, [r4, #4]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
 8006bb4:	1828      	adds	r0, r5, r0
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 8006bb6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
 8006bba:	f7ff bbab 	b.w	8006314 <prvAddCurrentTaskToDelayedList>
 8006bbe:	bf00      	nop
 8006bc0:	20002a78 	.word	0x20002a78

08006bc4 <vTaskPlaceOnEventListRestricted>:
/*-----------------------------------------------------------*/

#if configUSE_TIMERS == 1

	void vTaskPlaceOnEventListRestricted( const xList * const pxEventList, portTickType xTicksToWait )
	{
 8006bc4:	b538      	push	{r3, r4, r5, lr}
 8006bc6:	460d      	mov	r5, r1
	portTickType xTimeToWake;

		configASSERT( pxEventList );
 8006bc8:	b910      	cbnz	r0, 8006bd0 <vTaskPlaceOnEventListRestricted+0xc>
 8006bca:	f7fe fe4f 	bl	800586c <ulPortSetInterruptMask>
 8006bce:	e7fe      	b.n	8006bce <vTaskPlaceOnEventListRestricted+0xa>

		/* Place the event list item of the TCB in the appropriate event list.
		In this case it is assume that this is the only task that is going to
		be waiting on this event list, so the faster vListInsertEnd() function
		can be used in place of vListInsert. */
		vListInsertEnd( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
 8006bd0:	4c07      	ldr	r4, [pc, #28]	; (8006bf0 <vTaskPlaceOnEventListRestricted+0x2c>)
 8006bd2:	6821      	ldr	r1, [r4, #0]
 8006bd4:	3118      	adds	r1, #24
 8006bd6:	f7fe ffe5 	bl	8005ba4 <vListInsertEnd>

		/* We must remove this task from the ready list before adding it to the
		blocked list as the same list item is used for both lists.  This
		function is called form a critical section. */
		if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
 8006bda:	6820      	ldr	r0, [r4, #0]
 8006bdc:	3004      	adds	r0, #4
 8006bde:	f7ff f806 	bl	8005bee <uxListRemove>
			portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
		}

		/* Calculate the time at which the task should be woken if the event does
		not occur.  This may overflow but this doesn't matter. */
		xTimeToWake = xTickCount + xTicksToWait;
 8006be2:	6860      	ldr	r0, [r4, #4]

		traceTASK_DELAY_UNTIL();
		prvAddCurrentTaskToDelayedList( xTimeToWake );
 8006be4:	1828      	adds	r0, r5, r0
	}
 8006be6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		/* Calculate the time at which the task should be woken if the event does
		not occur.  This may overflow but this doesn't matter. */
		xTimeToWake = xTickCount + xTicksToWait;

		traceTASK_DELAY_UNTIL();
		prvAddCurrentTaskToDelayedList( xTimeToWake );
 8006bea:	f7ff bb93 	b.w	8006314 <prvAddCurrentTaskToDelayedList>
 8006bee:	bf00      	nop
 8006bf0:	20002a78 	.word	0x20002a78

08006bf4 <xTaskRemoveFromEventList>:
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 8006bf4:	68c3      	ldr	r3, [r0, #12]

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
 8006bf6:	b570      	push	{r4, r5, r6, lr}
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 8006bf8:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
 8006bfa:	b914      	cbnz	r4, 8006c02 <xTaskRemoveFromEventList+0xe>
 8006bfc:	f7fe fe36 	bl	800586c <ulPortSetInterruptMask>
 8006c00:	e7fe      	b.n	8006c00 <xTaskRemoveFromEventList+0xc>
	uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 8006c02:	f104 0618 	add.w	r6, r4, #24

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 8006c06:	4d12      	ldr	r5, [pc, #72]	; (8006c50 <xTaskRemoveFromEventList+0x5c>)

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
	configASSERT( pxUnblockedTCB );
	uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 8006c08:	4630      	mov	r0, r6
 8006c0a:	f7fe fff0 	bl	8005bee <uxListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 8006c0e:	f8d5 30f0 	ldr.w	r3, [r5, #240]	; 0xf0
 8006c12:	b97b      	cbnz	r3, 8006c34 <xTaskRemoveFromEventList+0x40>
	{
		uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 8006c14:	1d26      	adds	r6, r4, #4
 8006c16:	4630      	mov	r0, r6
 8006c18:	f7fe ffe9 	bl	8005bee <uxListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
 8006c1c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8006c1e:	f8d5 20e8 	ldr.w	r2, [r5, #232]	; 0xe8
 8006c22:	4293      	cmp	r3, r2
 8006c24:	4a0b      	ldr	r2, [pc, #44]	; (8006c54 <xTaskRemoveFromEventList+0x60>)
 8006c26:	bf88      	it	hi
 8006c28:	f8c5 30e8 	strhi.w	r3, [r5, #232]	; 0xe8
 8006c2c:	2014      	movs	r0, #20
 8006c2e:	fb00 2003 	mla	r0, r0, r3, r2
 8006c32:	e001      	b.n	8006c38 <xTaskRemoveFromEventList+0x44>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 8006c34:	f105 00a0 	add.w	r0, r5, #160	; 0xa0
 8006c38:	4631      	mov	r1, r6
 8006c3a:	f7fe ffb3 	bl	8005ba4 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8006c3e:	4b04      	ldr	r3, [pc, #16]	; (8006c50 <xTaskRemoveFromEventList+0x5c>)
 8006c40:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8006c42:	681b      	ldr	r3, [r3, #0]
 8006c44:	6adb      	ldr	r3, [r3, #44]	; 0x2c
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
 8006c46:	4298      	cmp	r0, r3
 8006c48:	bf34      	ite	cc
 8006c4a:	2000      	movcc	r0, #0
 8006c4c:	2001      	movcs	r0, #1
 8006c4e:	bd70      	pop	{r4, r5, r6, pc}
 8006c50:	20002a78 	.word	0x20002a78
 8006c54:	20002a8c 	.word	0x20002a8c

08006c58 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
 8006c58:	b508      	push	{r3, lr}
	configASSERT( pxTimeOut );
 8006c5a:	b910      	cbnz	r0, 8006c62 <vTaskSetTimeOutState+0xa>
 8006c5c:	f7fe fe06 	bl	800586c <ulPortSetInterruptMask>
 8006c60:	e7fe      	b.n	8006c60 <vTaskSetTimeOutState+0x8>
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 8006c62:	4b03      	ldr	r3, [pc, #12]	; (8006c70 <vTaskSetTimeOutState+0x18>)
 8006c64:	f8d3 20f4 	ldr.w	r2, [r3, #244]	; 0xf4
	pxTimeOut->xTimeOnEntering = xTickCount;
 8006c68:	685b      	ldr	r3, [r3, #4]
 8006c6a:	e880 000c 	stmia.w	r0, {r2, r3}
 8006c6e:	bd08      	pop	{r3, pc}
 8006c70:	20002a78 	.word	0x20002a78

08006c74 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
 8006c74:	b538      	push	{r3, r4, r5, lr}
 8006c76:	460d      	mov	r5, r1
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
 8006c78:	4604      	mov	r4, r0
 8006c7a:	b910      	cbnz	r0, 8006c82 <xTaskCheckForTimeOut+0xe>
 8006c7c:	f7fe fdf6 	bl	800586c <ulPortSetInterruptMask>
 8006c80:	e7fe      	b.n	8006c80 <xTaskCheckForTimeOut+0xc>
	configASSERT( pxTicksToWait );
 8006c82:	b911      	cbnz	r1, 8006c8a <xTaskCheckForTimeOut+0x16>
 8006c84:	f7fe fdf2 	bl	800586c <ulPortSetInterruptMask>
 8006c88:	e7fe      	b.n	8006c88 <xTaskCheckForTimeOut+0x14>

	taskENTER_CRITICAL();
 8006c8a:	f7fe fdf7 	bl	800587c <vPortEnterCritical>
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
 8006c8e:	682b      	ldr	r3, [r5, #0]
 8006c90:	1c59      	adds	r1, r3, #1
 8006c92:	d017      	beq.n	8006cc4 <xTaskCheckForTimeOut+0x50>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
 8006c94:	4a0f      	ldr	r2, [pc, #60]	; (8006cd4 <xTaskCheckForTimeOut+0x60>)
 8006c96:	6821      	ldr	r1, [r4, #0]
 8006c98:	f8d2 00f4 	ldr.w	r0, [r2, #244]	; 0xf4
 8006c9c:	4288      	cmp	r0, r1
 8006c9e:	4611      	mov	r1, r2
 8006ca0:	d003      	beq.n	8006caa <xTaskCheckForTimeOut+0x36>
 8006ca2:	6850      	ldr	r0, [r2, #4]
 8006ca4:	6862      	ldr	r2, [r4, #4]
 8006ca6:	4290      	cmp	r0, r2
 8006ca8:	d20e      	bcs.n	8006cc8 <xTaskCheckForTimeOut+0x54>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
 8006caa:	6849      	ldr	r1, [r1, #4]
 8006cac:	6862      	ldr	r2, [r4, #4]
 8006cae:	1a89      	subs	r1, r1, r2
 8006cb0:	4299      	cmp	r1, r3
 8006cb2:	d209      	bcs.n	8006cc8 <xTaskCheckForTimeOut+0x54>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
 8006cb4:	4907      	ldr	r1, [pc, #28]	; (8006cd4 <xTaskCheckForTimeOut+0x60>)
			vTaskSetTimeOutState( pxTimeOut );
 8006cb6:	4620      	mov	r0, r4
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
 8006cb8:	6849      	ldr	r1, [r1, #4]
 8006cba:	1a52      	subs	r2, r2, r1
 8006cbc:	18d3      	adds	r3, r2, r3
 8006cbe:	602b      	str	r3, [r5, #0]
			vTaskSetTimeOutState( pxTimeOut );
 8006cc0:	f7ff ffca 	bl	8006c58 <vTaskSetTimeOutState>
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
			{
				xReturn = pdFALSE;
 8006cc4:	2400      	movs	r4, #0
 8006cc6:	e000      	b.n	8006cca <xTaskCheckForTimeOut+0x56>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
 8006cc8:	2401      	movs	r4, #1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
 8006cca:	f7fe fde8 	bl	800589e <vPortExitCritical>

	return xReturn;
}
 8006cce:	4620      	mov	r0, r4
 8006cd0:	bd38      	pop	{r3, r4, r5, pc}
 8006cd2:	bf00      	nop
 8006cd4:	20002a78 	.word	0x20002a78

08006cd8 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
 8006cd8:	4b02      	ldr	r3, [pc, #8]	; (8006ce4 <vTaskMissedYield+0xc>)
 8006cda:	2201      	movs	r2, #1
 8006cdc:	f8c3 20fc 	str.w	r2, [r3, #252]	; 0xfc
 8006ce0:	4770      	bx	lr
 8006ce2:	bf00      	nop
 8006ce4:	20002a78 	.word	0x20002a78

08006ce8 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
 8006ce8:	4b01      	ldr	r3, [pc, #4]	; (8006cf0 <xTaskGetCurrentTaskHandle+0x8>)
 8006cea:	6818      	ldr	r0, [r3, #0]

		return xReturn;
	}
 8006cec:	4770      	bx	lr
 8006cee:	bf00      	nop
 8006cf0:	20002a78 	.word	0x20002a78

08006cf4 <xTaskGetSchedulerState>:

	portBASE_TYPE xTaskGetSchedulerState( void )
	{
	portBASE_TYPE xReturn;

		if( xSchedulerRunning == pdFALSE )
 8006cf4:	4b05      	ldr	r3, [pc, #20]	; (8006d0c <xTaskGetSchedulerState+0x18>)
 8006cf6:	f8d3 00dc 	ldr.w	r0, [r3, #220]	; 0xdc
 8006cfa:	b128      	cbz	r0, 8006d08 <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
		}
		else
		{
			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 8006cfc:	f8d3 00f0 	ldr.w	r0, [r3, #240]	; 0xf0
			{
				xReturn = taskSCHEDULER_RUNNING;
 8006d00:	2800      	cmp	r0, #0
 8006d02:	bf14      	ite	ne
 8006d04:	2002      	movne	r0, #2
 8006d06:	2001      	moveq	r0, #1
				xReturn = taskSCHEDULER_SUSPENDED;
			}
		}

		return xReturn;
	}
 8006d08:	4770      	bx	lr
 8006d0a:	bf00      	nop
 8006d0c:	20002a78 	.word	0x20002a78

08006d10 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
 8006d10:	b570      	push	{r4, r5, r6, lr}
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
 8006d12:	4604      	mov	r4, r0
 8006d14:	2800      	cmp	r0, #0
 8006d16:	d02b      	beq.n	8006d70 <vTaskPriorityInherit+0x60>
		{
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 8006d18:	4d16      	ldr	r5, [pc, #88]	; (8006d74 <vTaskPriorityInherit+0x64>)
 8006d1a:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 8006d1c:	682b      	ldr	r3, [r5, #0]
 8006d1e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006d20:	429a      	cmp	r2, r3
 8006d22:	d225      	bcs.n	8006d70 <vTaskPriorityInherit+0x60>
			{
				/* Adjust the mutex holder state to account for its new priority. */
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
 8006d24:	462b      	mov	r3, r5
 8006d26:	f853 1b14 	ldr.w	r1, [r3], #20
 8006d2a:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 8006d2c:	f1c1 0105 	rsb	r1, r1, #5
 8006d30:	6181      	str	r1, [r0, #24]

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
 8006d32:	2114      	movs	r1, #20
 8006d34:	fb01 3302 	mla	r3, r1, r2, r3
 8006d38:	6941      	ldr	r1, [r0, #20]
 8006d3a:	4299      	cmp	r1, r3
 8006d3c:	d115      	bne.n	8006d6a <vTaskPriorityInherit+0x5a>
				{
					if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
 8006d3e:	1d06      	adds	r6, r0, #4
 8006d40:	4630      	mov	r0, r6
 8006d42:	f7fe ff54 	bl	8005bee <uxListRemove>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 8006d46:	682b      	ldr	r3, [r5, #0]
					prvAddTaskToReadyQueue( pxTCB );
 8006d48:	f8d5 20e8 	ldr.w	r2, [r5, #232]	; 0xe8
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 8006d4c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
					prvAddTaskToReadyQueue( pxTCB );
 8006d4e:	4631      	mov	r1, r6
 8006d50:	4293      	cmp	r3, r2
 8006d52:	4a09      	ldr	r2, [pc, #36]	; (8006d78 <vTaskPriorityInherit+0x68>)
 8006d54:	bf88      	it	hi
 8006d56:	f8c5 30e8 	strhi.w	r3, [r5, #232]	; 0xe8
 8006d5a:	2014      	movs	r0, #20
 8006d5c:	fb00 2003 	mla	r0, r0, r3, r2
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 8006d60:	62e3      	str	r3, [r4, #44]	; 0x2c
				}

				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
			}
		}
	}
 8006d62:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
					prvAddTaskToReadyQueue( pxTCB );
 8006d66:	f7fe bf1d 	b.w	8005ba4 <vListInsertEnd>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 8006d6a:	682b      	ldr	r3, [r5, #0]
 8006d6c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006d6e:	62c3      	str	r3, [r0, #44]	; 0x2c
 8006d70:	bd70      	pop	{r4, r5, r6, pc}
 8006d72:	bf00      	nop
 8006d74:	20002a78 	.word	0x20002a78
 8006d78:	20002a8c 	.word	0x20002a8c

08006d7c <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
 8006d7c:	b538      	push	{r3, r4, r5, lr}
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
 8006d7e:	4604      	mov	r4, r0
 8006d80:	b1e0      	cbz	r0, 8006dbc <vTaskPriorityDisinherit+0x40>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8006d82:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 8006d84:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8006d86:	429a      	cmp	r2, r3
 8006d88:	d018      	beq.n	8006dbc <vTaskPriorityDisinherit+0x40>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
 8006d8a:	1d05      	adds	r5, r0, #4
 8006d8c:	4628      	mov	r0, r5
 8006d8e:	f7fe ff2e 	bl	8005bee <uxListRemove>
				}

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
 8006d92:	6c23      	ldr	r3, [r4, #64]	; 0x40
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
 8006d94:	f1c3 0205 	rsb	r2, r3, #5
 8006d98:	61a2      	str	r2, [r4, #24]
				prvAddTaskToReadyQueue( pxTCB );
 8006d9a:	4a09      	ldr	r2, [pc, #36]	; (8006dc0 <vTaskPriorityDisinherit+0x44>)
				}

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
 8006d9c:	62e3      	str	r3, [r4, #44]	; 0x2c
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
				prvAddTaskToReadyQueue( pxTCB );
 8006d9e:	f8d2 10e8 	ldr.w	r1, [r2, #232]	; 0xe8
 8006da2:	428b      	cmp	r3, r1
 8006da4:	bf88      	it	hi
 8006da6:	f8c2 30e8 	strhi.w	r3, [r2, #232]	; 0xe8
 8006daa:	4a06      	ldr	r2, [pc, #24]	; (8006dc4 <vTaskPriorityDisinherit+0x48>)
 8006dac:	2014      	movs	r0, #20
 8006dae:	fb00 2003 	mla	r0, r0, r3, r2
 8006db2:	4629      	mov	r1, r5
			}
		}
	}
 8006db4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
				prvAddTaskToReadyQueue( pxTCB );
 8006db8:	f7fe bef4 	b.w	8005ba4 <vListInsertEnd>
 8006dbc:	bd38      	pop	{r3, r4, r5, pc}
 8006dbe:	bf00      	nop
 8006dc0:	20002a78 	.word	0x20002a78
 8006dc4:	20002a8c 	.word	0x20002a8c

08006dc8 <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
 8006dc8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
	{
		if( xTimerQueue == NULL )
 8006dca:	4c0d      	ldr	r4, [pc, #52]	; (8006e00 <prvCheckForValidListAndQueue+0x38>)
static void prvCheckForValidListAndQueue( void )
{
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
 8006dcc:	f7fe fd56 	bl	800587c <vPortEnterCritical>
	{
		if( xTimerQueue == NULL )
 8006dd0:	6825      	ldr	r5, [r4, #0]
 8006dd2:	b985      	cbnz	r5, 8006df6 <prvCheckForValidListAndQueue+0x2e>
		{
			vListInitialise( &xActiveTimerList1 );
 8006dd4:	1d27      	adds	r7, r4, #4
 8006dd6:	4638      	mov	r0, r7
			vListInitialise( &xActiveTimerList2 );
 8006dd8:	f104 0618 	add.w	r6, r4, #24
	initialised. */
	taskENTER_CRITICAL();
	{
		if( xTimerQueue == NULL )
		{
			vListInitialise( &xActiveTimerList1 );
 8006ddc:	f7fe fed4 	bl	8005b88 <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
 8006de0:	4630      	mov	r0, r6
 8006de2:	f7fe fed1 	bl	8005b88 <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
			pxOverflowTimerList = &xActiveTimerList2;
			xTimerQueue = xQueueCreate( ( unsigned portBASE_TYPE ) configTIMER_QUEUE_LENGTH, sizeof( xTIMER_MESSAGE ) );
 8006de6:	2005      	movs	r0, #5
 8006de8:	210c      	movs	r1, #12
 8006dea:	462a      	mov	r2, r5
	{
		if( xTimerQueue == NULL )
		{
			vListInitialise( &xActiveTimerList1 );
			vListInitialise( &xActiveTimerList2 );
			pxCurrentTimerList = &xActiveTimerList1;
 8006dec:	62e7      	str	r7, [r4, #44]	; 0x2c
			pxOverflowTimerList = &xActiveTimerList2;
 8006dee:	6326      	str	r6, [r4, #48]	; 0x30
			xTimerQueue = xQueueCreate( ( unsigned portBASE_TYPE ) configTIMER_QUEUE_LENGTH, sizeof( xTIMER_MESSAGE ) );
 8006df0:	f7fe ffb3 	bl	8005d5a <xQueueGenericCreate>
 8006df4:	6020      	str	r0, [r4, #0]
		}
	}
	taskEXIT_CRITICAL();
}
 8006df6:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			pxCurrentTimerList = &xActiveTimerList1;
			pxOverflowTimerList = &xActiveTimerList2;
			xTimerQueue = xQueueCreate( ( unsigned portBASE_TYPE ) configTIMER_QUEUE_LENGTH, sizeof( xTIMER_MESSAGE ) );
		}
	}
	taskEXIT_CRITICAL();
 8006dfa:	f7fe bd50 	b.w	800589e <vPortExitCritical>
 8006dfe:	bf00      	nop
 8006e00:	20002b78 	.word	0x20002b78

08006e04 <prvInsertTimerInActiveList>:
	return xTimeNow;
}
/*-----------------------------------------------------------*/

static portBASE_TYPE prvInsertTimerInActiveList( xTIMER *pxTimer, portTickType xNextExpiryTime, portTickType xTimeNow, portTickType xCommandTime )
{
 8006e04:	b510      	push	{r4, lr}
portBASE_TYPE xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );

	if( xNextExpiryTime <= xTimeNow )
 8006e06:	4291      	cmp	r1, r2
	return xTimeNow;
}
/*-----------------------------------------------------------*/

static portBASE_TYPE prvInsertTimerInActiveList( xTIMER *pxTimer, portTickType xNextExpiryTime, portTickType xTimeNow, portTickType xCommandTime )
{
 8006e08:	4604      	mov	r4, r0
portBASE_TYPE xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 8006e0a:	6041      	str	r1, [r0, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 8006e0c:	6120      	str	r0, [r4, #16]

	if( xNextExpiryTime <= xTimeNow )
 8006e0e:	d806      	bhi.n	8006e1e <prvInsertTimerInActiveList+0x1a>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( ( portTickType ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks )
 8006e10:	6981      	ldr	r1, [r0, #24]
 8006e12:	1ad2      	subs	r2, r2, r3
 8006e14:	428a      	cmp	r2, r1
 8006e16:	d20d      	bcs.n	8006e34 <prvInsertTimerInActiveList+0x30>
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 8006e18:	4b07      	ldr	r3, [pc, #28]	; (8006e38 <prvInsertTimerInActiveList+0x34>)
 8006e1a:	6b18      	ldr	r0, [r3, #48]	; 0x30
 8006e1c:	e005      	b.n	8006e2a <prvInsertTimerInActiveList+0x26>
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 8006e1e:	429a      	cmp	r2, r3
 8006e20:	d201      	bcs.n	8006e26 <prvInsertTimerInActiveList+0x22>
 8006e22:	4299      	cmp	r1, r3
 8006e24:	d206      	bcs.n	8006e34 <prvInsertTimerInActiveList+0x30>
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 8006e26:	4b04      	ldr	r3, [pc, #16]	; (8006e38 <prvInsertTimerInActiveList+0x34>)
 8006e28:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 8006e2a:	1d21      	adds	r1, r4, #4
 8006e2c:	f7fe fec7 	bl	8005bbe <vListInsert>
}
/*-----------------------------------------------------------*/

static portBASE_TYPE prvInsertTimerInActiveList( xTIMER *pxTimer, portTickType xNextExpiryTime, portTickType xTimeNow, portTickType xCommandTime )
{
portBASE_TYPE xProcessTimerNow = pdFALSE;
 8006e30:	2000      	movs	r0, #0
 8006e32:	bd10      	pop	{r4, pc}
		timer was issued, and the time the command was processed? */
		if( ( ( portTickType ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks )
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
 8006e34:	2001      	movs	r0, #1
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
		}
	}

	return xProcessTimerNow;
}
 8006e36:	bd10      	pop	{r4, pc}
 8006e38:	20002b78 	.word	0x20002b78

08006e3c <xTimerCreateTimerTask>:
static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty ) PRIVILEGED_FUNCTION;

/*-----------------------------------------------------------*/

portBASE_TYPE xTimerCreateTimerTask( void )
{
 8006e3c:	b51f      	push	{r0, r1, r2, r3, r4, lr}

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
 8006e3e:	f7ff ffc3 	bl	8006dc8 <prvCheckForValidListAndQueue>

	if( xTimerQueue != NULL )
 8006e42:	4b0b      	ldr	r3, [pc, #44]	; (8006e70 <xTimerCreateTimerTask+0x34>)
 8006e44:	681b      	ldr	r3, [r3, #0]
 8006e46:	b913      	cbnz	r3, 8006e4e <xTimerCreateTimerTask+0x12>
			xReturn = xTaskCreate( prvTimerTask, ( const signed char * ) "Tmr Svc", ( unsigned short ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( unsigned portBASE_TYPE ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, NULL);
		}
		#endif
	}

	configASSERT( xReturn );
 8006e48:	f7fe fd10 	bl	800586c <ulPortSetInterruptMask>
 8006e4c:	e00d      	b.n	8006e6a <xTimerCreateTimerTask+0x2e>
			xReturn = xTaskCreate( prvTimerTask, ( const signed char * ) "Tmr Svc", ( unsigned short ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( unsigned portBASE_TYPE ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, &xTimerTaskHandle );
		}
		#else
		{
			/* Create the timer task without storing its handle. */
			xReturn = xTaskCreate( prvTimerTask, ( const signed char * ) "Tmr Svc", ( unsigned short ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( unsigned portBASE_TYPE ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, NULL);
 8006e4e:	2303      	movs	r3, #3
 8006e50:	9300      	str	r3, [sp, #0]
 8006e52:	2300      	movs	r3, #0
 8006e54:	9301      	str	r3, [sp, #4]
 8006e56:	9302      	str	r3, [sp, #8]
 8006e58:	9303      	str	r3, [sp, #12]
 8006e5a:	4806      	ldr	r0, [pc, #24]	; (8006e74 <xTimerCreateTimerTask+0x38>)
 8006e5c:	4906      	ldr	r1, [pc, #24]	; (8006e78 <xTimerCreateTimerTask+0x3c>)
 8006e5e:	f44f 72a0 	mov.w	r2, #320	; 0x140
 8006e62:	f7ff fa75 	bl	8006350 <xTaskGenericCreate>
		}
		#endif
	}

	configASSERT( xReturn );
 8006e66:	b908      	cbnz	r0, 8006e6c <xTimerCreateTimerTask+0x30>
 8006e68:	e7ee      	b.n	8006e48 <xTimerCreateTimerTask+0xc>
 8006e6a:	e7fe      	b.n	8006e6a <xTimerCreateTimerTask+0x2e>
	return xReturn;
}
 8006e6c:	b005      	add	sp, #20
 8006e6e:	bd00      	pop	{pc}
 8006e70:	20002b78 	.word	0x20002b78
 8006e74:	08006f6d 	.word	0x08006f6d
 8006e78:	0800aa07 	.word	0x0800aa07

08006e7c <xTimerCreate>:
/*-----------------------------------------------------------*/

xTimerHandle xTimerCreate( const signed char * const pcTimerName, portTickType xTimerPeriodInTicks, unsigned portBASE_TYPE uxAutoReload, void *pvTimerID, tmrTIMER_CALLBACK pxCallbackFunction )
{
 8006e7c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8006e80:	4680      	mov	r8, r0
 8006e82:	4617      	mov	r7, r2
 8006e84:	461e      	mov	r6, r3
xTIMER *pxNewTimer;

	/* Allocate the timer structure. */
	if( xTimerPeriodInTicks == ( portTickType ) 0U )
 8006e86:	460d      	mov	r5, r1
 8006e88:	b911      	cbnz	r1, 8006e90 <xTimerCreate+0x14>
	{
		pxNewTimer = NULL;
		configASSERT( ( xTimerPeriodInTicks > 0 ) );
 8006e8a:	f7fe fcef 	bl	800586c <ulPortSetInterruptMask>
 8006e8e:	e7fe      	b.n	8006e8e <xTimerCreate+0x12>
	}
	else
	{
		pxNewTimer = ( xTIMER * ) pvPortMalloc( sizeof( xTIMER ) );
 8006e90:	2028      	movs	r0, #40	; 0x28
 8006e92:	f7fe fc75 	bl	8005780 <pvPortMalloc>
		if( pxNewTimer != NULL )
 8006e96:	4604      	mov	r4, r0
 8006e98:	b158      	cbz	r0, 8006eb2 <xTimerCreate+0x36>
		{
			/* Ensure the infrastructure used by the timer service task has been
			created/initialised. */
			prvCheckForValidListAndQueue();
 8006e9a:	f7ff ff95 	bl	8006dc8 <prvCheckForValidListAndQueue>
			/* Initialise the timer structure members using the function parameters. */
			pxNewTimer->pcTimerName = pcTimerName;
			pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
			pxNewTimer->uxAutoReload = uxAutoReload;
			pxNewTimer->pvTimerID = pvTimerID;
			pxNewTimer->pxCallbackFunction = pxCallbackFunction;
 8006e9e:	9b06      	ldr	r3, [sp, #24]
			/* Ensure the infrastructure used by the timer service task has been
			created/initialised. */
			prvCheckForValidListAndQueue();

			/* Initialise the timer structure members using the function parameters. */
			pxNewTimer->pcTimerName = pcTimerName;
 8006ea0:	f8c4 8000 	str.w	r8, [r4]
			pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
 8006ea4:	61a5      	str	r5, [r4, #24]
			pxNewTimer->uxAutoReload = uxAutoReload;
 8006ea6:	61e7      	str	r7, [r4, #28]
			pxNewTimer->pvTimerID = pvTimerID;
 8006ea8:	6226      	str	r6, [r4, #32]
			pxNewTimer->pxCallbackFunction = pxCallbackFunction;
 8006eaa:	6263      	str	r3, [r4, #36]	; 0x24
			vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
 8006eac:	1d20      	adds	r0, r4, #4
 8006eae:	f7fe fe76 	bl	8005b9e <vListInitialiseItem>
			traceTIMER_CREATE_FAILED();
		}
	}

	return ( xTimerHandle ) pxNewTimer;
}
 8006eb2:	4620      	mov	r0, r4
 8006eb4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08006eb8 <xTimerGenericCommand>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTimerGenericCommand( xTimerHandle xTimer, portBASE_TYPE xCommandID, portTickType xOptionalValue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portTickType xBlockTime )
{
 8006eb8:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
portBASE_TYPE xReturn = pdFAIL;
xTIMER_MESSAGE xMessage;

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
 8006eba:	4d0f      	ldr	r5, [pc, #60]	; (8006ef8 <xTimerGenericCommand+0x40>)
	return ( xTimerHandle ) pxNewTimer;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTimerGenericCommand( xTimerHandle xTimer, portBASE_TYPE xCommandID, portTickType xOptionalValue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portTickType xBlockTime )
{
 8006ebc:	4606      	mov	r6, r0
portBASE_TYPE xReturn = pdFAIL;
xTIMER_MESSAGE xMessage;

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
 8006ebe:	6828      	ldr	r0, [r5, #0]
	return ( xTimerHandle ) pxNewTimer;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTimerGenericCommand( xTimerHandle xTimer, portBASE_TYPE xCommandID, portTickType xOptionalValue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portTickType xBlockTime )
{
 8006ec0:	461c      	mov	r4, r3
portBASE_TYPE xReturn = pdFAIL;
xTIMER_MESSAGE xMessage;

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
 8006ec2:	b1b0      	cbz	r0, 8006ef2 <xTimerGenericCommand+0x3a>
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
 8006ec4:	9101      	str	r1, [sp, #4]
		xMessage.xMessageValue = xOptionalValue;
 8006ec6:	9202      	str	r2, [sp, #8]
		xMessage.pxTimer = ( xTIMER * ) xTimer;
 8006ec8:	9603      	str	r6, [sp, #12]

		if( pxHigherPriorityTaskWoken == NULL )
 8006eca:	b96b      	cbnz	r3, 8006ee8 <xTimerGenericCommand+0x30>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 8006ecc:	f7ff ff12 	bl	8006cf4 <xTaskGetSchedulerState>
 8006ed0:	2801      	cmp	r0, #1
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xBlockTime );
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
 8006ed2:	bf18      	it	ne
 8006ed4:	4622      	movne	r2, r4

		if( pxHigherPriorityTaskWoken == NULL )
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xBlockTime );
 8006ed6:	6828      	ldr	r0, [r5, #0]
 8006ed8:	a901      	add	r1, sp, #4
 8006eda:	bf06      	itte	eq
 8006edc:	9a08      	ldreq	r2, [sp, #32]
 8006ede:	4623      	moveq	r3, r4
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
 8006ee0:	4613      	movne	r3, r2
 8006ee2:	f7fe ff5a 	bl	8005d9a <xQueueGenericSend>
 8006ee6:	e004      	b.n	8006ef2 <xTimerGenericCommand+0x3a>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
 8006ee8:	461a      	mov	r2, r3
 8006eea:	a901      	add	r1, sp, #4
 8006eec:	2300      	movs	r3, #0
 8006eee:	f7fe fff6 	bl	8005ede <xQueueGenericSendFromISR>

		traceTIMER_COMMAND_SEND( xTimer, xCommandID, xOptionalValue, xReturn );
	}

	return xReturn;
}
 8006ef2:	b004      	add	sp, #16
 8006ef4:	bd70      	pop	{r4, r5, r6, pc}
 8006ef6:	bf00      	nop
 8006ef8:	20002b78 	.word	0x20002b78

08006efc <prvSwitchTimerLists.isra.1>:
		}
	}
}
/*-----------------------------------------------------------*/

static void prvSwitchTimerLists( portTickType xLastTime )
 8006efc:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 8006f00:	4e19      	ldr	r6, [pc, #100]	; (8006f68 <prvSwitchTimerLists.isra.1+0x6c>)
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
 8006f02:	f04f 0800 	mov.w	r8, #0
 8006f06:	e024      	b.n	8006f52 <prvSwitchTimerLists.isra.1+0x56>
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 8006f08:	68da      	ldr	r2, [r3, #12]
 8006f0a:	6815      	ldr	r5, [r2, #0]

		/* Remove the timer from the list. */
		pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
 8006f0c:	68db      	ldr	r3, [r3, #12]
 8006f0e:	68dc      	ldr	r4, [r3, #12]
		uxListRemove( &( pxTimer->xTimerListItem ) );
 8006f10:	1d27      	adds	r7, r4, #4
 8006f12:	4638      	mov	r0, r7
 8006f14:	f7fe fe6b 	bl	8005bee <uxListRemove>

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
 8006f18:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8006f1a:	4620      	mov	r0, r4
 8006f1c:	4798      	blx	r3

		if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
 8006f1e:	69e3      	ldr	r3, [r4, #28]
 8006f20:	2b01      	cmp	r3, #1
 8006f22:	d116      	bne.n	8006f52 <prvSwitchTimerLists.isra.1+0x56>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
 8006f24:	69a3      	ldr	r3, [r4, #24]
 8006f26:	18eb      	adds	r3, r5, r3
			if( xReloadTime > xNextExpireTime )
 8006f28:	42ab      	cmp	r3, r5
 8006f2a:	d906      	bls.n	8006f3a <prvSwitchTimerLists.isra.1+0x3e>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
 8006f2c:	6063      	str	r3, [r4, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 8006f2e:	6124      	str	r4, [r4, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 8006f30:	6af0      	ldr	r0, [r6, #44]	; 0x2c
 8006f32:	4639      	mov	r1, r7
 8006f34:	f7fe fe43 	bl	8005bbe <vListInsert>
 8006f38:	e00b      	b.n	8006f52 <prvSwitchTimerLists.isra.1+0x56>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
 8006f3a:	2100      	movs	r1, #0
 8006f3c:	f8cd 8000 	str.w	r8, [sp]
 8006f40:	4620      	mov	r0, r4
 8006f42:	462a      	mov	r2, r5
 8006f44:	460b      	mov	r3, r1
 8006f46:	f7ff ffb7 	bl	8006eb8 <xTimerGenericCommand>
				configASSERT( xResult );
 8006f4a:	b910      	cbnz	r0, 8006f52 <prvSwitchTimerLists.isra.1+0x56>
 8006f4c:	f7fe fc8e 	bl	800586c <ulPortSetInterruptMask>
 8006f50:	e7fe      	b.n	8006f50 <prvSwitchTimerLists.isra.1+0x54>

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 8006f52:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 8006f54:	4a04      	ldr	r2, [pc, #16]	; (8006f68 <prvSwitchTimerLists.isra.1+0x6c>)
 8006f56:	6819      	ldr	r1, [r3, #0]
 8006f58:	2900      	cmp	r1, #0
 8006f5a:	d1d5      	bne.n	8006f08 <prvSwitchTimerLists.isra.1+0xc>
			}
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
 8006f5c:	6b11      	ldr	r1, [r2, #48]	; 0x30
	pxOverflowTimerList = pxTemp;
 8006f5e:	6313      	str	r3, [r2, #48]	; 0x30
			}
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
 8006f60:	62d1      	str	r1, [r2, #44]	; 0x2c
	pxOverflowTimerList = pxTemp;
}
 8006f62:	e8bd 81fc 	ldmia.w	sp!, {r2, r3, r4, r5, r6, r7, r8, pc}
 8006f66:	bf00      	nop
 8006f68:	20002b78 	.word	0x20002b78

08006f6c <prvTimerTask>:
	pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
 8006f6c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 8006f70:	4d52      	ldr	r5, [pc, #328]	; (80070bc <prvTimerTask+0x150>)
	pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
 8006f72:	b087      	sub	sp, #28
 8006f74:	46a8      	mov	r8, r5
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 8006f76:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8006f78:	681a      	ldr	r2, [r3, #0]
 8006f7a:	f1d2 0901 	rsbs	r9, r2, #1
 8006f7e:	bf38      	it	cc
 8006f80:	f04f 0900 	movcc.w	r9, #0
	if( *pxListWasEmpty == pdFALSE )
 8006f84:	f1b9 0f00 	cmp.w	r9, #0
 8006f88:	d102      	bne.n	8006f90 <prvTimerTask+0x24>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 8006f8a:	68db      	ldr	r3, [r3, #12]
 8006f8c:	681e      	ldr	r6, [r3, #0]
 8006f8e:	e000      	b.n	8006f92 <prvTimerTask+0x26>
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( portTickType ) 0U;
 8006f90:	2600      	movs	r6, #0
static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty )
{
portTickType xTimeNow;
portBASE_TYPE xTimerListsWereSwitched;

	vTaskSuspendAll();
 8006f92:	f7ff fbf7 	bl	8006784 <vTaskSuspendAll>
static portTickType prvSampleTimeNow( portBASE_TYPE *pxTimerListsWereSwitched )
{
portTickType xTimeNow;
PRIVILEGED_DATA static portTickType xLastTime = ( portTickType ) 0U;

	xTimeNow = xTaskGetTickCount();
 8006f96:	f7ff fbff 	bl	8006798 <xTaskGetTickCount>

	if( xTimeNow < xLastTime )
 8006f9a:	f8d8 3034 	ldr.w	r3, [r8, #52]	; 0x34
static portTickType prvSampleTimeNow( portBASE_TYPE *pxTimerListsWereSwitched )
{
portTickType xTimeNow;
PRIVILEGED_DATA static portTickType xLastTime = ( portTickType ) 0U;

	xTimeNow = xTaskGetTickCount();
 8006f9e:	4607      	mov	r7, r0

	if( xTimeNow < xLastTime )
 8006fa0:	4298      	cmp	r0, r3
 8006fa2:	d203      	bcs.n	8006fac <prvTimerTask+0x40>
	{
		prvSwitchTimerLists( xLastTime );
 8006fa4:	f7ff ffaa 	bl	8006efc <prvSwitchTimerLists.isra.1>
		*pxTimerListsWereSwitched = pdTRUE;
 8006fa8:	2301      	movs	r3, #1
 8006faa:	e000      	b.n	8006fae <prvTimerTask+0x42>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
 8006fac:	2300      	movs	r3, #0
	}

	xLastTime = xTimeNow;
 8006fae:	636f      	str	r7, [r5, #52]	; 0x34
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampelTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
		if( xTimerListsWereSwitched == pdFALSE )
 8006fb0:	2b00      	cmp	r3, #0
 8006fb2:	d134      	bne.n	800701e <prvTimerTask+0xb2>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 8006fb4:	f1b9 0f00 	cmp.w	r9, #0
 8006fb8:	d125      	bne.n	8007006 <prvTimerTask+0x9a>
 8006fba:	42be      	cmp	r6, r7
 8006fbc:	d823      	bhi.n	8007006 <prvTimerTask+0x9a>
			{
				xTaskResumeAll();
 8006fbe:	f7ff fc71 	bl	80068a4 <xTaskResumeAll>
xTIMER *pxTimer;
portBASE_TYPE xResult;

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
 8006fc2:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8006fc4:	68db      	ldr	r3, [r3, #12]
 8006fc6:	68dc      	ldr	r4, [r3, #12]
	uxListRemove( &( pxTimer->xTimerListItem ) );
 8006fc8:	1d20      	adds	r0, r4, #4
 8006fca:	f7fe fe10 	bl	8005bee <uxListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
 8006fce:	69e3      	ldr	r3, [r4, #28]
 8006fd0:	2b01      	cmp	r3, #1
 8006fd2:	d114      	bne.n	8006ffe <prvTimerTask+0x92>
		a time relative to anything other than the current time.  It
		will therefore be inserted into the correct list relative to
		the time this task thinks it is now, even if a command to
		switch lists due to a tick count overflow is already waiting in
		the timer queue. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
 8006fd4:	69a1      	ldr	r1, [r4, #24]
 8006fd6:	4620      	mov	r0, r4
 8006fd8:	1871      	adds	r1, r6, r1
 8006fda:	463a      	mov	r2, r7
 8006fdc:	4633      	mov	r3, r6
 8006fde:	f7ff ff11 	bl	8006e04 <prvInsertTimerInActiveList>
 8006fe2:	2801      	cmp	r0, #1
 8006fe4:	d10b      	bne.n	8006ffe <prvTimerTask+0x92>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
 8006fe6:	f8cd 9000 	str.w	r9, [sp]
 8006fea:	4620      	mov	r0, r4
 8006fec:	4649      	mov	r1, r9
 8006fee:	4632      	mov	r2, r6
 8006ff0:	464b      	mov	r3, r9
 8006ff2:	f7ff ff61 	bl	8006eb8 <xTimerGenericCommand>
			configASSERT( xResult );
 8006ff6:	b910      	cbnz	r0, 8006ffe <prvTimerTask+0x92>
 8006ff8:	f7fe fc38 	bl	800586c <ulPortSetInterruptMask>
 8006ffc:	e7fe      	b.n	8006ffc <prvTimerTask+0x90>
			( void ) xResult;
		}
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
 8006ffe:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8007000:	4620      	mov	r0, r4
 8007002:	4798      	blx	r3
 8007004:	e050      	b.n	80070a8 <prvTimerTask+0x13c>
				time has not been reached yet.  This task should therefore
				block to wait for the next expire time or a command to be
				received - whichever comes first.  The following line cannot
				be reached unless xNextExpireTime > xTimeNow, except in the
				case when the current timer list is empty. */
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ) );
 8007006:	f8d8 0000 	ldr.w	r0, [r8]
 800700a:	1bf1      	subs	r1, r6, r7
 800700c:	f7ff f965 	bl	80062da <vQueueWaitForMessageRestricted>

				if( xTaskResumeAll() == pdFALSE )
 8007010:	f7ff fc48 	bl	80068a4 <xTaskResumeAll>
 8007014:	2800      	cmp	r0, #0
 8007016:	d147      	bne.n	80070a8 <prvTimerTask+0x13c>
				{
					/* Yield to wait for either a command to arrive, or the block time
					to expire.  If a command arrived between the critical section being
					exited and this yield then the yield will not cause the task
					to block. */
					portYIELD_WITHIN_API();
 8007018:	f7fe fc1d 	bl	8005856 <vPortYield>
 800701c:	e044      	b.n	80070a8 <prvTimerTask+0x13c>
				}
			}
		}
		else
		{
			xTaskResumeAll();
 800701e:	f7ff fc41 	bl	80068a4 <xTaskResumeAll>
 8007022:	e041      	b.n	80070a8 <prvTimerTask+0x13c>
portBASE_TYPE xTimerListsWereSwitched, xResult;
portTickType xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL )
	{
		pxTimer = xMessage.pxTimer;
 8007024:	9c05      	ldr	r4, [sp, #20]

		if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
 8007026:	6963      	ldr	r3, [r4, #20]
 8007028:	b113      	cbz	r3, 8007030 <prvTimerTask+0xc4>
		{
			/* The timer is in a list, remove it. */
			uxListRemove( &( pxTimer->xTimerListItem ) );
 800702a:	1d20      	adds	r0, r4, #4
 800702c:	f7fe fddf 	bl	8005bee <uxListRemove>
static portTickType prvSampleTimeNow( portBASE_TYPE *pxTimerListsWereSwitched )
{
portTickType xTimeNow;
PRIVILEGED_DATA static portTickType xLastTime = ( portTickType ) 0U;

	xTimeNow = xTaskGetTickCount();
 8007030:	f7ff fbb2 	bl	8006798 <xTaskGetTickCount>

	if( xTimeNow < xLastTime )
 8007034:	6b6b      	ldr	r3, [r5, #52]	; 0x34
static portTickType prvSampleTimeNow( portBASE_TYPE *pxTimerListsWereSwitched )
{
portTickType xTimeNow;
PRIVILEGED_DATA static portTickType xLastTime = ( portTickType ) 0U;

	xTimeNow = xTaskGetTickCount();
 8007036:	4607      	mov	r7, r0

	if( xTimeNow < xLastTime )
 8007038:	4298      	cmp	r0, r3
 800703a:	d201      	bcs.n	8007040 <prvTimerTask+0xd4>
	{
		prvSwitchTimerLists( xLastTime );
 800703c:	f7ff ff5e 	bl	8006efc <prvSwitchTimerLists.isra.1>
		possibility of a higher priority task adding a message to the message
		queue with a time that is ahead of the timer daemon task (because it
		pre-empted the timer daemon task after the xTimeNow value was set). */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );

		switch( xMessage.xMessageID )
 8007040:	9e03      	ldr	r6, [sp, #12]
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
	}

	xLastTime = xTimeNow;
 8007042:	f8c8 7034 	str.w	r7, [r8, #52]	; 0x34
		possibility of a higher priority task adding a message to the message
		queue with a time that is ahead of the timer daemon task (because it
		pre-empted the timer daemon task after the xTimeNow value was set). */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );

		switch( xMessage.xMessageID )
 8007046:	2e02      	cmp	r6, #2
 8007048:	d01e      	beq.n	8007088 <prvTimerTask+0x11c>
 800704a:	2e03      	cmp	r6, #3
 800704c:	d029      	beq.n	80070a2 <prvTimerTask+0x136>
 800704e:	bb5e      	cbnz	r6, 80070a8 <prvTimerTask+0x13c>
		{
			case tmrCOMMAND_START :
				/* Start or restart a timer. */
				if( prvInsertTimerInActiveList( pxTimer,  xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.xMessageValue ) == pdTRUE )
 8007050:	9b04      	ldr	r3, [sp, #16]
 8007052:	69a1      	ldr	r1, [r4, #24]
 8007054:	4620      	mov	r0, r4
 8007056:	1859      	adds	r1, r3, r1
 8007058:	463a      	mov	r2, r7
 800705a:	f7ff fed3 	bl	8006e04 <prvInsertTimerInActiveList>
 800705e:	2801      	cmp	r0, #1
 8007060:	d122      	bne.n	80070a8 <prvTimerTask+0x13c>
				{
					/* The timer expired before it was added to the active timer
					list.  Process it now. */
					pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
 8007062:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8007064:	4620      	mov	r0, r4
 8007066:	4798      	blx	r3

					if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
 8007068:	69e3      	ldr	r3, [r4, #28]
 800706a:	2b01      	cmp	r3, #1
 800706c:	d11c      	bne.n	80070a8 <prvTimerTask+0x13c>
					{
						xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
 800706e:	69a2      	ldr	r2, [r4, #24]
 8007070:	9b04      	ldr	r3, [sp, #16]
 8007072:	9600      	str	r6, [sp, #0]
 8007074:	18d2      	adds	r2, r2, r3
 8007076:	4620      	mov	r0, r4
 8007078:	4631      	mov	r1, r6
 800707a:	4633      	mov	r3, r6
 800707c:	f7ff ff1c 	bl	8006eb8 <xTimerGenericCommand>
						configASSERT( xResult );
 8007080:	b990      	cbnz	r0, 80070a8 <prvTimerTask+0x13c>
 8007082:	f7fe fbf3 	bl	800586c <ulPortSetInterruptMask>
 8007086:	e7fe      	b.n	8007086 <prvTimerTask+0x11a>
				/* The timer has already been removed from the active list.
				There is nothing to do here. */
				break;

			case tmrCOMMAND_CHANGE_PERIOD :
				pxTimer->xTimerPeriodInTicks = xMessage.xMessageValue;
 8007088:	9904      	ldr	r1, [sp, #16]
 800708a:	61a1      	str	r1, [r4, #24]
				configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 800708c:	b911      	cbnz	r1, 8007094 <prvTimerTask+0x128>
 800708e:	f7fe fbed 	bl	800586c <ulPortSetInterruptMask>
 8007092:	e7fe      	b.n	8007092 <prvTimerTask+0x126>
				prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
 8007094:	4620      	mov	r0, r4
 8007096:	1879      	adds	r1, r7, r1
 8007098:	463a      	mov	r2, r7
 800709a:	463b      	mov	r3, r7
 800709c:	f7ff feb2 	bl	8006e04 <prvInsertTimerInActiveList>
 80070a0:	e002      	b.n	80070a8 <prvTimerTask+0x13c>
				break;

			case tmrCOMMAND_DELETE :
				/* The timer has already been removed from the active list,
				just free up the memory. */
				vPortFree( pxTimer );
 80070a2:	4620      	mov	r0, r4
 80070a4:	f7fe fb9a 	bl	80057dc <vPortFree>
xTIMER_MESSAGE xMessage;
xTIMER *pxTimer;
portBASE_TYPE xTimerListsWereSwitched, xResult;
portTickType xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL )
 80070a8:	2200      	movs	r2, #0
 80070aa:	6828      	ldr	r0, [r5, #0]
 80070ac:	a903      	add	r1, sp, #12
 80070ae:	4613      	mov	r3, r2
 80070b0:	f7fe ff4e 	bl	8005f50 <xQueueGenericReceive>
 80070b4:	2800      	cmp	r0, #0
 80070b6:	d1b5      	bne.n	8007024 <prvTimerTask+0xb8>
 80070b8:	e75d      	b.n	8006f76 <prvTimerTask+0xa>
 80070ba:	bf00      	nop
 80070bc:	20002b78 	.word	0x20002b78

080070c0 <xTimerIsTimerActive>:
	taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTimerIsTimerActive( xTimerHandle xTimer )
{
 80070c0:	b510      	push	{r4, lr}
 80070c2:	4604      	mov	r4, r0
portBASE_TYPE xTimerIsInActiveList;
xTIMER *pxTimer = ( xTIMER * ) xTimer;

	/* Is the timer in the list of active timers? */
	taskENTER_CRITICAL();
 80070c4:	f7fe fbda 	bl	800587c <vPortEnterCritical>
	{
		/* Checking to see if it is in the NULL list in effect checks to see if
		it is referenced from either the current or the overflow timer lists in
		one go, but the logic has to be reversed, hence the '!'. */
		xTimerIsInActiveList = !( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) );
 80070c8:	6964      	ldr	r4, [r4, #20]
 80070ca:	3400      	adds	r4, #0
 80070cc:	bf18      	it	ne
 80070ce:	2401      	movne	r4, #1
	}
	taskEXIT_CRITICAL();
 80070d0:	f7fe fbe5 	bl	800589e <vPortExitCritical>

	return xTimerIsInActiveList;
}
 80070d4:	4620      	mov	r0, r4
 80070d6:	bd10      	pop	{r4, pc}

080070d8 <pvTimerGetTimerID>:
void *pvTimerGetTimerID( xTimerHandle xTimer )
{
xTIMER *pxTimer = ( xTIMER * ) xTimer;

	return pxTimer->pvTimerID;
}
 80070d8:	6a00      	ldr	r0, [r0, #32]
 80070da:	4770      	bx	lr

080070dc <SystemInit>:
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
  #endif

  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 80070dc:	4b38      	ldr	r3, [pc, #224]	; (80071c0 <SystemInit+0xe4>)
  *         SystemFrequency variable.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 80070de:	b082      	sub	sp, #8
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
  #endif

  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 80070e0:	681a      	ldr	r2, [r3, #0]
 80070e2:	f042 0201 	orr.w	r2, r2, #1
 80070e6:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR &= 0xF87FC00C;
 80070e8:	6859      	ldr	r1, [r3, #4]
 80070ea:	4a36      	ldr	r2, [pc, #216]	; (80071c4 <SystemInit+0xe8>)
 80070ec:	400a      	ands	r2, r1
 80070ee:	605a      	str	r2, [r3, #4]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 80070f0:	681a      	ldr	r2, [r3, #0]
 80070f2:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 80070f6:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80070fa:	601a      	str	r2, [r3, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 80070fc:	681a      	ldr	r2, [r3, #0]
 80070fe:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8007102:	601a      	str	r2, [r3, #0]

  /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE bits */
  RCC->CFGR &= (uint32_t)0xFF80FFFF;
 8007104:	685a      	ldr	r2, [r3, #4]
 8007106:	f422 02fe 	bic.w	r2, r2, #8323072	; 0x7f0000
 800710a:	605a      	str	r2, [r3, #4]

  /* Reset PREDIV1[3:0] bits */
  RCC->CFGR2 &= (uint32_t)0xFFFFFFF0;
 800710c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800710e:	f022 020f 	bic.w	r2, r2, #15
 8007112:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Reset USARTSW[1:0], I2CSW and TIMs bits */
  RCC->CFGR3 &= (uint32_t)0xFF00FCCC;
 8007114:	6b19      	ldr	r1, [r3, #48]	; 0x30
 8007116:	4a2c      	ldr	r2, [pc, #176]	; (80071c8 <SystemInit+0xec>)
 8007118:	400a      	ands	r2, r1
 800711a:	631a      	str	r2, [r3, #48]	; 0x30
  
  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 800711c:	2200      	movs	r2, #0
 800711e:	609a      	str	r2, [r3, #8]
  * @param  None
  * @retval None
  */
static void SetSysClock(void)
{
  __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
 8007120:	9200      	str	r2, [sp, #0]
 8007122:	9201      	str	r2, [sp, #4]
/*            PLL (clocked by HSE) used as System clock source                */
/******************************************************************************/

  /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration -----------*/
  /* Enable HSE */
  RCC->CR |= ((uint32_t)RCC_CR_HSEON);
 8007124:	681a      	ldr	r2, [r3, #0]
 8007126:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 800712a:	601a      	str	r2, [r3, #0]
 
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC->CR & RCC_CR_HSERDY;
 800712c:	681a      	ldr	r2, [r3, #0]
 800712e:	f402 3200 	and.w	r2, r2, #131072	; 0x20000
 8007132:	9201      	str	r2, [sp, #4]
    StartUpCounter++;
 8007134:	9a00      	ldr	r2, [sp, #0]
 8007136:	3201      	adds	r2, #1
 8007138:	9200      	str	r2, [sp, #0]
  } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
 800713a:	9a01      	ldr	r2, [sp, #4]
 800713c:	b91a      	cbnz	r2, 8007146 <SystemInit+0x6a>
 800713e:	9a00      	ldr	r2, [sp, #0]
 8007140:	f5b2 6fa0 	cmp.w	r2, #1280	; 0x500
 8007144:	d1f2      	bne.n	800712c <SystemInit+0x50>

  if ((RCC->CR & RCC_CR_HSERDY) != RESET)
 8007146:	4b1e      	ldr	r3, [pc, #120]	; (80071c0 <SystemInit+0xe4>)
 8007148:	681b      	ldr	r3, [r3, #0]
 800714a:	f413 3300 	ands.w	r3, r3, #131072	; 0x20000
  {
    HSEStatus = (uint32_t)0x01;
 800714e:	bf18      	it	ne
 8007150:	2301      	movne	r3, #1
  }
  else
  {
    HSEStatus = (uint32_t)0x00;
 8007152:	9301      	str	r3, [sp, #4]
  }

  if (HSEStatus == (uint32_t)0x01)
 8007154:	9b01      	ldr	r3, [sp, #4]
 8007156:	2b01      	cmp	r3, #1
 8007158:	d004      	beq.n	8007164 <SystemInit+0x88>
  SetSysClock();
  
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */
 800715a:	4b1c      	ldr	r3, [pc, #112]	; (80071cc <SystemInit+0xf0>)
 800715c:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8007160:	609a      	str	r2, [r3, #8]
 8007162:	e02a      	b.n	80071ba <SystemInit+0xde>
  }

  if (HSEStatus == (uint32_t)0x01)
  {
    /* Enable Prefetch Buffer and set Flash Latency */
    FLASH->ACR = FLASH_ACR_PRFTBE | (uint32_t)FLASH_ACR_LATENCY_1;
 8007164:	4b1a      	ldr	r3, [pc, #104]	; (80071d0 <SystemInit+0xf4>)
 8007166:	2212      	movs	r2, #18
 8007168:	601a      	str	r2, [r3, #0]
 
     /* HCLK = SYSCLK / 1 */
     RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
 800716a:	f5a3 5380 	sub.w	r3, r3, #4096	; 0x1000
 800716e:	685a      	ldr	r2, [r3, #4]
 8007170:	605a      	str	r2, [r3, #4]
       
     /* PCLK2 = HCLK / 1 */
     RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
 8007172:	685a      	ldr	r2, [r3, #4]
 8007174:	605a      	str	r2, [r3, #4]
     
     /* PCLK1 = HCLK / 2 */
     RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;
 8007176:	685a      	ldr	r2, [r3, #4]
 8007178:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 800717c:	605a      	str	r2, [r3, #4]

    /* PLL configuration */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL));
 800717e:	685a      	ldr	r2, [r3, #4]
 8007180:	f422 127c 	bic.w	r2, r2, #4128768	; 0x3f0000
 8007184:	605a      	str	r2, [r3, #4]
    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_PREDIV1 | RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLMULL9);
 8007186:	685a      	ldr	r2, [r3, #4]
 8007188:	f442 12e8 	orr.w	r2, r2, #1900544	; 0x1d0000
 800718c:	605a      	str	r2, [r3, #4]

    /* Enable PLL */
    RCC->CR |= RCC_CR_PLLON;
 800718e:	681a      	ldr	r2, [r3, #0]
 8007190:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8007194:	601a      	str	r2, [r3, #0]

    /* Wait till PLL is ready */
    while((RCC->CR & RCC_CR_PLLRDY) == 0)
 8007196:	6819      	ldr	r1, [r3, #0]
 8007198:	4a09      	ldr	r2, [pc, #36]	; (80071c0 <SystemInit+0xe4>)
 800719a:	0189      	lsls	r1, r1, #6
 800719c:	d5fb      	bpl.n	8007196 <SystemInit+0xba>
    {
    }
    
    /* Select PLL as system clock source */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
 800719e:	6853      	ldr	r3, [r2, #4]
 80071a0:	f023 0303 	bic.w	r3, r3, #3
 80071a4:	6053      	str	r3, [r2, #4]
    RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;
 80071a6:	6853      	ldr	r3, [r2, #4]
 80071a8:	f043 0302 	orr.w	r3, r3, #2
 80071ac:	6053      	str	r3, [r2, #4]

    /* Wait till PLL is used as system clock source */
    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)RCC_CFGR_SWS_PLL)
 80071ae:	6853      	ldr	r3, [r2, #4]
 80071b0:	f003 030c 	and.w	r3, r3, #12
 80071b4:	2b08      	cmp	r3, #8
 80071b6:	d1fa      	bne.n	80071ae <SystemInit+0xd2>
 80071b8:	e7cf      	b.n	800715a <SystemInit+0x7e>
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */
#endif  
}
 80071ba:	b002      	add	sp, #8
 80071bc:	4770      	bx	lr
 80071be:	bf00      	nop
 80071c0:	40021000 	.word	0x40021000
 80071c4:	f87fc00c 	.word	0xf87fc00c
 80071c8:	ff00fccc 	.word	0xff00fccc
 80071cc:	e000ed00 	.word	0xe000ed00
 80071d0:	40022000 	.word	0x40022000

080071d4 <SystemCoreClockUpdate>:
void SystemCoreClockUpdate (void)
{
  uint32_t tmp = 0, pllmull = 0, pllsource = 0, prediv1factor = 0;

  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & RCC_CFGR_SWS;
 80071d4:	4a14      	ldr	r2, [pc, #80]	; (8007228 <SystemCoreClockUpdate+0x54>)
 80071d6:	4b15      	ldr	r3, [pc, #84]	; (800722c <SystemCoreClockUpdate+0x58>)
 80071d8:	6851      	ldr	r1, [r2, #4]
 80071da:	f001 010c 	and.w	r1, r1, #12
  
  switch (tmp)
 80071de:	2904      	cmp	r1, #4
 80071e0:	d001      	beq.n	80071e6 <SystemCoreClockUpdate+0x12>
 80071e2:	2908      	cmp	r1, #8
 80071e4:	d002      	beq.n	80071ec <SystemCoreClockUpdate+0x18>
  {
    case 0x00:  /* HSI used as system clock */
      SystemCoreClock = HSI_VALUE;
      break;
    case 0x04:  /* HSE used as system clock */
      SystemCoreClock = HSE_VALUE;
 80071e6:	4a12      	ldr	r2, [pc, #72]	; (8007230 <SystemCoreClockUpdate+0x5c>)
 80071e8:	601a      	str	r2, [r3, #0]
      break;
 80071ea:	e011      	b.n	8007210 <SystemCoreClockUpdate+0x3c>
    case 0x08:  /* PLL used as system clock */
      /* Get PLL clock source and multiplication factor ----------------------*/
      pllmull = RCC->CFGR & RCC_CFGR_PLLMULL;
 80071ec:	6851      	ldr	r1, [r2, #4]
      pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
 80071ee:	6850      	ldr	r0, [r2, #4]
      pllmull = ( pllmull >> 18) + 2;
 80071f0:	f3c1 4183 	ubfx	r1, r1, #18, #4
 80071f4:	3102      	adds	r1, #2
      
      if (pllsource == 0x00)
 80071f6:	03c0      	lsls	r0, r0, #15
 80071f8:	d401      	bmi.n	80071fe <SystemCoreClockUpdate+0x2a>
      {
        /* HSI oscillator clock divided by 2 selected as PLL clock entry */
        SystemCoreClock = (HSI_VALUE >> 1) * pllmull;
 80071fa:	4a0e      	ldr	r2, [pc, #56]	; (8007234 <SystemCoreClockUpdate+0x60>)
 80071fc:	e006      	b.n	800720c <SystemCoreClockUpdate+0x38>
      }
      else
      {
        prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
 80071fe:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
        /* HSE oscillator clock selected as PREDIV1 clock entry */
        SystemCoreClock = (HSE_VALUE / prediv1factor) * pllmull; 
 8007200:	480b      	ldr	r0, [pc, #44]	; (8007230 <SystemCoreClockUpdate+0x5c>)
        /* HSI oscillator clock divided by 2 selected as PLL clock entry */
        SystemCoreClock = (HSI_VALUE >> 1) * pllmull;
      }
      else
      {
        prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
 8007202:	f002 020f 	and.w	r2, r2, #15
 8007206:	3201      	adds	r2, #1
        /* HSE oscillator clock selected as PREDIV1 clock entry */
        SystemCoreClock = (HSE_VALUE / prediv1factor) * pllmull; 
 8007208:	fbb0 f2f2 	udiv	r2, r0, r2
 800720c:	4351      	muls	r1, r2
 800720e:	6019      	str	r1, [r3, #0]
      SystemCoreClock = HSI_VALUE;
      break;
  }
  /* Compute HCLK clock frequency ----------------*/
  /* Get HCLK prescaler */
  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
 8007210:	4b05      	ldr	r3, [pc, #20]	; (8007228 <SystemCoreClockUpdate+0x54>)
 8007212:	685a      	ldr	r2, [r3, #4]
 8007214:	4b05      	ldr	r3, [pc, #20]	; (800722c <SystemCoreClockUpdate+0x58>)
 8007216:	f3c2 1203 	ubfx	r2, r2, #4, #4
 800721a:	189a      	adds	r2, r3, r2
 800721c:	7911      	ldrb	r1, [r2, #4]
  /* HCLK clock frequency */
  SystemCoreClock >>= tmp;  
 800721e:	681a      	ldr	r2, [r3, #0]
 8007220:	fa22 f201 	lsr.w	r2, r2, r1
 8007224:	601a      	str	r2, [r3, #0]
 8007226:	4770      	bx	lr
 8007228:	40021000 	.word	0x40021000
 800722c:	20000034 	.word	0x20000034
 8007230:	007a1200 	.word	0x007a1200
 8007234:	003d0900 	.word	0x003d0900

08007238 <__aeabi_drsub>:
 8007238:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 800723c:	e002      	b.n	8007244 <__adddf3>
 800723e:	bf00      	nop

08007240 <__aeabi_dsub>:
 8007240:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

08007244 <__adddf3>:
 8007244:	b530      	push	{r4, r5, lr}
 8007246:	ea4f 0441 	mov.w	r4, r1, lsl #1
 800724a:	ea4f 0543 	mov.w	r5, r3, lsl #1
 800724e:	ea94 0f05 	teq	r4, r5
 8007252:	bf08      	it	eq
 8007254:	ea90 0f02 	teqeq	r0, r2
 8007258:	bf1f      	itttt	ne
 800725a:	ea54 0c00 	orrsne.w	ip, r4, r0
 800725e:	ea55 0c02 	orrsne.w	ip, r5, r2
 8007262:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 8007266:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 800726a:	f000 80e2 	beq.w	8007432 <__adddf3+0x1ee>
 800726e:	ea4f 5454 	mov.w	r4, r4, lsr #21
 8007272:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 8007276:	bfb8      	it	lt
 8007278:	426d      	neglt	r5, r5
 800727a:	dd0c      	ble.n	8007296 <__adddf3+0x52>
 800727c:	442c      	add	r4, r5
 800727e:	ea80 0202 	eor.w	r2, r0, r2
 8007282:	ea81 0303 	eor.w	r3, r1, r3
 8007286:	ea82 0000 	eor.w	r0, r2, r0
 800728a:	ea83 0101 	eor.w	r1, r3, r1
 800728e:	ea80 0202 	eor.w	r2, r0, r2
 8007292:	ea81 0303 	eor.w	r3, r1, r3
 8007296:	2d36      	cmp	r5, #54	; 0x36
 8007298:	bf88      	it	hi
 800729a:	bd30      	pophi	{r4, r5, pc}
 800729c:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 80072a0:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80072a4:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 80072a8:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 80072ac:	d002      	beq.n	80072b4 <__adddf3+0x70>
 80072ae:	4240      	negs	r0, r0
 80072b0:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80072b4:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 80072b8:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80072bc:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 80072c0:	d002      	beq.n	80072c8 <__adddf3+0x84>
 80072c2:	4252      	negs	r2, r2
 80072c4:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 80072c8:	ea94 0f05 	teq	r4, r5
 80072cc:	f000 80a7 	beq.w	800741e <__adddf3+0x1da>
 80072d0:	f1a4 0401 	sub.w	r4, r4, #1
 80072d4:	f1d5 0e20 	rsbs	lr, r5, #32
 80072d8:	db0d      	blt.n	80072f6 <__adddf3+0xb2>
 80072da:	fa02 fc0e 	lsl.w	ip, r2, lr
 80072de:	fa22 f205 	lsr.w	r2, r2, r5
 80072e2:	1880      	adds	r0, r0, r2
 80072e4:	f141 0100 	adc.w	r1, r1, #0
 80072e8:	fa03 f20e 	lsl.w	r2, r3, lr
 80072ec:	1880      	adds	r0, r0, r2
 80072ee:	fa43 f305 	asr.w	r3, r3, r5
 80072f2:	4159      	adcs	r1, r3
 80072f4:	e00e      	b.n	8007314 <__adddf3+0xd0>
 80072f6:	f1a5 0520 	sub.w	r5, r5, #32
 80072fa:	f10e 0e20 	add.w	lr, lr, #32
 80072fe:	2a01      	cmp	r2, #1
 8007300:	fa03 fc0e 	lsl.w	ip, r3, lr
 8007304:	bf28      	it	cs
 8007306:	f04c 0c02 	orrcs.w	ip, ip, #2
 800730a:	fa43 f305 	asr.w	r3, r3, r5
 800730e:	18c0      	adds	r0, r0, r3
 8007310:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 8007314:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8007318:	d507      	bpl.n	800732a <__adddf3+0xe6>
 800731a:	f04f 0e00 	mov.w	lr, #0
 800731e:	f1dc 0c00 	rsbs	ip, ip, #0
 8007322:	eb7e 0000 	sbcs.w	r0, lr, r0
 8007326:	eb6e 0101 	sbc.w	r1, lr, r1
 800732a:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 800732e:	d31b      	bcc.n	8007368 <__adddf3+0x124>
 8007330:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 8007334:	d30c      	bcc.n	8007350 <__adddf3+0x10c>
 8007336:	0849      	lsrs	r1, r1, #1
 8007338:	ea5f 0030 	movs.w	r0, r0, rrx
 800733c:	ea4f 0c3c 	mov.w	ip, ip, rrx
 8007340:	f104 0401 	add.w	r4, r4, #1
 8007344:	ea4f 5244 	mov.w	r2, r4, lsl #21
 8007348:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 800734c:	f080 809a 	bcs.w	8007484 <__adddf3+0x240>
 8007350:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 8007354:	bf08      	it	eq
 8007356:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 800735a:	f150 0000 	adcs.w	r0, r0, #0
 800735e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8007362:	ea41 0105 	orr.w	r1, r1, r5
 8007366:	bd30      	pop	{r4, r5, pc}
 8007368:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 800736c:	4140      	adcs	r0, r0
 800736e:	eb41 0101 	adc.w	r1, r1, r1
 8007372:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8007376:	f1a4 0401 	sub.w	r4, r4, #1
 800737a:	d1e9      	bne.n	8007350 <__adddf3+0x10c>
 800737c:	f091 0f00 	teq	r1, #0
 8007380:	bf04      	itt	eq
 8007382:	4601      	moveq	r1, r0
 8007384:	2000      	moveq	r0, #0
 8007386:	fab1 f381 	clz	r3, r1
 800738a:	bf08      	it	eq
 800738c:	3320      	addeq	r3, #32
 800738e:	f1a3 030b 	sub.w	r3, r3, #11
 8007392:	f1b3 0220 	subs.w	r2, r3, #32
 8007396:	da0c      	bge.n	80073b2 <__adddf3+0x16e>
 8007398:	320c      	adds	r2, #12
 800739a:	dd08      	ble.n	80073ae <__adddf3+0x16a>
 800739c:	f102 0c14 	add.w	ip, r2, #20
 80073a0:	f1c2 020c 	rsb	r2, r2, #12
 80073a4:	fa01 f00c 	lsl.w	r0, r1, ip
 80073a8:	fa21 f102 	lsr.w	r1, r1, r2
 80073ac:	e00c      	b.n	80073c8 <__adddf3+0x184>
 80073ae:	f102 0214 	add.w	r2, r2, #20
 80073b2:	bfd8      	it	le
 80073b4:	f1c2 0c20 	rsble	ip, r2, #32
 80073b8:	fa01 f102 	lsl.w	r1, r1, r2
 80073bc:	fa20 fc0c 	lsr.w	ip, r0, ip
 80073c0:	bfdc      	itt	le
 80073c2:	ea41 010c 	orrle.w	r1, r1, ip
 80073c6:	4090      	lslle	r0, r2
 80073c8:	1ae4      	subs	r4, r4, r3
 80073ca:	bfa2      	ittt	ge
 80073cc:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 80073d0:	4329      	orrge	r1, r5
 80073d2:	bd30      	popge	{r4, r5, pc}
 80073d4:	ea6f 0404 	mvn.w	r4, r4
 80073d8:	3c1f      	subs	r4, #31
 80073da:	da1c      	bge.n	8007416 <__adddf3+0x1d2>
 80073dc:	340c      	adds	r4, #12
 80073de:	dc0e      	bgt.n	80073fe <__adddf3+0x1ba>
 80073e0:	f104 0414 	add.w	r4, r4, #20
 80073e4:	f1c4 0220 	rsb	r2, r4, #32
 80073e8:	fa20 f004 	lsr.w	r0, r0, r4
 80073ec:	fa01 f302 	lsl.w	r3, r1, r2
 80073f0:	ea40 0003 	orr.w	r0, r0, r3
 80073f4:	fa21 f304 	lsr.w	r3, r1, r4
 80073f8:	ea45 0103 	orr.w	r1, r5, r3
 80073fc:	bd30      	pop	{r4, r5, pc}
 80073fe:	f1c4 040c 	rsb	r4, r4, #12
 8007402:	f1c4 0220 	rsb	r2, r4, #32
 8007406:	fa20 f002 	lsr.w	r0, r0, r2
 800740a:	fa01 f304 	lsl.w	r3, r1, r4
 800740e:	ea40 0003 	orr.w	r0, r0, r3
 8007412:	4629      	mov	r1, r5
 8007414:	bd30      	pop	{r4, r5, pc}
 8007416:	fa21 f004 	lsr.w	r0, r1, r4
 800741a:	4629      	mov	r1, r5
 800741c:	bd30      	pop	{r4, r5, pc}
 800741e:	f094 0f00 	teq	r4, #0
 8007422:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 8007426:	bf06      	itte	eq
 8007428:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 800742c:	3401      	addeq	r4, #1
 800742e:	3d01      	subne	r5, #1
 8007430:	e74e      	b.n	80072d0 <__adddf3+0x8c>
 8007432:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 8007436:	bf18      	it	ne
 8007438:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 800743c:	d029      	beq.n	8007492 <__adddf3+0x24e>
 800743e:	ea94 0f05 	teq	r4, r5
 8007442:	bf08      	it	eq
 8007444:	ea90 0f02 	teqeq	r0, r2
 8007448:	d005      	beq.n	8007456 <__adddf3+0x212>
 800744a:	ea54 0c00 	orrs.w	ip, r4, r0
 800744e:	bf04      	itt	eq
 8007450:	4619      	moveq	r1, r3
 8007452:	4610      	moveq	r0, r2
 8007454:	bd30      	pop	{r4, r5, pc}
 8007456:	ea91 0f03 	teq	r1, r3
 800745a:	bf1e      	ittt	ne
 800745c:	2100      	movne	r1, #0
 800745e:	2000      	movne	r0, #0
 8007460:	bd30      	popne	{r4, r5, pc}
 8007462:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 8007466:	d105      	bne.n	8007474 <__adddf3+0x230>
 8007468:	0040      	lsls	r0, r0, #1
 800746a:	4149      	adcs	r1, r1
 800746c:	bf28      	it	cs
 800746e:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 8007472:	bd30      	pop	{r4, r5, pc}
 8007474:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 8007478:	bf3c      	itt	cc
 800747a:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 800747e:	bd30      	popcc	{r4, r5, pc}
 8007480:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8007484:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 8007488:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 800748c:	f04f 0000 	mov.w	r0, #0
 8007490:	bd30      	pop	{r4, r5, pc}
 8007492:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 8007496:	bf1a      	itte	ne
 8007498:	4619      	movne	r1, r3
 800749a:	4610      	movne	r0, r2
 800749c:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 80074a0:	bf1c      	itt	ne
 80074a2:	460b      	movne	r3, r1
 80074a4:	4602      	movne	r2, r0
 80074a6:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80074aa:	bf06      	itte	eq
 80074ac:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 80074b0:	ea91 0f03 	teqeq	r1, r3
 80074b4:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 80074b8:	bd30      	pop	{r4, r5, pc}
 80074ba:	bf00      	nop

080074bc <__aeabi_ui2d>:
 80074bc:	f090 0f00 	teq	r0, #0
 80074c0:	bf04      	itt	eq
 80074c2:	2100      	moveq	r1, #0
 80074c4:	4770      	bxeq	lr
 80074c6:	b530      	push	{r4, r5, lr}
 80074c8:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80074cc:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80074d0:	f04f 0500 	mov.w	r5, #0
 80074d4:	f04f 0100 	mov.w	r1, #0
 80074d8:	e750      	b.n	800737c <__adddf3+0x138>
 80074da:	bf00      	nop

080074dc <__aeabi_i2d>:
 80074dc:	f090 0f00 	teq	r0, #0
 80074e0:	bf04      	itt	eq
 80074e2:	2100      	moveq	r1, #0
 80074e4:	4770      	bxeq	lr
 80074e6:	b530      	push	{r4, r5, lr}
 80074e8:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80074ec:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80074f0:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 80074f4:	bf48      	it	mi
 80074f6:	4240      	negmi	r0, r0
 80074f8:	f04f 0100 	mov.w	r1, #0
 80074fc:	e73e      	b.n	800737c <__adddf3+0x138>
 80074fe:	bf00      	nop

08007500 <__aeabi_f2d>:
 8007500:	0042      	lsls	r2, r0, #1
 8007502:	ea4f 01e2 	mov.w	r1, r2, asr #3
 8007506:	ea4f 0131 	mov.w	r1, r1, rrx
 800750a:	ea4f 7002 	mov.w	r0, r2, lsl #28
 800750e:	bf1f      	itttt	ne
 8007510:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 8007514:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 8007518:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 800751c:	4770      	bxne	lr
 800751e:	f092 0f00 	teq	r2, #0
 8007522:	bf14      	ite	ne
 8007524:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 8007528:	4770      	bxeq	lr
 800752a:	b530      	push	{r4, r5, lr}
 800752c:	f44f 7460 	mov.w	r4, #896	; 0x380
 8007530:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8007534:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8007538:	e720      	b.n	800737c <__adddf3+0x138>
 800753a:	bf00      	nop

0800753c <__aeabi_ul2d>:
 800753c:	ea50 0201 	orrs.w	r2, r0, r1
 8007540:	bf08      	it	eq
 8007542:	4770      	bxeq	lr
 8007544:	b530      	push	{r4, r5, lr}
 8007546:	f04f 0500 	mov.w	r5, #0
 800754a:	e00a      	b.n	8007562 <__aeabi_l2d+0x16>

0800754c <__aeabi_l2d>:
 800754c:	ea50 0201 	orrs.w	r2, r0, r1
 8007550:	bf08      	it	eq
 8007552:	4770      	bxeq	lr
 8007554:	b530      	push	{r4, r5, lr}
 8007556:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 800755a:	d502      	bpl.n	8007562 <__aeabi_l2d+0x16>
 800755c:	4240      	negs	r0, r0
 800755e:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8007562:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8007566:	f104 0432 	add.w	r4, r4, #50	; 0x32
 800756a:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 800756e:	f43f aedc 	beq.w	800732a <__adddf3+0xe6>
 8007572:	f04f 0203 	mov.w	r2, #3
 8007576:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 800757a:	bf18      	it	ne
 800757c:	3203      	addne	r2, #3
 800757e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8007582:	bf18      	it	ne
 8007584:	3203      	addne	r2, #3
 8007586:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 800758a:	f1c2 0320 	rsb	r3, r2, #32
 800758e:	fa00 fc03 	lsl.w	ip, r0, r3
 8007592:	fa20 f002 	lsr.w	r0, r0, r2
 8007596:	fa01 fe03 	lsl.w	lr, r1, r3
 800759a:	ea40 000e 	orr.w	r0, r0, lr
 800759e:	fa21 f102 	lsr.w	r1, r1, r2
 80075a2:	4414      	add	r4, r2
 80075a4:	e6c1      	b.n	800732a <__adddf3+0xe6>
 80075a6:	bf00      	nop

080075a8 <__aeabi_d2iz>:
 80075a8:	ea4f 0241 	mov.w	r2, r1, lsl #1
 80075ac:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 80075b0:	d215      	bcs.n	80075de <__aeabi_d2iz+0x36>
 80075b2:	d511      	bpl.n	80075d8 <__aeabi_d2iz+0x30>
 80075b4:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 80075b8:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 80075bc:	d912      	bls.n	80075e4 <__aeabi_d2iz+0x3c>
 80075be:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 80075c2:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80075c6:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 80075ca:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 80075ce:	fa23 f002 	lsr.w	r0, r3, r2
 80075d2:	bf18      	it	ne
 80075d4:	4240      	negne	r0, r0
 80075d6:	4770      	bx	lr
 80075d8:	f04f 0000 	mov.w	r0, #0
 80075dc:	4770      	bx	lr
 80075de:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 80075e2:	d105      	bne.n	80075f0 <__aeabi_d2iz+0x48>
 80075e4:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
 80075e8:	bf08      	it	eq
 80075ea:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 80075ee:	4770      	bx	lr
 80075f0:	f04f 0000 	mov.w	r0, #0
 80075f4:	4770      	bx	lr
 80075f6:	bf00      	nop

080075f8 <__aeabi_d2f>:
 80075f8:	ea4f 0241 	mov.w	r2, r1, lsl #1
 80075fc:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
 8007600:	bf24      	itt	cs
 8007602:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
 8007606:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
 800760a:	d90d      	bls.n	8007628 <__aeabi_d2f+0x30>
 800760c:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8007610:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 8007614:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 8007618:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
 800761c:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 8007620:	bf08      	it	eq
 8007622:	f020 0001 	biceq.w	r0, r0, #1
 8007626:	4770      	bx	lr
 8007628:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
 800762c:	d121      	bne.n	8007672 <__aeabi_d2f+0x7a>
 800762e:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
 8007632:	bfbc      	itt	lt
 8007634:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
 8007638:	4770      	bxlt	lr
 800763a:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800763e:	ea4f 5252 	mov.w	r2, r2, lsr #21
 8007642:	f1c2 0218 	rsb	r2, r2, #24
 8007646:	f1c2 0c20 	rsb	ip, r2, #32
 800764a:	fa10 f30c 	lsls.w	r3, r0, ip
 800764e:	fa20 f002 	lsr.w	r0, r0, r2
 8007652:	bf18      	it	ne
 8007654:	f040 0001 	orrne.w	r0, r0, #1
 8007658:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 800765c:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 8007660:	fa03 fc0c 	lsl.w	ip, r3, ip
 8007664:	ea40 000c 	orr.w	r0, r0, ip
 8007668:	fa23 f302 	lsr.w	r3, r3, r2
 800766c:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8007670:	e7cc      	b.n	800760c <__aeabi_d2f+0x14>
 8007672:	ea7f 5362 	mvns.w	r3, r2, asr #21
 8007676:	d107      	bne.n	8007688 <__aeabi_d2f+0x90>
 8007678:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 800767c:	bf1e      	ittt	ne
 800767e:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
 8007682:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
 8007686:	4770      	bxne	lr
 8007688:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
 800768c:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8007690:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8007694:	4770      	bx	lr
 8007696:	bf00      	nop

08007698 <__aeabi_frsub>:
 8007698:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
 800769c:	e002      	b.n	80076a4 <__addsf3>
 800769e:	bf00      	nop

080076a0 <__aeabi_fsub>:
 80076a0:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000

080076a4 <__addsf3>:
 80076a4:	0042      	lsls	r2, r0, #1
 80076a6:	bf1f      	itttt	ne
 80076a8:	ea5f 0341 	movsne.w	r3, r1, lsl #1
 80076ac:	ea92 0f03 	teqne	r2, r3
 80076b0:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
 80076b4:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 80076b8:	d06a      	beq.n	8007790 <__addsf3+0xec>
 80076ba:	ea4f 6212 	mov.w	r2, r2, lsr #24
 80076be:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
 80076c2:	bfc1      	itttt	gt
 80076c4:	18d2      	addgt	r2, r2, r3
 80076c6:	4041      	eorgt	r1, r0
 80076c8:	4048      	eorgt	r0, r1
 80076ca:	4041      	eorgt	r1, r0
 80076cc:	bfb8      	it	lt
 80076ce:	425b      	neglt	r3, r3
 80076d0:	2b19      	cmp	r3, #25
 80076d2:	bf88      	it	hi
 80076d4:	4770      	bxhi	lr
 80076d6:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
 80076da:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80076de:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 80076e2:	bf18      	it	ne
 80076e4:	4240      	negne	r0, r0
 80076e6:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 80076ea:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
 80076ee:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
 80076f2:	bf18      	it	ne
 80076f4:	4249      	negne	r1, r1
 80076f6:	ea92 0f03 	teq	r2, r3
 80076fa:	d03f      	beq.n	800777c <__addsf3+0xd8>
 80076fc:	f1a2 0201 	sub.w	r2, r2, #1
 8007700:	fa41 fc03 	asr.w	ip, r1, r3
 8007704:	eb10 000c 	adds.w	r0, r0, ip
 8007708:	f1c3 0320 	rsb	r3, r3, #32
 800770c:	fa01 f103 	lsl.w	r1, r1, r3
 8007710:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 8007714:	d502      	bpl.n	800771c <__addsf3+0x78>
 8007716:	4249      	negs	r1, r1
 8007718:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
 800771c:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
 8007720:	d313      	bcc.n	800774a <__addsf3+0xa6>
 8007722:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 8007726:	d306      	bcc.n	8007736 <__addsf3+0x92>
 8007728:	0840      	lsrs	r0, r0, #1
 800772a:	ea4f 0131 	mov.w	r1, r1, rrx
 800772e:	f102 0201 	add.w	r2, r2, #1
 8007732:	2afe      	cmp	r2, #254	; 0xfe
 8007734:	d251      	bcs.n	80077da <__addsf3+0x136>
 8007736:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
 800773a:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 800773e:	bf08      	it	eq
 8007740:	f020 0001 	biceq.w	r0, r0, #1
 8007744:	ea40 0003 	orr.w	r0, r0, r3
 8007748:	4770      	bx	lr
 800774a:	0049      	lsls	r1, r1, #1
 800774c:	eb40 0000 	adc.w	r0, r0, r0
 8007750:	f410 0f00 	tst.w	r0, #8388608	; 0x800000
 8007754:	f1a2 0201 	sub.w	r2, r2, #1
 8007758:	d1ed      	bne.n	8007736 <__addsf3+0x92>
 800775a:	fab0 fc80 	clz	ip, r0
 800775e:	f1ac 0c08 	sub.w	ip, ip, #8
 8007762:	ebb2 020c 	subs.w	r2, r2, ip
 8007766:	fa00 f00c 	lsl.w	r0, r0, ip
 800776a:	bfaa      	itet	ge
 800776c:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
 8007770:	4252      	neglt	r2, r2
 8007772:	4318      	orrge	r0, r3
 8007774:	bfbc      	itt	lt
 8007776:	40d0      	lsrlt	r0, r2
 8007778:	4318      	orrlt	r0, r3
 800777a:	4770      	bx	lr
 800777c:	f092 0f00 	teq	r2, #0
 8007780:	f481 0100 	eor.w	r1, r1, #8388608	; 0x800000
 8007784:	bf06      	itte	eq
 8007786:	f480 0000 	eoreq.w	r0, r0, #8388608	; 0x800000
 800778a:	3201      	addeq	r2, #1
 800778c:	3b01      	subne	r3, #1
 800778e:	e7b5      	b.n	80076fc <__addsf3+0x58>
 8007790:	ea4f 0341 	mov.w	r3, r1, lsl #1
 8007794:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 8007798:	bf18      	it	ne
 800779a:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 800779e:	d021      	beq.n	80077e4 <__addsf3+0x140>
 80077a0:	ea92 0f03 	teq	r2, r3
 80077a4:	d004      	beq.n	80077b0 <__addsf3+0x10c>
 80077a6:	f092 0f00 	teq	r2, #0
 80077aa:	bf08      	it	eq
 80077ac:	4608      	moveq	r0, r1
 80077ae:	4770      	bx	lr
 80077b0:	ea90 0f01 	teq	r0, r1
 80077b4:	bf1c      	itt	ne
 80077b6:	2000      	movne	r0, #0
 80077b8:	4770      	bxne	lr
 80077ba:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
 80077be:	d104      	bne.n	80077ca <__addsf3+0x126>
 80077c0:	0040      	lsls	r0, r0, #1
 80077c2:	bf28      	it	cs
 80077c4:	f040 4000 	orrcs.w	r0, r0, #2147483648	; 0x80000000
 80077c8:	4770      	bx	lr
 80077ca:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
 80077ce:	bf3c      	itt	cc
 80077d0:	f500 0000 	addcc.w	r0, r0, #8388608	; 0x800000
 80077d4:	4770      	bxcc	lr
 80077d6:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 80077da:	f043 40fe 	orr.w	r0, r3, #2130706432	; 0x7f000000
 80077de:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80077e2:	4770      	bx	lr
 80077e4:	ea7f 6222 	mvns.w	r2, r2, asr #24
 80077e8:	bf16      	itet	ne
 80077ea:	4608      	movne	r0, r1
 80077ec:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
 80077f0:	4601      	movne	r1, r0
 80077f2:	0242      	lsls	r2, r0, #9
 80077f4:	bf06      	itte	eq
 80077f6:	ea5f 2341 	movseq.w	r3, r1, lsl #9
 80077fa:	ea90 0f01 	teqeq	r0, r1
 80077fe:	f440 0080 	orrne.w	r0, r0, #4194304	; 0x400000
 8007802:	4770      	bx	lr

08007804 <__aeabi_ui2f>:
 8007804:	f04f 0300 	mov.w	r3, #0
 8007808:	e004      	b.n	8007814 <__aeabi_i2f+0x8>
 800780a:	bf00      	nop

0800780c <__aeabi_i2f>:
 800780c:	f010 4300 	ands.w	r3, r0, #2147483648	; 0x80000000
 8007810:	bf48      	it	mi
 8007812:	4240      	negmi	r0, r0
 8007814:	ea5f 0c00 	movs.w	ip, r0
 8007818:	bf08      	it	eq
 800781a:	4770      	bxeq	lr
 800781c:	f043 4396 	orr.w	r3, r3, #1258291200	; 0x4b000000
 8007820:	4601      	mov	r1, r0
 8007822:	f04f 0000 	mov.w	r0, #0
 8007826:	e01c      	b.n	8007862 <__aeabi_l2f+0x2a>

08007828 <__aeabi_ul2f>:
 8007828:	ea50 0201 	orrs.w	r2, r0, r1
 800782c:	bf08      	it	eq
 800782e:	4770      	bxeq	lr
 8007830:	f04f 0300 	mov.w	r3, #0
 8007834:	e00a      	b.n	800784c <__aeabi_l2f+0x14>
 8007836:	bf00      	nop

08007838 <__aeabi_l2f>:
 8007838:	ea50 0201 	orrs.w	r2, r0, r1
 800783c:	bf08      	it	eq
 800783e:	4770      	bxeq	lr
 8007840:	f011 4300 	ands.w	r3, r1, #2147483648	; 0x80000000
 8007844:	d502      	bpl.n	800784c <__aeabi_l2f+0x14>
 8007846:	4240      	negs	r0, r0
 8007848:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800784c:	ea5f 0c01 	movs.w	ip, r1
 8007850:	bf02      	ittt	eq
 8007852:	4684      	moveq	ip, r0
 8007854:	4601      	moveq	r1, r0
 8007856:	2000      	moveq	r0, #0
 8007858:	f043 43b6 	orr.w	r3, r3, #1526726656	; 0x5b000000
 800785c:	bf08      	it	eq
 800785e:	f1a3 5380 	subeq.w	r3, r3, #268435456	; 0x10000000
 8007862:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
 8007866:	fabc f28c 	clz	r2, ip
 800786a:	3a08      	subs	r2, #8
 800786c:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
 8007870:	db10      	blt.n	8007894 <__aeabi_l2f+0x5c>
 8007872:	fa01 fc02 	lsl.w	ip, r1, r2
 8007876:	4463      	add	r3, ip
 8007878:	fa00 fc02 	lsl.w	ip, r0, r2
 800787c:	f1c2 0220 	rsb	r2, r2, #32
 8007880:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 8007884:	fa20 f202 	lsr.w	r2, r0, r2
 8007888:	eb43 0002 	adc.w	r0, r3, r2
 800788c:	bf08      	it	eq
 800788e:	f020 0001 	biceq.w	r0, r0, #1
 8007892:	4770      	bx	lr
 8007894:	f102 0220 	add.w	r2, r2, #32
 8007898:	fa01 fc02 	lsl.w	ip, r1, r2
 800789c:	f1c2 0220 	rsb	r2, r2, #32
 80078a0:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
 80078a4:	fa21 f202 	lsr.w	r2, r1, r2
 80078a8:	eb43 0002 	adc.w	r0, r3, r2
 80078ac:	bf08      	it	eq
 80078ae:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 80078b2:	4770      	bx	lr

080078b4 <__aeabi_fmul>:
 80078b4:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80078b8:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 80078bc:	bf1e      	ittt	ne
 80078be:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 80078c2:	ea92 0f0c 	teqne	r2, ip
 80078c6:	ea93 0f0c 	teqne	r3, ip
 80078ca:	d06f      	beq.n	80079ac <__aeabi_fmul+0xf8>
 80078cc:	441a      	add	r2, r3
 80078ce:	ea80 0c01 	eor.w	ip, r0, r1
 80078d2:	0240      	lsls	r0, r0, #9
 80078d4:	bf18      	it	ne
 80078d6:	ea5f 2141 	movsne.w	r1, r1, lsl #9
 80078da:	d01e      	beq.n	800791a <__aeabi_fmul+0x66>
 80078dc:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 80078e0:	ea43 1050 	orr.w	r0, r3, r0, lsr #5
 80078e4:	ea43 1151 	orr.w	r1, r3, r1, lsr #5
 80078e8:	fba0 3101 	umull	r3, r1, r0, r1
 80078ec:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 80078f0:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
 80078f4:	bf3e      	ittt	cc
 80078f6:	0049      	lslcc	r1, r1, #1
 80078f8:	ea41 71d3 	orrcc.w	r1, r1, r3, lsr #31
 80078fc:	005b      	lslcc	r3, r3, #1
 80078fe:	ea40 0001 	orr.w	r0, r0, r1
 8007902:	f162 027f 	sbc.w	r2, r2, #127	; 0x7f
 8007906:	2afd      	cmp	r2, #253	; 0xfd
 8007908:	d81d      	bhi.n	8007946 <__aeabi_fmul+0x92>
 800790a:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 800790e:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 8007912:	bf08      	it	eq
 8007914:	f020 0001 	biceq.w	r0, r0, #1
 8007918:	4770      	bx	lr
 800791a:	f090 0f00 	teq	r0, #0
 800791e:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 8007922:	bf08      	it	eq
 8007924:	0249      	lsleq	r1, r1, #9
 8007926:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 800792a:	ea40 2051 	orr.w	r0, r0, r1, lsr #9
 800792e:	3a7f      	subs	r2, #127	; 0x7f
 8007930:	bfc2      	ittt	gt
 8007932:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 8007936:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 800793a:	4770      	bxgt	lr
 800793c:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8007940:	f04f 0300 	mov.w	r3, #0
 8007944:	3a01      	subs	r2, #1
 8007946:	dc5d      	bgt.n	8007a04 <__aeabi_fmul+0x150>
 8007948:	f112 0f19 	cmn.w	r2, #25
 800794c:	bfdc      	itt	le
 800794e:	f000 4000 	andle.w	r0, r0, #2147483648	; 0x80000000
 8007952:	4770      	bxle	lr
 8007954:	f1c2 0200 	rsb	r2, r2, #0
 8007958:	0041      	lsls	r1, r0, #1
 800795a:	fa21 f102 	lsr.w	r1, r1, r2
 800795e:	f1c2 0220 	rsb	r2, r2, #32
 8007962:	fa00 fc02 	lsl.w	ip, r0, r2
 8007966:	ea5f 0031 	movs.w	r0, r1, rrx
 800796a:	f140 0000 	adc.w	r0, r0, #0
 800796e:	ea53 034c 	orrs.w	r3, r3, ip, lsl #1
 8007972:	bf08      	it	eq
 8007974:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 8007978:	4770      	bx	lr
 800797a:	f092 0f00 	teq	r2, #0
 800797e:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 8007982:	bf02      	ittt	eq
 8007984:	0040      	lsleq	r0, r0, #1
 8007986:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 800798a:	3a01      	subeq	r2, #1
 800798c:	d0f9      	beq.n	8007982 <__aeabi_fmul+0xce>
 800798e:	ea40 000c 	orr.w	r0, r0, ip
 8007992:	f093 0f00 	teq	r3, #0
 8007996:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 800799a:	bf02      	ittt	eq
 800799c:	0049      	lsleq	r1, r1, #1
 800799e:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 80079a2:	3b01      	subeq	r3, #1
 80079a4:	d0f9      	beq.n	800799a <__aeabi_fmul+0xe6>
 80079a6:	ea41 010c 	orr.w	r1, r1, ip
 80079aa:	e78f      	b.n	80078cc <__aeabi_fmul+0x18>
 80079ac:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 80079b0:	ea92 0f0c 	teq	r2, ip
 80079b4:	bf18      	it	ne
 80079b6:	ea93 0f0c 	teqne	r3, ip
 80079ba:	d00a      	beq.n	80079d2 <__aeabi_fmul+0x11e>
 80079bc:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 80079c0:	bf18      	it	ne
 80079c2:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 80079c6:	d1d8      	bne.n	800797a <__aeabi_fmul+0xc6>
 80079c8:	ea80 0001 	eor.w	r0, r0, r1
 80079cc:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 80079d0:	4770      	bx	lr
 80079d2:	f090 0f00 	teq	r0, #0
 80079d6:	bf17      	itett	ne
 80079d8:	f090 4f00 	teqne	r0, #2147483648	; 0x80000000
 80079dc:	4608      	moveq	r0, r1
 80079de:	f091 0f00 	teqne	r1, #0
 80079e2:	f091 4f00 	teqne	r1, #2147483648	; 0x80000000
 80079e6:	d014      	beq.n	8007a12 <__aeabi_fmul+0x15e>
 80079e8:	ea92 0f0c 	teq	r2, ip
 80079ec:	d101      	bne.n	80079f2 <__aeabi_fmul+0x13e>
 80079ee:	0242      	lsls	r2, r0, #9
 80079f0:	d10f      	bne.n	8007a12 <__aeabi_fmul+0x15e>
 80079f2:	ea93 0f0c 	teq	r3, ip
 80079f6:	d103      	bne.n	8007a00 <__aeabi_fmul+0x14c>
 80079f8:	024b      	lsls	r3, r1, #9
 80079fa:	bf18      	it	ne
 80079fc:	4608      	movne	r0, r1
 80079fe:	d108      	bne.n	8007a12 <__aeabi_fmul+0x15e>
 8007a00:	ea80 0001 	eor.w	r0, r0, r1
 8007a04:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 8007a08:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8007a0c:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8007a10:	4770      	bx	lr
 8007a12:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8007a16:	f440 0040 	orr.w	r0, r0, #12582912	; 0xc00000
 8007a1a:	4770      	bx	lr

08007a1c <__aeabi_fdiv>:
 8007a1c:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8007a20:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 8007a24:	bf1e      	ittt	ne
 8007a26:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 8007a2a:	ea92 0f0c 	teqne	r2, ip
 8007a2e:	ea93 0f0c 	teqne	r3, ip
 8007a32:	d069      	beq.n	8007b08 <__aeabi_fdiv+0xec>
 8007a34:	eba2 0203 	sub.w	r2, r2, r3
 8007a38:	ea80 0c01 	eor.w	ip, r0, r1
 8007a3c:	0249      	lsls	r1, r1, #9
 8007a3e:	ea4f 2040 	mov.w	r0, r0, lsl #9
 8007a42:	d037      	beq.n	8007ab4 <__aeabi_fdiv+0x98>
 8007a44:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8007a48:	ea43 1111 	orr.w	r1, r3, r1, lsr #4
 8007a4c:	ea43 1310 	orr.w	r3, r3, r0, lsr #4
 8007a50:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 8007a54:	428b      	cmp	r3, r1
 8007a56:	bf38      	it	cc
 8007a58:	005b      	lslcc	r3, r3, #1
 8007a5a:	f142 027d 	adc.w	r2, r2, #125	; 0x7d
 8007a5e:	f44f 0c00 	mov.w	ip, #8388608	; 0x800000
 8007a62:	428b      	cmp	r3, r1
 8007a64:	bf24      	itt	cs
 8007a66:	1a5b      	subcs	r3, r3, r1
 8007a68:	ea40 000c 	orrcs.w	r0, r0, ip
 8007a6c:	ebb3 0f51 	cmp.w	r3, r1, lsr #1
 8007a70:	bf24      	itt	cs
 8007a72:	eba3 0351 	subcs.w	r3, r3, r1, lsr #1
 8007a76:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8007a7a:	ebb3 0f91 	cmp.w	r3, r1, lsr #2
 8007a7e:	bf24      	itt	cs
 8007a80:	eba3 0391 	subcs.w	r3, r3, r1, lsr #2
 8007a84:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8007a88:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
 8007a8c:	bf24      	itt	cs
 8007a8e:	eba3 03d1 	subcs.w	r3, r3, r1, lsr #3
 8007a92:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8007a96:	011b      	lsls	r3, r3, #4
 8007a98:	bf18      	it	ne
 8007a9a:	ea5f 1c1c 	movsne.w	ip, ip, lsr #4
 8007a9e:	d1e0      	bne.n	8007a62 <__aeabi_fdiv+0x46>
 8007aa0:	2afd      	cmp	r2, #253	; 0xfd
 8007aa2:	f63f af50 	bhi.w	8007946 <__aeabi_fmul+0x92>
 8007aa6:	428b      	cmp	r3, r1
 8007aa8:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 8007aac:	bf08      	it	eq
 8007aae:	f020 0001 	biceq.w	r0, r0, #1
 8007ab2:	4770      	bx	lr
 8007ab4:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 8007ab8:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 8007abc:	327f      	adds	r2, #127	; 0x7f
 8007abe:	bfc2      	ittt	gt
 8007ac0:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 8007ac4:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 8007ac8:	4770      	bxgt	lr
 8007aca:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8007ace:	f04f 0300 	mov.w	r3, #0
 8007ad2:	3a01      	subs	r2, #1
 8007ad4:	e737      	b.n	8007946 <__aeabi_fmul+0x92>
 8007ad6:	f092 0f00 	teq	r2, #0
 8007ada:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 8007ade:	bf02      	ittt	eq
 8007ae0:	0040      	lsleq	r0, r0, #1
 8007ae2:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 8007ae6:	3a01      	subeq	r2, #1
 8007ae8:	d0f9      	beq.n	8007ade <__aeabi_fdiv+0xc2>
 8007aea:	ea40 000c 	orr.w	r0, r0, ip
 8007aee:	f093 0f00 	teq	r3, #0
 8007af2:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8007af6:	bf02      	ittt	eq
 8007af8:	0049      	lsleq	r1, r1, #1
 8007afa:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 8007afe:	3b01      	subeq	r3, #1
 8007b00:	d0f9      	beq.n	8007af6 <__aeabi_fdiv+0xda>
 8007b02:	ea41 010c 	orr.w	r1, r1, ip
 8007b06:	e795      	b.n	8007a34 <__aeabi_fdiv+0x18>
 8007b08:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 8007b0c:	ea92 0f0c 	teq	r2, ip
 8007b10:	d108      	bne.n	8007b24 <__aeabi_fdiv+0x108>
 8007b12:	0242      	lsls	r2, r0, #9
 8007b14:	f47f af7d 	bne.w	8007a12 <__aeabi_fmul+0x15e>
 8007b18:	ea93 0f0c 	teq	r3, ip
 8007b1c:	f47f af70 	bne.w	8007a00 <__aeabi_fmul+0x14c>
 8007b20:	4608      	mov	r0, r1
 8007b22:	e776      	b.n	8007a12 <__aeabi_fmul+0x15e>
 8007b24:	ea93 0f0c 	teq	r3, ip
 8007b28:	d104      	bne.n	8007b34 <__aeabi_fdiv+0x118>
 8007b2a:	024b      	lsls	r3, r1, #9
 8007b2c:	f43f af4c 	beq.w	80079c8 <__aeabi_fmul+0x114>
 8007b30:	4608      	mov	r0, r1
 8007b32:	e76e      	b.n	8007a12 <__aeabi_fmul+0x15e>
 8007b34:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 8007b38:	bf18      	it	ne
 8007b3a:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 8007b3e:	d1ca      	bne.n	8007ad6 <__aeabi_fdiv+0xba>
 8007b40:	f030 4200 	bics.w	r2, r0, #2147483648	; 0x80000000
 8007b44:	f47f af5c 	bne.w	8007a00 <__aeabi_fmul+0x14c>
 8007b48:	f031 4300 	bics.w	r3, r1, #2147483648	; 0x80000000
 8007b4c:	f47f af3c 	bne.w	80079c8 <__aeabi_fmul+0x114>
 8007b50:	e75f      	b.n	8007a12 <__aeabi_fmul+0x15e>
 8007b52:	bf00      	nop

08007b54 <__gesf2>:
 8007b54:	f04f 3cff 	mov.w	ip, #4294967295
 8007b58:	e006      	b.n	8007b68 <__cmpsf2+0x4>
 8007b5a:	bf00      	nop

08007b5c <__lesf2>:
 8007b5c:	f04f 0c01 	mov.w	ip, #1
 8007b60:	e002      	b.n	8007b68 <__cmpsf2+0x4>
 8007b62:	bf00      	nop

08007b64 <__cmpsf2>:
 8007b64:	f04f 0c01 	mov.w	ip, #1
 8007b68:	f84d cd04 	str.w	ip, [sp, #-4]!
 8007b6c:	ea4f 0240 	mov.w	r2, r0, lsl #1
 8007b70:	ea4f 0341 	mov.w	r3, r1, lsl #1
 8007b74:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 8007b78:	bf18      	it	ne
 8007b7a:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 8007b7e:	d011      	beq.n	8007ba4 <__cmpsf2+0x40>
 8007b80:	b001      	add	sp, #4
 8007b82:	ea52 0c53 	orrs.w	ip, r2, r3, lsr #1
 8007b86:	bf18      	it	ne
 8007b88:	ea90 0f01 	teqne	r0, r1
 8007b8c:	bf58      	it	pl
 8007b8e:	ebb2 0003 	subspl.w	r0, r2, r3
 8007b92:	bf88      	it	hi
 8007b94:	17c8      	asrhi	r0, r1, #31
 8007b96:	bf38      	it	cc
 8007b98:	ea6f 70e1 	mvncc.w	r0, r1, asr #31
 8007b9c:	bf18      	it	ne
 8007b9e:	f040 0001 	orrne.w	r0, r0, #1
 8007ba2:	4770      	bx	lr
 8007ba4:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 8007ba8:	d102      	bne.n	8007bb0 <__cmpsf2+0x4c>
 8007baa:	ea5f 2c40 	movs.w	ip, r0, lsl #9
 8007bae:	d105      	bne.n	8007bbc <__cmpsf2+0x58>
 8007bb0:	ea7f 6c23 	mvns.w	ip, r3, asr #24
 8007bb4:	d1e4      	bne.n	8007b80 <__cmpsf2+0x1c>
 8007bb6:	ea5f 2c41 	movs.w	ip, r1, lsl #9
 8007bba:	d0e1      	beq.n	8007b80 <__cmpsf2+0x1c>
 8007bbc:	f85d 0b04 	ldr.w	r0, [sp], #4
 8007bc0:	4770      	bx	lr
 8007bc2:	bf00      	nop

08007bc4 <__aeabi_cfrcmple>:
 8007bc4:	4684      	mov	ip, r0
 8007bc6:	4608      	mov	r0, r1
 8007bc8:	4661      	mov	r1, ip
 8007bca:	e7ff      	b.n	8007bcc <__aeabi_cfcmpeq>

08007bcc <__aeabi_cfcmpeq>:
 8007bcc:	b50f      	push	{r0, r1, r2, r3, lr}
 8007bce:	f7ff ffc9 	bl	8007b64 <__cmpsf2>
 8007bd2:	2800      	cmp	r0, #0
 8007bd4:	bf48      	it	mi
 8007bd6:	f110 0f00 	cmnmi.w	r0, #0
 8007bda:	bd0f      	pop	{r0, r1, r2, r3, pc}

08007bdc <__aeabi_fcmpeq>:
 8007bdc:	f84d ed08 	str.w	lr, [sp, #-8]!
 8007be0:	f7ff fff4 	bl	8007bcc <__aeabi_cfcmpeq>
 8007be4:	bf0c      	ite	eq
 8007be6:	2001      	moveq	r0, #1
 8007be8:	2000      	movne	r0, #0
 8007bea:	f85d fb08 	ldr.w	pc, [sp], #8
 8007bee:	bf00      	nop

08007bf0 <__aeabi_fcmplt>:
 8007bf0:	f84d ed08 	str.w	lr, [sp, #-8]!
 8007bf4:	f7ff ffea 	bl	8007bcc <__aeabi_cfcmpeq>
 8007bf8:	bf34      	ite	cc
 8007bfa:	2001      	movcc	r0, #1
 8007bfc:	2000      	movcs	r0, #0
 8007bfe:	f85d fb08 	ldr.w	pc, [sp], #8
 8007c02:	bf00      	nop

08007c04 <__aeabi_fcmple>:
 8007c04:	f84d ed08 	str.w	lr, [sp, #-8]!
 8007c08:	f7ff ffe0 	bl	8007bcc <__aeabi_cfcmpeq>
 8007c0c:	bf94      	ite	ls
 8007c0e:	2001      	movls	r0, #1
 8007c10:	2000      	movhi	r0, #0
 8007c12:	f85d fb08 	ldr.w	pc, [sp], #8
 8007c16:	bf00      	nop

08007c18 <__aeabi_fcmpge>:
 8007c18:	f84d ed08 	str.w	lr, [sp, #-8]!
 8007c1c:	f7ff ffd2 	bl	8007bc4 <__aeabi_cfrcmple>
 8007c20:	bf94      	ite	ls
 8007c22:	2001      	movls	r0, #1
 8007c24:	2000      	movhi	r0, #0
 8007c26:	f85d fb08 	ldr.w	pc, [sp], #8
 8007c2a:	bf00      	nop

08007c2c <__aeabi_fcmpgt>:
 8007c2c:	f84d ed08 	str.w	lr, [sp, #-8]!
 8007c30:	f7ff ffc8 	bl	8007bc4 <__aeabi_cfrcmple>
 8007c34:	bf34      	ite	cc
 8007c36:	2001      	movcc	r0, #1
 8007c38:	2000      	movcs	r0, #0
 8007c3a:	f85d fb08 	ldr.w	pc, [sp], #8
 8007c3e:	bf00      	nop

08007c40 <__aeabi_f2iz>:
 8007c40:	ea4f 0240 	mov.w	r2, r0, lsl #1
 8007c44:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
 8007c48:	d30f      	bcc.n	8007c6a <__aeabi_f2iz+0x2a>
 8007c4a:	f04f 039e 	mov.w	r3, #158	; 0x9e
 8007c4e:	ebb3 6212 	subs.w	r2, r3, r2, lsr #24
 8007c52:	d90d      	bls.n	8007c70 <__aeabi_f2iz+0x30>
 8007c54:	ea4f 2300 	mov.w	r3, r0, lsl #8
 8007c58:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8007c5c:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
 8007c60:	fa23 f002 	lsr.w	r0, r3, r2
 8007c64:	bf18      	it	ne
 8007c66:	4240      	negne	r0, r0
 8007c68:	4770      	bx	lr
 8007c6a:	f04f 0000 	mov.w	r0, #0
 8007c6e:	4770      	bx	lr
 8007c70:	f112 0f61 	cmn.w	r2, #97	; 0x61
 8007c74:	d101      	bne.n	8007c7a <__aeabi_f2iz+0x3a>
 8007c76:	0242      	lsls	r2, r0, #9
 8007c78:	d105      	bne.n	8007c86 <__aeabi_f2iz+0x46>
 8007c7a:	f010 4000 	ands.w	r0, r0, #2147483648	; 0x80000000
 8007c7e:	bf08      	it	eq
 8007c80:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 8007c84:	4770      	bx	lr
 8007c86:	f04f 0000 	mov.w	r0, #0
 8007c8a:	4770      	bx	lr

08007c8c <__aeabi_f2uiz>:
 8007c8c:	0042      	lsls	r2, r0, #1
 8007c8e:	d20e      	bcs.n	8007cae <__aeabi_f2uiz+0x22>
 8007c90:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
 8007c94:	d30b      	bcc.n	8007cae <__aeabi_f2uiz+0x22>
 8007c96:	f04f 039e 	mov.w	r3, #158	; 0x9e
 8007c9a:	ebb3 6212 	subs.w	r2, r3, r2, lsr #24
 8007c9e:	d409      	bmi.n	8007cb4 <__aeabi_f2uiz+0x28>
 8007ca0:	ea4f 2300 	mov.w	r3, r0, lsl #8
 8007ca4:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8007ca8:	fa23 f002 	lsr.w	r0, r3, r2
 8007cac:	4770      	bx	lr
 8007cae:	f04f 0000 	mov.w	r0, #0
 8007cb2:	4770      	bx	lr
 8007cb4:	f112 0f61 	cmn.w	r2, #97	; 0x61
 8007cb8:	d101      	bne.n	8007cbe <__aeabi_f2uiz+0x32>
 8007cba:	0242      	lsls	r2, r0, #9
 8007cbc:	d102      	bne.n	8007cc4 <__aeabi_f2uiz+0x38>
 8007cbe:	f04f 30ff 	mov.w	r0, #4294967295
 8007cc2:	4770      	bx	lr
 8007cc4:	f04f 0000 	mov.w	r0, #0
 8007cc8:	4770      	bx	lr
 8007cca:	bf00      	nop

08007ccc <memcmp>:
 8007ccc:	2a03      	cmp	r2, #3
 8007cce:	b470      	push	{r4, r5, r6}
 8007cd0:	d922      	bls.n	8007d18 <memcmp+0x4c>
 8007cd2:	ea41 0300 	orr.w	r3, r1, r0
 8007cd6:	079b      	lsls	r3, r3, #30
 8007cd8:	d013      	beq.n	8007d02 <memcmp+0x36>
 8007cda:	7805      	ldrb	r5, [r0, #0]
 8007cdc:	3a01      	subs	r2, #1
 8007cde:	780c      	ldrb	r4, [r1, #0]
 8007ce0:	2300      	movs	r3, #0
 8007ce2:	42a5      	cmp	r5, r4
 8007ce4:	d006      	beq.n	8007cf4 <memcmp+0x28>
 8007ce6:	e01b      	b.n	8007d20 <memcmp+0x54>
 8007ce8:	f810 5f01 	ldrb.w	r5, [r0, #1]!
 8007cec:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 8007cf0:	42a5      	cmp	r5, r4
 8007cf2:	d115      	bne.n	8007d20 <memcmp+0x54>
 8007cf4:	4293      	cmp	r3, r2
 8007cf6:	f103 0301 	add.w	r3, r3, #1
 8007cfa:	d1f5      	bne.n	8007ce8 <memcmp+0x1c>
 8007cfc:	2000      	movs	r0, #0
 8007cfe:	bc70      	pop	{r4, r5, r6}
 8007d00:	4770      	bx	lr
 8007d02:	460c      	mov	r4, r1
 8007d04:	4603      	mov	r3, r0
 8007d06:	3104      	adds	r1, #4
 8007d08:	3004      	adds	r0, #4
 8007d0a:	681e      	ldr	r6, [r3, #0]
 8007d0c:	6825      	ldr	r5, [r4, #0]
 8007d0e:	42ae      	cmp	r6, r5
 8007d10:	d108      	bne.n	8007d24 <memcmp+0x58>
 8007d12:	3a04      	subs	r2, #4
 8007d14:	2a03      	cmp	r2, #3
 8007d16:	d8f4      	bhi.n	8007d02 <memcmp+0x36>
 8007d18:	2a00      	cmp	r2, #0
 8007d1a:	d1de      	bne.n	8007cda <memcmp+0xe>
 8007d1c:	4610      	mov	r0, r2
 8007d1e:	e7ee      	b.n	8007cfe <memcmp+0x32>
 8007d20:	1b28      	subs	r0, r5, r4
 8007d22:	e7ec      	b.n	8007cfe <memcmp+0x32>
 8007d24:	4621      	mov	r1, r4
 8007d26:	4618      	mov	r0, r3
 8007d28:	2a00      	cmp	r2, #0
 8007d2a:	d1d6      	bne.n	8007cda <memcmp+0xe>
 8007d2c:	e7f6      	b.n	8007d1c <memcmp+0x50>
 8007d2e:	bf00      	nop

08007d30 <memcpy>:
 8007d30:	2a03      	cmp	r2, #3
 8007d32:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8007d36:	d809      	bhi.n	8007d4c <memcpy+0x1c>
 8007d38:	b12a      	cbz	r2, 8007d46 <memcpy+0x16>
 8007d3a:	2300      	movs	r3, #0
 8007d3c:	5ccc      	ldrb	r4, [r1, r3]
 8007d3e:	54c4      	strb	r4, [r0, r3]
 8007d40:	3301      	adds	r3, #1
 8007d42:	4293      	cmp	r3, r2
 8007d44:	d1fa      	bne.n	8007d3c <memcpy+0xc>
 8007d46:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8007d4a:	4770      	bx	lr
 8007d4c:	0783      	lsls	r3, r0, #30
 8007d4e:	4402      	add	r2, r0
 8007d50:	d00e      	beq.n	8007d70 <memcpy+0x40>
 8007d52:	1c44      	adds	r4, r0, #1
 8007d54:	1c4d      	adds	r5, r1, #1
 8007d56:	f815 7c01 	ldrb.w	r7, [r5, #-1]
 8007d5a:	f004 0603 	and.w	r6, r4, #3
 8007d5e:	4623      	mov	r3, r4
 8007d60:	3401      	adds	r4, #1
 8007d62:	4629      	mov	r1, r5
 8007d64:	3501      	adds	r5, #1
 8007d66:	f804 7c02 	strb.w	r7, [r4, #-2]
 8007d6a:	2e00      	cmp	r6, #0
 8007d6c:	d1f3      	bne.n	8007d56 <memcpy+0x26>
 8007d6e:	e000      	b.n	8007d72 <memcpy+0x42>
 8007d70:	4603      	mov	r3, r0
 8007d72:	f011 0403 	ands.w	r4, r1, #3
 8007d76:	d06d      	beq.n	8007e54 <memcpy+0x124>
 8007d78:	1ad7      	subs	r7, r2, r3
 8007d7a:	1b0d      	subs	r5, r1, r4
 8007d7c:	2f03      	cmp	r7, #3
 8007d7e:	682e      	ldr	r6, [r5, #0]
 8007d80:	dd19      	ble.n	8007db6 <memcpy+0x86>
 8007d82:	f1c4 0c04 	rsb	ip, r4, #4
 8007d86:	ea4f 08c4 	mov.w	r8, r4, lsl #3
 8007d8a:	1d1c      	adds	r4, r3, #4
 8007d8c:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 8007d90:	f855 7f04 	ldr.w	r7, [r5, #4]!
 8007d94:	ebc4 0902 	rsb	r9, r4, r2
 8007d98:	4623      	mov	r3, r4
 8007d9a:	3104      	adds	r1, #4
 8007d9c:	3404      	adds	r4, #4
 8007d9e:	f1b9 0f03 	cmp.w	r9, #3
 8007da2:	fa26 fa08 	lsr.w	sl, r6, r8
 8007da6:	fa07 fb0c 	lsl.w	fp, r7, ip
 8007daa:	463e      	mov	r6, r7
 8007dac:	ea4b 070a 	orr.w	r7, fp, sl
 8007db0:	f844 7c08 	str.w	r7, [r4, #-8]
 8007db4:	dcec      	bgt.n	8007d90 <memcpy+0x60>
 8007db6:	429a      	cmp	r2, r3
 8007db8:	d9c5      	bls.n	8007d46 <memcpy+0x16>
 8007dba:	3301      	adds	r3, #1
 8007dbc:	3101      	adds	r1, #1
 8007dbe:	3201      	adds	r2, #1
 8007dc0:	f811 4c01 	ldrb.w	r4, [r1, #-1]
 8007dc4:	3301      	adds	r3, #1
 8007dc6:	3101      	adds	r1, #1
 8007dc8:	4293      	cmp	r3, r2
 8007dca:	f803 4c02 	strb.w	r4, [r3, #-2]
 8007dce:	d1f7      	bne.n	8007dc0 <memcpy+0x90>
 8007dd0:	e7b9      	b.n	8007d46 <memcpy+0x16>
 8007dd2:	680c      	ldr	r4, [r1, #0]
 8007dd4:	3340      	adds	r3, #64	; 0x40
 8007dd6:	3140      	adds	r1, #64	; 0x40
 8007dd8:	f843 4c40 	str.w	r4, [r3, #-64]
 8007ddc:	f851 4c3c 	ldr.w	r4, [r1, #-60]
 8007de0:	f843 4c3c 	str.w	r4, [r3, #-60]
 8007de4:	f851 4c38 	ldr.w	r4, [r1, #-56]
 8007de8:	f843 4c38 	str.w	r4, [r3, #-56]
 8007dec:	f851 4c34 	ldr.w	r4, [r1, #-52]
 8007df0:	f843 4c34 	str.w	r4, [r3, #-52]
 8007df4:	f851 4c30 	ldr.w	r4, [r1, #-48]
 8007df8:	f843 4c30 	str.w	r4, [r3, #-48]
 8007dfc:	f851 4c2c 	ldr.w	r4, [r1, #-44]
 8007e00:	f843 4c2c 	str.w	r4, [r3, #-44]
 8007e04:	f851 4c28 	ldr.w	r4, [r1, #-40]
 8007e08:	f843 4c28 	str.w	r4, [r3, #-40]
 8007e0c:	f851 4c24 	ldr.w	r4, [r1, #-36]
 8007e10:	f843 4c24 	str.w	r4, [r3, #-36]
 8007e14:	f851 4c20 	ldr.w	r4, [r1, #-32]
 8007e18:	f843 4c20 	str.w	r4, [r3, #-32]
 8007e1c:	f851 4c1c 	ldr.w	r4, [r1, #-28]
 8007e20:	f843 4c1c 	str.w	r4, [r3, #-28]
 8007e24:	f851 4c18 	ldr.w	r4, [r1, #-24]
 8007e28:	f843 4c18 	str.w	r4, [r3, #-24]
 8007e2c:	f851 4c14 	ldr.w	r4, [r1, #-20]
 8007e30:	f843 4c14 	str.w	r4, [r3, #-20]
 8007e34:	f851 4c10 	ldr.w	r4, [r1, #-16]
 8007e38:	f843 4c10 	str.w	r4, [r3, #-16]
 8007e3c:	f851 4c0c 	ldr.w	r4, [r1, #-12]
 8007e40:	f843 4c0c 	str.w	r4, [r3, #-12]
 8007e44:	f851 4c08 	ldr.w	r4, [r1, #-8]
 8007e48:	f843 4c08 	str.w	r4, [r3, #-8]
 8007e4c:	f851 4c04 	ldr.w	r4, [r1, #-4]
 8007e50:	f843 4c04 	str.w	r4, [r3, #-4]
 8007e54:	1ad4      	subs	r4, r2, r3
 8007e56:	2c3f      	cmp	r4, #63	; 0x3f
 8007e58:	dcbb      	bgt.n	8007dd2 <memcpy+0xa2>
 8007e5a:	e011      	b.n	8007e80 <memcpy+0x150>
 8007e5c:	680c      	ldr	r4, [r1, #0]
 8007e5e:	3310      	adds	r3, #16
 8007e60:	3110      	adds	r1, #16
 8007e62:	f843 4c10 	str.w	r4, [r3, #-16]
 8007e66:	f851 4c0c 	ldr.w	r4, [r1, #-12]
 8007e6a:	f843 4c0c 	str.w	r4, [r3, #-12]
 8007e6e:	f851 4c08 	ldr.w	r4, [r1, #-8]
 8007e72:	f843 4c08 	str.w	r4, [r3, #-8]
 8007e76:	f851 4c04 	ldr.w	r4, [r1, #-4]
 8007e7a:	f843 4c04 	str.w	r4, [r3, #-4]
 8007e7e:	1ad4      	subs	r4, r2, r3
 8007e80:	2c0f      	cmp	r4, #15
 8007e82:	dceb      	bgt.n	8007e5c <memcpy+0x12c>
 8007e84:	2c03      	cmp	r4, #3
 8007e86:	dd96      	ble.n	8007db6 <memcpy+0x86>
 8007e88:	1d1c      	adds	r4, r3, #4
 8007e8a:	1d0d      	adds	r5, r1, #4
 8007e8c:	f855 7c04 	ldr.w	r7, [r5, #-4]
 8007e90:	1b16      	subs	r6, r2, r4
 8007e92:	4623      	mov	r3, r4
 8007e94:	4629      	mov	r1, r5
 8007e96:	3404      	adds	r4, #4
 8007e98:	3504      	adds	r5, #4
 8007e9a:	2e03      	cmp	r6, #3
 8007e9c:	f844 7c08 	str.w	r7, [r4, #-8]
 8007ea0:	dcf4      	bgt.n	8007e8c <memcpy+0x15c>
 8007ea2:	e788      	b.n	8007db6 <memcpy+0x86>

08007ea4 <memset>:
 8007ea4:	2a03      	cmp	r2, #3
 8007ea6:	b2c9      	uxtb	r1, r1
 8007ea8:	b470      	push	{r4, r5, r6}
 8007eaa:	d808      	bhi.n	8007ebe <memset+0x1a>
 8007eac:	b12a      	cbz	r2, 8007eba <memset+0x16>
 8007eae:	4603      	mov	r3, r0
 8007eb0:	1812      	adds	r2, r2, r0
 8007eb2:	f803 1b01 	strb.w	r1, [r3], #1
 8007eb6:	4293      	cmp	r3, r2
 8007eb8:	d1fb      	bne.n	8007eb2 <memset+0xe>
 8007eba:	bc70      	pop	{r4, r5, r6}
 8007ebc:	4770      	bx	lr
 8007ebe:	0783      	lsls	r3, r0, #30
 8007ec0:	4402      	add	r2, r0
 8007ec2:	d009      	beq.n	8007ed8 <memset+0x34>
 8007ec4:	1c44      	adds	r4, r0, #1
 8007ec6:	f004 0503 	and.w	r5, r4, #3
 8007eca:	4623      	mov	r3, r4
 8007ecc:	f804 1c01 	strb.w	r1, [r4, #-1]
 8007ed0:	3401      	adds	r4, #1
 8007ed2:	2d00      	cmp	r5, #0
 8007ed4:	d1f7      	bne.n	8007ec6 <memset+0x22>
 8007ed6:	e000      	b.n	8007eda <memset+0x36>
 8007ed8:	4603      	mov	r3, r0
 8007eda:	1ad5      	subs	r5, r2, r3
 8007edc:	eb01 2401 	add.w	r4, r1, r1, lsl #8
 8007ee0:	2d3f      	cmp	r5, #63	; 0x3f
 8007ee2:	eb04 4404 	add.w	r4, r4, r4, lsl #16
 8007ee6:	dd2c      	ble.n	8007f42 <memset+0x9e>
 8007ee8:	601c      	str	r4, [r3, #0]
 8007eea:	3340      	adds	r3, #64	; 0x40
 8007eec:	1ad5      	subs	r5, r2, r3
 8007eee:	f843 4c3c 	str.w	r4, [r3, #-60]
 8007ef2:	2d3f      	cmp	r5, #63	; 0x3f
 8007ef4:	f843 4c38 	str.w	r4, [r3, #-56]
 8007ef8:	f843 4c34 	str.w	r4, [r3, #-52]
 8007efc:	f843 4c30 	str.w	r4, [r3, #-48]
 8007f00:	f843 4c2c 	str.w	r4, [r3, #-44]
 8007f04:	f843 4c28 	str.w	r4, [r3, #-40]
 8007f08:	f843 4c24 	str.w	r4, [r3, #-36]
 8007f0c:	f843 4c20 	str.w	r4, [r3, #-32]
 8007f10:	f843 4c1c 	str.w	r4, [r3, #-28]
 8007f14:	f843 4c18 	str.w	r4, [r3, #-24]
 8007f18:	f843 4c14 	str.w	r4, [r3, #-20]
 8007f1c:	f843 4c10 	str.w	r4, [r3, #-16]
 8007f20:	f843 4c0c 	str.w	r4, [r3, #-12]
 8007f24:	f843 4c08 	str.w	r4, [r3, #-8]
 8007f28:	f843 4c04 	str.w	r4, [r3, #-4]
 8007f2c:	dcdc      	bgt.n	8007ee8 <memset+0x44>
 8007f2e:	e008      	b.n	8007f42 <memset+0x9e>
 8007f30:	601c      	str	r4, [r3, #0]
 8007f32:	3310      	adds	r3, #16
 8007f34:	1ad5      	subs	r5, r2, r3
 8007f36:	f843 4c0c 	str.w	r4, [r3, #-12]
 8007f3a:	f843 4c08 	str.w	r4, [r3, #-8]
 8007f3e:	f843 4c04 	str.w	r4, [r3, #-4]
 8007f42:	2d0f      	cmp	r5, #15
 8007f44:	dcf4      	bgt.n	8007f30 <memset+0x8c>
 8007f46:	2d03      	cmp	r5, #3
 8007f48:	dd08      	ble.n	8007f5c <memset+0xb8>
 8007f4a:	1d1d      	adds	r5, r3, #4
 8007f4c:	1b56      	subs	r6, r2, r5
 8007f4e:	f845 4c04 	str.w	r4, [r5, #-4]
 8007f52:	2e03      	cmp	r6, #3
 8007f54:	462b      	mov	r3, r5
 8007f56:	f105 0504 	add.w	r5, r5, #4
 8007f5a:	dcf7      	bgt.n	8007f4c <memset+0xa8>
 8007f5c:	429a      	cmp	r2, r3
 8007f5e:	d9ac      	bls.n	8007eba <memset+0x16>
 8007f60:	3301      	adds	r3, #1
 8007f62:	3201      	adds	r2, #1
 8007f64:	f803 1c01 	strb.w	r1, [r3, #-1]
 8007f68:	3301      	adds	r3, #1
 8007f6a:	4293      	cmp	r3, r2
 8007f6c:	d1fa      	bne.n	8007f64 <memset+0xc0>
 8007f6e:	e7a4      	b.n	8007eba <memset+0x16>

08007f70 <strncpy>:
 8007f70:	ea41 0300 	orr.w	r3, r1, r0
 8007f74:	f013 0f03 	tst.w	r3, #3
 8007f78:	4603      	mov	r3, r0
 8007f7a:	b470      	push	{r4, r5, r6}
 8007f7c:	d025      	beq.n	8007fca <strncpy+0x5a>
 8007f7e:	b1aa      	cbz	r2, 8007fac <strncpy+0x3c>
 8007f80:	780c      	ldrb	r4, [r1, #0]
 8007f82:	3a01      	subs	r2, #1
 8007f84:	f803 4b01 	strb.w	r4, [r3], #1
 8007f88:	b14c      	cbz	r4, 8007f9e <strncpy+0x2e>
 8007f8a:	461c      	mov	r4, r3
 8007f8c:	b172      	cbz	r2, 8007fac <strncpy+0x3c>
 8007f8e:	f811 5f01 	ldrb.w	r5, [r1, #1]!
 8007f92:	3a01      	subs	r2, #1
 8007f94:	f804 5b01 	strb.w	r5, [r4], #1
 8007f98:	4623      	mov	r3, r4
 8007f9a:	2d00      	cmp	r5, #0
 8007f9c:	d1f6      	bne.n	8007f8c <strncpy+0x1c>
 8007f9e:	b12a      	cbz	r2, 8007fac <strncpy+0x3c>
 8007fa0:	189a      	adds	r2, r3, r2
 8007fa2:	2100      	movs	r1, #0
 8007fa4:	f803 1b01 	strb.w	r1, [r3], #1
 8007fa8:	4293      	cmp	r3, r2
 8007faa:	d1fb      	bne.n	8007fa4 <strncpy+0x34>
 8007fac:	bc70      	pop	{r4, r5, r6}
 8007fae:	4770      	bx	lr
 8007fb0:	460e      	mov	r6, r1
 8007fb2:	f851 4b04 	ldr.w	r4, [r1], #4
 8007fb6:	f1a4 3501 	sub.w	r5, r4, #16843009	; 0x1010101
 8007fba:	ea25 0504 	bic.w	r5, r5, r4
 8007fbe:	f015 3f80 	tst.w	r5, #2155905152	; 0x80808080
 8007fc2:	d105      	bne.n	8007fd0 <strncpy+0x60>
 8007fc4:	3a04      	subs	r2, #4
 8007fc6:	f843 4b04 	str.w	r4, [r3], #4
 8007fca:	2a03      	cmp	r2, #3
 8007fcc:	d8f0      	bhi.n	8007fb0 <strncpy+0x40>
 8007fce:	e7d6      	b.n	8007f7e <strncpy+0xe>
 8007fd0:	4631      	mov	r1, r6
 8007fd2:	e7d4      	b.n	8007f7e <strncpy+0xe>

08007fd4 <cosf>:
 8007fd4:	f640 73d8 	movw	r3, #4056	; 0xfd8
 8007fd8:	f020 4200 	bic.w	r2, r0, #2147483648	; 0x80000000
 8007fdc:	f6c3 7349 	movt	r3, #16201	; 0x3f49
 8007fe0:	4601      	mov	r1, r0
 8007fe2:	429a      	cmp	r2, r3
 8007fe4:	b500      	push	{lr}
 8007fe6:	b083      	sub	sp, #12
 8007fe8:	dd15      	ble.n	8008016 <cosf+0x42>
 8007fea:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
 8007fee:	db03      	blt.n	8007ff8 <cosf+0x24>
 8007ff0:	f7ff fb56 	bl	80076a0 <__aeabi_fsub>
 8007ff4:	b003      	add	sp, #12
 8007ff6:	bd00      	pop	{pc}
 8007ff8:	4669      	mov	r1, sp
 8007ffa:	f000 fd61 	bl	8008ac0 <__ieee754_rem_pio2f>
 8007ffe:	f000 0203 	and.w	r2, r0, #3
 8008002:	9800      	ldr	r0, [sp, #0]
 8008004:	2a01      	cmp	r2, #1
 8008006:	d010      	beq.n	800802a <cosf+0x56>
 8008008:	2a02      	cmp	r2, #2
 800800a:	d008      	beq.n	800801e <cosf+0x4a>
 800800c:	b99a      	cbnz	r2, 8008036 <cosf+0x62>
 800800e:	9901      	ldr	r1, [sp, #4]
 8008010:	f000 ff50 	bl	8008eb4 <__kernel_cosf>
 8008014:	e7ee      	b.n	8007ff4 <cosf+0x20>
 8008016:	2100      	movs	r1, #0
 8008018:	f000 ff4c 	bl	8008eb4 <__kernel_cosf>
 800801c:	e7ea      	b.n	8007ff4 <cosf+0x20>
 800801e:	9901      	ldr	r1, [sp, #4]
 8008020:	f000 ff48 	bl	8008eb4 <__kernel_cosf>
 8008024:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
 8008028:	e7e4      	b.n	8007ff4 <cosf+0x20>
 800802a:	9901      	ldr	r1, [sp, #4]
 800802c:	f001 fb4a 	bl	80096c4 <__kernel_sinf>
 8008030:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
 8008034:	e7de      	b.n	8007ff4 <cosf+0x20>
 8008036:	2201      	movs	r2, #1
 8008038:	9901      	ldr	r1, [sp, #4]
 800803a:	f001 fb43 	bl	80096c4 <__kernel_sinf>
 800803e:	e7d9      	b.n	8007ff4 <cosf+0x20>

08008040 <sinf>:
 8008040:	f640 73d8 	movw	r3, #4056	; 0xfd8
 8008044:	f020 4200 	bic.w	r2, r0, #2147483648	; 0x80000000
 8008048:	f6c3 7349 	movt	r3, #16201	; 0x3f49
 800804c:	4601      	mov	r1, r0
 800804e:	429a      	cmp	r2, r3
 8008050:	b500      	push	{lr}
 8008052:	b083      	sub	sp, #12
 8008054:	dd16      	ble.n	8008084 <sinf+0x44>
 8008056:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
 800805a:	db03      	blt.n	8008064 <sinf+0x24>
 800805c:	f7ff fb20 	bl	80076a0 <__aeabi_fsub>
 8008060:	b003      	add	sp, #12
 8008062:	bd00      	pop	{pc}
 8008064:	4669      	mov	r1, sp
 8008066:	f000 fd2b 	bl	8008ac0 <__ieee754_rem_pio2f>
 800806a:	f000 0003 	and.w	r0, r0, #3
 800806e:	2801      	cmp	r0, #1
 8008070:	d015      	beq.n	800809e <sinf+0x5e>
 8008072:	2802      	cmp	r0, #2
 8008074:	d00b      	beq.n	800808e <sinf+0x4e>
 8008076:	b9b8      	cbnz	r0, 80080a8 <sinf+0x68>
 8008078:	9800      	ldr	r0, [sp, #0]
 800807a:	2201      	movs	r2, #1
 800807c:	9901      	ldr	r1, [sp, #4]
 800807e:	f001 fb21 	bl	80096c4 <__kernel_sinf>
 8008082:	e7ed      	b.n	8008060 <sinf+0x20>
 8008084:	2100      	movs	r1, #0
 8008086:	2200      	movs	r2, #0
 8008088:	f001 fb1c 	bl	80096c4 <__kernel_sinf>
 800808c:	e7e8      	b.n	8008060 <sinf+0x20>
 800808e:	9800      	ldr	r0, [sp, #0]
 8008090:	2201      	movs	r2, #1
 8008092:	9901      	ldr	r1, [sp, #4]
 8008094:	f001 fb16 	bl	80096c4 <__kernel_sinf>
 8008098:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
 800809c:	e7e0      	b.n	8008060 <sinf+0x20>
 800809e:	9800      	ldr	r0, [sp, #0]
 80080a0:	9901      	ldr	r1, [sp, #4]
 80080a2:	f000 ff07 	bl	8008eb4 <__kernel_cosf>
 80080a6:	e7db      	b.n	8008060 <sinf+0x20>
 80080a8:	9800      	ldr	r0, [sp, #0]
 80080aa:	9901      	ldr	r1, [sp, #4]
 80080ac:	f000 ff02 	bl	8008eb4 <__kernel_cosf>
 80080b0:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
 80080b4:	e7d4      	b.n	8008060 <sinf+0x20>
 80080b6:	bf00      	nop

080080b8 <atan2>:
 80080b8:	f000 b8fa 	b.w	80082b0 <__ieee754_atan2>

080080bc <sqrt>:
 80080bc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80080c0:	b08a      	sub	sp, #40	; 0x28
 80080c2:	4604      	mov	r4, r0
 80080c4:	460d      	mov	r5, r1
 80080c6:	f000 fa03 	bl	80084d0 <__ieee754_sqrt>
 80080ca:	f240 0a48 	movw	sl, #72	; 0x48
 80080ce:	f2c2 0a00 	movt	sl, #8192	; 0x2000
 80080d2:	f99a 3000 	ldrsb.w	r3, [sl]
 80080d6:	3301      	adds	r3, #1
 80080d8:	4606      	mov	r6, r0
 80080da:	460f      	mov	r7, r1
 80080dc:	d00f      	beq.n	80080fe <sqrt+0x42>
 80080de:	4620      	mov	r0, r4
 80080e0:	4629      	mov	r1, r5
 80080e2:	f001 fd0d 	bl	8009b00 <__fpclassifyd>
 80080e6:	b150      	cbz	r0, 80080fe <sqrt+0x42>
 80080e8:	f04f 0800 	mov.w	r8, #0
 80080ec:	f04f 0900 	mov.w	r9, #0
 80080f0:	4620      	mov	r0, r4
 80080f2:	4629      	mov	r1, r5
 80080f4:	4642      	mov	r2, r8
 80080f6:	464b      	mov	r3, r9
 80080f8:	f002 f996 	bl	800a428 <__aeabi_dcmplt>
 80080fc:	b920      	cbnz	r0, 8008108 <sqrt+0x4c>
 80080fe:	4630      	mov	r0, r6
 8008100:	4639      	mov	r1, r7
 8008102:	b00a      	add	sp, #40	; 0x28
 8008104:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8008108:	f89a 6000 	ldrb.w	r6, [sl]
 800810c:	f64a 2310 	movw	r3, #43536	; 0xaa10
 8008110:	f6c0 0300 	movt	r3, #2048	; 0x800
 8008114:	2201      	movs	r2, #1
 8008116:	e9cd 4504 	strd	r4, r5, [sp, #16]
 800811a:	e88d 000c 	stmia.w	sp, {r2, r3}
 800811e:	2300      	movs	r3, #0
 8008120:	e9cd 4502 	strd	r4, r5, [sp, #8]
 8008124:	9308      	str	r3, [sp, #32]
 8008126:	b956      	cbnz	r6, 800813e <sqrt+0x82>
 8008128:	e9cd 8906 	strd	r8, r9, [sp, #24]
 800812c:	4668      	mov	r0, sp
 800812e:	f001 fd0f 	bl	8009b50 <matherr>
 8008132:	b170      	cbz	r0, 8008152 <sqrt+0x96>
 8008134:	9b08      	ldr	r3, [sp, #32]
 8008136:	b98b      	cbnz	r3, 800815c <sqrt+0xa0>
 8008138:	e9dd 6706 	ldrd	r6, r7, [sp, #24]
 800813c:	e7df      	b.n	80080fe <sqrt+0x42>
 800813e:	4640      	mov	r0, r8
 8008140:	4649      	mov	r1, r9
 8008142:	4642      	mov	r2, r8
 8008144:	464b      	mov	r3, r9
 8008146:	f002 f827 	bl	800a198 <__aeabi_ddiv>
 800814a:	2e02      	cmp	r6, #2
 800814c:	e9cd 0106 	strd	r0, r1, [sp, #24]
 8008150:	d1ec      	bne.n	800812c <sqrt+0x70>
 8008152:	f001 fef1 	bl	8009f38 <__errno>
 8008156:	2321      	movs	r3, #33	; 0x21
 8008158:	6003      	str	r3, [r0, #0]
 800815a:	e7eb      	b.n	8008134 <sqrt+0x78>
 800815c:	f001 feec 	bl	8009f38 <__errno>
 8008160:	9b08      	ldr	r3, [sp, #32]
 8008162:	6003      	str	r3, [r0, #0]
 8008164:	e7e8      	b.n	8008138 <sqrt+0x7c>
 8008166:	bf00      	nop

08008168 <asinf>:
 8008168:	b570      	push	{r4, r5, r6, lr}
 800816a:	b08a      	sub	sp, #40	; 0x28
 800816c:	4606      	mov	r6, r0
 800816e:	f000 fa75 	bl	800865c <__ieee754_asinf>
 8008172:	f240 0448 	movw	r4, #72	; 0x48
 8008176:	f2c2 0400 	movt	r4, #8192	; 0x2000
 800817a:	f994 3000 	ldrsb.w	r3, [r4]
 800817e:	3301      	adds	r3, #1
 8008180:	4605      	mov	r5, r0
 8008182:	d003      	beq.n	800818c <asinf+0x24>
 8008184:	4630      	mov	r0, r6
 8008186:	f001 fe55 	bl	8009e34 <__fpclassifyf>
 800818a:	b910      	cbnz	r0, 8008192 <asinf+0x2a>
 800818c:	4628      	mov	r0, r5
 800818e:	b00a      	add	sp, #40	; 0x28
 8008190:	bd70      	pop	{r4, r5, r6, pc}
 8008192:	4630      	mov	r0, r6
 8008194:	f001 fe02 	bl	8009d9c <fabsf>
 8008198:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 800819c:	f7ff fd46 	bl	8007c2c <__aeabi_fcmpgt>
 80081a0:	2800      	cmp	r0, #0
 80081a2:	d0f3      	beq.n	800818c <asinf+0x24>
 80081a4:	f64a 2318 	movw	r3, #43544	; 0xaa18
 80081a8:	4630      	mov	r0, r6
 80081aa:	f6c0 0300 	movt	r3, #2048	; 0x800
 80081ae:	9301      	str	r3, [sp, #4]
 80081b0:	2301      	movs	r3, #1
 80081b2:	9300      	str	r3, [sp, #0]
 80081b4:	2300      	movs	r3, #0
 80081b6:	9308      	str	r3, [sp, #32]
 80081b8:	f7ff f9a2 	bl	8007500 <__aeabi_f2d>
 80081bc:	4602      	mov	r2, r0
 80081be:	f64a 2014 	movw	r0, #43540	; 0xaa14
 80081c2:	f6c0 0000 	movt	r0, #2048	; 0x800
 80081c6:	460b      	mov	r3, r1
 80081c8:	e9cd 2304 	strd	r2, r3, [sp, #16]
 80081cc:	e9cd 2302 	strd	r2, r3, [sp, #8]
 80081d0:	f001 fcc0 	bl	8009b54 <nan>
 80081d4:	f994 3000 	ldrsb.w	r3, [r4]
 80081d8:	2b02      	cmp	r3, #2
 80081da:	e9cd 0106 	strd	r0, r1, [sp, #24]
 80081de:	d00b      	beq.n	80081f8 <asinf+0x90>
 80081e0:	4668      	mov	r0, sp
 80081e2:	f001 fcb5 	bl	8009b50 <matherr>
 80081e6:	b138      	cbz	r0, 80081f8 <asinf+0x90>
 80081e8:	9b08      	ldr	r3, [sp, #32]
 80081ea:	b953      	cbnz	r3, 8008202 <asinf+0x9a>
 80081ec:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 80081f0:	f7ff fa02 	bl	80075f8 <__aeabi_d2f>
 80081f4:	4605      	mov	r5, r0
 80081f6:	e7c9      	b.n	800818c <asinf+0x24>
 80081f8:	f001 fe9e 	bl	8009f38 <__errno>
 80081fc:	2321      	movs	r3, #33	; 0x21
 80081fe:	6003      	str	r3, [r0, #0]
 8008200:	e7f2      	b.n	80081e8 <asinf+0x80>
 8008202:	f001 fe99 	bl	8009f38 <__errno>
 8008206:	9b08      	ldr	r3, [sp, #32]
 8008208:	6003      	str	r3, [r0, #0]
 800820a:	e7ef      	b.n	80081ec <asinf+0x84>

0800820c <atan2f>:
 800820c:	f000 bbb2 	b.w	8008974 <__ieee754_atan2f>

08008210 <sqrtf>:
 8008210:	b570      	push	{r4, r5, r6, lr}
 8008212:	b08a      	sub	sp, #40	; 0x28
 8008214:	4605      	mov	r5, r0
 8008216:	f000 fdf9 	bl	8008e0c <__ieee754_sqrtf>
 800821a:	f240 0448 	movw	r4, #72	; 0x48
 800821e:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8008222:	f994 3000 	ldrsb.w	r3, [r4]
 8008226:	3301      	adds	r3, #1
 8008228:	4606      	mov	r6, r0
 800822a:	d008      	beq.n	800823e <sqrtf+0x2e>
 800822c:	4628      	mov	r0, r5
 800822e:	f001 fe01 	bl	8009e34 <__fpclassifyf>
 8008232:	b120      	cbz	r0, 800823e <sqrtf+0x2e>
 8008234:	4628      	mov	r0, r5
 8008236:	2100      	movs	r1, #0
 8008238:	f7ff fcda 	bl	8007bf0 <__aeabi_fcmplt>
 800823c:	b910      	cbnz	r0, 8008244 <sqrtf+0x34>
 800823e:	4630      	mov	r0, r6
 8008240:	b00a      	add	sp, #40	; 0x28
 8008242:	bd70      	pop	{r4, r5, r6, pc}
 8008244:	f64a 2320 	movw	r3, #43552	; 0xaa20
 8008248:	4628      	mov	r0, r5
 800824a:	f6c0 0300 	movt	r3, #2048	; 0x800
 800824e:	9301      	str	r3, [sp, #4]
 8008250:	2301      	movs	r3, #1
 8008252:	9300      	str	r3, [sp, #0]
 8008254:	2300      	movs	r3, #0
 8008256:	9308      	str	r3, [sp, #32]
 8008258:	f7ff f952 	bl	8007500 <__aeabi_f2d>
 800825c:	7824      	ldrb	r4, [r4, #0]
 800825e:	e9cd 0104 	strd	r0, r1, [sp, #16]
 8008262:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8008266:	b97c      	cbnz	r4, 8008288 <sqrtf+0x78>
 8008268:	2200      	movs	r2, #0
 800826a:	2300      	movs	r3, #0
 800826c:	e9cd 2306 	strd	r2, r3, [sp, #24]
 8008270:	4668      	mov	r0, sp
 8008272:	f001 fc6d 	bl	8009b50 <matherr>
 8008276:	b188      	cbz	r0, 800829c <sqrtf+0x8c>
 8008278:	9b08      	ldr	r3, [sp, #32]
 800827a:	b9a3      	cbnz	r3, 80082a6 <sqrtf+0x96>
 800827c:	e9dd 0106 	ldrd	r0, r1, [sp, #24]
 8008280:	f7ff f9ba 	bl	80075f8 <__aeabi_d2f>
 8008284:	4606      	mov	r6, r0
 8008286:	e7da      	b.n	800823e <sqrtf+0x2e>
 8008288:	2000      	movs	r0, #0
 800828a:	2100      	movs	r1, #0
 800828c:	4602      	mov	r2, r0
 800828e:	460b      	mov	r3, r1
 8008290:	f001 ff82 	bl	800a198 <__aeabi_ddiv>
 8008294:	2c02      	cmp	r4, #2
 8008296:	e9cd 0106 	strd	r0, r1, [sp, #24]
 800829a:	d1e9      	bne.n	8008270 <sqrtf+0x60>
 800829c:	f001 fe4c 	bl	8009f38 <__errno>
 80082a0:	2321      	movs	r3, #33	; 0x21
 80082a2:	6003      	str	r3, [r0, #0]
 80082a4:	e7e8      	b.n	8008278 <sqrtf+0x68>
 80082a6:	f001 fe47 	bl	8009f38 <__errno>
 80082aa:	9b08      	ldr	r3, [sp, #32]
 80082ac:	6003      	str	r3, [r0, #0]
 80082ae:	e7e5      	b.n	800827c <sqrtf+0x6c>

080082b0 <__ieee754_atan2>:
 80082b0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80082b4:	b084      	sub	sp, #16
 80082b6:	2600      	movs	r6, #0
 80082b8:	4604      	mov	r4, r0
 80082ba:	e9cd 2300 	strd	r2, r3, [sp]
 80082be:	f6c7 76f0 	movt	r6, #32752	; 0x7ff0
 80082c2:	e89d 1080 	ldmia.w	sp, {r7, ip}
 80082c6:	460d      	mov	r5, r1
 80082c8:	e9cd 2302 	strd	r2, r3, [sp, #8]
 80082cc:	4602      	mov	r2, r0
 80082ce:	f1c7 0900 	rsb	r9, r7, #0
 80082d2:	f02c 4800 	bic.w	r8, ip, #2147483648	; 0x80000000
 80082d6:	ea49 0907 	orr.w	r9, r9, r7
 80082da:	460b      	mov	r3, r1
 80082dc:	ea48 79d9 	orr.w	r9, r8, r9, lsr #31
 80082e0:	45b1      	cmp	r9, r6
 80082e2:	d84f      	bhi.n	8008384 <__ieee754_atan2+0xd4>
 80082e4:	f1c0 0a00 	rsb	sl, r0, #0
 80082e8:	f021 4900 	bic.w	r9, r1, #2147483648	; 0x80000000
 80082ec:	ea4a 0a00 	orr.w	sl, sl, r0
 80082f0:	ea49 7ada 	orr.w	sl, r9, sl, lsr #31
 80082f4:	45b2      	cmp	sl, r6
 80082f6:	d845      	bhi.n	8008384 <__ieee754_atan2+0xd4>
 80082f8:	f10c 4c40 	add.w	ip, ip, #3221225472	; 0xc0000000
 80082fc:	f8dd a004 	ldr.w	sl, [sp, #4]
 8008300:	f50c 1c80 	add.w	ip, ip, #1048576	; 0x100000
 8008304:	ea5c 0c07 	orrs.w	ip, ip, r7
 8008308:	d05c      	beq.n	80083c4 <__ieee754_atan2+0x114>
 800830a:	ea4f 76aa 	mov.w	r6, sl, asr #30
 800830e:	ea59 0202 	orrs.w	r2, r9, r2
 8008312:	f006 0602 	and.w	r6, r6, #2
 8008316:	ea46 76d1 	orr.w	r6, r6, r1, lsr #31
 800831a:	d040      	beq.n	800839e <__ieee754_atan2+0xee>
 800831c:	ea58 0707 	orrs.w	r7, r8, r7
 8008320:	d04a      	beq.n	80083b8 <__ieee754_atan2+0x108>
 8008322:	2200      	movs	r2, #0
 8008324:	f6c7 72f0 	movt	r2, #32752	; 0x7ff0
 8008328:	4590      	cmp	r8, r2
 800832a:	d05c      	beq.n	80083e6 <__ieee754_atan2+0x136>
 800832c:	2200      	movs	r2, #0
 800832e:	f6c7 72f0 	movt	r2, #32752	; 0x7ff0
 8008332:	4591      	cmp	r9, r2
 8008334:	d040      	beq.n	80083b8 <__ieee754_atan2+0x108>
 8008336:	ebc8 0809 	rsb	r8, r8, r9
 800833a:	ea4f 5828 	mov.w	r8, r8, asr #20
 800833e:	f1b8 0f3c 	cmp.w	r8, #60	; 0x3c
 8008342:	dc4c      	bgt.n	80083de <__ieee754_atan2+0x12e>
 8008344:	f118 0f3c 	cmn.w	r8, #60	; 0x3c
 8008348:	bfac      	ite	ge
 800834a:	f04f 0800 	movge.w	r8, #0
 800834e:	f04f 0801 	movlt.w	r8, #1
 8008352:	ea18 78da 	ands.w	r8, r8, sl, lsr #31
 8008356:	d073      	beq.n	8008440 <__ieee754_atan2+0x190>
 8008358:	2000      	movs	r0, #0
 800835a:	2100      	movs	r1, #0
 800835c:	2e01      	cmp	r6, #1
 800835e:	d06b      	beq.n	8008438 <__ieee754_atan2+0x188>
 8008360:	2e02      	cmp	r6, #2
 8008362:	d05a      	beq.n	800841a <__ieee754_atan2+0x16a>
 8008364:	4604      	mov	r4, r0
 8008366:	460d      	mov	r5, r1
 8008368:	b1a6      	cbz	r6, 8008394 <__ieee754_atan2+0xe4>
 800836a:	a347      	add	r3, pc, #284	; (adr r3, 8008488 <__ieee754_atan2+0x1d8>)
 800836c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008370:	f7fe ff66 	bl	8007240 <__aeabi_dsub>
 8008374:	a346      	add	r3, pc, #280	; (adr r3, 8008490 <__ieee754_atan2+0x1e0>)
 8008376:	e9d3 2300 	ldrd	r2, r3, [r3]
 800837a:	f7fe ff61 	bl	8007240 <__aeabi_dsub>
 800837e:	4604      	mov	r4, r0
 8008380:	460d      	mov	r5, r1
 8008382:	e007      	b.n	8008394 <__ieee754_atan2+0xe4>
 8008384:	4620      	mov	r0, r4
 8008386:	4629      	mov	r1, r5
 8008388:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800838c:	f7fe ff5a 	bl	8007244 <__adddf3>
 8008390:	4604      	mov	r4, r0
 8008392:	460d      	mov	r5, r1
 8008394:	4620      	mov	r0, r4
 8008396:	4629      	mov	r1, r5
 8008398:	b004      	add	sp, #16
 800839a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800839e:	2e03      	cmp	r6, #3
 80083a0:	d8bc      	bhi.n	800831c <__ieee754_atan2+0x6c>
 80083a2:	a201      	add	r2, pc, #4	; (adr r2, 80083a8 <__ieee754_atan2+0xf8>)
 80083a4:	f852 f026 	ldr.w	pc, [r2, r6, lsl #2]
 80083a8:	08008395 	.word	0x08008395
 80083ac:	08008395 	.word	0x08008395
 80083b0:	080083d7 	.word	0x080083d7
 80083b4:	080083cf 	.word	0x080083cf
 80083b8:	2b00      	cmp	r3, #0
 80083ba:	db2a      	blt.n	8008412 <__ieee754_atan2+0x162>
 80083bc:	a536      	add	r5, pc, #216	; (adr r5, 8008498 <__ieee754_atan2+0x1e8>)
 80083be:	e9d5 4500 	ldrd	r4, r5, [r5]
 80083c2:	e7e7      	b.n	8008394 <__ieee754_atan2+0xe4>
 80083c4:	b004      	add	sp, #16
 80083c6:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80083ca:	f001 b9fd 	b.w	80097c8 <atan>
 80083ce:	a534      	add	r5, pc, #208	; (adr r5, 80084a0 <__ieee754_atan2+0x1f0>)
 80083d0:	e9d5 4500 	ldrd	r4, r5, [r5]
 80083d4:	e7de      	b.n	8008394 <__ieee754_atan2+0xe4>
 80083d6:	a52e      	add	r5, pc, #184	; (adr r5, 8008490 <__ieee754_atan2+0x1e0>)
 80083d8:	e9d5 4500 	ldrd	r4, r5, [r5]
 80083dc:	e7da      	b.n	8008394 <__ieee754_atan2+0xe4>
 80083de:	a12e      	add	r1, pc, #184	; (adr r1, 8008498 <__ieee754_atan2+0x1e8>)
 80083e0:	e9d1 0100 	ldrd	r0, r1, [r1]
 80083e4:	e7ba      	b.n	800835c <__ieee754_atan2+0xac>
 80083e6:	45c1      	cmp	r9, r8
 80083e8:	d035      	beq.n	8008456 <__ieee754_atan2+0x1a6>
 80083ea:	2e03      	cmp	r6, #3
 80083ec:	d89e      	bhi.n	800832c <__ieee754_atan2+0x7c>
 80083ee:	a201      	add	r2, pc, #4	; (adr r2, 80083f4 <__ieee754_atan2+0x144>)
 80083f0:	f852 f026 	ldr.w	pc, [r2, r6, lsl #2]
 80083f4:	0800840d 	.word	0x0800840d
 80083f8:	08008405 	.word	0x08008405
 80083fc:	080083d7 	.word	0x080083d7
 8008400:	080083cf 	.word	0x080083cf
 8008404:	2400      	movs	r4, #0
 8008406:	f04f 4500 	mov.w	r5, #2147483648	; 0x80000000
 800840a:	e7c3      	b.n	8008394 <__ieee754_atan2+0xe4>
 800840c:	2400      	movs	r4, #0
 800840e:	2500      	movs	r5, #0
 8008410:	e7c0      	b.n	8008394 <__ieee754_atan2+0xe4>
 8008412:	a525      	add	r5, pc, #148	; (adr r5, 80084a8 <__ieee754_atan2+0x1f8>)
 8008414:	e9d5 4500 	ldrd	r4, r5, [r5]
 8008418:	e7bc      	b.n	8008394 <__ieee754_atan2+0xe4>
 800841a:	a31b      	add	r3, pc, #108	; (adr r3, 8008488 <__ieee754_atan2+0x1d8>)
 800841c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8008420:	f7fe ff0e 	bl	8007240 <__aeabi_dsub>
 8008424:	4602      	mov	r2, r0
 8008426:	460b      	mov	r3, r1
 8008428:	a119      	add	r1, pc, #100	; (adr r1, 8008490 <__ieee754_atan2+0x1e0>)
 800842a:	e9d1 0100 	ldrd	r0, r1, [r1]
 800842e:	f7fe ff07 	bl	8007240 <__aeabi_dsub>
 8008432:	4604      	mov	r4, r0
 8008434:	460d      	mov	r5, r1
 8008436:	e7ad      	b.n	8008394 <__ieee754_atan2+0xe4>
 8008438:	4604      	mov	r4, r0
 800843a:	f101 4500 	add.w	r5, r1, #2147483648	; 0x80000000
 800843e:	e7a9      	b.n	8008394 <__ieee754_atan2+0xe4>
 8008440:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8008444:	4620      	mov	r0, r4
 8008446:	4629      	mov	r1, r5
 8008448:	f001 fea6 	bl	800a198 <__aeabi_ddiv>
 800844c:	f001 fb54 	bl	8009af8 <fabs>
 8008450:	f001 f9ba 	bl	80097c8 <atan>
 8008454:	e782      	b.n	800835c <__ieee754_atan2+0xac>
 8008456:	2e03      	cmp	r6, #3
 8008458:	d8ae      	bhi.n	80083b8 <__ieee754_atan2+0x108>
 800845a:	e8df f006 	tbb	[pc, r6]
 800845e:	0a0e      	.short	0x0a0e
 8008460:	0206      	.short	0x0206
 8008462:	a513      	add	r5, pc, #76	; (adr r5, 80084b0 <__ieee754_atan2+0x200>)
 8008464:	e9d5 4500 	ldrd	r4, r5, [r5]
 8008468:	e794      	b.n	8008394 <__ieee754_atan2+0xe4>
 800846a:	a513      	add	r5, pc, #76	; (adr r5, 80084b8 <__ieee754_atan2+0x208>)
 800846c:	e9d5 4500 	ldrd	r4, r5, [r5]
 8008470:	e790      	b.n	8008394 <__ieee754_atan2+0xe4>
 8008472:	a513      	add	r5, pc, #76	; (adr r5, 80084c0 <__ieee754_atan2+0x210>)
 8008474:	e9d5 4500 	ldrd	r4, r5, [r5]
 8008478:	e78c      	b.n	8008394 <__ieee754_atan2+0xe4>
 800847a:	a513      	add	r5, pc, #76	; (adr r5, 80084c8 <__ieee754_atan2+0x218>)
 800847c:	e9d5 4500 	ldrd	r4, r5, [r5]
 8008480:	e788      	b.n	8008394 <__ieee754_atan2+0xe4>
 8008482:	bf00      	nop
 8008484:	f3af 8000 	nop.w
 8008488:	33145c07 	.word	0x33145c07
 800848c:	3ca1a626 	.word	0x3ca1a626
 8008490:	54442d18 	.word	0x54442d18
 8008494:	400921fb 	.word	0x400921fb
 8008498:	54442d18 	.word	0x54442d18
 800849c:	3ff921fb 	.word	0x3ff921fb
 80084a0:	54442d18 	.word	0x54442d18
 80084a4:	c00921fb 	.word	0xc00921fb
 80084a8:	54442d18 	.word	0x54442d18
 80084ac:	bff921fb 	.word	0xbff921fb
 80084b0:	7f3321d2 	.word	0x7f3321d2
 80084b4:	c002d97c 	.word	0xc002d97c
 80084b8:	7f3321d2 	.word	0x7f3321d2
 80084bc:	4002d97c 	.word	0x4002d97c
 80084c0:	54442d18 	.word	0x54442d18
 80084c4:	bfe921fb 	.word	0xbfe921fb
 80084c8:	54442d18 	.word	0x54442d18
 80084cc:	3fe921fb 	.word	0x3fe921fb

080084d0 <__ieee754_sqrt>:
 80084d0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80084d4:	2700      	movs	r7, #0
 80084d6:	46b9      	mov	r9, r7
 80084d8:	f6c7 77f0 	movt	r7, #32752	; 0x7ff0
 80084dc:	f6c7 79f0 	movt	r9, #32752	; 0x7ff0
 80084e0:	400f      	ands	r7, r1
 80084e2:	454f      	cmp	r7, r9
 80084e4:	4604      	mov	r4, r0
 80084e6:	460d      	mov	r5, r1
 80084e8:	4602      	mov	r2, r0
 80084ea:	460b      	mov	r3, r1
 80084ec:	460e      	mov	r6, r1
 80084ee:	4680      	mov	r8, r0
 80084f0:	f000 8099 	beq.w	8008626 <__ieee754_sqrt+0x156>
 80084f4:	2900      	cmp	r1, #0
 80084f6:	dd77      	ble.n	80085e8 <__ieee754_sqrt+0x118>
 80084f8:	150f      	asrs	r7, r1, #20
 80084fa:	f000 8082 	beq.w	8008602 <__ieee754_sqrt+0x132>
 80084fe:	f026 437f 	bic.w	r3, r6, #4278190080	; 0xff000000
 8008502:	f2a7 37ff 	subw	r7, r7, #1023	; 0x3ff
 8008506:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
 800850a:	07fa      	lsls	r2, r7, #31
 800850c:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8008510:	bf44      	itt	mi
 8008512:	ea4f 72d8 	movmi.w	r2, r8, lsr #31
 8008516:	ea4f 0848 	movmi.w	r8, r8, lsl #1
 800851a:	f04f 0c00 	mov.w	ip, #0
 800851e:	bf48      	it	mi
 8008520:	eb02 0343 	addmi.w	r3, r2, r3, lsl #1
 8008524:	4660      	mov	r0, ip
 8008526:	ea4f 72d8 	mov.w	r2, r8, lsr #31
 800852a:	107f      	asrs	r7, r7, #1
 800852c:	eb02 0343 	add.w	r3, r2, r3, lsl #1
 8008530:	2416      	movs	r4, #22
 8008532:	ea4f 0248 	mov.w	r2, r8, lsl #1
 8008536:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 800853a:	1845      	adds	r5, r0, r1
 800853c:	0fd6      	lsrs	r6, r2, #31
 800853e:	429d      	cmp	r5, r3
 8008540:	ea4f 0242 	mov.w	r2, r2, lsl #1
 8008544:	bfde      	ittt	le
 8008546:	ebc5 0303 	rsble	r3, r5, r3
 800854a:	1868      	addle	r0, r5, r1
 800854c:	448c      	addle	ip, r1
 800854e:	0849      	lsrs	r1, r1, #1
 8008550:	3c01      	subs	r4, #1
 8008552:	eb06 0343 	add.w	r3, r6, r3, lsl #1
 8008556:	d1f0      	bne.n	800853a <__ieee754_sqrt+0x6a>
 8008558:	2620      	movs	r6, #32
 800855a:	46a0      	mov	r8, r4
 800855c:	f04f 4100 	mov.w	r1, #2147483648	; 0x80000000
 8008560:	e00e      	b.n	8008580 <__ieee754_sqrt+0xb0>
 8008562:	4681      	mov	r9, r0
 8008564:	1a1b      	subs	r3, r3, r0
 8008566:	4295      	cmp	r5, r2
 8008568:	bf88      	it	hi
 800856a:	3b01      	subhi	r3, #1
 800856c:	1b52      	subs	r2, r2, r5
 800856e:	1864      	adds	r4, r4, r1
 8008570:	4648      	mov	r0, r9
 8008572:	0fd5      	lsrs	r5, r2, #31
 8008574:	0849      	lsrs	r1, r1, #1
 8008576:	0052      	lsls	r2, r2, #1
 8008578:	3e01      	subs	r6, #1
 800857a:	eb05 0343 	add.w	r3, r5, r3, lsl #1
 800857e:	d015      	beq.n	80085ac <__ieee754_sqrt+0xdc>
 8008580:	4298      	cmp	r0, r3
 8008582:	eb01 0508 	add.w	r5, r1, r8
 8008586:	db03      	blt.n	8008590 <__ieee754_sqrt+0xc0>
 8008588:	4295      	cmp	r5, r2
 800858a:	bf98      	it	ls
 800858c:	4283      	cmpls	r3, r0
 800858e:	d1f0      	bne.n	8008572 <__ieee754_sqrt+0xa2>
 8008590:	f005 4900 	and.w	r9, r5, #2147483648	; 0x80000000
 8008594:	eb05 0801 	add.w	r8, r5, r1
 8008598:	f1b9 4f00 	cmp.w	r9, #2147483648	; 0x80000000
 800859c:	d1e1      	bne.n	8008562 <__ieee754_sqrt+0x92>
 800859e:	f1b8 0f00 	cmp.w	r8, #0
 80085a2:	bfa8      	it	ge
 80085a4:	f100 0901 	addge.w	r9, r0, #1
 80085a8:	dadc      	bge.n	8008564 <__ieee754_sqrt+0x94>
 80085aa:	e7da      	b.n	8008562 <__ieee754_sqrt+0x92>
 80085ac:	4313      	orrs	r3, r2
 80085ae:	d112      	bne.n	80085d6 <__ieee754_sqrt+0x106>
 80085b0:	0866      	lsrs	r6, r4, #1
 80085b2:	ea4f 036c 	mov.w	r3, ip, asr #1
 80085b6:	f01c 0f01 	tst.w	ip, #1
 80085ba:	f103 537f 	add.w	r3, r3, #1069547520	; 0x3fc00000
 80085be:	bf18      	it	ne
 80085c0:	f046 4600 	orrne.w	r6, r6, #2147483648	; 0x80000000
 80085c4:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
 80085c8:	4634      	mov	r4, r6
 80085ca:	eb03 5507 	add.w	r5, r3, r7, lsl #20
 80085ce:	4620      	mov	r0, r4
 80085d0:	4629      	mov	r1, r5
 80085d2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80085d6:	1c63      	adds	r3, r4, #1
 80085d8:	bf08      	it	eq
 80085da:	f10c 0c01 	addeq.w	ip, ip, #1
 80085de:	d0e8      	beq.n	80085b2 <__ieee754_sqrt+0xe2>
 80085e0:	f004 0301 	and.w	r3, r4, #1
 80085e4:	191c      	adds	r4, r3, r4
 80085e6:	e7e3      	b.n	80085b0 <__ieee754_sqrt+0xe0>
 80085e8:	f021 4600 	bic.w	r6, r1, #2147483648	; 0x80000000
 80085ec:	4306      	orrs	r6, r0
 80085ee:	d0ee      	beq.n	80085ce <__ieee754_sqrt+0xfe>
 80085f0:	bb41      	cbnz	r1, 8008644 <__ieee754_sqrt+0x174>
 80085f2:	460f      	mov	r7, r1
 80085f4:	ea4f 26d8 	mov.w	r6, r8, lsr #11
 80085f8:	3f15      	subs	r7, #21
 80085fa:	ea4f 5848 	mov.w	r8, r8, lsl #21
 80085fe:	2e00      	cmp	r6, #0
 8008600:	d0f8      	beq.n	80085f4 <__ieee754_sqrt+0x124>
 8008602:	f416 1380 	ands.w	r3, r6, #1048576	; 0x100000
 8008606:	d119      	bne.n	800863c <__ieee754_sqrt+0x16c>
 8008608:	0076      	lsls	r6, r6, #1
 800860a:	3301      	adds	r3, #1
 800860c:	02f1      	lsls	r1, r6, #11
 800860e:	d5fb      	bpl.n	8008608 <__ieee754_sqrt+0x138>
 8008610:	f1c3 0101 	rsb	r1, r3, #1
 8008614:	f1c3 0220 	rsb	r2, r3, #32
 8008618:	fa28 f202 	lsr.w	r2, r8, r2
 800861c:	187f      	adds	r7, r7, r1
 800861e:	4316      	orrs	r6, r2
 8008620:	fa08 f803 	lsl.w	r8, r8, r3
 8008624:	e76b      	b.n	80084fe <__ieee754_sqrt+0x2e>
 8008626:	f001 fc8d 	bl	8009f44 <__aeabi_dmul>
 800862a:	4602      	mov	r2, r0
 800862c:	460b      	mov	r3, r1
 800862e:	4620      	mov	r0, r4
 8008630:	4629      	mov	r1, r5
 8008632:	f7fe fe07 	bl	8007244 <__adddf3>
 8008636:	4604      	mov	r4, r0
 8008638:	460d      	mov	r5, r1
 800863a:	e7c8      	b.n	80085ce <__ieee754_sqrt+0xfe>
 800863c:	2220      	movs	r2, #32
 800863e:	2101      	movs	r1, #1
 8008640:	2300      	movs	r3, #0
 8008642:	e7e9      	b.n	8008618 <__ieee754_sqrt+0x148>
 8008644:	4602      	mov	r2, r0
 8008646:	460b      	mov	r3, r1
 8008648:	f7fe fdfa 	bl	8007240 <__aeabi_dsub>
 800864c:	4602      	mov	r2, r0
 800864e:	460b      	mov	r3, r1
 8008650:	f001 fda2 	bl	800a198 <__aeabi_ddiv>
 8008654:	4604      	mov	r4, r0
 8008656:	460d      	mov	r5, r1
 8008658:	e7b9      	b.n	80085ce <__ieee754_sqrt+0xfe>
 800865a:	bf00      	nop

0800865c <__ieee754_asinf>:
 800865c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8008660:	f020 4500 	bic.w	r5, r0, #2147483648	; 0x80000000
 8008664:	f1b5 5f7e 	cmp.w	r5, #1065353216	; 0x3f800000
 8008668:	4604      	mov	r4, r0
 800866a:	4606      	mov	r6, r0
 800866c:	f000 80fd 	beq.w	800886a <__ieee754_asinf+0x20e>
 8008670:	f300 80d5 	bgt.w	800881e <__ieee754_asinf+0x1c2>
 8008674:	f1b5 5f7c 	cmp.w	r5, #1056964608	; 0x3f000000
 8008678:	da10      	bge.n	800869c <__ieee754_asinf+0x40>
 800867a:	f1b5 5f48 	cmp.w	r5, #838860800	; 0x32000000
 800867e:	f280 810a 	bge.w	8008896 <__ieee754_asinf+0x23a>
 8008682:	f24f 21ca 	movw	r1, #62154	; 0xf2ca
 8008686:	f2c7 1149 	movt	r1, #29001	; 0x7149
 800868a:	f7ff f80b 	bl	80076a4 <__addsf3>
 800868e:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 8008692:	f7ff facb 	bl	8007c2c <__aeabi_fcmpgt>
 8008696:	2800      	cmp	r0, #0
 8008698:	f040 80c8 	bne.w	800882c <__ieee754_asinf+0x1d0>
 800869c:	4620      	mov	r0, r4
 800869e:	f001 fb7d 	bl	8009d9c <fabsf>
 80086a2:	4601      	mov	r1, r0
 80086a4:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 80086a8:	f7fe fffa 	bl	80076a0 <__aeabi_fsub>
 80086ac:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 80086b0:	f7ff f900 	bl	80078b4 <__aeabi_fmul>
 80086b4:	f64e 7108 	movw	r1, #61192	; 0xef08
 80086b8:	f6c3 0111 	movt	r1, #14353	; 0x3811
 80086bc:	4604      	mov	r4, r0
 80086be:	f7ff f8f9 	bl	80078b4 <__aeabi_fmul>
 80086c2:	f647 7104 	movw	r1, #32516	; 0x7f04
 80086c6:	f6c3 214f 	movt	r1, #14927	; 0x3a4f
 80086ca:	f7fe ffeb 	bl	80076a4 <__addsf3>
 80086ce:	4621      	mov	r1, r4
 80086d0:	f7ff f8f0 	bl	80078b4 <__aeabi_fmul>
 80086d4:	f241 1146 	movw	r1, #4422	; 0x1146
 80086d8:	f6c3 5124 	movt	r1, #15652	; 0x3d24
 80086dc:	f7fe ffe0 	bl	80076a0 <__aeabi_fsub>
 80086e0:	4621      	mov	r1, r4
 80086e2:	f7ff f8e7 	bl	80078b4 <__aeabi_fmul>
 80086e6:	f640 21a8 	movw	r1, #2728	; 0xaa8
 80086ea:	f6c3 614e 	movt	r1, #15950	; 0x3e4e
 80086ee:	f7fe ffd9 	bl	80076a4 <__addsf3>
 80086f2:	4621      	mov	r1, r4
 80086f4:	f7ff f8de 	bl	80078b4 <__aeabi_fmul>
 80086f8:	f24b 0190 	movw	r1, #45200	; 0xb090
 80086fc:	f6c3 61a6 	movt	r1, #16038	; 0x3ea6
 8008700:	f7fe ffce 	bl	80076a0 <__aeabi_fsub>
 8008704:	4621      	mov	r1, r4
 8008706:	f7ff f8d5 	bl	80078b4 <__aeabi_fmul>
 800870a:	f64a 21ab 	movw	r1, #43691	; 0xaaab
 800870e:	f6c3 612a 	movt	r1, #15914	; 0x3e2a
 8008712:	f7fe ffc7 	bl	80076a4 <__addsf3>
 8008716:	4621      	mov	r1, r4
 8008718:	f7ff f8cc 	bl	80078b4 <__aeabi_fmul>
 800871c:	f24c 612e 	movw	r1, #50734	; 0xc62e
 8008720:	f6c3 519d 	movt	r1, #15773	; 0x3d9d
 8008724:	4681      	mov	r9, r0
 8008726:	4620      	mov	r0, r4
 8008728:	f7ff f8c4 	bl	80078b4 <__aeabi_fmul>
 800872c:	f243 3161 	movw	r1, #13153	; 0x3361
 8008730:	f6c3 7130 	movt	r1, #16176	; 0x3f30
 8008734:	f7fe ffb4 	bl	80076a0 <__aeabi_fsub>
 8008738:	4621      	mov	r1, r4
 800873a:	f7ff f8bb 	bl	80078b4 <__aeabi_fmul>
 800873e:	f245 712d 	movw	r1, #22317	; 0x572d
 8008742:	f2c4 0101 	movt	r1, #16385	; 0x4001
 8008746:	f7fe ffad 	bl	80076a4 <__addsf3>
 800874a:	4621      	mov	r1, r4
 800874c:	f7ff f8b2 	bl	80078b4 <__aeabi_fmul>
 8008750:	f24d 1139 	movw	r1, #53561	; 0xd139
 8008754:	f2c4 0119 	movt	r1, #16409	; 0x4019
 8008758:	f7fe ffa2 	bl	80076a0 <__aeabi_fsub>
 800875c:	4621      	mov	r1, r4
 800875e:	f7ff f8a9 	bl	80078b4 <__aeabi_fmul>
 8008762:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 8008766:	f7fe ff9d 	bl	80076a4 <__addsf3>
 800876a:	4680      	mov	r8, r0
 800876c:	4620      	mov	r0, r4
 800876e:	f000 fb4d 	bl	8008e0c <__ieee754_sqrtf>
 8008772:	f649 1399 	movw	r3, #39321	; 0x9999
 8008776:	f6c3 7379 	movt	r3, #16249	; 0x3f79
 800877a:	429d      	cmp	r5, r3
 800877c:	4607      	mov	r7, r0
 800877e:	dc58      	bgt.n	8008832 <__ieee754_asinf+0x1d6>
 8008780:	4601      	mov	r1, r0
 8008782:	f420 657f 	bic.w	r5, r0, #4080	; 0xff0
 8008786:	f7fe ff8d 	bl	80076a4 <__addsf3>
 800878a:	4641      	mov	r1, r8
 800878c:	f025 050f 	bic.w	r5, r5, #15
 8008790:	4682      	mov	sl, r0
 8008792:	4648      	mov	r0, r9
 8008794:	f7ff f942 	bl	8007a1c <__aeabi_fdiv>
 8008798:	4601      	mov	r1, r0
 800879a:	4650      	mov	r0, sl
 800879c:	f7ff f88a 	bl	80078b4 <__aeabi_fmul>
 80087a0:	4629      	mov	r1, r5
 80087a2:	4680      	mov	r8, r0
 80087a4:	4628      	mov	r0, r5
 80087a6:	f7ff f885 	bl	80078b4 <__aeabi_fmul>
 80087aa:	4601      	mov	r1, r0
 80087ac:	4620      	mov	r0, r4
 80087ae:	f7fe ff77 	bl	80076a0 <__aeabi_fsub>
 80087b2:	4629      	mov	r1, r5
 80087b4:	4604      	mov	r4, r0
 80087b6:	4638      	mov	r0, r7
 80087b8:	f7fe ff74 	bl	80076a4 <__addsf3>
 80087bc:	4601      	mov	r1, r0
 80087be:	4620      	mov	r0, r4
 80087c0:	f7ff f92c 	bl	8007a1c <__aeabi_fdiv>
 80087c4:	4601      	mov	r1, r0
 80087c6:	f7fe ff6d 	bl	80076a4 <__addsf3>
 80087ca:	4601      	mov	r1, r0
 80087cc:	f64b 502e 	movw	r0, #48430	; 0xbd2e
 80087d0:	f2cb 303b 	movt	r0, #45883	; 0xb33b
 80087d4:	f7fe ff64 	bl	80076a0 <__aeabi_fsub>
 80087d8:	4601      	mov	r1, r0
 80087da:	4640      	mov	r0, r8
 80087dc:	f7fe ff60 	bl	80076a0 <__aeabi_fsub>
 80087e0:	4629      	mov	r1, r5
 80087e2:	4604      	mov	r4, r0
 80087e4:	4628      	mov	r0, r5
 80087e6:	f7fe ff5d 	bl	80076a4 <__addsf3>
 80087ea:	4601      	mov	r1, r0
 80087ec:	f640 70db 	movw	r0, #4059	; 0xfdb
 80087f0:	f6c3 7049 	movt	r0, #16201	; 0x3f49
 80087f4:	f7fe ff54 	bl	80076a0 <__aeabi_fsub>
 80087f8:	4601      	mov	r1, r0
 80087fa:	4620      	mov	r0, r4
 80087fc:	f7fe ff50 	bl	80076a0 <__aeabi_fsub>
 8008800:	4601      	mov	r1, r0
 8008802:	f640 70db 	movw	r0, #4059	; 0xfdb
 8008806:	f6c3 7049 	movt	r0, #16201	; 0x3f49
 800880a:	f7fe ff49 	bl	80076a0 <__aeabi_fsub>
 800880e:	2e00      	cmp	r6, #0
 8008810:	bfd4      	ite	le
 8008812:	f100 4400 	addle.w	r4, r0, #2147483648	; 0x80000000
 8008816:	4604      	movgt	r4, r0
 8008818:	4620      	mov	r0, r4
 800881a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800881e:	4601      	mov	r1, r0
 8008820:	f7fe ff3e 	bl	80076a0 <__aeabi_fsub>
 8008824:	4601      	mov	r1, r0
 8008826:	f7ff f8f9 	bl	8007a1c <__aeabi_fdiv>
 800882a:	4604      	mov	r4, r0
 800882c:	4620      	mov	r0, r4
 800882e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8008832:	4641      	mov	r1, r8
 8008834:	4648      	mov	r0, r9
 8008836:	f7ff f8f1 	bl	8007a1c <__aeabi_fdiv>
 800883a:	4601      	mov	r1, r0
 800883c:	4638      	mov	r0, r7
 800883e:	f7ff f839 	bl	80078b4 <__aeabi_fmul>
 8008842:	4639      	mov	r1, r7
 8008844:	f7fe ff2e 	bl	80076a4 <__addsf3>
 8008848:	4601      	mov	r1, r0
 800884a:	f7fe ff2b 	bl	80076a4 <__addsf3>
 800884e:	f64b 512e 	movw	r1, #48430	; 0xbd2e
 8008852:	f2c3 313b 	movt	r1, #13115	; 0x333b
 8008856:	f7fe ff25 	bl	80076a4 <__addsf3>
 800885a:	4601      	mov	r1, r0
 800885c:	f640 70db 	movw	r0, #4059	; 0xfdb
 8008860:	f6c3 70c9 	movt	r0, #16329	; 0x3fc9
 8008864:	f7fe ff1c 	bl	80076a0 <__aeabi_fsub>
 8008868:	e7d1      	b.n	800880e <__ieee754_asinf+0x1b2>
 800886a:	f640 71db 	movw	r1, #4059	; 0xfdb
 800886e:	f6c3 71c9 	movt	r1, #16329	; 0x3fc9
 8008872:	f7ff f81f 	bl	80078b4 <__aeabi_fmul>
 8008876:	f64b 512e 	movw	r1, #48430	; 0xbd2e
 800887a:	f2cb 313b 	movt	r1, #45883	; 0xb33b
 800887e:	4605      	mov	r5, r0
 8008880:	4620      	mov	r0, r4
 8008882:	f7ff f817 	bl	80078b4 <__aeabi_fmul>
 8008886:	4601      	mov	r1, r0
 8008888:	4628      	mov	r0, r5
 800888a:	f7fe ff0b 	bl	80076a4 <__addsf3>
 800888e:	4604      	mov	r4, r0
 8008890:	4620      	mov	r0, r4
 8008892:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8008896:	4601      	mov	r1, r0
 8008898:	f7ff f80c 	bl	80078b4 <__aeabi_fmul>
 800889c:	f64e 7108 	movw	r1, #61192	; 0xef08
 80088a0:	f6c3 0111 	movt	r1, #14353	; 0x3811
 80088a4:	4605      	mov	r5, r0
 80088a6:	f7ff f805 	bl	80078b4 <__aeabi_fmul>
 80088aa:	f647 7104 	movw	r1, #32516	; 0x7f04
 80088ae:	f6c3 214f 	movt	r1, #14927	; 0x3a4f
 80088b2:	f7fe fef7 	bl	80076a4 <__addsf3>
 80088b6:	4629      	mov	r1, r5
 80088b8:	f7fe fffc 	bl	80078b4 <__aeabi_fmul>
 80088bc:	f241 1146 	movw	r1, #4422	; 0x1146
 80088c0:	f6c3 5124 	movt	r1, #15652	; 0x3d24
 80088c4:	f7fe feec 	bl	80076a0 <__aeabi_fsub>
 80088c8:	4629      	mov	r1, r5
 80088ca:	f7fe fff3 	bl	80078b4 <__aeabi_fmul>
 80088ce:	f640 21a8 	movw	r1, #2728	; 0xaa8
 80088d2:	f6c3 614e 	movt	r1, #15950	; 0x3e4e
 80088d6:	f7fe fee5 	bl	80076a4 <__addsf3>
 80088da:	4629      	mov	r1, r5
 80088dc:	f7fe ffea 	bl	80078b4 <__aeabi_fmul>
 80088e0:	f24b 0190 	movw	r1, #45200	; 0xb090
 80088e4:	f6c3 61a6 	movt	r1, #16038	; 0x3ea6
 80088e8:	f7fe feda 	bl	80076a0 <__aeabi_fsub>
 80088ec:	4629      	mov	r1, r5
 80088ee:	f7fe ffe1 	bl	80078b4 <__aeabi_fmul>
 80088f2:	f64a 21ab 	movw	r1, #43691	; 0xaaab
 80088f6:	f6c3 612a 	movt	r1, #15914	; 0x3e2a
 80088fa:	f7fe fed3 	bl	80076a4 <__addsf3>
 80088fe:	4629      	mov	r1, r5
 8008900:	f7fe ffd8 	bl	80078b4 <__aeabi_fmul>
 8008904:	f24c 612e 	movw	r1, #50734	; 0xc62e
 8008908:	f6c3 519d 	movt	r1, #15773	; 0x3d9d
 800890c:	4606      	mov	r6, r0
 800890e:	4628      	mov	r0, r5
 8008910:	f7fe ffd0 	bl	80078b4 <__aeabi_fmul>
 8008914:	f243 3161 	movw	r1, #13153	; 0x3361
 8008918:	f6c3 7130 	movt	r1, #16176	; 0x3f30
 800891c:	f7fe fec0 	bl	80076a0 <__aeabi_fsub>
 8008920:	4629      	mov	r1, r5
 8008922:	f7fe ffc7 	bl	80078b4 <__aeabi_fmul>
 8008926:	f245 712d 	movw	r1, #22317	; 0x572d
 800892a:	f2c4 0101 	movt	r1, #16385	; 0x4001
 800892e:	f7fe feb9 	bl	80076a4 <__addsf3>
 8008932:	4629      	mov	r1, r5
 8008934:	f7fe ffbe 	bl	80078b4 <__aeabi_fmul>
 8008938:	f24d 1139 	movw	r1, #53561	; 0xd139
 800893c:	f2c4 0119 	movt	r1, #16409	; 0x4019
 8008940:	f7fe feae 	bl	80076a0 <__aeabi_fsub>
 8008944:	4629      	mov	r1, r5
 8008946:	f7fe ffb5 	bl	80078b4 <__aeabi_fmul>
 800894a:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 800894e:	f7fe fea9 	bl	80076a4 <__addsf3>
 8008952:	4601      	mov	r1, r0
 8008954:	4630      	mov	r0, r6
 8008956:	f7ff f861 	bl	8007a1c <__aeabi_fdiv>
 800895a:	4601      	mov	r1, r0
 800895c:	4620      	mov	r0, r4
 800895e:	f7fe ffa9 	bl	80078b4 <__aeabi_fmul>
 8008962:	4601      	mov	r1, r0
 8008964:	4620      	mov	r0, r4
 8008966:	f7fe fe9d 	bl	80076a4 <__addsf3>
 800896a:	4604      	mov	r4, r0
 800896c:	4620      	mov	r0, r4
 800896e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8008972:	bf00      	nop

08008974 <__ieee754_atan2f>:
 8008974:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8008976:	f021 4600 	bic.w	r6, r1, #2147483648	; 0x80000000
 800897a:	f020 4400 	bic.w	r4, r0, #2147483648	; 0x80000000
 800897e:	4603      	mov	r3, r0
 8008980:	f1b4 4fff 	cmp.w	r4, #2139095040	; 0x7f800000
 8008984:	bfd8      	it	le
 8008986:	f1b6 4fff 	cmple.w	r6, #2139095040	; 0x7f800000
 800898a:	4605      	mov	r5, r0
 800898c:	dc45      	bgt.n	8008a1a <__ieee754_atan2f+0xa6>
 800898e:	f1b1 5f7e 	cmp.w	r1, #1065353216	; 0x3f800000
 8008992:	d04c      	beq.n	8008a2e <__ieee754_atan2f+0xba>
 8008994:	178f      	asrs	r7, r1, #30
 8008996:	f007 0702 	and.w	r7, r7, #2
 800899a:	ea47 77d0 	orr.w	r7, r7, r0, lsr #31
 800899e:	b94c      	cbnz	r4, 80089b4 <__ieee754_atan2f+0x40>
 80089a0:	2f02      	cmp	r7, #2
 80089a2:	d03f      	beq.n	8008a24 <__ieee754_atan2f+0xb0>
 80089a4:	2f03      	cmp	r7, #3
 80089a6:	d103      	bne.n	80089b0 <__ieee754_atan2f+0x3c>
 80089a8:	f640 73db 	movw	r3, #4059	; 0xfdb
 80089ac:	f2cc 0349 	movt	r3, #49225	; 0xc049
 80089b0:	4618      	mov	r0, r3
 80089b2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80089b4:	b336      	cbz	r6, 8008a04 <__ieee754_atan2f+0x90>
 80089b6:	f1b6 4fff 	cmp.w	r6, #2139095040	; 0x7f800000
 80089ba:	d055      	beq.n	8008a68 <__ieee754_atan2f+0xf4>
 80089bc:	f1b4 4fff 	cmp.w	r4, #2139095040	; 0x7f800000
 80089c0:	d020      	beq.n	8008a04 <__ieee754_atan2f+0x90>
 80089c2:	1ba4      	subs	r4, r4, r6
 80089c4:	15e4      	asrs	r4, r4, #23
 80089c6:	2c3c      	cmp	r4, #60	; 0x3c
 80089c8:	bfc4      	itt	gt
 80089ca:	f640 70db 	movwgt	r0, #4059	; 0xfdb
 80089ce:	f6c3 70c9 	movtgt	r0, #16329	; 0x3fc9
 80089d2:	dd30      	ble.n	8008a36 <__ieee754_atan2f+0xc2>
 80089d4:	2f01      	cmp	r7, #1
 80089d6:	bf08      	it	eq
 80089d8:	f100 4300 	addeq.w	r3, r0, #2147483648	; 0x80000000
 80089dc:	d0e8      	beq.n	80089b0 <__ieee754_atan2f+0x3c>
 80089de:	2f02      	cmp	r7, #2
 80089e0:	d033      	beq.n	8008a4a <__ieee754_atan2f+0xd6>
 80089e2:	4603      	mov	r3, r0
 80089e4:	2f00      	cmp	r7, #0
 80089e6:	d0e3      	beq.n	80089b0 <__ieee754_atan2f+0x3c>
 80089e8:	f64b 512e 	movw	r1, #48430	; 0xbd2e
 80089ec:	f2c3 31bb 	movt	r1, #13243	; 0x33bb
 80089f0:	f7fe fe58 	bl	80076a4 <__addsf3>
 80089f4:	f640 71db 	movw	r1, #4059	; 0xfdb
 80089f8:	f2c4 0149 	movt	r1, #16457	; 0x4049
 80089fc:	f7fe fe50 	bl	80076a0 <__aeabi_fsub>
 8008a00:	4603      	mov	r3, r0
 8008a02:	e7d5      	b.n	80089b0 <__ieee754_atan2f+0x3c>
 8008a04:	2d00      	cmp	r5, #0
 8008a06:	f640 73db 	movw	r3, #4059	; 0xfdb
 8008a0a:	bfb8      	it	lt
 8008a0c:	f6cb 73c9 	movtlt	r3, #49097	; 0xbfc9
 8008a10:	dbce      	blt.n	80089b0 <__ieee754_atan2f+0x3c>
 8008a12:	f6c3 73c9 	movt	r3, #16329	; 0x3fc9
 8008a16:	4618      	mov	r0, r3
 8008a18:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8008a1a:	f7fe fe43 	bl	80076a4 <__addsf3>
 8008a1e:	4603      	mov	r3, r0
 8008a20:	4618      	mov	r0, r3
 8008a22:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8008a24:	f640 73db 	movw	r3, #4059	; 0xfdb
 8008a28:	f2c4 0349 	movt	r3, #16457	; 0x4049
 8008a2c:	e7c0      	b.n	80089b0 <__ieee754_atan2f+0x3c>
 8008a2e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 8008a32:	f001 b895 	b.w	8009b60 <atanf>
 8008a36:	f114 0f3c 	cmn.w	r4, #60	; 0x3c
 8008a3a:	bfac      	ite	ge
 8008a3c:	2400      	movge	r4, #0
 8008a3e:	2401      	movlt	r4, #1
 8008a40:	ea14 74d1 	ands.w	r4, r4, r1, lsr #31
 8008a44:	d01d      	beq.n	8008a82 <__ieee754_atan2f+0x10e>
 8008a46:	2000      	movs	r0, #0
 8008a48:	e7c4      	b.n	80089d4 <__ieee754_atan2f+0x60>
 8008a4a:	f64b 512e 	movw	r1, #48430	; 0xbd2e
 8008a4e:	f2c3 31bb 	movt	r1, #13243	; 0x33bb
 8008a52:	f7fe fe27 	bl	80076a4 <__addsf3>
 8008a56:	4601      	mov	r1, r0
 8008a58:	f640 70db 	movw	r0, #4059	; 0xfdb
 8008a5c:	f2c4 0049 	movt	r0, #16457	; 0x4049
 8008a60:	f7fe fe1e 	bl	80076a0 <__aeabi_fsub>
 8008a64:	4603      	mov	r3, r0
 8008a66:	e7a3      	b.n	80089b0 <__ieee754_atan2f+0x3c>
 8008a68:	f1b4 4fff 	cmp.w	r4, #2139095040	; 0x7f800000
 8008a6c:	d010      	beq.n	8008a90 <__ieee754_atan2f+0x11c>
 8008a6e:	2f02      	cmp	r7, #2
 8008a70:	d0d8      	beq.n	8008a24 <__ieee754_atan2f+0xb0>
 8008a72:	2f03      	cmp	r7, #3
 8008a74:	d098      	beq.n	80089a8 <__ieee754_atan2f+0x34>
 8008a76:	2300      	movs	r3, #0
 8008a78:	2f01      	cmp	r7, #1
 8008a7a:	d199      	bne.n	80089b0 <__ieee754_atan2f+0x3c>
 8008a7c:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
 8008a80:	e796      	b.n	80089b0 <__ieee754_atan2f+0x3c>
 8008a82:	f7fe ffcb 	bl	8007a1c <__aeabi_fdiv>
 8008a86:	f001 f989 	bl	8009d9c <fabsf>
 8008a8a:	f001 f869 	bl	8009b60 <atanf>
 8008a8e:	e7a1      	b.n	80089d4 <__ieee754_atan2f+0x60>
 8008a90:	2f02      	cmp	r7, #2
 8008a92:	d00b      	beq.n	8008aac <__ieee754_atan2f+0x138>
 8008a94:	2f03      	cmp	r7, #3
 8008a96:	d00e      	beq.n	8008ab6 <__ieee754_atan2f+0x142>
 8008a98:	2f01      	cmp	r7, #1
 8008a9a:	f640 73db 	movw	r3, #4059	; 0xfdb
 8008a9e:	bf18      	it	ne
 8008aa0:	f6c3 7349 	movtne	r3, #16201	; 0x3f49
 8008aa4:	d184      	bne.n	80089b0 <__ieee754_atan2f+0x3c>
 8008aa6:	f6cb 7349 	movt	r3, #48969	; 0xbf49
 8008aaa:	e781      	b.n	80089b0 <__ieee754_atan2f+0x3c>
 8008aac:	f64c 33e4 	movw	r3, #52196	; 0xcbe4
 8008ab0:	f2c4 0316 	movt	r3, #16406	; 0x4016
 8008ab4:	e77c      	b.n	80089b0 <__ieee754_atan2f+0x3c>
 8008ab6:	f64c 33e4 	movw	r3, #52196	; 0xcbe4
 8008aba:	f2cc 0316 	movt	r3, #49174	; 0xc016
 8008abe:	e777      	b.n	80089b0 <__ieee754_atan2f+0x3c>

08008ac0 <__ieee754_rem_pio2f>:
 8008ac0:	f640 73d8 	movw	r3, #4056	; 0xfd8
 8008ac4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008ac8:	f6c3 7349 	movt	r3, #16201	; 0x3f49
 8008acc:	f020 4400 	bic.w	r4, r0, #2147483648	; 0x80000000
 8008ad0:	b089      	sub	sp, #36	; 0x24
 8008ad2:	429c      	cmp	r4, r3
 8008ad4:	4606      	mov	r6, r0
 8008ad6:	460d      	mov	r5, r1
 8008ad8:	f340 8088 	ble.w	8008bec <__ieee754_rem_pio2f+0x12c>
 8008adc:	f64c 33e3 	movw	r3, #52195	; 0xcbe3
 8008ae0:	f2c4 0316 	movt	r3, #16406	; 0x4016
 8008ae4:	429c      	cmp	r4, r3
 8008ae6:	dc25      	bgt.n	8008b34 <__ieee754_rem_pio2f+0x74>
 8008ae8:	2800      	cmp	r0, #0
 8008aea:	f44f 6178 	mov.w	r1, #3968	; 0xf80
 8008aee:	f6c3 71c9 	movt	r1, #16329	; 0x3fc9
 8008af2:	f340 814d 	ble.w	8008d90 <__ieee754_rem_pio2f+0x2d0>
 8008af6:	f7fe fdd3 	bl	80076a0 <__aeabi_fsub>
 8008afa:	f44f 637d 	mov.w	r3, #4048	; 0xfd0
 8008afe:	f024 040f 	bic.w	r4, r4, #15
 8008b02:	f6c3 73c9 	movt	r3, #16329	; 0x3fc9
 8008b06:	429c      	cmp	r4, r3
 8008b08:	4606      	mov	r6, r0
 8008b0a:	d07e      	beq.n	8008c0a <__ieee754_rem_pio2f+0x14a>
 8008b0c:	f244 4143 	movw	r1, #17475	; 0x4443
 8008b10:	2701      	movs	r7, #1
 8008b12:	f2c3 7135 	movt	r1, #14133	; 0x3735
 8008b16:	f7fe fdc3 	bl	80076a0 <__aeabi_fsub>
 8008b1a:	4601      	mov	r1, r0
 8008b1c:	6028      	str	r0, [r5, #0]
 8008b1e:	4630      	mov	r0, r6
 8008b20:	f7fe fdbe 	bl	80076a0 <__aeabi_fsub>
 8008b24:	f244 4143 	movw	r1, #17475	; 0x4443
 8008b28:	f2c3 7135 	movt	r1, #14133	; 0x3735
 8008b2c:	f7fe fdb8 	bl	80076a0 <__aeabi_fsub>
 8008b30:	6068      	str	r0, [r5, #4]
 8008b32:	e05f      	b.n	8008bf4 <__ieee754_rem_pio2f+0x134>
 8008b34:	f44f 6378 	mov.w	r3, #3968	; 0xf80
 8008b38:	f2c4 3349 	movt	r3, #17225	; 0x4349
 8008b3c:	429c      	cmp	r4, r3
 8008b3e:	dd7f      	ble.n	8008c40 <__ieee754_rem_pio2f+0x180>
 8008b40:	f1b4 4fff 	cmp.w	r4, #2139095040	; 0x7f800000
 8008b44:	da5a      	bge.n	8008bfc <__ieee754_rem_pio2f+0x13c>
 8008b46:	ea4f 59e4 	mov.w	r9, r4, asr #23
 8008b4a:	f1a9 0986 	sub.w	r9, r9, #134	; 0x86
 8008b4e:	eba4 54c9 	sub.w	r4, r4, r9, lsl #23
 8008b52:	4620      	mov	r0, r4
 8008b54:	f7ff f874 	bl	8007c40 <__aeabi_f2iz>
 8008b58:	f7fe fe58 	bl	800780c <__aeabi_i2f>
 8008b5c:	4603      	mov	r3, r0
 8008b5e:	4601      	mov	r1, r0
 8008b60:	4620      	mov	r0, r4
 8008b62:	9305      	str	r3, [sp, #20]
 8008b64:	f7fe fd9c 	bl	80076a0 <__aeabi_fsub>
 8008b68:	f04f 4187 	mov.w	r1, #1132462080	; 0x43800000
 8008b6c:	f7fe fea2 	bl	80078b4 <__aeabi_fmul>
 8008b70:	4607      	mov	r7, r0
 8008b72:	f7ff f865 	bl	8007c40 <__aeabi_f2iz>
 8008b76:	f7fe fe49 	bl	800780c <__aeabi_i2f>
 8008b7a:	4601      	mov	r1, r0
 8008b7c:	4604      	mov	r4, r0
 8008b7e:	4638      	mov	r0, r7
 8008b80:	9406      	str	r4, [sp, #24]
 8008b82:	f7fe fd8d 	bl	80076a0 <__aeabi_fsub>
 8008b86:	f04f 4187 	mov.w	r1, #1132462080	; 0x43800000
 8008b8a:	f7fe fe93 	bl	80078b4 <__aeabi_fmul>
 8008b8e:	2100      	movs	r1, #0
 8008b90:	2703      	movs	r7, #3
 8008b92:	9007      	str	r0, [sp, #28]
 8008b94:	f7ff f822 	bl	8007bdc <__aeabi_fcmpeq>
 8008b98:	b188      	cbz	r0, 8008bbe <__ieee754_rem_pio2f+0xfe>
 8008b9a:	2703      	movs	r7, #3
 8008b9c:	4620      	mov	r0, r4
 8008b9e:	2100      	movs	r1, #0
 8008ba0:	f10d 0818 	add.w	r8, sp, #24
 8008ba4:	3f01      	subs	r7, #1
 8008ba6:	f7ff f819 	bl	8007bdc <__aeabi_fcmpeq>
 8008baa:	b140      	cbz	r0, 8008bbe <__ieee754_rem_pio2f+0xfe>
 8008bac:	f858 4d04 	ldr.w	r4, [r8, #-4]!
 8008bb0:	2100      	movs	r1, #0
 8008bb2:	3f01      	subs	r7, #1
 8008bb4:	4620      	mov	r0, r4
 8008bb6:	f7ff f811 	bl	8007bdc <__aeabi_fcmpeq>
 8008bba:	2800      	cmp	r0, #0
 8008bbc:	d1f6      	bne.n	8008bac <__ieee754_rem_pio2f+0xec>
 8008bbe:	2302      	movs	r3, #2
 8008bc0:	9300      	str	r3, [sp, #0]
 8008bc2:	4b91      	ldr	r3, [pc, #580]	; (8008e08 <__ieee754_rem_pio2f+0x348>)
 8008bc4:	a805      	add	r0, sp, #20
 8008bc6:	4629      	mov	r1, r5
 8008bc8:	464a      	mov	r2, r9
 8008bca:	9301      	str	r3, [sp, #4]
 8008bcc:	463b      	mov	r3, r7
 8008bce:	f000 fa4d 	bl	800906c <__kernel_rem_pio2f>
 8008bd2:	2e00      	cmp	r6, #0
 8008bd4:	4607      	mov	r7, r0
 8008bd6:	da0d      	bge.n	8008bf4 <__ieee754_rem_pio2f+0x134>
 8008bd8:	682a      	ldr	r2, [r5, #0]
 8008bda:	4247      	negs	r7, r0
 8008bdc:	686b      	ldr	r3, [r5, #4]
 8008bde:	f102 4200 	add.w	r2, r2, #2147483648	; 0x80000000
 8008be2:	602a      	str	r2, [r5, #0]
 8008be4:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
 8008be8:	606b      	str	r3, [r5, #4]
 8008bea:	e003      	b.n	8008bf4 <__ieee754_rem_pio2f+0x134>
 8008bec:	2700      	movs	r7, #0
 8008bee:	6028      	str	r0, [r5, #0]
 8008bf0:	2300      	movs	r3, #0
 8008bf2:	604b      	str	r3, [r1, #4]
 8008bf4:	4638      	mov	r0, r7
 8008bf6:	b009      	add	sp, #36	; 0x24
 8008bf8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8008bfc:	4601      	mov	r1, r0
 8008bfe:	2700      	movs	r7, #0
 8008c00:	f7fe fd4e 	bl	80076a0 <__aeabi_fsub>
 8008c04:	6068      	str	r0, [r5, #4]
 8008c06:	6028      	str	r0, [r5, #0]
 8008c08:	e7f4      	b.n	8008bf4 <__ieee754_rem_pio2f+0x134>
 8008c0a:	f44f 4188 	mov.w	r1, #17408	; 0x4400
 8008c0e:	2701      	movs	r7, #1
 8008c10:	f2c3 7135 	movt	r1, #14133	; 0x3735
 8008c14:	f7fe fd44 	bl	80076a0 <__aeabi_fsub>
 8008c18:	f24a 3108 	movw	r1, #41736	; 0xa308
 8008c1c:	f6c2 6185 	movt	r1, #11909	; 0x2e85
 8008c20:	4604      	mov	r4, r0
 8008c22:	f7fe fd3d 	bl	80076a0 <__aeabi_fsub>
 8008c26:	4601      	mov	r1, r0
 8008c28:	6028      	str	r0, [r5, #0]
 8008c2a:	4620      	mov	r0, r4
 8008c2c:	f7fe fd38 	bl	80076a0 <__aeabi_fsub>
 8008c30:	f24a 3108 	movw	r1, #41736	; 0xa308
 8008c34:	f6c2 6185 	movt	r1, #11909	; 0x2e85
 8008c38:	f7fe fd32 	bl	80076a0 <__aeabi_fsub>
 8008c3c:	6068      	str	r0, [r5, #4]
 8008c3e:	e7d9      	b.n	8008bf4 <__ieee754_rem_pio2f+0x134>
 8008c40:	f001 f8ac 	bl	8009d9c <fabsf>
 8008c44:	f64f 1184 	movw	r1, #63876	; 0xf984
 8008c48:	f6c3 7122 	movt	r1, #16162	; 0x3f22
 8008c4c:	4680      	mov	r8, r0
 8008c4e:	f7fe fe31 	bl	80078b4 <__aeabi_fmul>
 8008c52:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 8008c56:	f7fe fd25 	bl	80076a4 <__addsf3>
 8008c5a:	f7fe fff1 	bl	8007c40 <__aeabi_f2iz>
 8008c5e:	4607      	mov	r7, r0
 8008c60:	f7fe fdd4 	bl	800780c <__aeabi_i2f>
 8008c64:	f44f 6178 	mov.w	r1, #3968	; 0xf80
 8008c68:	f6c3 71c9 	movt	r1, #16329	; 0x3fc9
 8008c6c:	4683      	mov	fp, r0
 8008c6e:	f7fe fe21 	bl	80078b4 <__aeabi_fmul>
 8008c72:	4601      	mov	r1, r0
 8008c74:	4640      	mov	r0, r8
 8008c76:	f7fe fd13 	bl	80076a0 <__aeabi_fsub>
 8008c7a:	f244 4143 	movw	r1, #17475	; 0x4443
 8008c7e:	f2c3 7135 	movt	r1, #14133	; 0x3735
 8008c82:	4681      	mov	r9, r0
 8008c84:	4658      	mov	r0, fp
 8008c86:	f7fe fe15 	bl	80078b4 <__aeabi_fmul>
 8008c8a:	2f1f      	cmp	r7, #31
 8008c8c:	4682      	mov	sl, r0
 8008c8e:	4648      	mov	r0, r9
 8008c90:	dc23      	bgt.n	8008cda <__ieee754_rem_pio2f+0x21a>
 8008c92:	f24a 5394 	movw	r3, #42388	; 0xa594
 8008c96:	1e79      	subs	r1, r7, #1
 8008c98:	f6c0 0300 	movt	r3, #2048	; 0x800
 8008c9c:	f024 02ff 	bic.w	r2, r4, #255	; 0xff
 8008ca0:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8008ca4:	429a      	cmp	r2, r3
 8008ca6:	d018      	beq.n	8008cda <__ieee754_rem_pio2f+0x21a>
 8008ca8:	4651      	mov	r1, sl
 8008caa:	f7fe fcf9 	bl	80076a0 <__aeabi_fsub>
 8008cae:	4680      	mov	r8, r0
 8008cb0:	f8c5 8000 	str.w	r8, [r5]
 8008cb4:	4641      	mov	r1, r8
 8008cb6:	4648      	mov	r0, r9
 8008cb8:	f7fe fcf2 	bl	80076a0 <__aeabi_fsub>
 8008cbc:	4651      	mov	r1, sl
 8008cbe:	f7fe fcef 	bl	80076a0 <__aeabi_fsub>
 8008cc2:	2e00      	cmp	r6, #0
 8008cc4:	6068      	str	r0, [r5, #4]
 8008cc6:	da95      	bge.n	8008bf4 <__ieee754_rem_pio2f+0x134>
 8008cc8:	f108 4800 	add.w	r8, r8, #2147483648	; 0x80000000
 8008ccc:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
 8008cd0:	f8c5 8000 	str.w	r8, [r5]
 8008cd4:	427f      	negs	r7, r7
 8008cd6:	6068      	str	r0, [r5, #4]
 8008cd8:	e78c      	b.n	8008bf4 <__ieee754_rem_pio2f+0x134>
 8008cda:	4651      	mov	r1, sl
 8008cdc:	f7fe fce0 	bl	80076a0 <__aeabi_fsub>
 8008ce0:	15e3      	asrs	r3, r4, #23
 8008ce2:	f3c0 52c7 	ubfx	r2, r0, #23, #8
 8008ce6:	4680      	mov	r8, r0
 8008ce8:	1a9a      	subs	r2, r3, r2
 8008cea:	2a08      	cmp	r2, #8
 8008cec:	dde0      	ble.n	8008cb0 <__ieee754_rem_pio2f+0x1f0>
 8008cee:	f44f 4188 	mov.w	r1, #17408	; 0x4400
 8008cf2:	4658      	mov	r0, fp
 8008cf4:	f2c3 7135 	movt	r1, #14133	; 0x3735
 8008cf8:	9303      	str	r3, [sp, #12]
 8008cfa:	f7fe fddb 	bl	80078b4 <__aeabi_fmul>
 8008cfe:	4680      	mov	r8, r0
 8008d00:	4648      	mov	r0, r9
 8008d02:	4641      	mov	r1, r8
 8008d04:	f7fe fccc 	bl	80076a0 <__aeabi_fsub>
 8008d08:	4604      	mov	r4, r0
 8008d0a:	4648      	mov	r0, r9
 8008d0c:	4621      	mov	r1, r4
 8008d0e:	f7fe fcc7 	bl	80076a0 <__aeabi_fsub>
 8008d12:	4641      	mov	r1, r8
 8008d14:	f7fe fcc4 	bl	80076a0 <__aeabi_fsub>
 8008d18:	f24a 3108 	movw	r1, #41736	; 0xa308
 8008d1c:	f6c2 6185 	movt	r1, #11909	; 0x2e85
 8008d20:	4680      	mov	r8, r0
 8008d22:	4658      	mov	r0, fp
 8008d24:	f7fe fdc6 	bl	80078b4 <__aeabi_fmul>
 8008d28:	4641      	mov	r1, r8
 8008d2a:	f7fe fcb9 	bl	80076a0 <__aeabi_fsub>
 8008d2e:	4682      	mov	sl, r0
 8008d30:	4620      	mov	r0, r4
 8008d32:	4651      	mov	r1, sl
 8008d34:	f7fe fcb4 	bl	80076a0 <__aeabi_fsub>
 8008d38:	9b03      	ldr	r3, [sp, #12]
 8008d3a:	f3c0 52c7 	ubfx	r2, r0, #23, #8
 8008d3e:	4680      	mov	r8, r0
 8008d40:	1a9b      	subs	r3, r3, r2
 8008d42:	2b19      	cmp	r3, #25
 8008d44:	bfdc      	itt	le
 8008d46:	6028      	strle	r0, [r5, #0]
 8008d48:	46a1      	movle	r9, r4
 8008d4a:	ddb3      	ble.n	8008cb4 <__ieee754_rem_pio2f+0x1f4>
 8008d4c:	f44f 4123 	mov.w	r1, #41728	; 0xa300
 8008d50:	4658      	mov	r0, fp
 8008d52:	f6c2 6185 	movt	r1, #11909	; 0x2e85
 8008d56:	f7fe fdad 	bl	80078b4 <__aeabi_fmul>
 8008d5a:	4680      	mov	r8, r0
 8008d5c:	4620      	mov	r0, r4
 8008d5e:	4641      	mov	r1, r8
 8008d60:	f7fe fc9e 	bl	80076a0 <__aeabi_fsub>
 8008d64:	4681      	mov	r9, r0
 8008d66:	4620      	mov	r0, r4
 8008d68:	4649      	mov	r1, r9
 8008d6a:	f7fe fc99 	bl	80076a0 <__aeabi_fsub>
 8008d6e:	4641      	mov	r1, r8
 8008d70:	f7fe fc96 	bl	80076a0 <__aeabi_fsub>
 8008d74:	f243 1132 	movw	r1, #12594	; 0x3132
 8008d78:	f2c2 418d 	movt	r1, #9357	; 0x248d
 8008d7c:	4604      	mov	r4, r0
 8008d7e:	4658      	mov	r0, fp
 8008d80:	f7fe fd98 	bl	80078b4 <__aeabi_fmul>
 8008d84:	4621      	mov	r1, r4
 8008d86:	f7fe fc8b 	bl	80076a0 <__aeabi_fsub>
 8008d8a:	4682      	mov	sl, r0
 8008d8c:	4648      	mov	r0, r9
 8008d8e:	e78b      	b.n	8008ca8 <__ieee754_rem_pio2f+0x1e8>
 8008d90:	f7fe fc88 	bl	80076a4 <__addsf3>
 8008d94:	f44f 637d 	mov.w	r3, #4048	; 0xfd0
 8008d98:	f024 040f 	bic.w	r4, r4, #15
 8008d9c:	f6c3 73c9 	movt	r3, #16329	; 0x3fc9
 8008da0:	429c      	cmp	r4, r3
 8008da2:	4606      	mov	r6, r0
 8008da4:	d014      	beq.n	8008dd0 <__ieee754_rem_pio2f+0x310>
 8008da6:	f244 4143 	movw	r1, #17475	; 0x4443
 8008daa:	f04f 37ff 	mov.w	r7, #4294967295
 8008dae:	f2c3 7135 	movt	r1, #14133	; 0x3735
 8008db2:	f7fe fc77 	bl	80076a4 <__addsf3>
 8008db6:	4601      	mov	r1, r0
 8008db8:	6028      	str	r0, [r5, #0]
 8008dba:	4630      	mov	r0, r6
 8008dbc:	f7fe fc70 	bl	80076a0 <__aeabi_fsub>
 8008dc0:	f244 4143 	movw	r1, #17475	; 0x4443
 8008dc4:	f2c3 7135 	movt	r1, #14133	; 0x3735
 8008dc8:	f7fe fc6c 	bl	80076a4 <__addsf3>
 8008dcc:	6068      	str	r0, [r5, #4]
 8008dce:	e711      	b.n	8008bf4 <__ieee754_rem_pio2f+0x134>
 8008dd0:	f44f 4188 	mov.w	r1, #17408	; 0x4400
 8008dd4:	f04f 37ff 	mov.w	r7, #4294967295
 8008dd8:	f2c3 7135 	movt	r1, #14133	; 0x3735
 8008ddc:	f7fe fc62 	bl	80076a4 <__addsf3>
 8008de0:	f24a 3108 	movw	r1, #41736	; 0xa308
 8008de4:	f6c2 6185 	movt	r1, #11909	; 0x2e85
 8008de8:	4604      	mov	r4, r0
 8008dea:	f7fe fc5b 	bl	80076a4 <__addsf3>
 8008dee:	4601      	mov	r1, r0
 8008df0:	6028      	str	r0, [r5, #0]
 8008df2:	4620      	mov	r0, r4
 8008df4:	f7fe fc54 	bl	80076a0 <__aeabi_fsub>
 8008df8:	f24a 3108 	movw	r1, #41736	; 0xa308
 8008dfc:	f6c2 6185 	movt	r1, #11909	; 0x2e85
 8008e00:	f7fe fc50 	bl	80076a4 <__addsf3>
 8008e04:	6068      	str	r0, [r5, #4]
 8008e06:	e6f5      	b.n	8008bf4 <__ieee754_rem_pio2f+0x134>
 8008e08:	0800a614 	.word	0x0800a614

08008e0c <__ieee754_sqrtf>:
 8008e0c:	f020 4200 	bic.w	r2, r0, #2147483648	; 0x80000000
 8008e10:	4603      	mov	r3, r0
 8008e12:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
 8008e16:	b570      	push	{r4, r5, r6, lr}
 8008e18:	4604      	mov	r4, r0
 8008e1a:	d237      	bcs.n	8008e8c <__ieee754_sqrtf+0x80>
 8008e1c:	b3a2      	cbz	r2, 8008e88 <__ieee754_sqrtf+0x7c>
 8008e1e:	2800      	cmp	r0, #0
 8008e20:	db3e      	blt.n	8008ea0 <__ieee754_sqrtf+0x94>
 8008e22:	15c4      	asrs	r4, r0, #23
 8008e24:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
 8008e28:	d209      	bcs.n	8008e3e <__ieee754_sqrtf+0x32>
 8008e2a:	f410 0200 	ands.w	r2, r0, #8388608	; 0x800000
 8008e2e:	d13f      	bne.n	8008eb0 <__ieee754_sqrtf+0xa4>
 8008e30:	005b      	lsls	r3, r3, #1
 8008e32:	3201      	adds	r2, #1
 8008e34:	0219      	lsls	r1, r3, #8
 8008e36:	d5fb      	bpl.n	8008e30 <__ieee754_sqrtf+0x24>
 8008e38:	f1c2 0201 	rsb	r2, r2, #1
 8008e3c:	18a4      	adds	r4, r4, r2
 8008e3e:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8008e42:	3c7f      	subs	r4, #127	; 0x7f
 8008e44:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
 8008e48:	07e2      	lsls	r2, r4, #31
 8008e4a:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8008e4e:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8008e52:	bf48      	it	mi
 8008e54:	005b      	lslmi	r3, r3, #1
 8008e56:	2600      	movs	r6, #0
 8008e58:	1060      	asrs	r0, r4, #1
 8008e5a:	2119      	movs	r1, #25
 8008e5c:	005b      	lsls	r3, r3, #1
 8008e5e:	4635      	mov	r5, r6
 8008e60:	18ac      	adds	r4, r5, r2
 8008e62:	429c      	cmp	r4, r3
 8008e64:	bfde      	ittt	le
 8008e66:	ebc4 0303 	rsble	r3, r4, r3
 8008e6a:	18a5      	addle	r5, r4, r2
 8008e6c:	18b6      	addle	r6, r6, r2
 8008e6e:	0852      	lsrs	r2, r2, #1
 8008e70:	005b      	lsls	r3, r3, #1
 8008e72:	3901      	subs	r1, #1
 8008e74:	d1f4      	bne.n	8008e60 <__ieee754_sqrtf+0x54>
 8008e76:	b113      	cbz	r3, 8008e7e <__ieee754_sqrtf+0x72>
 8008e78:	f006 0301 	and.w	r3, r6, #1
 8008e7c:	18f6      	adds	r6, r6, r3
 8008e7e:	1076      	asrs	r6, r6, #1
 8008e80:	f106 567c 	add.w	r6, r6, #1056964608	; 0x3f000000
 8008e84:	eb06 54c0 	add.w	r4, r6, r0, lsl #23
 8008e88:	4620      	mov	r0, r4
 8008e8a:	bd70      	pop	{r4, r5, r6, pc}
 8008e8c:	4601      	mov	r1, r0
 8008e8e:	f7fe fd11 	bl	80078b4 <__aeabi_fmul>
 8008e92:	4601      	mov	r1, r0
 8008e94:	4620      	mov	r0, r4
 8008e96:	f7fe fc05 	bl	80076a4 <__addsf3>
 8008e9a:	4604      	mov	r4, r0
 8008e9c:	4620      	mov	r0, r4
 8008e9e:	bd70      	pop	{r4, r5, r6, pc}
 8008ea0:	4601      	mov	r1, r0
 8008ea2:	f7fe fbfd 	bl	80076a0 <__aeabi_fsub>
 8008ea6:	4601      	mov	r1, r0
 8008ea8:	f7fe fdb8 	bl	8007a1c <__aeabi_fdiv>
 8008eac:	4604      	mov	r4, r0
 8008eae:	e7eb      	b.n	8008e88 <__ieee754_sqrtf+0x7c>
 8008eb0:	2201      	movs	r2, #1
 8008eb2:	e7c3      	b.n	8008e3c <__ieee754_sqrtf+0x30>

08008eb4 <__kernel_cosf>:
 8008eb4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8008eb8:	f020 4600 	bic.w	r6, r0, #2147483648	; 0x80000000
 8008ebc:	f1b6 5f48 	cmp.w	r6, #838860800	; 0x32000000
 8008ec0:	4605      	mov	r5, r0
 8008ec2:	460f      	mov	r7, r1
 8008ec4:	da5b      	bge.n	8008f7e <__kernel_cosf+0xca>
 8008ec6:	f7fe febb 	bl	8007c40 <__aeabi_f2iz>
 8008eca:	2800      	cmp	r0, #0
 8008ecc:	f000 80ca 	beq.w	8009064 <__kernel_cosf+0x1b0>
 8008ed0:	4629      	mov	r1, r5
 8008ed2:	4628      	mov	r0, r5
 8008ed4:	f7fe fcee 	bl	80078b4 <__aeabi_fmul>
 8008ed8:	f24d 714e 	movw	r1, #55118	; 0xd74e
 8008edc:	f6ca 5147 	movt	r1, #44359	; 0xad47
 8008ee0:	4604      	mov	r4, r0
 8008ee2:	f7fe fce7 	bl	80078b4 <__aeabi_fmul>
 8008ee6:	f247 41f6 	movw	r1, #29942	; 0x74f6
 8008eea:	f2c3 110f 	movt	r1, #12559	; 0x310f
 8008eee:	f7fe fbd9 	bl	80076a4 <__addsf3>
 8008ef2:	4621      	mov	r1, r4
 8008ef4:	f7fe fcde 	bl	80078b4 <__aeabi_fmul>
 8008ef8:	f24f 217c 	movw	r1, #62076	; 0xf27c
 8008efc:	f2c3 4193 	movt	r1, #13459	; 0x3493
 8008f00:	f7fe fbce 	bl	80076a0 <__aeabi_fsub>
 8008f04:	4621      	mov	r1, r4
 8008f06:	f7fe fcd5 	bl	80078b4 <__aeabi_fmul>
 8008f0a:	f640 5101 	movw	r1, #3329	; 0xd01
 8008f0e:	f2c3 71d0 	movt	r1, #14288	; 0x37d0
 8008f12:	f7fe fbc7 	bl	80076a4 <__addsf3>
 8008f16:	4621      	mov	r1, r4
 8008f18:	f7fe fccc 	bl	80078b4 <__aeabi_fmul>
 8008f1c:	f640 3161 	movw	r1, #2913	; 0xb61
 8008f20:	f6c3 21b6 	movt	r1, #15030	; 0x3ab6
 8008f24:	f7fe fbbc 	bl	80076a0 <__aeabi_fsub>
 8008f28:	4621      	mov	r1, r4
 8008f2a:	f7fe fcc3 	bl	80078b4 <__aeabi_fmul>
 8008f2e:	f64a 21ab 	movw	r1, #43691	; 0xaaab
 8008f32:	f6c3 512a 	movt	r1, #15658	; 0x3d2a
 8008f36:	f7fe fbb5 	bl	80076a4 <__addsf3>
 8008f3a:	4621      	mov	r1, r4
 8008f3c:	f7fe fcba 	bl	80078b4 <__aeabi_fmul>
 8008f40:	4680      	mov	r8, r0
 8008f42:	4620      	mov	r0, r4
 8008f44:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 8008f48:	f7fe fcb4 	bl	80078b4 <__aeabi_fmul>
 8008f4c:	4641      	mov	r1, r8
 8008f4e:	4606      	mov	r6, r0
 8008f50:	4620      	mov	r0, r4
 8008f52:	f7fe fcaf 	bl	80078b4 <__aeabi_fmul>
 8008f56:	4639      	mov	r1, r7
 8008f58:	4604      	mov	r4, r0
 8008f5a:	4628      	mov	r0, r5
 8008f5c:	f7fe fcaa 	bl	80078b4 <__aeabi_fmul>
 8008f60:	4601      	mov	r1, r0
 8008f62:	4620      	mov	r0, r4
 8008f64:	f7fe fb9c 	bl	80076a0 <__aeabi_fsub>
 8008f68:	4601      	mov	r1, r0
 8008f6a:	4630      	mov	r0, r6
 8008f6c:	f7fe fb98 	bl	80076a0 <__aeabi_fsub>
 8008f70:	4601      	mov	r1, r0
 8008f72:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 8008f76:	f7fe fb93 	bl	80076a0 <__aeabi_fsub>
 8008f7a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8008f7e:	4601      	mov	r1, r0
 8008f80:	f7fe fc98 	bl	80078b4 <__aeabi_fmul>
 8008f84:	f24d 714e 	movw	r1, #55118	; 0xd74e
 8008f88:	f6ca 5147 	movt	r1, #44359	; 0xad47
 8008f8c:	4604      	mov	r4, r0
 8008f8e:	f7fe fc91 	bl	80078b4 <__aeabi_fmul>
 8008f92:	f247 41f6 	movw	r1, #29942	; 0x74f6
 8008f96:	f2c3 110f 	movt	r1, #12559	; 0x310f
 8008f9a:	f7fe fb83 	bl	80076a4 <__addsf3>
 8008f9e:	4621      	mov	r1, r4
 8008fa0:	f7fe fc88 	bl	80078b4 <__aeabi_fmul>
 8008fa4:	f24f 217c 	movw	r1, #62076	; 0xf27c
 8008fa8:	f2c3 4193 	movt	r1, #13459	; 0x3493
 8008fac:	f7fe fb78 	bl	80076a0 <__aeabi_fsub>
 8008fb0:	4621      	mov	r1, r4
 8008fb2:	f7fe fc7f 	bl	80078b4 <__aeabi_fmul>
 8008fb6:	f640 5101 	movw	r1, #3329	; 0xd01
 8008fba:	f2c3 71d0 	movt	r1, #14288	; 0x37d0
 8008fbe:	f7fe fb71 	bl	80076a4 <__addsf3>
 8008fc2:	4621      	mov	r1, r4
 8008fc4:	f7fe fc76 	bl	80078b4 <__aeabi_fmul>
 8008fc8:	f640 3161 	movw	r1, #2913	; 0xb61
 8008fcc:	f6c3 21b6 	movt	r1, #15030	; 0x3ab6
 8008fd0:	f7fe fb66 	bl	80076a0 <__aeabi_fsub>
 8008fd4:	4621      	mov	r1, r4
 8008fd6:	f7fe fc6d 	bl	80078b4 <__aeabi_fmul>
 8008fda:	f64a 21ab 	movw	r1, #43691	; 0xaaab
 8008fde:	f6c3 512a 	movt	r1, #15658	; 0x3d2a
 8008fe2:	f7fe fb5f 	bl	80076a4 <__addsf3>
 8008fe6:	4621      	mov	r1, r4
 8008fe8:	f7fe fc64 	bl	80078b4 <__aeabi_fmul>
 8008fec:	f649 1399 	movw	r3, #39321	; 0x9999
 8008ff0:	f6c3 6399 	movt	r3, #16025	; 0x3e99
 8008ff4:	429e      	cmp	r6, r3
 8008ff6:	4680      	mov	r8, r0
 8008ff8:	dda3      	ble.n	8008f42 <__kernel_cosf+0x8e>
 8008ffa:	2300      	movs	r3, #0
 8008ffc:	f6c3 7348 	movt	r3, #16200	; 0x3f48
 8009000:	429e      	cmp	r6, r3
 8009002:	dc27      	bgt.n	8009054 <__kernel_cosf+0x1a0>
 8009004:	f106 467f 	add.w	r6, r6, #4278190080	; 0xff000000
 8009008:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 800900c:	4631      	mov	r1, r6
 800900e:	f7fe fb47 	bl	80076a0 <__aeabi_fsub>
 8009012:	4681      	mov	r9, r0
 8009014:	4620      	mov	r0, r4
 8009016:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 800901a:	f7fe fc4b 	bl	80078b4 <__aeabi_fmul>
 800901e:	4631      	mov	r1, r6
 8009020:	f7fe fb3e 	bl	80076a0 <__aeabi_fsub>
 8009024:	4641      	mov	r1, r8
 8009026:	4606      	mov	r6, r0
 8009028:	4620      	mov	r0, r4
 800902a:	f7fe fc43 	bl	80078b4 <__aeabi_fmul>
 800902e:	4639      	mov	r1, r7
 8009030:	4604      	mov	r4, r0
 8009032:	4628      	mov	r0, r5
 8009034:	f7fe fc3e 	bl	80078b4 <__aeabi_fmul>
 8009038:	4601      	mov	r1, r0
 800903a:	4620      	mov	r0, r4
 800903c:	f7fe fb30 	bl	80076a0 <__aeabi_fsub>
 8009040:	4601      	mov	r1, r0
 8009042:	4630      	mov	r0, r6
 8009044:	f7fe fb2c 	bl	80076a0 <__aeabi_fsub>
 8009048:	4601      	mov	r1, r0
 800904a:	4648      	mov	r0, r9
 800904c:	f7fe fb28 	bl	80076a0 <__aeabi_fsub>
 8009050:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8009054:	f04f 0900 	mov.w	r9, #0
 8009058:	2600      	movs	r6, #0
 800905a:	f6c3 7938 	movt	r9, #16184	; 0x3f38
 800905e:	f6c3 6690 	movt	r6, #16016	; 0x3e90
 8009062:	e7d7      	b.n	8009014 <__kernel_cosf+0x160>
 8009064:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 8009068:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

0800906c <__kernel_rem_pio2f>:
 800906c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8009070:	b0df      	sub	sp, #380	; 0x17c
 8009072:	1d15      	adds	r5, r2, #4
 8009074:	1ed4      	subs	r4, r2, #3
 8009076:	bf58      	it	pl
 8009078:	4625      	movpl	r5, r4
 800907a:	930b      	str	r3, [sp, #44]	; 0x2c
 800907c:	f64a 142c 	movw	r4, #43308	; 0xa92c
 8009080:	3b01      	subs	r3, #1
 8009082:	9303      	str	r3, [sp, #12]
 8009084:	f6c0 0400 	movt	r4, #2048	; 0x800
 8009088:	9b68      	ldr	r3, [sp, #416]	; 0x1a0
 800908a:	10ed      	asrs	r5, r5, #3
 800908c:	ea25 75e5 	bic.w	r5, r5, r5, asr #31
 8009090:	950c      	str	r5, [sp, #48]	; 0x30
 8009092:	4606      	mov	r6, r0
 8009094:	9109      	str	r1, [sp, #36]	; 0x24
 8009096:	f854 4023 	ldr.w	r4, [r4, r3, lsl #2]
 800909a:	43eb      	mvns	r3, r5
 800909c:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
 80090a0:	9307      	str	r3, [sp, #28]
 80090a2:	9408      	str	r4, [sp, #32]
 80090a4:	9a08      	ldr	r2, [sp, #32]
 80090a6:	9c03      	ldr	r4, [sp, #12]
 80090a8:	1b2f      	subs	r7, r5, r4
 80090aa:	18a5      	adds	r5, r4, r2
 80090ac:	d415      	bmi.n	80090da <__kernel_rem_pio2f+0x6e>
 80090ae:	9b69      	ldr	r3, [sp, #420]	; 0x1a4
 80090b0:	197d      	adds	r5, r7, r5
 80090b2:	3501      	adds	r5, #1
 80090b4:	f04f 0800 	mov.w	r8, #0
 80090b8:	eb03 0987 	add.w	r9, r3, r7, lsl #2
 80090bc:	ac22      	add	r4, sp, #136	; 0x88
 80090be:	2000      	movs	r0, #0
 80090c0:	2f00      	cmp	r7, #0
 80090c2:	db03      	blt.n	80090cc <__kernel_rem_pio2f+0x60>
 80090c4:	f859 0008 	ldr.w	r0, [r9, r8]
 80090c8:	f7fe fba0 	bl	800780c <__aeabi_i2f>
 80090cc:	3701      	adds	r7, #1
 80090ce:	f844 0008 	str.w	r0, [r4, r8]
 80090d2:	42af      	cmp	r7, r5
 80090d4:	f108 0804 	add.w	r8, r8, #4
 80090d8:	d1f1      	bne.n	80090be <__kernel_rem_pio2f+0x52>
 80090da:	9b08      	ldr	r3, [sp, #32]
 80090dc:	2b00      	cmp	r3, #0
 80090de:	f2c0 82de 	blt.w	800969e <__kernel_rem_pio2f+0x632>
 80090e2:	9b08      	ldr	r3, [sp, #32]
 80090e4:	a84a      	add	r0, sp, #296	; 0x128
 80090e6:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
 80090e8:	ad49      	add	r5, sp, #292	; 0x124
 80090ea:	009b      	lsls	r3, r3, #2
 80090ec:	9302      	str	r3, [sp, #8]
 80090ee:	18c7      	adds	r7, r0, r3
 80090f0:	ea4f 0b84 	mov.w	fp, r4, lsl #2
 80090f4:	9a03      	ldr	r2, [sp, #12]
 80090f6:	2a00      	cmp	r2, #0
 80090f8:	f2c0 8208 	blt.w	800950c <__kernel_rem_pio2f+0x4a0>
 80090fc:	ab22      	add	r3, sp, #136	; 0x88
 80090fe:	f04f 0800 	mov.w	r8, #0
 8009102:	eb03 0a84 	add.w	sl, r3, r4, lsl #2
 8009106:	f04f 0900 	mov.w	r9, #0
 800910a:	f856 0008 	ldr.w	r0, [r6, r8]
 800910e:	f108 0804 	add.w	r8, r8, #4
 8009112:	f85a 1d04 	ldr.w	r1, [sl, #-4]!
 8009116:	f7fe fbcd 	bl	80078b4 <__aeabi_fmul>
 800911a:	4601      	mov	r1, r0
 800911c:	4648      	mov	r0, r9
 800911e:	f7fe fac1 	bl	80076a4 <__addsf3>
 8009122:	45d8      	cmp	r8, fp
 8009124:	4681      	mov	r9, r0
 8009126:	d1f0      	bne.n	800910a <__kernel_rem_pio2f+0x9e>
 8009128:	f845 9f04 	str.w	r9, [r5, #4]!
 800912c:	3401      	adds	r4, #1
 800912e:	42bd      	cmp	r5, r7
 8009130:	d1e0      	bne.n	80090f4 <__kernel_rem_pio2f+0x88>
 8009132:	f8dd 8020 	ldr.w	r8, [sp, #32]
 8009136:	ac0e      	add	r4, sp, #56	; 0x38
 8009138:	9a02      	ldr	r2, [sp, #8]
 800913a:	18a4      	adds	r4, r4, r2
 800913c:	940d      	str	r4, [sp, #52]	; 0x34
 800913e:	ea4f 0488 	mov.w	r4, r8, lsl #2
 8009142:	a85e      	add	r0, sp, #376	; 0x178
 8009144:	1903      	adds	r3, r0, r4
 8009146:	f1b8 0f00 	cmp.w	r8, #0
 800914a:	9402      	str	r4, [sp, #8]
 800914c:	f853 ac50 	ldr.w	sl, [r3, #-80]
 8009150:	dd22      	ble.n	8009198 <__kernel_rem_pio2f+0x12c>
 8009152:	9a02      	ldr	r2, [sp, #8]
 8009154:	ac0d      	add	r4, sp, #52	; 0x34
 8009156:	ab4a      	add	r3, sp, #296	; 0x128
 8009158:	189d      	adds	r5, r3, r2
 800915a:	18a7      	adds	r7, r4, r2
 800915c:	f04f 516e 	mov.w	r1, #998244352	; 0x3b800000
 8009160:	4650      	mov	r0, sl
 8009162:	f7fe fba7 	bl	80078b4 <__aeabi_fmul>
 8009166:	f7fe fd6b 	bl	8007c40 <__aeabi_f2iz>
 800916a:	f7fe fb4f 	bl	800780c <__aeabi_i2f>
 800916e:	f04f 4187 	mov.w	r1, #1132462080	; 0x43800000
 8009172:	4681      	mov	r9, r0
 8009174:	f7fe fb9e 	bl	80078b4 <__aeabi_fmul>
 8009178:	4601      	mov	r1, r0
 800917a:	4650      	mov	r0, sl
 800917c:	f7fe fa90 	bl	80076a0 <__aeabi_fsub>
 8009180:	f7fe fd5e 	bl	8007c40 <__aeabi_f2iz>
 8009184:	4649      	mov	r1, r9
 8009186:	f844 0f04 	str.w	r0, [r4, #4]!
 800918a:	f855 0d04 	ldr.w	r0, [r5, #-4]!
 800918e:	f7fe fa89 	bl	80076a4 <__addsf3>
 8009192:	42bc      	cmp	r4, r7
 8009194:	4682      	mov	sl, r0
 8009196:	d1e1      	bne.n	800915c <__kernel_rem_pio2f+0xf0>
 8009198:	9907      	ldr	r1, [sp, #28]
 800919a:	4650      	mov	r0, sl
 800919c:	f000 fe64 	bl	8009e68 <scalbnf>
 80091a0:	f04f 5178 	mov.w	r1, #1040187392	; 0x3e000000
 80091a4:	4604      	mov	r4, r0
 80091a6:	f7fe fb85 	bl	80078b4 <__aeabi_fmul>
 80091aa:	f000 fdfb 	bl	8009da4 <floorf>
 80091ae:	f04f 4182 	mov.w	r1, #1090519040	; 0x41000000
 80091b2:	f7fe fb7f 	bl	80078b4 <__aeabi_fmul>
 80091b6:	4601      	mov	r1, r0
 80091b8:	4620      	mov	r0, r4
 80091ba:	f7fe fa71 	bl	80076a0 <__aeabi_fsub>
 80091be:	4604      	mov	r4, r0
 80091c0:	f7fe fd3e 	bl	8007c40 <__aeabi_f2iz>
 80091c4:	4605      	mov	r5, r0
 80091c6:	f7fe fb21 	bl	800780c <__aeabi_i2f>
 80091ca:	4601      	mov	r1, r0
 80091cc:	4620      	mov	r0, r4
 80091ce:	f7fe fa67 	bl	80076a0 <__aeabi_fsub>
 80091d2:	9a07      	ldr	r2, [sp, #28]
 80091d4:	2a00      	cmp	r2, #0
 80091d6:	4607      	mov	r7, r0
 80091d8:	f340 8173 	ble.w	80094c2 <__kernel_rem_pio2f+0x456>
 80091dc:	9b07      	ldr	r3, [sp, #28]
 80091de:	f108 32ff 	add.w	r2, r8, #4294967295
 80091e2:	ac0e      	add	r4, sp, #56	; 0x38
 80091e4:	f1c3 0108 	rsb	r1, r3, #8
 80091e8:	f1c3 0007 	rsb	r0, r3, #7
 80091ec:	f854 3022 	ldr.w	r3, [r4, r2, lsl #2]
 80091f0:	fa43 f401 	asr.w	r4, r3, r1
 80091f4:	192d      	adds	r5, r5, r4
 80091f6:	fa04 f101 	lsl.w	r1, r4, r1
 80091fa:	1a5b      	subs	r3, r3, r1
 80091fc:	a90e      	add	r1, sp, #56	; 0x38
 80091fe:	fa43 fa00 	asr.w	sl, r3, r0
 8009202:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
 8009206:	f1ba 0f00 	cmp.w	sl, #0
 800920a:	dd30      	ble.n	800926e <__kernel_rem_pio2f+0x202>
 800920c:	3501      	adds	r5, #1
 800920e:	f1b8 0f00 	cmp.w	r8, #0
 8009212:	f340 8179 	ble.w	8009508 <__kernel_rem_pio2f+0x49c>
 8009216:	9c02      	ldr	r4, [sp, #8]
 8009218:	ab0e      	add	r3, sp, #56	; 0x38
 800921a:	1919      	adds	r1, r3, r4
 800921c:	2400      	movs	r4, #0
 800921e:	e007      	b.n	8009230 <__kernel_rem_pio2f+0x1c4>
 8009220:	b122      	cbz	r2, 800922c <__kernel_rem_pio2f+0x1c0>
 8009222:	2401      	movs	r4, #1
 8009224:	f5c2 7280 	rsb	r2, r2, #256	; 0x100
 8009228:	f843 2c04 	str.w	r2, [r3, #-4]
 800922c:	428b      	cmp	r3, r1
 800922e:	d00a      	beq.n	8009246 <__kernel_rem_pio2f+0x1da>
 8009230:	f853 2b04 	ldr.w	r2, [r3], #4
 8009234:	2c00      	cmp	r4, #0
 8009236:	d0f3      	beq.n	8009220 <__kernel_rem_pio2f+0x1b4>
 8009238:	2401      	movs	r4, #1
 800923a:	428b      	cmp	r3, r1
 800923c:	f1c2 02ff 	rsb	r2, r2, #255	; 0xff
 8009240:	f843 2c04 	str.w	r2, [r3, #-4]
 8009244:	d1f4      	bne.n	8009230 <__kernel_rem_pio2f+0x1c4>
 8009246:	9a07      	ldr	r2, [sp, #28]
 8009248:	2a00      	cmp	r2, #0
 800924a:	dd0d      	ble.n	8009268 <__kernel_rem_pio2f+0x1fc>
 800924c:	2a01      	cmp	r2, #1
 800924e:	f000 8141 	beq.w	80094d4 <__kernel_rem_pio2f+0x468>
 8009252:	2a02      	cmp	r2, #2
 8009254:	d108      	bne.n	8009268 <__kernel_rem_pio2f+0x1fc>
 8009256:	f108 33ff 	add.w	r3, r8, #4294967295
 800925a:	a90e      	add	r1, sp, #56	; 0x38
 800925c:	f851 2023 	ldr.w	r2, [r1, r3, lsl #2]
 8009260:	f002 023f 	and.w	r2, r2, #63	; 0x3f
 8009264:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
 8009268:	f1ba 0f02 	cmp.w	sl, #2
 800926c:	d078      	beq.n	8009360 <__kernel_rem_pio2f+0x2f4>
 800926e:	4638      	mov	r0, r7
 8009270:	2100      	movs	r1, #0
 8009272:	f7fe fcb3 	bl	8007bdc <__aeabi_fcmpeq>
 8009276:	2800      	cmp	r0, #0
 8009278:	f000 808c 	beq.w	8009394 <__kernel_rem_pio2f+0x328>
 800927c:	9a08      	ldr	r2, [sp, #32]
 800927e:	f108 30ff 	add.w	r0, r8, #4294967295
 8009282:	4282      	cmp	r2, r0
 8009284:	dc0d      	bgt.n	80092a2 <__kernel_rem_pio2f+0x236>
 8009286:	9c02      	ldr	r4, [sp, #8]
 8009288:	a90e      	add	r1, sp, #56	; 0x38
 800928a:	2200      	movs	r2, #0
 800928c:	190b      	adds	r3, r1, r4
 800928e:	9c0d      	ldr	r4, [sp, #52]	; 0x34
 8009290:	f853 1d04 	ldr.w	r1, [r3, #-4]!
 8009294:	42a3      	cmp	r3, r4
 8009296:	ea42 0201 	orr.w	r2, r2, r1
 800929a:	d1f9      	bne.n	8009290 <__kernel_rem_pio2f+0x224>
 800929c:	2a00      	cmp	r2, #0
 800929e:	f040 81e7 	bne.w	8009670 <__kernel_rem_pio2f+0x604>
 80092a2:	9b08      	ldr	r3, [sp, #32]
 80092a4:	ac0e      	add	r4, sp, #56	; 0x38
 80092a6:	1e5a      	subs	r2, r3, #1
 80092a8:	f854 3022 	ldr.w	r3, [r4, r2, lsl #2]
 80092ac:	2b00      	cmp	r3, #0
 80092ae:	f040 81f4 	bne.w	800969a <__kernel_rem_pio2f+0x62e>
 80092b2:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 80092b6:	2301      	movs	r3, #1
 80092b8:	f852 1d04 	ldr.w	r1, [r2, #-4]!
 80092bc:	3301      	adds	r3, #1
 80092be:	2900      	cmp	r1, #0
 80092c0:	d0fa      	beq.n	80092b8 <__kernel_rem_pio2f+0x24c>
 80092c2:	4443      	add	r3, r8
 80092c4:	f108 0201 	add.w	r2, r8, #1
 80092c8:	429a      	cmp	r2, r3
 80092ca:	930a      	str	r3, [sp, #40]	; 0x28
 80092cc:	dc45      	bgt.n	800935a <__kernel_rem_pio2f+0x2ee>
 80092ce:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 80092d0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80092d2:	ebc8 0a04 	rsb	sl, r8, r4
 80092d6:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
 80092d8:	eb08 0103 	add.w	r1, r8, r3
 80092dc:	9802      	ldr	r0, [sp, #8]
 80092de:	eb04 0308 	add.w	r3, r4, r8
 80092e2:	9c03      	ldr	r4, [sp, #12]
 80092e4:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 80092e8:	f8cd a014 	str.w	sl, [sp, #20]
 80092ec:	18a2      	adds	r2, r4, r2
 80092ee:	ac22      	add	r4, sp, #136	; 0x88
 80092f0:	9406      	str	r4, [sp, #24]
 80092f2:	1c55      	adds	r5, r2, #1
 80092f4:	9c69      	ldr	r4, [sp, #420]	; 0x1a4
 80092f6:	9a06      	ldr	r2, [sp, #24]
 80092f8:	eb04 0881 	add.w	r8, r4, r1, lsl #2
 80092fc:	ac4a      	add	r4, sp, #296	; 0x128
 80092fe:	1824      	adds	r4, r4, r0
 8009300:	9402      	str	r4, [sp, #8]
 8009302:	2400      	movs	r4, #0
 8009304:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8009308:	9304      	str	r3, [sp, #16]
 800930a:	f858 0f04 	ldr.w	r0, [r8, #4]!
 800930e:	f04f 0900 	mov.w	r9, #0
 8009312:	f7fe fa7b 	bl	800780c <__aeabi_i2f>
 8009316:	9a03      	ldr	r2, [sp, #12]
 8009318:	9b04      	ldr	r3, [sp, #16]
 800931a:	2a00      	cmp	r2, #0
 800931c:	5118      	str	r0, [r3, r4]
 800931e:	db13      	blt.n	8009348 <__kernel_rem_pio2f+0x2dc>
 8009320:	9b06      	ldr	r3, [sp, #24]
 8009322:	f04f 0a00 	mov.w	sl, #0
 8009326:	eb03 0785 	add.w	r7, r3, r5, lsl #2
 800932a:	f856 000a 	ldr.w	r0, [r6, sl]
 800932e:	f10a 0a04 	add.w	sl, sl, #4
 8009332:	f857 1d04 	ldr.w	r1, [r7, #-4]!
 8009336:	f7fe fabd 	bl	80078b4 <__aeabi_fmul>
 800933a:	4601      	mov	r1, r0
 800933c:	4648      	mov	r0, r9
 800933e:	f7fe f9b1 	bl	80076a4 <__addsf3>
 8009342:	45da      	cmp	sl, fp
 8009344:	4681      	mov	r9, r0
 8009346:	d1f0      	bne.n	800932a <__kernel_rem_pio2f+0x2be>
 8009348:	9b05      	ldr	r3, [sp, #20]
 800934a:	3404      	adds	r4, #4
 800934c:	9a02      	ldr	r2, [sp, #8]
 800934e:	3501      	adds	r5, #1
 8009350:	429c      	cmp	r4, r3
 8009352:	f842 9f04 	str.w	r9, [r2, #4]!
 8009356:	9202      	str	r2, [sp, #8]
 8009358:	d1d7      	bne.n	800930a <__kernel_rem_pio2f+0x29e>
 800935a:	f8dd 8028 	ldr.w	r8, [sp, #40]	; 0x28
 800935e:	e6ee      	b.n	800913e <__kernel_rem_pio2f+0xd2>
 8009360:	4639      	mov	r1, r7
 8009362:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 8009366:	f7fe f99b 	bl	80076a0 <__aeabi_fsub>
 800936a:	4607      	mov	r7, r0
 800936c:	2c00      	cmp	r4, #0
 800936e:	f43f af7e 	beq.w	800926e <__kernel_rem_pio2f+0x202>
 8009372:	9907      	ldr	r1, [sp, #28]
 8009374:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 8009378:	f000 fd76 	bl	8009e68 <scalbnf>
 800937c:	4601      	mov	r1, r0
 800937e:	4638      	mov	r0, r7
 8009380:	f7fe f98e 	bl	80076a0 <__aeabi_fsub>
 8009384:	2100      	movs	r1, #0
 8009386:	4607      	mov	r7, r0
 8009388:	4638      	mov	r0, r7
 800938a:	f7fe fc27 	bl	8007bdc <__aeabi_fcmpeq>
 800938e:	2800      	cmp	r0, #0
 8009390:	f47f af74 	bne.w	800927c <__kernel_rem_pio2f+0x210>
 8009394:	9b07      	ldr	r3, [sp, #28]
 8009396:	4638      	mov	r0, r7
 8009398:	9502      	str	r5, [sp, #8]
 800939a:	4654      	mov	r4, sl
 800939c:	4259      	negs	r1, r3
 800939e:	f000 fd63 	bl	8009e68 <scalbnf>
 80093a2:	f04f 4187 	mov.w	r1, #1132462080	; 0x43800000
 80093a6:	4605      	mov	r5, r0
 80093a8:	f7fe fc36 	bl	8007c18 <__aeabi_fcmpge>
 80093ac:	2800      	cmp	r0, #0
 80093ae:	f000 817c 	beq.w	80096aa <__kernel_rem_pio2f+0x63e>
 80093b2:	f04f 516e 	mov.w	r1, #998244352	; 0x3b800000
 80093b6:	4628      	mov	r0, r5
 80093b8:	f7fe fa7c 	bl	80078b4 <__aeabi_fmul>
 80093bc:	9a07      	ldr	r2, [sp, #28]
 80093be:	3208      	adds	r2, #8
 80093c0:	9207      	str	r2, [sp, #28]
 80093c2:	f7fe fc3d 	bl	8007c40 <__aeabi_f2iz>
 80093c6:	f7fe fa21 	bl	800780c <__aeabi_i2f>
 80093ca:	f04f 4187 	mov.w	r1, #1132462080	; 0x43800000
 80093ce:	4606      	mov	r6, r0
 80093d0:	f7fe fa70 	bl	80078b4 <__aeabi_fmul>
 80093d4:	4601      	mov	r1, r0
 80093d6:	4628      	mov	r0, r5
 80093d8:	f7fe f962 	bl	80076a0 <__aeabi_fsub>
 80093dc:	f7fe fc30 	bl	8007c40 <__aeabi_f2iz>
 80093e0:	ab0e      	add	r3, sp, #56	; 0x38
 80093e2:	f843 0028 	str.w	r0, [r3, r8, lsl #2]
 80093e6:	4630      	mov	r0, r6
 80093e8:	f7fe fc2a 	bl	8007c40 <__aeabi_f2iz>
 80093ec:	f108 0801 	add.w	r8, r8, #1
 80093f0:	a90e      	add	r1, sp, #56	; 0x38
 80093f2:	f841 0028 	str.w	r0, [r1, r8, lsl #2]
 80093f6:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 80093fa:	9907      	ldr	r1, [sp, #28]
 80093fc:	f000 fd34 	bl	8009e68 <scalbnf>
 8009400:	f1b8 0f00 	cmp.w	r8, #0
 8009404:	4605      	mov	r5, r0
 8009406:	db53      	blt.n	80094b0 <__kernel_rem_pio2f+0x444>
 8009408:	ebc8 7788 	rsb	r7, r8, r8, lsl #30
 800940c:	ea4f 0688 	mov.w	r6, r8, lsl #2
 8009410:	ab0e      	add	r3, sp, #56	; 0x38
 8009412:	a84a      	add	r0, sp, #296	; 0x128
 8009414:	00bf      	lsls	r7, r7, #2
 8009416:	eb03 0906 	add.w	r9, r3, r6
 800941a:	3f04      	subs	r7, #4
 800941c:	1986      	adds	r6, r0, r6
 800941e:	f04f 0b00 	mov.w	fp, #0
 8009422:	f859 000b 	ldr.w	r0, [r9, fp]
 8009426:	f7fe f9f1 	bl	800780c <__aeabi_i2f>
 800942a:	4629      	mov	r1, r5
 800942c:	f7fe fa42 	bl	80078b4 <__aeabi_fmul>
 8009430:	f04f 516e 	mov.w	r1, #998244352	; 0x3b800000
 8009434:	f846 000b 	str.w	r0, [r6, fp]
 8009438:	4628      	mov	r0, r5
 800943a:	f7fe fa3b 	bl	80078b4 <__aeabi_fmul>
 800943e:	f1ab 0b04 	sub.w	fp, fp, #4
 8009442:	45bb      	cmp	fp, r7
 8009444:	4605      	mov	r5, r0
 8009446:	d1ec      	bne.n	8009422 <__kernel_rem_pio2f+0x3b6>
 8009448:	4f9d      	ldr	r7, [pc, #628]	; (80096c0 <__kernel_rem_pio2f+0x654>)
 800944a:	f108 0b01 	add.w	fp, r8, #1
 800944e:	f8dd a020 	ldr.w	sl, [sp, #32]
 8009452:	2500      	movs	r5, #0
 8009454:	f8cd 800c 	str.w	r8, [sp, #12]
 8009458:	9404      	str	r4, [sp, #16]
 800945a:	f1ba 0f00 	cmp.w	sl, #0
 800945e:	f2c0 8105 	blt.w	800966c <__kernel_rem_pio2f+0x600>
 8009462:	2d00      	cmp	r5, #0
 8009464:	f2c0 8102 	blt.w	800966c <__kernel_rem_pio2f+0x600>
 8009468:	f04f 0900 	mov.w	r9, #0
 800946c:	2400      	movs	r4, #0
 800946e:	46c8      	mov	r8, r9
 8009470:	e001      	b.n	8009476 <__kernel_rem_pio2f+0x40a>
 8009472:	45a8      	cmp	r8, r5
 8009474:	dc10      	bgt.n	8009498 <__kernel_rem_pio2f+0x42c>
 8009476:	f856 1009 	ldr.w	r1, [r6, r9]
 800947a:	f108 0801 	add.w	r8, r8, #1
 800947e:	f857 0009 	ldr.w	r0, [r7, r9]
 8009482:	f109 0904 	add.w	r9, r9, #4
 8009486:	f7fe fa15 	bl	80078b4 <__aeabi_fmul>
 800948a:	4601      	mov	r1, r0
 800948c:	4620      	mov	r0, r4
 800948e:	f7fe f909 	bl	80076a4 <__addsf3>
 8009492:	45c2      	cmp	sl, r8
 8009494:	4604      	mov	r4, r0
 8009496:	daec      	bge.n	8009472 <__kernel_rem_pio2f+0x406>
 8009498:	a95e      	add	r1, sp, #376	; 0x178
 800949a:	3e04      	subs	r6, #4
 800949c:	eb01 0385 	add.w	r3, r1, r5, lsl #2
 80094a0:	3501      	adds	r5, #1
 80094a2:	455d      	cmp	r5, fp
 80094a4:	f843 4ca0 	str.w	r4, [r3, #-160]
 80094a8:	d1d7      	bne.n	800945a <__kernel_rem_pio2f+0x3ee>
 80094aa:	f8dd 800c 	ldr.w	r8, [sp, #12]
 80094ae:	9c04      	ldr	r4, [sp, #16]
 80094b0:	9a68      	ldr	r2, [sp, #416]	; 0x1a0
 80094b2:	2a03      	cmp	r2, #3
 80094b4:	d843      	bhi.n	800953e <__kernel_rem_pio2f+0x4d2>
 80094b6:	e8df f012 	tbh	[pc, r2, lsl #1]
 80094ba:	00c4      	.short	0x00c4
 80094bc:	00980098 	.word	0x00980098
 80094c0:	0048      	.short	0x0048
 80094c2:	d111      	bne.n	80094e8 <__kernel_rem_pio2f+0x47c>
 80094c4:	f108 33ff 	add.w	r3, r8, #4294967295
 80094c8:	aa0e      	add	r2, sp, #56	; 0x38
 80094ca:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80094ce:	ea4f 2a23 	mov.w	sl, r3, asr #8
 80094d2:	e698      	b.n	8009206 <__kernel_rem_pio2f+0x19a>
 80094d4:	f108 33ff 	add.w	r3, r8, #4294967295
 80094d8:	a80e      	add	r0, sp, #56	; 0x38
 80094da:	f850 2023 	ldr.w	r2, [r0, r3, lsl #2]
 80094de:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 80094e2:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
 80094e6:	e6bf      	b.n	8009268 <__kernel_rem_pio2f+0x1fc>
 80094e8:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 80094ec:	f04f 0a00 	mov.w	sl, #0
 80094f0:	f7fe fb92 	bl	8007c18 <__aeabi_fcmpge>
 80094f4:	2800      	cmp	r0, #0
 80094f6:	f43f aeba 	beq.w	800926e <__kernel_rem_pio2f+0x202>
 80094fa:	3501      	adds	r5, #1
 80094fc:	f1b8 0f00 	cmp.w	r8, #0
 8009500:	f04f 0a02 	mov.w	sl, #2
 8009504:	f73f ae87 	bgt.w	8009216 <__kernel_rem_pio2f+0x1aa>
 8009508:	2400      	movs	r4, #0
 800950a:	e69c      	b.n	8009246 <__kernel_rem_pio2f+0x1da>
 800950c:	f04f 0900 	mov.w	r9, #0
 8009510:	3401      	adds	r4, #1
 8009512:	f845 9f04 	str.w	r9, [r5, #4]!
 8009516:	42bd      	cmp	r5, r7
 8009518:	f47f adec 	bne.w	80090f4 <__kernel_rem_pio2f+0x88>
 800951c:	e609      	b.n	8009132 <__kernel_rem_pio2f+0xc6>
 800951e:	2000      	movs	r0, #0
 8009520:	2c00      	cmp	r4, #0
 8009522:	d05b      	beq.n	80095dc <__kernel_rem_pio2f+0x570>
 8009524:	9b36      	ldr	r3, [sp, #216]	; 0xd8
 8009526:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
 800952a:	9c09      	ldr	r4, [sp, #36]	; 0x24
 800952c:	f103 4200 	add.w	r2, r3, #2147483648	; 0x80000000
 8009530:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8009532:	6098      	str	r0, [r3, #8]
 8009534:	9b37      	ldr	r3, [sp, #220]	; 0xdc
 8009536:	6022      	str	r2, [r4, #0]
 8009538:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
 800953c:	6063      	str	r3, [r4, #4]
 800953e:	9a02      	ldr	r2, [sp, #8]
 8009540:	f002 0007 	and.w	r0, r2, #7
 8009544:	b05f      	add	sp, #380	; 0x17c
 8009546:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800954a:	f1b8 0f00 	cmp.w	r8, #0
 800954e:	dde6      	ble.n	800951e <__kernel_rem_pio2f+0x4b2>
 8009550:	f108 35ff 	add.w	r5, r8, #4294967295
 8009554:	af36      	add	r7, sp, #216	; 0xd8
 8009556:	aa35      	add	r2, sp, #212	; 0xd4
 8009558:	eb07 0585 	add.w	r5, r7, r5, lsl #2
 800955c:	462e      	mov	r6, r5
 800955e:	f856 b904 	ldr.w	fp, [r6], #-4
 8009562:	f8d6 a008 	ldr.w	sl, [r6, #8]
 8009566:	4658      	mov	r0, fp
 8009568:	9201      	str	r2, [sp, #4]
 800956a:	4651      	mov	r1, sl
 800956c:	f7fe f89a 	bl	80076a4 <__addsf3>
 8009570:	4681      	mov	r9, r0
 8009572:	4658      	mov	r0, fp
 8009574:	4649      	mov	r1, r9
 8009576:	f7fe f893 	bl	80076a0 <__aeabi_fsub>
 800957a:	4601      	mov	r1, r0
 800957c:	4650      	mov	r0, sl
 800957e:	f7fe f891 	bl	80076a4 <__addsf3>
 8009582:	9a01      	ldr	r2, [sp, #4]
 8009584:	f8c6 9004 	str.w	r9, [r6, #4]
 8009588:	4296      	cmp	r6, r2
 800958a:	60b0      	str	r0, [r6, #8]
 800958c:	d1e7      	bne.n	800955e <__kernel_rem_pio2f+0x4f2>
 800958e:	f1b8 0f01 	cmp.w	r8, #1
 8009592:	ddc4      	ble.n	800951e <__kernel_rem_pio2f+0x4b2>
 8009594:	f855 a904 	ldr.w	sl, [r5], #-4
 8009598:	f8d5 9008 	ldr.w	r9, [r5, #8]
 800959c:	4650      	mov	r0, sl
 800959e:	4649      	mov	r1, r9
 80095a0:	f7fe f880 	bl	80076a4 <__addsf3>
 80095a4:	4606      	mov	r6, r0
 80095a6:	4650      	mov	r0, sl
 80095a8:	4631      	mov	r1, r6
 80095aa:	f7fe f879 	bl	80076a0 <__aeabi_fsub>
 80095ae:	4601      	mov	r1, r0
 80095b0:	4648      	mov	r0, r9
 80095b2:	f7fe f877 	bl	80076a4 <__addsf3>
 80095b6:	42bd      	cmp	r5, r7
 80095b8:	606e      	str	r6, [r5, #4]
 80095ba:	60a8      	str	r0, [r5, #8]
 80095bc:	d1ea      	bne.n	8009594 <__kernel_rem_pio2f+0x528>
 80095be:	f108 0801 	add.w	r8, r8, #1
 80095c2:	f105 0608 	add.w	r6, r5, #8
 80095c6:	2000      	movs	r0, #0
 80095c8:	eb05 0588 	add.w	r5, r5, r8, lsl #2
 80095cc:	f855 1d04 	ldr.w	r1, [r5, #-4]!
 80095d0:	f7fe f868 	bl	80076a4 <__addsf3>
 80095d4:	42b5      	cmp	r5, r6
 80095d6:	d1f9      	bne.n	80095cc <__kernel_rem_pio2f+0x560>
 80095d8:	2c00      	cmp	r4, #0
 80095da:	d1a3      	bne.n	8009524 <__kernel_rem_pio2f+0x4b8>
 80095dc:	9c09      	ldr	r4, [sp, #36]	; 0x24
 80095de:	9b36      	ldr	r3, [sp, #216]	; 0xd8
 80095e0:	60a0      	str	r0, [r4, #8]
 80095e2:	6023      	str	r3, [r4, #0]
 80095e4:	9b37      	ldr	r3, [sp, #220]	; 0xdc
 80095e6:	6063      	str	r3, [r4, #4]
 80095e8:	e7a9      	b.n	800953e <__kernel_rem_pio2f+0x4d2>
 80095ea:	2000      	movs	r0, #0
 80095ec:	f1b8 0f00 	cmp.w	r8, #0
 80095f0:	db0b      	blt.n	800960a <__kernel_rem_pio2f+0x59e>
 80095f2:	f108 0501 	add.w	r5, r8, #1
 80095f6:	ae36      	add	r6, sp, #216	; 0xd8
 80095f8:	2000      	movs	r0, #0
 80095fa:	eb06 0585 	add.w	r5, r6, r5, lsl #2
 80095fe:	f855 1d04 	ldr.w	r1, [r5, #-4]!
 8009602:	f7fe f84f 	bl	80076a4 <__addsf3>
 8009606:	42b5      	cmp	r5, r6
 8009608:	d1f9      	bne.n	80095fe <__kernel_rem_pio2f+0x592>
 800960a:	f100 4300 	add.w	r3, r0, #2147483648	; 0x80000000
 800960e:	b904      	cbnz	r4, 8009612 <__kernel_rem_pio2f+0x5a6>
 8009610:	4603      	mov	r3, r0
 8009612:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8009614:	4601      	mov	r1, r0
 8009616:	9836      	ldr	r0, [sp, #216]	; 0xd8
 8009618:	6013      	str	r3, [r2, #0]
 800961a:	f7fe f841 	bl	80076a0 <__aeabi_fsub>
 800961e:	f1b8 0f00 	cmp.w	r8, #0
 8009622:	dd08      	ble.n	8009636 <__kernel_rem_pio2f+0x5ca>
 8009624:	ad36      	add	r5, sp, #216	; 0xd8
 8009626:	eb05 0888 	add.w	r8, r5, r8, lsl #2
 800962a:	f855 1f04 	ldr.w	r1, [r5, #4]!
 800962e:	f7fe f839 	bl	80076a4 <__addsf3>
 8009632:	4545      	cmp	r5, r8
 8009634:	d1f9      	bne.n	800962a <__kernel_rem_pio2f+0x5be>
 8009636:	b10c      	cbz	r4, 800963c <__kernel_rem_pio2f+0x5d0>
 8009638:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
 800963c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800963e:	6058      	str	r0, [r3, #4]
 8009640:	e77d      	b.n	800953e <__kernel_rem_pio2f+0x4d2>
 8009642:	f1b8 0f00 	cmp.w	r8, #0
 8009646:	db39      	blt.n	80096bc <__kernel_rem_pio2f+0x650>
 8009648:	f108 0501 	add.w	r5, r8, #1
 800964c:	ae36      	add	r6, sp, #216	; 0xd8
 800964e:	2000      	movs	r0, #0
 8009650:	eb06 0585 	add.w	r5, r6, r5, lsl #2
 8009654:	f855 1d04 	ldr.w	r1, [r5, #-4]!
 8009658:	f7fe f824 	bl	80076a4 <__addsf3>
 800965c:	42b5      	cmp	r5, r6
 800965e:	d1f9      	bne.n	8009654 <__kernel_rem_pio2f+0x5e8>
 8009660:	b10c      	cbz	r4, 8009666 <__kernel_rem_pio2f+0x5fa>
 8009662:	f100 4000 	add.w	r0, r0, #2147483648	; 0x80000000
 8009666:	9c09      	ldr	r4, [sp, #36]	; 0x24
 8009668:	6020      	str	r0, [r4, #0]
 800966a:	e768      	b.n	800953e <__kernel_rem_pio2f+0x4d2>
 800966c:	2400      	movs	r4, #0
 800966e:	e713      	b.n	8009498 <__kernel_rem_pio2f+0x42c>
 8009670:	a90e      	add	r1, sp, #56	; 0x38
 8009672:	9a07      	ldr	r2, [sp, #28]
 8009674:	9502      	str	r5, [sp, #8]
 8009676:	4654      	mov	r4, sl
 8009678:	f851 3020 	ldr.w	r3, [r1, r0, lsl #2]
 800967c:	3a08      	subs	r2, #8
 800967e:	9207      	str	r2, [sp, #28]
 8009680:	b9d3      	cbnz	r3, 80096b8 <__kernel_rem_pio2f+0x64c>
 8009682:	eb01 0380 	add.w	r3, r1, r0, lsl #2
 8009686:	4680      	mov	r8, r0
 8009688:	f853 1d04 	ldr.w	r1, [r3, #-4]!
 800968c:	f108 38ff 	add.w	r8, r8, #4294967295
 8009690:	3a08      	subs	r2, #8
 8009692:	2900      	cmp	r1, #0
 8009694:	d0f8      	beq.n	8009688 <__kernel_rem_pio2f+0x61c>
 8009696:	9207      	str	r2, [sp, #28]
 8009698:	e6ad      	b.n	80093f6 <__kernel_rem_pio2f+0x38a>
 800969a:	2301      	movs	r3, #1
 800969c:	e611      	b.n	80092c2 <__kernel_rem_pio2f+0x256>
 800969e:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80096a0:	009c      	lsls	r4, r3, #2
 80096a2:	9402      	str	r4, [sp, #8]
 80096a4:	ea4f 0b82 	mov.w	fp, r2, lsl #2
 80096a8:	e543      	b.n	8009132 <__kernel_rem_pio2f+0xc6>
 80096aa:	4628      	mov	r0, r5
 80096ac:	f7fe fac8 	bl	8007c40 <__aeabi_f2iz>
 80096b0:	aa0e      	add	r2, sp, #56	; 0x38
 80096b2:	f842 0028 	str.w	r0, [r2, r8, lsl #2]
 80096b6:	e69e      	b.n	80093f6 <__kernel_rem_pio2f+0x38a>
 80096b8:	4680      	mov	r8, r0
 80096ba:	e69c      	b.n	80093f6 <__kernel_rem_pio2f+0x38a>
 80096bc:	2000      	movs	r0, #0
 80096be:	e7cf      	b.n	8009660 <__kernel_rem_pio2f+0x5f4>
 80096c0:	0800a938 	.word	0x0800a938

080096c4 <__kernel_sinf>:
 80096c4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80096c8:	f020 4300 	bic.w	r3, r0, #2147483648	; 0x80000000
 80096cc:	f1b3 5f48 	cmp.w	r3, #838860800	; 0x32000000
 80096d0:	4604      	mov	r4, r0
 80096d2:	460f      	mov	r7, r1
 80096d4:	4690      	mov	r8, r2
 80096d6:	da03      	bge.n	80096e0 <__kernel_sinf+0x1c>
 80096d8:	f7fe fab2 	bl	8007c40 <__aeabi_f2iz>
 80096dc:	2800      	cmp	r0, #0
 80096de:	d059      	beq.n	8009794 <__kernel_sinf+0xd0>
 80096e0:	4621      	mov	r1, r4
 80096e2:	4620      	mov	r0, r4
 80096e4:	f7fe f8e6 	bl	80078b4 <__aeabi_fmul>
 80096e8:	4621      	mov	r1, r4
 80096ea:	4605      	mov	r5, r0
 80096ec:	f7fe f8e2 	bl	80078b4 <__aeabi_fmul>
 80096f0:	f64c 11d3 	movw	r1, #51667	; 0xc9d3
 80096f4:	f6c2 712e 	movt	r1, #12078	; 0x2f2e
 80096f8:	4606      	mov	r6, r0
 80096fa:	4628      	mov	r0, r5
 80096fc:	f7fe f8da 	bl	80078b4 <__aeabi_fmul>
 8009700:	f642 7134 	movw	r1, #12084	; 0x2f34
 8009704:	f2c3 21d7 	movt	r1, #13015	; 0x32d7
 8009708:	f7fd ffca 	bl	80076a0 <__aeabi_fsub>
 800970c:	4629      	mov	r1, r5
 800970e:	f7fe f8d1 	bl	80078b4 <__aeabi_fmul>
 8009712:	f64e 711b 	movw	r1, #61211	; 0xef1b
 8009716:	f2c3 6138 	movt	r1, #13880	; 0x3638
 800971a:	f7fd ffc3 	bl	80076a4 <__addsf3>
 800971e:	4629      	mov	r1, r5
 8009720:	f7fe f8c8 	bl	80078b4 <__aeabi_fmul>
 8009724:	f640 5101 	movw	r1, #3329	; 0xd01
 8009728:	f6c3 1150 	movt	r1, #14672	; 0x3950
 800972c:	f7fd ffb8 	bl	80076a0 <__aeabi_fsub>
 8009730:	4629      	mov	r1, r5
 8009732:	f7fe f8bf 	bl	80078b4 <__aeabi_fmul>
 8009736:	f648 0189 	movw	r1, #34953	; 0x8889
 800973a:	f6c3 4108 	movt	r1, #15368	; 0x3c08
 800973e:	f7fd ffb1 	bl	80076a4 <__addsf3>
 8009742:	4681      	mov	r9, r0
 8009744:	f1b8 0f00 	cmp.w	r8, #0
 8009748:	d027      	beq.n	800979a <__kernel_sinf+0xd6>
 800974a:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
 800974e:	4638      	mov	r0, r7
 8009750:	f7fe f8b0 	bl	80078b4 <__aeabi_fmul>
 8009754:	4649      	mov	r1, r9
 8009756:	4680      	mov	r8, r0
 8009758:	4630      	mov	r0, r6
 800975a:	f7fe f8ab 	bl	80078b4 <__aeabi_fmul>
 800975e:	4601      	mov	r1, r0
 8009760:	4640      	mov	r0, r8
 8009762:	f7fd ff9d 	bl	80076a0 <__aeabi_fsub>
 8009766:	4629      	mov	r1, r5
 8009768:	f7fe f8a4 	bl	80078b4 <__aeabi_fmul>
 800976c:	4639      	mov	r1, r7
 800976e:	f7fd ff97 	bl	80076a0 <__aeabi_fsub>
 8009772:	f64a 21ab 	movw	r1, #43691	; 0xaaab
 8009776:	f6c3 612a 	movt	r1, #15914	; 0x3e2a
 800977a:	4605      	mov	r5, r0
 800977c:	4630      	mov	r0, r6
 800977e:	f7fe f899 	bl	80078b4 <__aeabi_fmul>
 8009782:	4601      	mov	r1, r0
 8009784:	4628      	mov	r0, r5
 8009786:	f7fd ff8d 	bl	80076a4 <__addsf3>
 800978a:	4601      	mov	r1, r0
 800978c:	4620      	mov	r0, r4
 800978e:	f7fd ff87 	bl	80076a0 <__aeabi_fsub>
 8009792:	4604      	mov	r4, r0
 8009794:	4620      	mov	r0, r4
 8009796:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800979a:	4601      	mov	r1, r0
 800979c:	4628      	mov	r0, r5
 800979e:	f7fe f889 	bl	80078b4 <__aeabi_fmul>
 80097a2:	f64a 21ab 	movw	r1, #43691	; 0xaaab
 80097a6:	f6c3 612a 	movt	r1, #15914	; 0x3e2a
 80097aa:	f7fd ff79 	bl	80076a0 <__aeabi_fsub>
 80097ae:	4631      	mov	r1, r6
 80097b0:	f7fe f880 	bl	80078b4 <__aeabi_fmul>
 80097b4:	4601      	mov	r1, r0
 80097b6:	4620      	mov	r0, r4
 80097b8:	f7fd ff74 	bl	80076a4 <__addsf3>
 80097bc:	4604      	mov	r4, r0
 80097be:	4620      	mov	r0, r4
 80097c0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80097c4:	0000      	movs	r0, r0
	...

080097c8 <atan>:
 80097c8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80097cc:	4689      	mov	r9, r1
 80097ce:	f64f 71ff 	movw	r1, #65535	; 0xffff
 80097d2:	f029 4400 	bic.w	r4, r9, #2147483648	; 0x80000000
 80097d6:	f2c4 410f 	movt	r1, #17423	; 0x440f
 80097da:	4680      	mov	r8, r0
 80097dc:	428c      	cmp	r4, r1
 80097de:	464a      	mov	r2, r9
 80097e0:	46ca      	mov	sl, r9
 80097e2:	dd1f      	ble.n	8009824 <atan+0x5c>
 80097e4:	2300      	movs	r3, #0
 80097e6:	f6c7 73f0 	movt	r3, #32752	; 0x7ff0
 80097ea:	429c      	cmp	r4, r3
 80097ec:	f300 80c0 	bgt.w	8009970 <atan+0x1a8>
 80097f0:	bf14      	ite	ne
 80097f2:	2300      	movne	r3, #0
 80097f4:	2301      	moveq	r3, #1
 80097f6:	2800      	cmp	r0, #0
 80097f8:	bf0c      	ite	eq
 80097fa:	2100      	moveq	r1, #0
 80097fc:	f003 0101 	andne.w	r1, r3, #1
 8009800:	2900      	cmp	r1, #0
 8009802:	f040 80b5 	bne.w	8009970 <atan+0x1a8>
 8009806:	f242 19fb 	movw	r9, #8699	; 0x21fb
 800980a:	f642 5818 	movw	r8, #11544	; 0x2d18
 800980e:	464b      	mov	r3, r9
 8009810:	f6cb 79f9 	movt	r9, #49145	; 0xbff9
 8009814:	f6c3 73f9 	movt	r3, #16377	; 0x3ff9
 8009818:	f2c5 4844 	movt	r8, #21572	; 0x5444
 800981c:	2a00      	cmp	r2, #0
 800981e:	bfc8      	it	gt
 8009820:	4699      	movgt	r9, r3
 8009822:	e0ad      	b.n	8009980 <atan+0x1b8>
 8009824:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8009828:	f6c3 73db 	movt	r3, #16347	; 0x3fdb
 800982c:	429c      	cmp	r4, r3
 800982e:	f300 80ba 	bgt.w	80099a6 <atan+0x1de>
 8009832:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8009836:	f6c3 631f 	movt	r3, #15903	; 0x3e1f
 800983a:	429c      	cmp	r4, r3
 800983c:	f340 80a4 	ble.w	8009988 <atan+0x1c0>
 8009840:	f04f 3bff 	mov.w	fp, #4294967295
 8009844:	4642      	mov	r2, r8
 8009846:	464b      	mov	r3, r9
 8009848:	4640      	mov	r0, r8
 800984a:	4649      	mov	r1, r9
 800984c:	f000 fb7a 	bl	8009f44 <__aeabi_dmul>
 8009850:	4602      	mov	r2, r0
 8009852:	460b      	mov	r3, r1
 8009854:	4606      	mov	r6, r0
 8009856:	460f      	mov	r7, r1
 8009858:	f000 fb74 	bl	8009f44 <__aeabi_dmul>
 800985c:	a38e      	add	r3, pc, #568	; (adr r3, 8009a98 <atan+0x2d0>)
 800985e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009862:	4604      	mov	r4, r0
 8009864:	460d      	mov	r5, r1
 8009866:	f000 fb6d 	bl	8009f44 <__aeabi_dmul>
 800986a:	a38d      	add	r3, pc, #564	; (adr r3, 8009aa0 <atan+0x2d8>)
 800986c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009870:	f7fd fce8 	bl	8007244 <__adddf3>
 8009874:	4622      	mov	r2, r4
 8009876:	462b      	mov	r3, r5
 8009878:	f000 fb64 	bl	8009f44 <__aeabi_dmul>
 800987c:	a38a      	add	r3, pc, #552	; (adr r3, 8009aa8 <atan+0x2e0>)
 800987e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009882:	f7fd fcdf 	bl	8007244 <__adddf3>
 8009886:	4622      	mov	r2, r4
 8009888:	462b      	mov	r3, r5
 800988a:	f000 fb5b 	bl	8009f44 <__aeabi_dmul>
 800988e:	a388      	add	r3, pc, #544	; (adr r3, 8009ab0 <atan+0x2e8>)
 8009890:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009894:	f7fd fcd6 	bl	8007244 <__adddf3>
 8009898:	4622      	mov	r2, r4
 800989a:	462b      	mov	r3, r5
 800989c:	f000 fb52 	bl	8009f44 <__aeabi_dmul>
 80098a0:	a385      	add	r3, pc, #532	; (adr r3, 8009ab8 <atan+0x2f0>)
 80098a2:	e9d3 2300 	ldrd	r2, r3, [r3]
 80098a6:	f7fd fccd 	bl	8007244 <__adddf3>
 80098aa:	4622      	mov	r2, r4
 80098ac:	462b      	mov	r3, r5
 80098ae:	f000 fb49 	bl	8009f44 <__aeabi_dmul>
 80098b2:	a383      	add	r3, pc, #524	; (adr r3, 8009ac0 <atan+0x2f8>)
 80098b4:	e9d3 2300 	ldrd	r2, r3, [r3]
 80098b8:	f7fd fcc4 	bl	8007244 <__adddf3>
 80098bc:	4632      	mov	r2, r6
 80098be:	463b      	mov	r3, r7
 80098c0:	f000 fb40 	bl	8009f44 <__aeabi_dmul>
 80098c4:	a380      	add	r3, pc, #512	; (adr r3, 8009ac8 <atan+0x300>)
 80098c6:	e9d3 2300 	ldrd	r2, r3, [r3]
 80098ca:	4606      	mov	r6, r0
 80098cc:	460f      	mov	r7, r1
 80098ce:	4620      	mov	r0, r4
 80098d0:	4629      	mov	r1, r5
 80098d2:	f000 fb37 	bl	8009f44 <__aeabi_dmul>
 80098d6:	a37e      	add	r3, pc, #504	; (adr r3, 8009ad0 <atan+0x308>)
 80098d8:	e9d3 2300 	ldrd	r2, r3, [r3]
 80098dc:	f7fd fcb0 	bl	8007240 <__aeabi_dsub>
 80098e0:	4622      	mov	r2, r4
 80098e2:	462b      	mov	r3, r5
 80098e4:	f000 fb2e 	bl	8009f44 <__aeabi_dmul>
 80098e8:	a37b      	add	r3, pc, #492	; (adr r3, 8009ad8 <atan+0x310>)
 80098ea:	e9d3 2300 	ldrd	r2, r3, [r3]
 80098ee:	f7fd fca7 	bl	8007240 <__aeabi_dsub>
 80098f2:	4622      	mov	r2, r4
 80098f4:	462b      	mov	r3, r5
 80098f6:	f000 fb25 	bl	8009f44 <__aeabi_dmul>
 80098fa:	a379      	add	r3, pc, #484	; (adr r3, 8009ae0 <atan+0x318>)
 80098fc:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009900:	f7fd fc9e 	bl	8007240 <__aeabi_dsub>
 8009904:	4622      	mov	r2, r4
 8009906:	462b      	mov	r3, r5
 8009908:	f000 fb1c 	bl	8009f44 <__aeabi_dmul>
 800990c:	a376      	add	r3, pc, #472	; (adr r3, 8009ae8 <atan+0x320>)
 800990e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8009912:	f7fd fc95 	bl	8007240 <__aeabi_dsub>
 8009916:	4622      	mov	r2, r4
 8009918:	462b      	mov	r3, r5
 800991a:	f000 fb13 	bl	8009f44 <__aeabi_dmul>
 800991e:	f1bb 3fff 	cmp.w	fp, #4294967295
 8009922:	4602      	mov	r2, r0
 8009924:	460b      	mov	r3, r1
 8009926:	d063      	beq.n	80099f0 <atan+0x228>
 8009928:	f64a 1468 	movw	r4, #43368	; 0xa968
 800992c:	4630      	mov	r0, r6
 800992e:	f6c0 0400 	movt	r4, #2048	; 0x800
 8009932:	4639      	mov	r1, r7
 8009934:	eb04 0bcb 	add.w	fp, r4, fp, lsl #3
 8009938:	f7fd fc84 	bl	8007244 <__adddf3>
 800993c:	464b      	mov	r3, r9
 800993e:	4642      	mov	r2, r8
 8009940:	f000 fb00 	bl	8009f44 <__aeabi_dmul>
 8009944:	e9db 2308 	ldrd	r2, r3, [fp, #32]
 8009948:	f7fd fc7a 	bl	8007240 <__aeabi_dsub>
 800994c:	464b      	mov	r3, r9
 800994e:	4642      	mov	r2, r8
 8009950:	f7fd fc76 	bl	8007240 <__aeabi_dsub>
 8009954:	4602      	mov	r2, r0
 8009956:	460b      	mov	r3, r1
 8009958:	e9db 0100 	ldrd	r0, r1, [fp]
 800995c:	f7fd fc70 	bl	8007240 <__aeabi_dsub>
 8009960:	f1ba 0f00 	cmp.w	sl, #0
 8009964:	4680      	mov	r8, r0
 8009966:	bfb4      	ite	lt
 8009968:	f101 4900 	addlt.w	r9, r1, #2147483648	; 0x80000000
 800996c:	4689      	movge	r9, r1
 800996e:	e007      	b.n	8009980 <atan+0x1b8>
 8009970:	4640      	mov	r0, r8
 8009972:	4642      	mov	r2, r8
 8009974:	4649      	mov	r1, r9
 8009976:	464b      	mov	r3, r9
 8009978:	f7fd fc64 	bl	8007244 <__adddf3>
 800997c:	4680      	mov	r8, r0
 800997e:	4689      	mov	r9, r1
 8009980:	4640      	mov	r0, r8
 8009982:	4649      	mov	r1, r9
 8009984:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8009988:	a359      	add	r3, pc, #356	; (adr r3, 8009af0 <atan+0x328>)
 800998a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800998e:	4649      	mov	r1, r9
 8009990:	f7fd fc58 	bl	8007244 <__adddf3>
 8009994:	2300      	movs	r3, #0
 8009996:	2200      	movs	r2, #0
 8009998:	f6c3 73f0 	movt	r3, #16368	; 0x3ff0
 800999c:	f000 fd62 	bl	800a464 <__aeabi_dcmpgt>
 80099a0:	2800      	cmp	r0, #0
 80099a2:	d1ed      	bne.n	8009980 <atan+0x1b8>
 80099a4:	e74c      	b.n	8009840 <atan+0x78>
 80099a6:	4649      	mov	r1, r9
 80099a8:	f000 f8a6 	bl	8009af8 <fabs>
 80099ac:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80099b0:	f6c3 73f2 	movt	r3, #16370	; 0x3ff2
 80099b4:	429c      	cmp	r4, r3
 80099b6:	4606      	mov	r6, r0
 80099b8:	460f      	mov	r7, r1
 80099ba:	dc2a      	bgt.n	8009a12 <atan+0x24a>
 80099bc:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80099c0:	f6c3 73e5 	movt	r3, #16357	; 0x3fe5
 80099c4:	429c      	cmp	r4, r3
 80099c6:	dc58      	bgt.n	8009a7a <atan+0x2b2>
 80099c8:	4602      	mov	r2, r0
 80099ca:	460b      	mov	r3, r1
 80099cc:	f7fd fc3a 	bl	8007244 <__adddf3>
 80099d0:	2300      	movs	r3, #0
 80099d2:	2200      	movs	r2, #0
 80099d4:	f6c3 73f0 	movt	r3, #16368	; 0x3ff0
 80099d8:	f7fd fc32 	bl	8007240 <__aeabi_dsub>
 80099dc:	f04f 0b00 	mov.w	fp, #0
 80099e0:	2200      	movs	r2, #0
 80099e2:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80099e6:	4604      	mov	r4, r0
 80099e8:	460d      	mov	r5, r1
 80099ea:	4630      	mov	r0, r6
 80099ec:	4639      	mov	r1, r7
 80099ee:	e02c      	b.n	8009a4a <atan+0x282>
 80099f0:	4630      	mov	r0, r6
 80099f2:	4639      	mov	r1, r7
 80099f4:	f7fd fc26 	bl	8007244 <__adddf3>
 80099f8:	4642      	mov	r2, r8
 80099fa:	464b      	mov	r3, r9
 80099fc:	f000 faa2 	bl	8009f44 <__aeabi_dmul>
 8009a00:	4602      	mov	r2, r0
 8009a02:	460b      	mov	r3, r1
 8009a04:	4640      	mov	r0, r8
 8009a06:	4649      	mov	r1, r9
 8009a08:	f7fd fc1a 	bl	8007240 <__aeabi_dsub>
 8009a0c:	4680      	mov	r8, r0
 8009a0e:	4689      	mov	r9, r1
 8009a10:	e7b6      	b.n	8009980 <atan+0x1b8>
 8009a12:	f647 73ff 	movw	r3, #32767	; 0x7fff
 8009a16:	f2c4 0303 	movt	r3, #16387	; 0x4003
 8009a1a:	429c      	cmp	r4, r3
 8009a1c:	dc20      	bgt.n	8009a60 <atan+0x298>
 8009a1e:	2300      	movs	r3, #0
 8009a20:	2200      	movs	r2, #0
 8009a22:	f6c3 73f8 	movt	r3, #16376	; 0x3ff8
 8009a26:	f04f 0b02 	mov.w	fp, #2
 8009a2a:	f7fd fc09 	bl	8007240 <__aeabi_dsub>
 8009a2e:	2300      	movs	r3, #0
 8009a30:	2200      	movs	r2, #0
 8009a32:	f6c3 73f8 	movt	r3, #16376	; 0x3ff8
 8009a36:	4604      	mov	r4, r0
 8009a38:	460d      	mov	r5, r1
 8009a3a:	4630      	mov	r0, r6
 8009a3c:	4639      	mov	r1, r7
 8009a3e:	f000 fa81 	bl	8009f44 <__aeabi_dmul>
 8009a42:	2300      	movs	r3, #0
 8009a44:	2200      	movs	r2, #0
 8009a46:	f6c3 73f0 	movt	r3, #16368	; 0x3ff0
 8009a4a:	f7fd fbfb 	bl	8007244 <__adddf3>
 8009a4e:	4602      	mov	r2, r0
 8009a50:	460b      	mov	r3, r1
 8009a52:	4620      	mov	r0, r4
 8009a54:	4629      	mov	r1, r5
 8009a56:	f000 fb9f 	bl	800a198 <__aeabi_ddiv>
 8009a5a:	4680      	mov	r8, r0
 8009a5c:	4689      	mov	r9, r1
 8009a5e:	e6f1      	b.n	8009844 <atan+0x7c>
 8009a60:	2100      	movs	r1, #0
 8009a62:	2000      	movs	r0, #0
 8009a64:	f6cb 71f0 	movt	r1, #49136	; 0xbff0
 8009a68:	4632      	mov	r2, r6
 8009a6a:	463b      	mov	r3, r7
 8009a6c:	f04f 0b03 	mov.w	fp, #3
 8009a70:	f000 fb92 	bl	800a198 <__aeabi_ddiv>
 8009a74:	4680      	mov	r8, r0
 8009a76:	4689      	mov	r9, r1
 8009a78:	e6e4      	b.n	8009844 <atan+0x7c>
 8009a7a:	2300      	movs	r3, #0
 8009a7c:	2200      	movs	r2, #0
 8009a7e:	f6c3 73f0 	movt	r3, #16368	; 0x3ff0
 8009a82:	f04f 0b01 	mov.w	fp, #1
 8009a86:	f7fd fbdb 	bl	8007240 <__aeabi_dsub>
 8009a8a:	4604      	mov	r4, r0
 8009a8c:	460d      	mov	r5, r1
 8009a8e:	4630      	mov	r0, r6
 8009a90:	4639      	mov	r1, r7
 8009a92:	e7d6      	b.n	8009a42 <atan+0x27a>
 8009a94:	f3af 8000 	nop.w
 8009a98:	e322da11 	.word	0xe322da11
 8009a9c:	3f90ad3a 	.word	0x3f90ad3a
 8009aa0:	24760deb 	.word	0x24760deb
 8009aa4:	3fa97b4b 	.word	0x3fa97b4b
 8009aa8:	a0d03d51 	.word	0xa0d03d51
 8009aac:	3fb10d66 	.word	0x3fb10d66
 8009ab0:	c54c206e 	.word	0xc54c206e
 8009ab4:	3fb745cd 	.word	0x3fb745cd
 8009ab8:	920083ff 	.word	0x920083ff
 8009abc:	3fc24924 	.word	0x3fc24924
 8009ac0:	5555550d 	.word	0x5555550d
 8009ac4:	3fd55555 	.word	0x3fd55555
 8009ac8:	2c6a6c2f 	.word	0x2c6a6c2f
 8009acc:	bfa2b444 	.word	0xbfa2b444
 8009ad0:	52defd9a 	.word	0x52defd9a
 8009ad4:	3fadde2d 	.word	0x3fadde2d
 8009ad8:	af749a6d 	.word	0xaf749a6d
 8009adc:	3fb3b0f2 	.word	0x3fb3b0f2
 8009ae0:	fe231671 	.word	0xfe231671
 8009ae4:	3fbc71c6 	.word	0x3fbc71c6
 8009ae8:	9998ebc4 	.word	0x9998ebc4
 8009aec:	3fc99999 	.word	0x3fc99999
 8009af0:	8800759c 	.word	0x8800759c
 8009af4:	7e37e43c 	.word	0x7e37e43c

08009af8 <fabs>:
 8009af8:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8009afc:	4770      	bx	lr
 8009afe:	bf00      	nop

08009b00 <__fpclassifyd>:
 8009b00:	ea50 0201 	orrs.w	r2, r0, r1
 8009b04:	d101      	bne.n	8009b0a <__fpclassifyd+0xa>
 8009b06:	2002      	movs	r0, #2
 8009b08:	4770      	bx	lr
 8009b0a:	f1d0 0201 	rsbs	r2, r0, #1
 8009b0e:	bf38      	it	cc
 8009b10:	2200      	movcc	r2, #0
 8009b12:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
 8009b16:	bf08      	it	eq
 8009b18:	2800      	cmpeq	r0, #0
 8009b1a:	d0f4      	beq.n	8009b06 <__fpclassifyd+0x6>
 8009b1c:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
 8009b20:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8009b24:	f5a3 1080 	sub.w	r0, r3, #1048576	; 0x100000
 8009b28:	f6c7 71df 	movt	r1, #32735	; 0x7fdf
 8009b2c:	4288      	cmp	r0, r1
 8009b2e:	d801      	bhi.n	8009b34 <__fpclassifyd+0x34>
 8009b30:	2004      	movs	r0, #4
 8009b32:	4770      	bx	lr
 8009b34:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 8009b38:	d201      	bcs.n	8009b3e <__fpclassifyd+0x3e>
 8009b3a:	2003      	movs	r0, #3
 8009b3c:	4770      	bx	lr
 8009b3e:	2000      	movs	r0, #0
 8009b40:	f6c7 70f0 	movt	r0, #32752	; 0x7ff0
 8009b44:	4283      	cmp	r3, r0
 8009b46:	bf14      	ite	ne
 8009b48:	2000      	movne	r0, #0
 8009b4a:	f002 0001 	andeq.w	r0, r2, #1
 8009b4e:	4770      	bx	lr

08009b50 <matherr>:
 8009b50:	2000      	movs	r0, #0
 8009b52:	4770      	bx	lr

08009b54 <nan>:
 8009b54:	2100      	movs	r1, #0
 8009b56:	2000      	movs	r0, #0
 8009b58:	f6c7 71f8 	movt	r1, #32760	; 0x7ff8
 8009b5c:	4770      	bx	lr
 8009b5e:	bf00      	nop

08009b60 <atanf>:
 8009b60:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8009b64:	f020 4500 	bic.w	r5, r0, #2147483648	; 0x80000000
 8009b68:	f1b5 4fa1 	cmp.w	r5, #1350565888	; 0x50800000
 8009b6c:	4604      	mov	r4, r0
 8009b6e:	4606      	mov	r6, r0
 8009b70:	db0e      	blt.n	8009b90 <atanf+0x30>
 8009b72:	f1b5 4fff 	cmp.w	r5, #2139095040	; 0x7f800000
 8009b76:	f300 80a4 	bgt.w	8009cc2 <atanf+0x162>
 8009b7a:	2800      	cmp	r0, #0
 8009b7c:	f640 74db 	movw	r4, #4059	; 0xfdb
 8009b80:	bfc8      	it	gt
 8009b82:	f6c3 74c9 	movtgt	r4, #16329	; 0x3fc9
 8009b86:	f340 80cf 	ble.w	8009d28 <atanf+0x1c8>
 8009b8a:	4620      	mov	r0, r4
 8009b8c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8009b90:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8009b94:	f6c3 63df 	movt	r3, #16095	; 0x3edf
 8009b98:	429d      	cmp	r5, r3
 8009b9a:	f300 80a9 	bgt.w	8009cf0 <atanf+0x190>
 8009b9e:	f1b5 5f44 	cmp.w	r5, #822083584	; 0x31000000
 8009ba2:	f2c0 8095 	blt.w	8009cd0 <atanf+0x170>
 8009ba6:	f04f 37ff 	mov.w	r7, #4294967295
 8009baa:	4621      	mov	r1, r4
 8009bac:	4620      	mov	r0, r4
 8009bae:	f7fd fe81 	bl	80078b4 <__aeabi_fmul>
 8009bb2:	4601      	mov	r1, r0
 8009bb4:	4680      	mov	r8, r0
 8009bb6:	f7fd fe7d 	bl	80078b4 <__aeabi_fmul>
 8009bba:	f646 11d7 	movw	r1, #27095	; 0x69d7
 8009bbe:	f6c3 4185 	movt	r1, #15493	; 0x3c85
 8009bc2:	4605      	mov	r5, r0
 8009bc4:	f7fd fe76 	bl	80078b4 <__aeabi_fmul>
 8009bc8:	f64d 2159 	movw	r1, #55897	; 0xda59
 8009bcc:	f6c3 514b 	movt	r1, #15691	; 0x3d4b
 8009bd0:	f7fd fd68 	bl	80076a4 <__addsf3>
 8009bd4:	4629      	mov	r1, r5
 8009bd6:	f7fd fe6d 	bl	80078b4 <__aeabi_fmul>
 8009bda:	f646 3135 	movw	r1, #27445	; 0x6b35
 8009bde:	f6c3 5188 	movt	r1, #15752	; 0x3d88
 8009be2:	f7fd fd5f 	bl	80076a4 <__addsf3>
 8009be6:	4629      	mov	r1, r5
 8009be8:	f7fd fe64 	bl	80078b4 <__aeabi_fmul>
 8009bec:	f642 616e 	movw	r1, #11886	; 0x2e6e
 8009bf0:	f6c3 51ba 	movt	r1, #15802	; 0x3dba
 8009bf4:	f7fd fd56 	bl	80076a4 <__addsf3>
 8009bf8:	4629      	mov	r1, r5
 8009bfa:	f7fd fe5b 	bl	80078b4 <__aeabi_fmul>
 8009bfe:	f644 1125 	movw	r1, #18725	; 0x4925
 8009c02:	f6c3 6112 	movt	r1, #15890	; 0x3e12
 8009c06:	f7fd fd4d 	bl	80076a4 <__addsf3>
 8009c0a:	4629      	mov	r1, r5
 8009c0c:	f7fd fe52 	bl	80078b4 <__aeabi_fmul>
 8009c10:	f64a 21ab 	movw	r1, #43691	; 0xaaab
 8009c14:	f6c3 61aa 	movt	r1, #16042	; 0x3eaa
 8009c18:	f7fd fd44 	bl	80076a4 <__addsf3>
 8009c1c:	4641      	mov	r1, r8
 8009c1e:	f7fd fe49 	bl	80078b4 <__aeabi_fmul>
 8009c22:	f24a 2121 	movw	r1, #41505	; 0xa221
 8009c26:	f6cb 5115 	movt	r1, #48405	; 0xbd15
 8009c2a:	4680      	mov	r8, r0
 8009c2c:	4628      	mov	r0, r5
 8009c2e:	f7fd fe41 	bl	80078b4 <__aeabi_fmul>
 8009c32:	f24f 116b 	movw	r1, #61803	; 0xf16b
 8009c36:	f6c3 516e 	movt	r1, #15726	; 0x3d6e
 8009c3a:	f7fd fd31 	bl	80076a0 <__aeabi_fsub>
 8009c3e:	4629      	mov	r1, r5
 8009c40:	f7fd fe38 	bl	80078b4 <__aeabi_fmul>
 8009c44:	f248 7195 	movw	r1, #34709	; 0x8795
 8009c48:	f6c3 519d 	movt	r1, #15773	; 0x3d9d
 8009c4c:	f7fd fd28 	bl	80076a0 <__aeabi_fsub>
 8009c50:	4629      	mov	r1, r5
 8009c52:	f7fd fe2f 	bl	80078b4 <__aeabi_fmul>
 8009c56:	f648 6138 	movw	r1, #36408	; 0x8e38
 8009c5a:	f6c3 51e3 	movt	r1, #15843	; 0x3de3
 8009c5e:	f7fd fd1f 	bl	80076a0 <__aeabi_fsub>
 8009c62:	4629      	mov	r1, r5
 8009c64:	f7fd fe26 	bl	80078b4 <__aeabi_fmul>
 8009c68:	f64c 41cd 	movw	r1, #52429	; 0xcccd
 8009c6c:	f6c3 614c 	movt	r1, #15948	; 0x3e4c
 8009c70:	f7fd fd16 	bl	80076a0 <__aeabi_fsub>
 8009c74:	4629      	mov	r1, r5
 8009c76:	f7fd fe1d 	bl	80078b4 <__aeabi_fmul>
 8009c7a:	1c7b      	adds	r3, r7, #1
 8009c7c:	4601      	mov	r1, r0
 8009c7e:	d056      	beq.n	8009d2e <atanf+0x1ce>
 8009c80:	f64a 15a8 	movw	r5, #43432	; 0xa9a8
 8009c84:	4640      	mov	r0, r8
 8009c86:	f7fd fd0d 	bl	80076a4 <__addsf3>
 8009c8a:	f6c0 0500 	movt	r5, #2048	; 0x800
 8009c8e:	4621      	mov	r1, r4
 8009c90:	f7fd fe10 	bl	80078b4 <__aeabi_fmul>
 8009c94:	eb05 0387 	add.w	r3, r5, r7, lsl #2
 8009c98:	6919      	ldr	r1, [r3, #16]
 8009c9a:	f7fd fd01 	bl	80076a0 <__aeabi_fsub>
 8009c9e:	4621      	mov	r1, r4
 8009ca0:	f7fd fcfe 	bl	80076a0 <__aeabi_fsub>
 8009ca4:	4601      	mov	r1, r0
 8009ca6:	f855 0027 	ldr.w	r0, [r5, r7, lsl #2]
 8009caa:	f7fd fcf9 	bl	80076a0 <__aeabi_fsub>
 8009cae:	2e00      	cmp	r6, #0
 8009cb0:	bfb8      	it	lt
 8009cb2:	f100 4400 	addlt.w	r4, r0, #2147483648	; 0x80000000
 8009cb6:	f6ff af68 	blt.w	8009b8a <atanf+0x2a>
 8009cba:	4604      	mov	r4, r0
 8009cbc:	4620      	mov	r0, r4
 8009cbe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8009cc2:	4601      	mov	r1, r0
 8009cc4:	f7fd fcee 	bl	80076a4 <__addsf3>
 8009cc8:	4604      	mov	r4, r0
 8009cca:	4620      	mov	r0, r4
 8009ccc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8009cd0:	f24f 21ca 	movw	r1, #62154	; 0xf2ca
 8009cd4:	f2c7 1149 	movt	r1, #29001	; 0x7149
 8009cd8:	f7fd fce4 	bl	80076a4 <__addsf3>
 8009cdc:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 8009ce0:	f7fd ffa4 	bl	8007c2c <__aeabi_fcmpgt>
 8009ce4:	2800      	cmp	r0, #0
 8009ce6:	f43f af5e 	beq.w	8009ba6 <atanf+0x46>
 8009cea:	4620      	mov	r0, r4
 8009cec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8009cf0:	f000 f854 	bl	8009d9c <fabsf>
 8009cf4:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8009cf8:	f6c3 7397 	movt	r3, #16279	; 0x3f97
 8009cfc:	429d      	cmp	r5, r3
 8009cfe:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8009d02:	4604      	mov	r4, r0
 8009d04:	dc1f      	bgt.n	8009d46 <atanf+0x1e6>
 8009d06:	f6c3 732f 	movt	r3, #16175	; 0x3f2f
 8009d0a:	429d      	cmp	r5, r3
 8009d0c:	dc3d      	bgt.n	8009d8a <atanf+0x22a>
 8009d0e:	4601      	mov	r1, r0
 8009d10:	2700      	movs	r7, #0
 8009d12:	f7fd fcc7 	bl	80076a4 <__addsf3>
 8009d16:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 8009d1a:	f7fd fcc1 	bl	80076a0 <__aeabi_fsub>
 8009d1e:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
 8009d22:	4605      	mov	r5, r0
 8009d24:	4620      	mov	r0, r4
 8009d26:	e01f      	b.n	8009d68 <atanf+0x208>
 8009d28:	f6cb 74c9 	movt	r4, #49097	; 0xbfc9
 8009d2c:	e72d      	b.n	8009b8a <atanf+0x2a>
 8009d2e:	4640      	mov	r0, r8
 8009d30:	f7fd fcb8 	bl	80076a4 <__addsf3>
 8009d34:	4621      	mov	r1, r4
 8009d36:	f7fd fdbd 	bl	80078b4 <__aeabi_fmul>
 8009d3a:	4601      	mov	r1, r0
 8009d3c:	4620      	mov	r0, r4
 8009d3e:	f7fd fcaf 	bl	80076a0 <__aeabi_fsub>
 8009d42:	4604      	mov	r4, r0
 8009d44:	e721      	b.n	8009b8a <atanf+0x2a>
 8009d46:	f2c4 031b 	movt	r3, #16411	; 0x401b
 8009d4a:	429d      	cmp	r5, r3
 8009d4c:	dc14      	bgt.n	8009d78 <atanf+0x218>
 8009d4e:	f04f 517f 	mov.w	r1, #1069547520	; 0x3fc00000
 8009d52:	2702      	movs	r7, #2
 8009d54:	f7fd fca4 	bl	80076a0 <__aeabi_fsub>
 8009d58:	f04f 517f 	mov.w	r1, #1069547520	; 0x3fc00000
 8009d5c:	4605      	mov	r5, r0
 8009d5e:	4620      	mov	r0, r4
 8009d60:	f7fd fda8 	bl	80078b4 <__aeabi_fmul>
 8009d64:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 8009d68:	f7fd fc9c 	bl	80076a4 <__addsf3>
 8009d6c:	4601      	mov	r1, r0
 8009d6e:	4628      	mov	r0, r5
 8009d70:	f7fd fe54 	bl	8007a1c <__aeabi_fdiv>
 8009d74:	4604      	mov	r4, r0
 8009d76:	e718      	b.n	8009baa <atanf+0x4a>
 8009d78:	2000      	movs	r0, #0
 8009d7a:	4621      	mov	r1, r4
 8009d7c:	f6cb 7080 	movt	r0, #49024	; 0xbf80
 8009d80:	2703      	movs	r7, #3
 8009d82:	f7fd fe4b 	bl	8007a1c <__aeabi_fdiv>
 8009d86:	4604      	mov	r4, r0
 8009d88:	e70f      	b.n	8009baa <atanf+0x4a>
 8009d8a:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
 8009d8e:	2701      	movs	r7, #1
 8009d90:	f7fd fc86 	bl	80076a0 <__aeabi_fsub>
 8009d94:	4605      	mov	r5, r0
 8009d96:	4620      	mov	r0, r4
 8009d98:	e7e4      	b.n	8009d64 <atanf+0x204>
 8009d9a:	bf00      	nop

08009d9c <fabsf>:
 8009d9c:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
 8009da0:	4770      	bx	lr
 8009da2:	bf00      	nop

08009da4 <floorf>:
 8009da4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8009da6:	f020 4600 	bic.w	r6, r0, #2147483648	; 0x80000000
 8009daa:	4601      	mov	r1, r0
 8009dac:	4604      	mov	r4, r0
 8009dae:	0df5      	lsrs	r5, r6, #23
 8009db0:	3d7f      	subs	r5, #127	; 0x7f
 8009db2:	2d16      	cmp	r5, #22
 8009db4:	dc20      	bgt.n	8009df8 <floorf+0x54>
 8009db6:	2d00      	cmp	r5, #0
 8009db8:	4607      	mov	r7, r0
 8009dba:	db25      	blt.n	8009e08 <floorf+0x64>
 8009dbc:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8009dc0:	f2c0 037f 	movt	r3, #127	; 0x7f
 8009dc4:	fa43 f605 	asr.w	r6, r3, r5
 8009dc8:	4206      	tst	r6, r0
 8009dca:	d013      	beq.n	8009df4 <floorf+0x50>
 8009dcc:	f24f 21ca 	movw	r1, #62154	; 0xf2ca
 8009dd0:	f2c7 1149 	movt	r1, #29001	; 0x7149
 8009dd4:	f7fd fc66 	bl	80076a4 <__addsf3>
 8009dd8:	2100      	movs	r1, #0
 8009dda:	f7fd ff27 	bl	8007c2c <__aeabi_fcmpgt>
 8009dde:	b140      	cbz	r0, 8009df2 <floorf+0x4e>
 8009de0:	2c00      	cmp	r4, #0
 8009de2:	bfbe      	ittt	lt
 8009de4:	f44f 0300 	movlt.w	r3, #8388608	; 0x800000
 8009de8:	fa43 f505 	asrlt.w	r5, r3, r5
 8009dec:	1967      	addlt	r7, r4, r5
 8009dee:	ea27 0406 	bic.w	r4, r7, r6
 8009df2:	4621      	mov	r1, r4
 8009df4:	4608      	mov	r0, r1
 8009df6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8009df8:	f1b6 4fff 	cmp.w	r6, #2139095040	; 0x7f800000
 8009dfc:	d3fa      	bcc.n	8009df4 <floorf+0x50>
 8009dfe:	f7fd fc51 	bl	80076a4 <__addsf3>
 8009e02:	4601      	mov	r1, r0
 8009e04:	4608      	mov	r0, r1
 8009e06:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8009e08:	f24f 21ca 	movw	r1, #62154	; 0xf2ca
 8009e0c:	f2c7 1149 	movt	r1, #29001	; 0x7149
 8009e10:	f7fd fc48 	bl	80076a4 <__addsf3>
 8009e14:	2100      	movs	r1, #0
 8009e16:	f7fd ff09 	bl	8007c2c <__aeabi_fcmpgt>
 8009e1a:	2800      	cmp	r0, #0
 8009e1c:	d0e9      	beq.n	8009df2 <floorf+0x4e>
 8009e1e:	2c00      	cmp	r4, #0
 8009e20:	db01      	blt.n	8009e26 <floorf+0x82>
 8009e22:	2400      	movs	r4, #0
 8009e24:	e7e5      	b.n	8009df2 <floorf+0x4e>
 8009e26:	2300      	movs	r3, #0
 8009e28:	f6cb 7380 	movt	r3, #49024	; 0xbf80
 8009e2c:	2e00      	cmp	r6, #0
 8009e2e:	bf18      	it	ne
 8009e30:	461c      	movne	r4, r3
 8009e32:	e7de      	b.n	8009df2 <floorf+0x4e>

08009e34 <__fpclassifyf>:
 8009e34:	f030 4000 	bics.w	r0, r0, #2147483648	; 0x80000000
 8009e38:	d101      	bne.n	8009e3e <__fpclassifyf+0xa>
 8009e3a:	2002      	movs	r0, #2
 8009e3c:	4770      	bx	lr
 8009e3e:	f5a0 0300 	sub.w	r3, r0, #8388608	; 0x800000
 8009e42:	f1b3 4ffe 	cmp.w	r3, #2130706432	; 0x7f000000
 8009e46:	d201      	bcs.n	8009e4c <__fpclassifyf+0x18>
 8009e48:	2004      	movs	r0, #4
 8009e4a:	4770      	bx	lr
 8009e4c:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 8009e50:	1e42      	subs	r2, r0, #1
 8009e52:	f2c0 037f 	movt	r3, #127	; 0x7f
 8009e56:	429a      	cmp	r2, r3
 8009e58:	d801      	bhi.n	8009e5e <__fpclassifyf+0x2a>
 8009e5a:	2003      	movs	r0, #3
 8009e5c:	4770      	bx	lr
 8009e5e:	f1b0 43ff 	subs.w	r3, r0, #2139095040	; 0x7f800000
 8009e62:	4258      	negs	r0, r3
 8009e64:	4158      	adcs	r0, r3
 8009e66:	4770      	bx	lr

08009e68 <scalbnf>:
 8009e68:	b538      	push	{r3, r4, r5, lr}
 8009e6a:	f030 4400 	bics.w	r4, r0, #2147483648	; 0x80000000
 8009e6e:	4603      	mov	r3, r0
 8009e70:	4602      	mov	r2, r0
 8009e72:	460d      	mov	r5, r1
 8009e74:	d011      	beq.n	8009e9a <scalbnf+0x32>
 8009e76:	f1b4 4fff 	cmp.w	r4, #2139095040	; 0x7f800000
 8009e7a:	d210      	bcs.n	8009e9e <scalbnf+0x36>
 8009e7c:	f5b4 0f00 	cmp.w	r4, #8388608	; 0x800000
 8009e80:	d313      	bcc.n	8009eaa <scalbnf+0x42>
 8009e82:	0de4      	lsrs	r4, r4, #23
 8009e84:	1964      	adds	r4, r4, r5
 8009e86:	2cfe      	cmp	r4, #254	; 0xfe
 8009e88:	bfc8      	it	gt
 8009e8a:	4619      	movgt	r1, r3
 8009e8c:	dc33      	bgt.n	8009ef6 <scalbnf+0x8e>
 8009e8e:	2c00      	cmp	r4, #0
 8009e90:	dd1b      	ble.n	8009eca <scalbnf+0x62>
 8009e92:	f022 42ff 	bic.w	r2, r2, #2139095040	; 0x7f800000
 8009e96:	ea42 53c4 	orr.w	r3, r2, r4, lsl #23
 8009e9a:	4618      	mov	r0, r3
 8009e9c:	bd38      	pop	{r3, r4, r5, pc}
 8009e9e:	4601      	mov	r1, r0
 8009ea0:	f7fd fc00 	bl	80076a4 <__addsf3>
 8009ea4:	4603      	mov	r3, r0
 8009ea6:	4618      	mov	r0, r3
 8009ea8:	bd38      	pop	{r3, r4, r5, pc}
 8009eaa:	f04f 4198 	mov.w	r1, #1275068416	; 0x4c000000
 8009eae:	f7fd fd01 	bl	80078b4 <__aeabi_fmul>
 8009eb2:	f643 42b0 	movw	r2, #15536	; 0x3cb0
 8009eb6:	f6cf 72ff 	movt	r2, #65535	; 0xffff
 8009eba:	4295      	cmp	r5, r2
 8009ebc:	4603      	mov	r3, r0
 8009ebe:	db12      	blt.n	8009ee6 <scalbnf+0x7e>
 8009ec0:	f3c0 54c7 	ubfx	r4, r0, #23, #8
 8009ec4:	4602      	mov	r2, r0
 8009ec6:	3c19      	subs	r4, #25
 8009ec8:	e7dc      	b.n	8009e84 <scalbnf+0x1c>
 8009eca:	f114 0f16 	cmn.w	r4, #22
 8009ece:	da20      	bge.n	8009f12 <scalbnf+0xaa>
 8009ed0:	f24c 3250 	movw	r2, #50000	; 0xc350
 8009ed4:	4619      	mov	r1, r3
 8009ed6:	4295      	cmp	r5, r2
 8009ed8:	dc0d      	bgt.n	8009ef6 <scalbnf+0x8e>
 8009eda:	f244 2060 	movw	r0, #16992	; 0x4260
 8009ede:	f6c0 50a2 	movt	r0, #3490	; 0xda2
 8009ee2:	f000 f823 	bl	8009f2c <copysignf>
 8009ee6:	f244 2160 	movw	r1, #16992	; 0x4260
 8009eea:	f6c0 51a2 	movt	r1, #3490	; 0xda2
 8009eee:	f7fd fce1 	bl	80078b4 <__aeabi_fmul>
 8009ef2:	4603      	mov	r3, r0
 8009ef4:	e7d1      	b.n	8009e9a <scalbnf+0x32>
 8009ef6:	f24f 20ca 	movw	r0, #62154	; 0xf2ca
 8009efa:	f2c7 1049 	movt	r0, #29001	; 0x7149
 8009efe:	f000 f815 	bl	8009f2c <copysignf>
 8009f02:	f24f 21ca 	movw	r1, #62154	; 0xf2ca
 8009f06:	f2c7 1149 	movt	r1, #29001	; 0x7149
 8009f0a:	f7fd fcd3 	bl	80078b4 <__aeabi_fmul>
 8009f0e:	4603      	mov	r3, r0
 8009f10:	e7c3      	b.n	8009e9a <scalbnf+0x32>
 8009f12:	f104 0019 	add.w	r0, r4, #25
 8009f16:	f022 42ff 	bic.w	r2, r2, #2139095040	; 0x7f800000
 8009f1a:	f04f 514c 	mov.w	r1, #855638016	; 0x33000000
 8009f1e:	ea42 50c0 	orr.w	r0, r2, r0, lsl #23
 8009f22:	f7fd fcc7 	bl	80078b4 <__aeabi_fmul>
 8009f26:	4603      	mov	r3, r0
 8009f28:	e7b7      	b.n	8009e9a <scalbnf+0x32>
 8009f2a:	bf00      	nop

08009f2c <copysignf>:
 8009f2c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8009f30:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
 8009f34:	4308      	orrs	r0, r1
 8009f36:	4770      	bx	lr

08009f38 <__errno>:
 8009f38:	f240 034c 	movw	r3, #76	; 0x4c
 8009f3c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8009f40:	6818      	ldr	r0, [r3, #0]
 8009f42:	4770      	bx	lr

08009f44 <__aeabi_dmul>:
 8009f44:	b570      	push	{r4, r5, r6, lr}
 8009f46:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8009f4a:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 8009f4e:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8009f52:	bf1d      	ittte	ne
 8009f54:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8009f58:	ea94 0f0c 	teqne	r4, ip
 8009f5c:	ea95 0f0c 	teqne	r5, ip
 8009f60:	f000 f8de 	bleq	800a120 <__aeabi_dmul+0x1dc>
 8009f64:	442c      	add	r4, r5
 8009f66:	ea81 0603 	eor.w	r6, r1, r3
 8009f6a:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 8009f6e:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 8009f72:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 8009f76:	bf18      	it	ne
 8009f78:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 8009f7c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8009f80:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8009f84:	d038      	beq.n	8009ff8 <__aeabi_dmul+0xb4>
 8009f86:	fba0 ce02 	umull	ip, lr, r0, r2
 8009f8a:	f04f 0500 	mov.w	r5, #0
 8009f8e:	fbe1 e502 	umlal	lr, r5, r1, r2
 8009f92:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 8009f96:	fbe0 e503 	umlal	lr, r5, r0, r3
 8009f9a:	f04f 0600 	mov.w	r6, #0
 8009f9e:	fbe1 5603 	umlal	r5, r6, r1, r3
 8009fa2:	f09c 0f00 	teq	ip, #0
 8009fa6:	bf18      	it	ne
 8009fa8:	f04e 0e01 	orrne.w	lr, lr, #1
 8009fac:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 8009fb0:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 8009fb4:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 8009fb8:	d204      	bcs.n	8009fc4 <__aeabi_dmul+0x80>
 8009fba:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 8009fbe:	416d      	adcs	r5, r5
 8009fc0:	eb46 0606 	adc.w	r6, r6, r6
 8009fc4:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 8009fc8:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 8009fcc:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 8009fd0:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 8009fd4:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 8009fd8:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 8009fdc:	bf88      	it	hi
 8009fde:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 8009fe2:	d81e      	bhi.n	800a022 <__aeabi_dmul+0xde>
 8009fe4:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 8009fe8:	bf08      	it	eq
 8009fea:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 8009fee:	f150 0000 	adcs.w	r0, r0, #0
 8009ff2:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8009ff6:	bd70      	pop	{r4, r5, r6, pc}
 8009ff8:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 8009ffc:	ea46 0101 	orr.w	r1, r6, r1
 800a000:	ea40 0002 	orr.w	r0, r0, r2
 800a004:	ea81 0103 	eor.w	r1, r1, r3
 800a008:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 800a00c:	bfc2      	ittt	gt
 800a00e:	ebd4 050c 	rsbsgt	r5, r4, ip
 800a012:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 800a016:	bd70      	popgt	{r4, r5, r6, pc}
 800a018:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800a01c:	f04f 0e00 	mov.w	lr, #0
 800a020:	3c01      	subs	r4, #1
 800a022:	f300 80ab 	bgt.w	800a17c <__aeabi_dmul+0x238>
 800a026:	f114 0f36 	cmn.w	r4, #54	; 0x36
 800a02a:	bfde      	ittt	le
 800a02c:	2000      	movle	r0, #0
 800a02e:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 800a032:	bd70      	pople	{r4, r5, r6, pc}
 800a034:	f1c4 0400 	rsb	r4, r4, #0
 800a038:	3c20      	subs	r4, #32
 800a03a:	da35      	bge.n	800a0a8 <__aeabi_dmul+0x164>
 800a03c:	340c      	adds	r4, #12
 800a03e:	dc1b      	bgt.n	800a078 <__aeabi_dmul+0x134>
 800a040:	f104 0414 	add.w	r4, r4, #20
 800a044:	f1c4 0520 	rsb	r5, r4, #32
 800a048:	fa00 f305 	lsl.w	r3, r0, r5
 800a04c:	fa20 f004 	lsr.w	r0, r0, r4
 800a050:	fa01 f205 	lsl.w	r2, r1, r5
 800a054:	ea40 0002 	orr.w	r0, r0, r2
 800a058:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 800a05c:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 800a060:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 800a064:	fa21 f604 	lsr.w	r6, r1, r4
 800a068:	eb42 0106 	adc.w	r1, r2, r6
 800a06c:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800a070:	bf08      	it	eq
 800a072:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800a076:	bd70      	pop	{r4, r5, r6, pc}
 800a078:	f1c4 040c 	rsb	r4, r4, #12
 800a07c:	f1c4 0520 	rsb	r5, r4, #32
 800a080:	fa00 f304 	lsl.w	r3, r0, r4
 800a084:	fa20 f005 	lsr.w	r0, r0, r5
 800a088:	fa01 f204 	lsl.w	r2, r1, r4
 800a08c:	ea40 0002 	orr.w	r0, r0, r2
 800a090:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800a094:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 800a098:	f141 0100 	adc.w	r1, r1, #0
 800a09c:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800a0a0:	bf08      	it	eq
 800a0a2:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800a0a6:	bd70      	pop	{r4, r5, r6, pc}
 800a0a8:	f1c4 0520 	rsb	r5, r4, #32
 800a0ac:	fa00 f205 	lsl.w	r2, r0, r5
 800a0b0:	ea4e 0e02 	orr.w	lr, lr, r2
 800a0b4:	fa20 f304 	lsr.w	r3, r0, r4
 800a0b8:	fa01 f205 	lsl.w	r2, r1, r5
 800a0bc:	ea43 0302 	orr.w	r3, r3, r2
 800a0c0:	fa21 f004 	lsr.w	r0, r1, r4
 800a0c4:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800a0c8:	fa21 f204 	lsr.w	r2, r1, r4
 800a0cc:	ea20 0002 	bic.w	r0, r0, r2
 800a0d0:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 800a0d4:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800a0d8:	bf08      	it	eq
 800a0da:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800a0de:	bd70      	pop	{r4, r5, r6, pc}
 800a0e0:	f094 0f00 	teq	r4, #0
 800a0e4:	d10f      	bne.n	800a106 <__aeabi_dmul+0x1c2>
 800a0e6:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 800a0ea:	0040      	lsls	r0, r0, #1
 800a0ec:	eb41 0101 	adc.w	r1, r1, r1
 800a0f0:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800a0f4:	bf08      	it	eq
 800a0f6:	3c01      	subeq	r4, #1
 800a0f8:	d0f7      	beq.n	800a0ea <__aeabi_dmul+0x1a6>
 800a0fa:	ea41 0106 	orr.w	r1, r1, r6
 800a0fe:	f095 0f00 	teq	r5, #0
 800a102:	bf18      	it	ne
 800a104:	4770      	bxne	lr
 800a106:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 800a10a:	0052      	lsls	r2, r2, #1
 800a10c:	eb43 0303 	adc.w	r3, r3, r3
 800a110:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 800a114:	bf08      	it	eq
 800a116:	3d01      	subeq	r5, #1
 800a118:	d0f7      	beq.n	800a10a <__aeabi_dmul+0x1c6>
 800a11a:	ea43 0306 	orr.w	r3, r3, r6
 800a11e:	4770      	bx	lr
 800a120:	ea94 0f0c 	teq	r4, ip
 800a124:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 800a128:	bf18      	it	ne
 800a12a:	ea95 0f0c 	teqne	r5, ip
 800a12e:	d00c      	beq.n	800a14a <__aeabi_dmul+0x206>
 800a130:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800a134:	bf18      	it	ne
 800a136:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800a13a:	d1d1      	bne.n	800a0e0 <__aeabi_dmul+0x19c>
 800a13c:	ea81 0103 	eor.w	r1, r1, r3
 800a140:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800a144:	f04f 0000 	mov.w	r0, #0
 800a148:	bd70      	pop	{r4, r5, r6, pc}
 800a14a:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800a14e:	bf06      	itte	eq
 800a150:	4610      	moveq	r0, r2
 800a152:	4619      	moveq	r1, r3
 800a154:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800a158:	d019      	beq.n	800a18e <__aeabi_dmul+0x24a>
 800a15a:	ea94 0f0c 	teq	r4, ip
 800a15e:	d102      	bne.n	800a166 <__aeabi_dmul+0x222>
 800a160:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 800a164:	d113      	bne.n	800a18e <__aeabi_dmul+0x24a>
 800a166:	ea95 0f0c 	teq	r5, ip
 800a16a:	d105      	bne.n	800a178 <__aeabi_dmul+0x234>
 800a16c:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 800a170:	bf1c      	itt	ne
 800a172:	4610      	movne	r0, r2
 800a174:	4619      	movne	r1, r3
 800a176:	d10a      	bne.n	800a18e <__aeabi_dmul+0x24a>
 800a178:	ea81 0103 	eor.w	r1, r1, r3
 800a17c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800a180:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 800a184:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 800a188:	f04f 0000 	mov.w	r0, #0
 800a18c:	bd70      	pop	{r4, r5, r6, pc}
 800a18e:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 800a192:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 800a196:	bd70      	pop	{r4, r5, r6, pc}

0800a198 <__aeabi_ddiv>:
 800a198:	b570      	push	{r4, r5, r6, lr}
 800a19a:	f04f 0cff 	mov.w	ip, #255	; 0xff
 800a19e:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 800a1a2:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800a1a6:	bf1d      	ittte	ne
 800a1a8:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 800a1ac:	ea94 0f0c 	teqne	r4, ip
 800a1b0:	ea95 0f0c 	teqne	r5, ip
 800a1b4:	f000 f8a7 	bleq	800a306 <__aeabi_ddiv+0x16e>
 800a1b8:	eba4 0405 	sub.w	r4, r4, r5
 800a1bc:	ea81 0e03 	eor.w	lr, r1, r3
 800a1c0:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 800a1c4:	ea4f 3101 	mov.w	r1, r1, lsl #12
 800a1c8:	f000 8088 	beq.w	800a2dc <__aeabi_ddiv+0x144>
 800a1cc:	ea4f 3303 	mov.w	r3, r3, lsl #12
 800a1d0:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 800a1d4:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 800a1d8:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 800a1dc:	ea4f 2202 	mov.w	r2, r2, lsl #8
 800a1e0:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 800a1e4:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 800a1e8:	ea4f 2600 	mov.w	r6, r0, lsl #8
 800a1ec:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 800a1f0:	429d      	cmp	r5, r3
 800a1f2:	bf08      	it	eq
 800a1f4:	4296      	cmpeq	r6, r2
 800a1f6:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 800a1fa:	f504 7440 	add.w	r4, r4, #768	; 0x300
 800a1fe:	d202      	bcs.n	800a206 <__aeabi_ddiv+0x6e>
 800a200:	085b      	lsrs	r3, r3, #1
 800a202:	ea4f 0232 	mov.w	r2, r2, rrx
 800a206:	1ab6      	subs	r6, r6, r2
 800a208:	eb65 0503 	sbc.w	r5, r5, r3
 800a20c:	085b      	lsrs	r3, r3, #1
 800a20e:	ea4f 0232 	mov.w	r2, r2, rrx
 800a212:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 800a216:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 800a21a:	ebb6 0e02 	subs.w	lr, r6, r2
 800a21e:	eb75 0e03 	sbcs.w	lr, r5, r3
 800a222:	bf22      	ittt	cs
 800a224:	1ab6      	subcs	r6, r6, r2
 800a226:	4675      	movcs	r5, lr
 800a228:	ea40 000c 	orrcs.w	r0, r0, ip
 800a22c:	085b      	lsrs	r3, r3, #1
 800a22e:	ea4f 0232 	mov.w	r2, r2, rrx
 800a232:	ebb6 0e02 	subs.w	lr, r6, r2
 800a236:	eb75 0e03 	sbcs.w	lr, r5, r3
 800a23a:	bf22      	ittt	cs
 800a23c:	1ab6      	subcs	r6, r6, r2
 800a23e:	4675      	movcs	r5, lr
 800a240:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 800a244:	085b      	lsrs	r3, r3, #1
 800a246:	ea4f 0232 	mov.w	r2, r2, rrx
 800a24a:	ebb6 0e02 	subs.w	lr, r6, r2
 800a24e:	eb75 0e03 	sbcs.w	lr, r5, r3
 800a252:	bf22      	ittt	cs
 800a254:	1ab6      	subcs	r6, r6, r2
 800a256:	4675      	movcs	r5, lr
 800a258:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 800a25c:	085b      	lsrs	r3, r3, #1
 800a25e:	ea4f 0232 	mov.w	r2, r2, rrx
 800a262:	ebb6 0e02 	subs.w	lr, r6, r2
 800a266:	eb75 0e03 	sbcs.w	lr, r5, r3
 800a26a:	bf22      	ittt	cs
 800a26c:	1ab6      	subcs	r6, r6, r2
 800a26e:	4675      	movcs	r5, lr
 800a270:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 800a274:	ea55 0e06 	orrs.w	lr, r5, r6
 800a278:	d018      	beq.n	800a2ac <__aeabi_ddiv+0x114>
 800a27a:	ea4f 1505 	mov.w	r5, r5, lsl #4
 800a27e:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 800a282:	ea4f 1606 	mov.w	r6, r6, lsl #4
 800a286:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 800a28a:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 800a28e:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800a292:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 800a296:	d1c0      	bne.n	800a21a <__aeabi_ddiv+0x82>
 800a298:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800a29c:	d10b      	bne.n	800a2b6 <__aeabi_ddiv+0x11e>
 800a29e:	ea41 0100 	orr.w	r1, r1, r0
 800a2a2:	f04f 0000 	mov.w	r0, #0
 800a2a6:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 800a2aa:	e7b6      	b.n	800a21a <__aeabi_ddiv+0x82>
 800a2ac:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800a2b0:	bf04      	itt	eq
 800a2b2:	4301      	orreq	r1, r0
 800a2b4:	2000      	moveq	r0, #0
 800a2b6:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 800a2ba:	bf88      	it	hi
 800a2bc:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 800a2c0:	f63f aeaf 	bhi.w	800a022 <__aeabi_dmul+0xde>
 800a2c4:	ebb5 0c03 	subs.w	ip, r5, r3
 800a2c8:	bf04      	itt	eq
 800a2ca:	ebb6 0c02 	subseq.w	ip, r6, r2
 800a2ce:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 800a2d2:	f150 0000 	adcs.w	r0, r0, #0
 800a2d6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800a2da:	bd70      	pop	{r4, r5, r6, pc}
 800a2dc:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 800a2e0:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 800a2e4:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 800a2e8:	bfc2      	ittt	gt
 800a2ea:	ebd4 050c 	rsbsgt	r5, r4, ip
 800a2ee:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 800a2f2:	bd70      	popgt	{r4, r5, r6, pc}
 800a2f4:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800a2f8:	f04f 0e00 	mov.w	lr, #0
 800a2fc:	3c01      	subs	r4, #1
 800a2fe:	e690      	b.n	800a022 <__aeabi_dmul+0xde>
 800a300:	ea45 0e06 	orr.w	lr, r5, r6
 800a304:	e68d      	b.n	800a022 <__aeabi_dmul+0xde>
 800a306:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 800a30a:	ea94 0f0c 	teq	r4, ip
 800a30e:	bf08      	it	eq
 800a310:	ea95 0f0c 	teqeq	r5, ip
 800a314:	f43f af3b 	beq.w	800a18e <__aeabi_dmul+0x24a>
 800a318:	ea94 0f0c 	teq	r4, ip
 800a31c:	d10a      	bne.n	800a334 <__aeabi_ddiv+0x19c>
 800a31e:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 800a322:	f47f af34 	bne.w	800a18e <__aeabi_dmul+0x24a>
 800a326:	ea95 0f0c 	teq	r5, ip
 800a32a:	f47f af25 	bne.w	800a178 <__aeabi_dmul+0x234>
 800a32e:	4610      	mov	r0, r2
 800a330:	4619      	mov	r1, r3
 800a332:	e72c      	b.n	800a18e <__aeabi_dmul+0x24a>
 800a334:	ea95 0f0c 	teq	r5, ip
 800a338:	d106      	bne.n	800a348 <__aeabi_ddiv+0x1b0>
 800a33a:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 800a33e:	f43f aefd 	beq.w	800a13c <__aeabi_dmul+0x1f8>
 800a342:	4610      	mov	r0, r2
 800a344:	4619      	mov	r1, r3
 800a346:	e722      	b.n	800a18e <__aeabi_dmul+0x24a>
 800a348:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800a34c:	bf18      	it	ne
 800a34e:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 800a352:	f47f aec5 	bne.w	800a0e0 <__aeabi_dmul+0x19c>
 800a356:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 800a35a:	f47f af0d 	bne.w	800a178 <__aeabi_dmul+0x234>
 800a35e:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 800a362:	f47f aeeb 	bne.w	800a13c <__aeabi_dmul+0x1f8>
 800a366:	e712      	b.n	800a18e <__aeabi_dmul+0x24a>

0800a368 <__gedf2>:
 800a368:	f04f 3cff 	mov.w	ip, #4294967295
 800a36c:	e006      	b.n	800a37c <__cmpdf2+0x4>
 800a36e:	bf00      	nop

0800a370 <__ledf2>:
 800a370:	f04f 0c01 	mov.w	ip, #1
 800a374:	e002      	b.n	800a37c <__cmpdf2+0x4>
 800a376:	bf00      	nop

0800a378 <__cmpdf2>:
 800a378:	f04f 0c01 	mov.w	ip, #1
 800a37c:	f84d cd04 	str.w	ip, [sp, #-4]!
 800a380:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 800a384:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 800a388:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 800a38c:	bf18      	it	ne
 800a38e:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 800a392:	d01b      	beq.n	800a3cc <__cmpdf2+0x54>
 800a394:	b001      	add	sp, #4
 800a396:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 800a39a:	bf0c      	ite	eq
 800a39c:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 800a3a0:	ea91 0f03 	teqne	r1, r3
 800a3a4:	bf02      	ittt	eq
 800a3a6:	ea90 0f02 	teqeq	r0, r2
 800a3aa:	2000      	moveq	r0, #0
 800a3ac:	4770      	bxeq	lr
 800a3ae:	f110 0f00 	cmn.w	r0, #0
 800a3b2:	ea91 0f03 	teq	r1, r3
 800a3b6:	bf58      	it	pl
 800a3b8:	4299      	cmppl	r1, r3
 800a3ba:	bf08      	it	eq
 800a3bc:	4290      	cmpeq	r0, r2
 800a3be:	bf2c      	ite	cs
 800a3c0:	17d8      	asrcs	r0, r3, #31
 800a3c2:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 800a3c6:	f040 0001 	orr.w	r0, r0, #1
 800a3ca:	4770      	bx	lr
 800a3cc:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 800a3d0:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 800a3d4:	d102      	bne.n	800a3dc <__cmpdf2+0x64>
 800a3d6:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 800a3da:	d107      	bne.n	800a3ec <__cmpdf2+0x74>
 800a3dc:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 800a3e0:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 800a3e4:	d1d6      	bne.n	800a394 <__cmpdf2+0x1c>
 800a3e6:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 800a3ea:	d0d3      	beq.n	800a394 <__cmpdf2+0x1c>
 800a3ec:	f85d 0b04 	ldr.w	r0, [sp], #4
 800a3f0:	4770      	bx	lr
 800a3f2:	bf00      	nop

0800a3f4 <__aeabi_cdrcmple>:
 800a3f4:	4684      	mov	ip, r0
 800a3f6:	4610      	mov	r0, r2
 800a3f8:	4662      	mov	r2, ip
 800a3fa:	468c      	mov	ip, r1
 800a3fc:	4619      	mov	r1, r3
 800a3fe:	4663      	mov	r3, ip
 800a400:	e000      	b.n	800a404 <__aeabi_cdcmpeq>
 800a402:	bf00      	nop

0800a404 <__aeabi_cdcmpeq>:
 800a404:	b501      	push	{r0, lr}
 800a406:	f7ff ffb7 	bl	800a378 <__cmpdf2>
 800a40a:	2800      	cmp	r0, #0
 800a40c:	bf48      	it	mi
 800a40e:	f110 0f00 	cmnmi.w	r0, #0
 800a412:	bd01      	pop	{r0, pc}

0800a414 <__aeabi_dcmpeq>:
 800a414:	f84d ed08 	str.w	lr, [sp, #-8]!
 800a418:	f7ff fff4 	bl	800a404 <__aeabi_cdcmpeq>
 800a41c:	bf0c      	ite	eq
 800a41e:	2001      	moveq	r0, #1
 800a420:	2000      	movne	r0, #0
 800a422:	f85d fb08 	ldr.w	pc, [sp], #8
 800a426:	bf00      	nop

0800a428 <__aeabi_dcmplt>:
 800a428:	f84d ed08 	str.w	lr, [sp, #-8]!
 800a42c:	f7ff ffea 	bl	800a404 <__aeabi_cdcmpeq>
 800a430:	bf34      	ite	cc
 800a432:	2001      	movcc	r0, #1
 800a434:	2000      	movcs	r0, #0
 800a436:	f85d fb08 	ldr.w	pc, [sp], #8
 800a43a:	bf00      	nop

0800a43c <__aeabi_dcmple>:
 800a43c:	f84d ed08 	str.w	lr, [sp, #-8]!
 800a440:	f7ff ffe0 	bl	800a404 <__aeabi_cdcmpeq>
 800a444:	bf94      	ite	ls
 800a446:	2001      	movls	r0, #1
 800a448:	2000      	movhi	r0, #0
 800a44a:	f85d fb08 	ldr.w	pc, [sp], #8
 800a44e:	bf00      	nop

0800a450 <__aeabi_dcmpge>:
 800a450:	f84d ed08 	str.w	lr, [sp, #-8]!
 800a454:	f7ff ffce 	bl	800a3f4 <__aeabi_cdrcmple>
 800a458:	bf94      	ite	ls
 800a45a:	2001      	movls	r0, #1
 800a45c:	2000      	movhi	r0, #0
 800a45e:	f85d fb08 	ldr.w	pc, [sp], #8
 800a462:	bf00      	nop

0800a464 <__aeabi_dcmpgt>:
 800a464:	f84d ed08 	str.w	lr, [sp, #-8]!
 800a468:	f7ff ffc4 	bl	800a3f4 <__aeabi_cdrcmple>
 800a46c:	bf34      	ite	cc
 800a46e:	2001      	movcc	r0, #1
 800a470:	2000      	movcs	r0, #0
 800a472:	f85d fb08 	ldr.w	pc, [sp], #8
 800a476:	bf00      	nop

0800a478 <main>:
static void Position_Controller( void *pvParameters );
// static void Position_Controller( void *pvParameters );


int main()
{
 800a478:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 800a47a:	4b24      	ldr	r3, [pc, #144]	; (800a50c <main+0x94>)

	/* Motor Enstufe ausschalten */
	//GPIO_ResetBits(GPIOB, GPIO_Pin_1 | GPIO_Pin_2);
	Disable_Motor();

	xTaskCreate( Position_Controller, ( signed char * ) "IMU_Gyro", configMINIMAL_STACK_SIZE, NULL, 4, NULL );
 800a47c:	2400      	movs	r4, #0
// static void Position_Controller( void *pvParameters );


int main()
{
	SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 800a47e:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 800a482:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 800a486:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

	RCC_Configuration();
 800a48a:	f7f7 ff93 	bl	80023b4 <RCC_Configuration>
	NVIC_Configuration();
 800a48e:	f7f7 ffa9 	bl	80023e4 <NVIC_Configuration>
	GPIO_Configuration();
 800a492:	f7f7 ffdb 	bl	800244c <GPIO_Configuration>
	USART_Configuration();
 800a496:	f7f8 f8db 	bl	8002650 <USART_Configuration>
	setup_xBeeS6();
 800a49a:	f7f8 fc3f 	bl	8002d1c <setup_xBeeS6>
	SPI_Configuration();
 800a49e:	f7f8 f919 	bl	80026d4 <SPI_Configuration>
	I2C_Configuration();
 800a4a2:	f7f8 f949 	bl	8002738 <I2C_Configuration>
	//TIM2_PWM_Configuration();
	TIM3_PWM_Configuration();
 800a4a6:	f7f8 f9f1 	bl	800288c <TIM3_PWM_Configuration>
	TIM4_Configuration();
 800a4aa:	f7f8 fa3d 	bl	8002928 <TIM4_Configuration>
	ADC_Configuration();
 800a4ae:	f7f8 fa64 	bl	800297a <ADC_Configuration>
	EXTI_Configuration();
 800a4b2:	f7f8 fa61 	bl	8002978 <EXTI_Configuration>
	DMA_Configuration(&accBuffer[0]);
 800a4b6:	4816      	ldr	r0, [pc, #88]	; (800a510 <main+0x98>)
 800a4b8:	f7f8 f95c 	bl	8002774 <DMA_Configuration>
	//TIM4_PWM_INPUT_Configuration();

	SETTINGS_init(&GlobalSettings);
 800a4bc:	4815      	ldr	r0, [pc, #84]	; (800a514 <main+0x9c>)
 800a4be:	f7f8 fbd5 	bl	8002c6c <SETTINGS_init>
	CTRLSTATES_init(&CtrlStates);
 800a4c2:	4815      	ldr	r0, [pc, #84]	; (800a518 <main+0xa0>)
 800a4c4:	f7f8 fc26 	bl	8002d14 <CTRLSTATES_init>

	xCoRoutineCreate( vLedCtrlCoRoutine, 0, 0 );
 800a4c8:	2100      	movs	r1, #0
 800a4ca:	460a      	mov	r2, r1
 800a4cc:	4813      	ldr	r0, [pc, #76]	; (800a51c <main+0xa4>)
 800a4ce:	f7fb fa45 	bl	800595c <xCoRoutineCreate>

	//xCoRoutineCreate( vRemoteCtrlWatchdogCoRoutine, 1, 0 );

	/* Motor Enstufe ausschalten */
	//GPIO_ResetBits(GPIOB, GPIO_Pin_1 | GPIO_Pin_2);
	Disable_Motor();
 800a4d2:	f7f6 fc49 	bl	8000d68 <Disable_Motor>

	xTaskCreate( Position_Controller, ( signed char * ) "IMU_Gyro", configMINIMAL_STACK_SIZE, NULL, 4, NULL );
 800a4d6:	2304      	movs	r3, #4
 800a4d8:	e88d 0018 	stmia.w	sp, {r3, r4}
 800a4dc:	4910      	ldr	r1, [pc, #64]	; (800a520 <main+0xa8>)
 800a4de:	f44f 72a0 	mov.w	r2, #320	; 0x140
 800a4e2:	4623      	mov	r3, r4
 800a4e4:	9402      	str	r4, [sp, #8]
 800a4e6:	9403      	str	r4, [sp, #12]
 800a4e8:	480e      	ldr	r0, [pc, #56]	; (800a524 <main+0xac>)
 800a4ea:	f7fb ff31 	bl	8006350 <xTaskGenericCreate>
	//xTaskCreate( Position_Controller, ( signed char * ) "Pos_Contr", configMINIMAL_STACK_SIZE, NULL, 3, NULL );
	xTaskCreate( IMU_Print_Values, ( signed char * ) "Print_Euler", configMINIMAL_STACK_SIZE, NULL, 2, NULL );
 800a4ee:	2302      	movs	r3, #2
 800a4f0:	e88d 0018 	stmia.w	sp, {r3, r4}
 800a4f4:	490c      	ldr	r1, [pc, #48]	; (800a528 <main+0xb0>)
 800a4f6:	f44f 72a0 	mov.w	r2, #320	; 0x140
 800a4fa:	4623      	mov	r3, r4
 800a4fc:	9402      	str	r4, [sp, #8]
 800a4fe:	9403      	str	r4, [sp, #12]
 800a500:	480a      	ldr	r0, [pc, #40]	; (800a52c <main+0xb4>)
 800a502:	f7fb ff25 	bl	8006350 <xTaskGenericCreate>

	/* Start the tasks and timer running. */
	vTaskStartScheduler();
 800a506:	f7fc f901 	bl	800670c <vTaskStartScheduler>
 800a50a:	e7fe      	b.n	800a50a <main+0x92>
 800a50c:	e000ed00 	.word	0xe000ed00
 800a510:	20002c90 	.word	0x20002c90
 800a514:	20002bbc 	.word	0x20002bbc
 800a518:	20002c1c 	.word	0x20002c1c
 800a51c:	08001f45 	.word	0x08001f45
 800a520:	0800a9e6 	.word	0x0800a9e6
 800a524:	08001dd5 	.word	0x08001dd5
 800a528:	0800a9ef 	.word	0x0800a9ef
 800a52c:	08001d9d 	.word	0x08001d9d

0800a530 <Reset_Handler>:
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 800a530:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 800a532:	f000 b804 	b.w	800a53e <LoopCopyDataInit>

0800a536 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 800a536:	4b0c      	ldr	r3, [pc, #48]	; (800a568 <LoopFillZerobss+0x12>)
  ldr  r3, [r3, r1]
 800a538:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 800a53a:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 800a53c:	3104      	adds	r1, #4

0800a53e <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 800a53e:	480b      	ldr	r0, [pc, #44]	; (800a56c <LoopFillZerobss+0x16>)
  ldr  r3, =_edata
 800a540:	4b0b      	ldr	r3, [pc, #44]	; (800a570 <LoopFillZerobss+0x1a>)
  adds  r2, r0, r1
 800a542:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 800a544:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 800a546:	f4ff aff6 	bcc.w	800a536 <CopyDataInit>
  ldr  r2, =_sbss
 800a54a:	4a0a      	ldr	r2, [pc, #40]	; (800a574 <LoopFillZerobss+0x1e>)
  b  LoopFillZerobss
 800a54c:	f000 b803 	b.w	800a556 <LoopFillZerobss>

0800a550 <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 800a550:	2300      	movs	r3, #0
  str  r3, [r2], #4
 800a552:	f842 3b04 	str.w	r3, [r2], #4

0800a556 <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 800a556:	4b08      	ldr	r3, [pc, #32]	; (800a578 <LoopFillZerobss+0x22>)
  cmp  r2, r3
 800a558:	429a      	cmp	r2, r3
  bcc  FillZerobss
 800a55a:	f4ff aff9 	bcc.w	800a550 <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit   
 800a55e:	f7fc fdbd 	bl	80070dc <SystemInit>
/* Call the application's entry point.*/
  bl  main
 800a562:	f7ff ff89 	bl	800a478 <main>
  bx  lr    
 800a566:	4770      	bx	lr
/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
  b  LoopCopyDataInit

CopyDataInit:
  ldr  r3, =_sidata
 800a568:	0800aa2c 	.word	0x0800aa2c
  ldr  r3, [r3, r1]
  str  r3, [r0, r1]
  adds  r1, r1, #4
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 800a56c:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 800a570:	20000140 	.word	0x20000140
  adds  r2, r0, r1
  cmp  r2, r3
  bcc  CopyDataInit
  ldr  r2, =_sbss
 800a574:	20000140 	.word	0x20000140
FillZerobss:
  movs  r3, #0
  str  r3, [r2], #4
    
LoopFillZerobss:
  ldr  r3, = _ebss
 800a578:	2000306c 	.word	0x2000306c

0800a57c <ADC1_2_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 800a57c:	f7ff bffe 	b.w	800a57c <ADC1_2_IRQHandler>

0800a580 <ucExpectedStackBytes.5909>:
 800a580:	a5a5 a5a5 a5a5 a5a5 a5a5 a5a5 a5a5 a5a5     ................
 800a590:	a5a5 a5a5                                   ....

0800a594 <npio2_hw>:
 800a594:	0f00 3fc9 0f00 4049 cb00 4096 0f00 40c9     ...?..I@...@...@
 800a5a4:	5300 40fb cb00 4116 ed00 412f 0f00 4149     .S.@...A../A..IA
 800a5b4:	3100 4162 5300 417b 3a00 418a cb00 4196     .1bA.S{A.:.A...A
 800a5c4:	5c00 41a3 ed00 41af 7e00 41bc 0f00 41c9     .\.A...A.~.A...A
 800a5d4:	a000 41d5 3100 41e2 c200 41ee 5300 41fb     ...A.1.A...A.S.A
 800a5e4:	f200 4203 3a00 420a 8300 4210 cb00 4216     ...B.:.B...B...B
 800a5f4:	1400 421d 5c00 4223 a500 4229 ed00 422f     ...B.\#B..)B../B
 800a604:	3600 4236 7e00 423c c700 4242 0f00 4249     .66B.~<B..BB..IB

0800a614 <two_over_pi>:
 800a614:	00a2 0000 00f9 0000 0083 0000 006e 0000     ............n...
 800a624:	004e 0000 0044 0000 0015 0000 0029 0000     N...D.......)...
 800a634:	00fc 0000 0027 0000 0057 0000 00d1 0000     ....'...W.......
 800a644:	00f5 0000 0034 0000 00dd 0000 00c0 0000     ....4...........
 800a654:	00db 0000 0062 0000 0095 0000 0099 0000     ....b...........
 800a664:	003c 0000 0043 0000 0090 0000 0041 0000     <...C.......A...
 800a674:	00fe 0000 0051 0000 0063 0000 00ab 0000     ....Q...c.......
 800a684:	00de 0000 00bb 0000 00c5 0000 0061 0000     ............a...
 800a694:	00b7 0000 0024 0000 006e 0000 003a 0000     ....$...n...:...
 800a6a4:	0042 0000 004d 0000 00d2 0000 00e0 0000     B...M...........
 800a6b4:	0006 0000 0049 0000 002e 0000 00ea 0000     ....I...........
 800a6c4:	0009 0000 00d1 0000 0092 0000 001c 0000     ................
 800a6d4:	00fe 0000 001d 0000 00eb 0000 001c 0000     ................
 800a6e4:	00b1 0000 0029 0000 00a7 0000 003e 0000     ....).......>...
 800a6f4:	00e8 0000 0082 0000 0035 0000 00f5 0000     ........5.......
 800a704:	002e 0000 00bb 0000 0044 0000 0084 0000     ........D.......
 800a714:	00e9 0000 009c 0000 0070 0000 0026 0000     ........p...&...
 800a724:	00b4 0000 005f 0000 007e 0000 0041 0000     ...._...~...A...
 800a734:	0039 0000 0091 0000 00d6 0000 0039 0000     9...........9...
 800a744:	0083 0000 0053 0000 0039 0000 00f4 0000     ....S...9.......
 800a754:	009c 0000 0084 0000 005f 0000 008b 0000     ........_.......
 800a764:	00bd 0000 00f9 0000 0028 0000 003b 0000     ........(...;...
 800a774:	001f 0000 00f8 0000 0097 0000 00ff 0000     ................
 800a784:	00de 0000 0005 0000 0098 0000 000f 0000     ................
 800a794:	00ef 0000 002f 0000 0011 0000 008b 0000     ..../...........
 800a7a4:	005a 0000 000a 0000 006d 0000 001f 0000     Z.......m.......
 800a7b4:	006d 0000 0036 0000 007e 0000 00cf 0000     m...6...~.......
 800a7c4:	0027 0000 00cb 0000 0009 0000 00b7 0000     '...............
 800a7d4:	004f 0000 0046 0000 003f 0000 0066 0000     O...F...?...f...
 800a7e4:	009e 0000 005f 0000 00ea 0000 002d 0000     ...._.......-...
 800a7f4:	0075 0000 0027 0000 00ba 0000 00c7 0000     u...'...........
 800a804:	00eb 0000 00e5 0000 00f1 0000 007b 0000     ............{...
 800a814:	003d 0000 0007 0000 0039 0000 00f7 0000     =.......9.......
 800a824:	008a 0000 0052 0000 0092 0000 00ea 0000     ....R...........
 800a834:	006b 0000 00fb 0000 005f 0000 00b1 0000     k......._.......
 800a844:	001f 0000 008d 0000 005d 0000 0008 0000     ........].......
 800a854:	0056 0000 0003 0000 0030 0000 0046 0000     V.......0...F...
 800a864:	00fc 0000 007b 0000 006b 0000 00ab 0000     ....{...k.......
 800a874:	00f0 0000 00cf 0000 00bc 0000 0020 0000     ............ ...
 800a884:	009a 0000 00f4 0000 0036 0000 001d 0000     ........6.......
 800a894:	00a9 0000 00e3 0000 0091 0000 0061 0000     ............a...
 800a8a4:	005e 0000 00e6 0000 001b 0000 0008 0000     ^...............
 800a8b4:	0065 0000 0099 0000 0085 0000 005f 0000     e..........._...
 800a8c4:	0014 0000 00a0 0000 0068 0000 0040 0000     ........h...@...
 800a8d4:	008d 0000 00ff 0000 00d8 0000 0080 0000     ................
 800a8e4:	004d 0000 0073 0000 0027 0000 0031 0000     M...s...'...1...
 800a8f4:	0006 0000 0006 0000 0015 0000 0056 0000     ............V...
 800a904:	00ca 0000 0073 0000 00a8 0000 00c9 0000     ....s...........
 800a914:	0060 0000 00e2 0000 007b 0000 00c0 0000     `.......{.......
 800a924:	008c 0000 006b 0000                         ....k...

0800a92c <init_jk>:
 800a92c:	0004 0000 0007 0000 0009 0000               ............

0800a938 <PIo2>:
 800a938:	0000 3fc9 0000 39f0 0000 37da 0000 33a2     ...?...9...7...3
 800a948:	0000 2e84 0000 2b50 0000 27c2 0000 22d0     ......P+...'..."
 800a958:	0000 1fc4 0000 1bc6 0000 1744 0000 0000     ..........D.....

0800a968 <atanhi>:
 800a968:	bb4f 0561 ac67 3fdd 2d18 5444 21fb 3fe9     O.a.g..?.-DT.!.?
 800a978:	f69b d281 730b 3fef 2d18 5444 21fb 3ff9     .....s.?.-DT.!.?

0800a988 <atanlo>:
 800a988:	65e2 222f 2b7f 3c7a 5c07 3314 a626 3c81     .e/".+z<.\.3&..<
 800a998:	cbbd 7af0 0788 3c70 5c07 3314 a626 3c91     ...z..p<.\.3&..<

0800a9a8 <atanhi>:
 800a9a8:	6338 3eed 0fda 3f49 985e 3f7b 0fda 3fc9     8c.>..I?^.{?...?

0800a9b8 <atanlo>:
 800a9b8:	3769 31ac 2168 3322 0fb4 3314 2168 33a2     i7.1h!"3...3h!.3
 800a9c8:	7245 6f72 2072 7947 6f72 5420 7365 2174     Error Gyro Test!
 800a9d8:	0d0a 2500 2c64 6425 252c 0d64 000a 4d49     ...%d,%d,%d...IM
 800a9e8:	5f55 7947 6f72 5000 6972 746e 455f 6c75     U_Gyro.Print_Eul
 800a9f8:	7265 2800 756e 6c6c 0029 4449 454c 5400     er.(null).IDLE.T
 800aa08:	726d 5320 6376 0000 7173 7472 0000 0000     mr Svc..sqrt....
 800aa18:	7361 6e69 0066 0000 7173 7472 0066 0000     asinf...sqrtf...
 800aa28:	0043 0000                                   C...
